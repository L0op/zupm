diff --git a/ext/Kbuild b/ext/Kbuild
index 97cb478..0e8e091 100644
--- a/ext/Kbuild
+++ b/ext/Kbuild
@@ -1,3 +1,5 @@
 obj-y += hal/
 obj-y += lib/
 obj-y += fs/
+obj-$(CONFIG_MRAA) += lib/mraa/
+obj-y += lib/upm/
diff --git a/ext/Kconfig b/ext/Kconfig
index 9d26499..a61c4ee 100644
--- a/ext/Kconfig
+++ b/ext/Kconfig
@@ -24,4 +24,8 @@ source "ext/lib/crypto/Kconfig"
 
 source "ext/fs/Kconfig"
 
+source "ext/lib/mraa/Kconfig"
+
+source "ext/lib/upm/Kconfig"
+
 endmenu
diff --git a/ext/Makefile b/ext/Makefile
index 45b3952..7d4a5c2 100644
--- a/ext/Makefile
+++ b/ext/Makefile
@@ -1,3 +1,7 @@
 include $(srctree)/ext/lib/Makefile
 include $(srctree)/ext/hal/Makefile
 include $(srctree)/ext/fs/Makefile
+ifdef CONFIG_MRAA
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/mraa/include
+endif
+include $(srctree)/ext/lib/upm/Makefile
diff --git a/ext/lib/mraa/.clang-format b/ext/lib/mraa/.clang-format
new file mode 100644
index 0000000..6860bcf
--- /dev/null
+++ b/ext/lib/mraa/.clang-format
@@ -0,0 +1,50 @@
+AccessModifierOffset: -2
+AlignEscapedNewlinesLeft: true
+AlignTrailingComments: true
+AllowAllParametersOfDeclarationOnNextLine: false
+AllowShortFunctionsOnASingleLine: false
+AllowShortIfStatementsOnASingleLine: false
+AllowShortLoopsOnASingleLine: false
+AlwaysBreakBeforeMultilineStrings: false
+AlwaysBreakTemplateDeclarations: false
+AlwaysBreakAfterDefinitionReturnType: true
+BinPackParameters: false
+BreakBeforeBinaryOperators: false
+BreakBeforeBraces: Linux
+BreakBeforeTernaryOperators: false
+BreakConstructorInitializersBeforeComma: false
+ColumnLimit: 100
+CommentPragmas: ''
+ConstructorInitializerAllOnOneLineOrOnePerLine: false
+ConstructorInitializerIndentWidth: 0
+ContinuationIndentWidth: 0
+Cpp11BracedListStyle: false
+DerivePointerBinding: false
+IndentCaseLabels: true
+IndentFunctionDeclarationAfterType: false
+IndentWidth: 4
+Language: Cpp
+MaxEmptyLinesToKeep: 2
+NamespaceIndentation: None
+ObjCSpaceAfterProperty: true
+ObjCSpaceBeforeProtocolList: true
+PenaltyBreakBeforeFirstCallParameter: 100
+PenaltyBreakComment: 100
+PenaltyBreakFirstLessLess: 0
+PenaltyBreakString: 100
+PenaltyExcessCharacter: 1
+PenaltyReturnTypeOnItsOwnLine: 20
+PointerBindsToType: true
+PointerAlignment: Left
+SpaceBeforeAssignmentOperators: true
+SpaceBeforeParens: ControlStatements
+SpaceInEmptyParentheses: false
+SpacesBeforeTrailingComments: 1
+SpacesInAngles: false
+SpacesInCStyleCastParentheses: false
+SpaceAfterCStyleCast: true
+SpacesInContainerLiterals: false
+SpacesInParentheses: false
+Standard: Cpp11
+TabWidth: 4
+UseTab: Never
diff --git a/ext/lib/mraa/CONTRIBUTING.md b/ext/lib/mraa/CONTRIBUTING.md
new file mode 100644
index 0000000..268fae4
--- /dev/null
+++ b/ext/lib/mraa/CONTRIBUTING.md
@@ -0,0 +1,105 @@
+Contributing to zmraa                           {#contributing}
+=====================
+
+zmraa is an opensource project and we are actively looking for people to help
+with:
+
+- Writing platform supports for all types of boards running zephyr
+- People to extend the functionality, API with useful functions
+- Anything we haven't thought about :) Ideas always welcome!
+- mraa.io changes should be published to libmraa first, if it's zephyr specific
+  then let's discuss it in an issue first!
+
+The recommended method to contribute is to fork on github, and then send pull
+requests to the main project. You can open issues if you find any bugs/have
+questions. If you want to work on a large feature then we suggest you file an
+issue first so we can avoid dissapointments come merging time!
+
+If you'd rather not use github you are more than welcome to send git formatted
+patches to our mailing list mraa@lists.01.org which you can register for access
+on: https://lists.01.org/mailman/listinfo/mraa
+
+Basic rules
+-----------
+- Your code must build
+- Commits must have a sign-off line by at least yourself
+- Commits must be named <file/module>: Some decent description
+- Try not to break master. In any commit.
+- Try to split commits up logically, you will be asked to rebase them if they
+  are not.
+- Try to stick to the established coding style regardless of your personal
+  feeling for it! Use clang-format (3.6+ required)
+- If you add a new API, mraa.io (libmraa is the ref. implementation) needs to
+  be updated
+
+Coding Style
+------------
+
+Coding style for all code is defined by clang-format, have a look at it. Avoid
+styling fixes as they make history difficult to read. Javascript & Java can
+also be parsed through the clang-format, it complains but seems to do an ok
+job. Few exceptions to coding styles:
+- All python code is indented by 2 spaces
+- CmakeLists files are 2 space indented and a space is required before all
+  brackets so endif () and if () and command (). Also use lowercase for
+  everything but variables. Cmake is case insensitive but this isn't the wild
+  wild west ;-)
+
+Use common sense and don't be afraid to challenge something if it doesn't make sense!
+
+Author Rules
+------------
+
+If you create a file, then add yourself as the Author at the top. If you did a
+large contribution to it (or if you want to ;-)), then fee free to add yourself
+to the contributors list in that file. You can also add your own copyright
+statement to the file but cannot add a license of your own. If you're borrowing
+code that comes from a project with another license, make sure to explicitly
+note this in your PR.
+
+Code signing
+------------
+
+The sign-off is a simple line at the end of the explanation for the
+patch, which certifies that you wrote it or otherwise have the right to pass it
+on as an open-source patch.  The rules are pretty simple: if you can certify
+the below:
+
+        Developer's Certificate of Origin 1.1
+
+        By making a contribution to this project, I certify that:
+
+        (a) The contribution was created in whole or in part by me and I
+            have the right to submit it under the open source license
+            indicated in the file; or
+
+        (b) The contribution is based upon previous work that, to the best
+            of my knowledge, is covered under an appropriate open source
+            license and I have the right under that license to submit that
+            work with modifications, whether created in whole or in part
+            by me, under the same open source license (unless I am
+            permitted to submit under a different license), as indicated
+            in the file; or
+
+        (c) The contribution was provided directly to me by some other
+            person who certified (a), (b) or (c) and I have not modified
+            it.
+
+        (d) I understand and agree that this project and the contribution
+            are public and that a record of the contribution (including all
+            personal information I submit with it, including my sign-off) is
+            maintained indefinitely and may be redistributed consistent with
+            this project or the open source license(s) involved.
+
+then you just add a line saying
+
+	Signed-off-by: Random J Developer <random@developer.example.org>
+
+Using your real name (sorry, no pseudonyms or anonymous contributions.)
+
+Where to find us
+----------------
+
+Hop onto the freenode network on IRC and join #mraa. Please be patient as we're
+not always online.
+
diff --git a/ext/lib/mraa/COPYING b/ext/lib/mraa/COPYING
new file mode 100644
index 0000000..cbecaa8
--- /dev/null
+++ b/ext/lib/mraa/COPYING
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+Copyright Â© 2016 Intel Corporation
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/ext/lib/mraa/Kconfig b/ext/lib/mraa/Kconfig
new file mode 100644
index 0000000..ebdf93d
--- /dev/null
+++ b/ext/lib/mraa/Kconfig
@@ -0,0 +1,85 @@
+# Kconfig - Cryptography primitive options for TinyCrypt
+
+#
+# Copyright (c) 2015 Intel Corporation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+config  MRAA
+        bool
+        prompt "Mraa Support"
+        default n
+        select PINMUX
+        select PINMUX_DEV
+        select PINMUX_DEV_QMSI
+        help
+          This option enables the mraa lib
+
+config  MRAA_GPIO
+        bool
+        prompt "Mraa GPIO function support"
+        select MRAA
+        select GPIO
+        default n
+        help
+          This option enables support for MRAA GPIO
+
+config  MRAA_AIO
+        bool
+        prompt "Mraa AIO function support"
+        select MRAA
+        select AIO
+        default n
+        help
+          This option enables support for MRAA AIO
+
+config  MRAA_I2C
+        bool
+        prompt "Mraa I2C function support"
+        select I2C
+        select MRAA
+        select MRAA_GPIO
+        default n
+        help
+          This option enables support for MRAA I2C
+
+config  MRAA_PWM
+        bool
+        prompt "Mraa PWM function support"
+        select PWM
+        select MRAA
+        default n
+        help
+          This option enables support for MRAA PWM
+
+config  MRAA_UART
+        bool
+        prompt "Mraa UART function support"
+        select UART
+        select UART_LINE_CTRL
+        select MRAA
+        default n
+        help
+          This option enables support for MRAA UART
+
+config  MRAA_SPI
+        bool
+        prompt "Mraa SPI function support"
+        select SPI
+        select GPIO
+        select MRAA
+        select PINMUX
+        default n
+        help
+          This option enables support for MRAA SPI
diff --git a/ext/lib/mraa/Makefile b/ext/lib/mraa/Makefile
new file mode 100644
index 0000000..fb55e83
--- /dev/null
+++ b/ext/lib/mraa/Makefile
@@ -0,0 +1,11 @@
+ccflags-y +=-I$(srctree)/ext/lib/mraa/include
+obj-$(CONFIG_MRAA) := source/mraa.o
+obj-$(CONFIG_MRAA_GPIO) += source/gpio.o
+obj-$(CONFIG_MRAA_I2C) += source/i2c.o
+obj-$(CONFIG_MRAA_PWM) += source/pwm.o
+obj-$(CONFIG_MRAA_AIO) += source/aio.o
+obj-$(CONFIG_MRAA_UART) += source/uart.o
+obj-$(CONFIG_MRAA_SPI) += source/spi.o
+obj-$(CONFIG_BOARD_ARDUINO_101) += source/arduino_101.o
+obj-$(CONFIG_BOARD_ARDUINO_101_SSS) += source/arduino_101_sss.o
+obj-$(CONFIG_BOARD_QUARK_D2000_CRB) += source/intel_d2k_crb.o
diff --git a/ext/lib/mraa/README.md b/ext/lib/mraa/README.md
new file mode 100644
index 0000000..e84f74d
--- /dev/null
+++ b/ext/lib/mraa/README.md
@@ -0,0 +1,101 @@
+ZMRAA is an implementation of the MRAA API for Zephyr project.
+
+Supported Devices
+-----------------
+* Arduino 101
+* Quark D2000 CRB
+
+Supported APIs
+-----------------
+* GPIO
+* I2C
+* AIO
+* PWM
+* I2C
+* SPI
+
+Protocols per Core: Arduino 101
+-------------------------------
+In general almost every protocol mentioned above is present on each core.
+However, that stops being the case when you look at it from the POV of what's
+present on the Arduino headers. The following table lists the protocols that
+are present per core and exposed via the headers:
+
+| Protocol |           ARC                  |           QUARK                |
+|----------|--------------------------------|--------------------------------|
+|   AIO    | Present                        | Not present                    |
+|   GPIO   | Present                        | Present                        |
+|   PWM    | Present                        | Present                        |
+|   I2C    | Present                        | Not present                    |
+|   UART   | Not present                    | Present                        |
+|   SPI    | Present (Only internally)      | Present                        |
+
+Pin Availability on Arduino 101 via ZMRAA
+-----------------------------------------
+On 101 there are at least 69 pins that can be configured. ZMRAA tries to provide
+access to as many as possible. Most of the pins exposed on the headers of the
+Arduino 101 can be accessed via both cores - Quark and ARC, but there are a
+few pins and protocols that can be accessed from only one of the cores. To see
+which protocol is available on which core please check the corresponding section.
+
+A look at the pins accessible via the **Quark core:**
+**GPIO** - D2-D5, D7, D8, D10-D13
+**PWM** - D3, D5, D6, D9
+**UART** - D0(RX), D1(TX)
+**SPI** - D11(MOSI), D12(MISO), D13(SCK) | CS via GPIO
+
+Pins accessible via the **ARC core:**
+**GPIO** - D14-D19 (These are analog pins A0-A5 numbered 14-19)
+*ex: mraa_gpio_init(14); in this case pin A0 would be used as a digital pin*
+*    mraa_gpio_init(15); in this case it's pin A1 and so on and so forth*
+
+**AIO** - A0-A5, D10-D13
+*you can number the digital pins as they are: mraa_aio_init(10)*
+*This initializes pin D10*
+
+**PWM** - D3, D5, D6, D9
+**I2C** - I2C pins on the board
+**SPI** - Not exposed externally, but has access to the internal BMI160
+
+*If a protocol and its corresponding pins have not been mentioned under a*
+*particular core then that protocol is not available on that core.*
+
+Adding ZMRAA to Zephyr
+----------------------
+
+```
+cd zephyr/ext/lib
+git clone https://github.com/intel-iot-devkit/zmraa.git mraa
+```
+
+Then you need to apply [zmraa.patch](zmraa.patch) to add the configuration entries
+```
+cd $ZEPHYR_BASE
+git am ext/lib/mraa/zmraa.patch
+```
+
+Build GPIO Example
+------------------
+Add mraa and gpio driver to your Zephyr configuration and build sample.
+Select `Device Drivers -> GPIO Drivers -> QMSI GPIO driver` and
+`MRAA -> Mraa GPIO function support`
+If you use a Quark D2K board then switch `BOARD=arduino_101` for
+`BOARD=quark_d2000_crb`
+
+```
+source $ZEPHYR_BASE/zephyr-env.sh
+cd ext/lib/mraa/examples/shell
+make BOARD=arduino_101 menuconfig
+```
+
+Now build the sample:
+
+```
+make BOARD=arduino_101 
+```
+
+And upload it to the board by running:
+
+```bash
+dfu-util -R -a x86_app -D outdir/zephyr.bin
+```
diff --git a/ext/lib/mraa/examples/aio-read/Makefile b/ext/lib/mraa/examples/aio-read/Makefile
new file mode 100644
index 0000000..9e43fce
--- /dev/null
+++ b/ext/lib/mraa/examples/aio-read/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = nano
+BOARD ?= arduino_101_sss_factory
+CONF_FILE = prj_aio.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/aio-read/README.txt b/ext/lib/mraa/examples/aio-read/README.txt
new file mode 100644
index 0000000..c66af64
--- /dev/null
+++ b/ext/lib/mraa/examples/aio-read/README.txt
@@ -0,0 +1,27 @@
+Title: AIO Read
+
+Description:
+
+A simple Analog Read application.
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+This nanokernel project outputs values read in from the the A0 pin onto the
+console. The project employs the MRAA AIO layer in order to read these values.
+The first 10 values it reads are of 10 bits and the following 10 are 12 bits.
+
+Running it:
+
+make pristine
+
+make BOARD=arduino_101_sss_factory
+
+If using DFU-UTIL:
+dfu-util -a sensor_core -D outdir/zephyr.bin -R
+
+Or if using JTAG/Flyswatter:
+make BOARD=arduino_101_sss_factory flash
+
+--------------------------------------------------------------------------------
+
diff --git a/ext/lib/mraa/examples/aio-read/prj_aio.conf b/ext/lib/mraa/examples/aio-read/prj_aio.conf
new file mode 100644
index 0000000..d024366
--- /dev/null
+++ b/ext/lib/mraa/examples/aio-read/prj_aio.conf
@@ -0,0 +1,16 @@
+# Console output
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+# Enabling underlying ADC driver
+CONFIG_ADC=y
+CONFIG_ADC_DW=y
+CONFIG_ADC_DW_REPETITIVE=y
+# configuring MRAA AIO layer
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+# enabling malloc support in Zephyr
+CONFIG_NEWLIB_LIBC=y
+# timer support
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
diff --git a/ext/lib/mraa/examples/aio-read/src/Makefile b/ext/lib/mraa/examples/aio-read/src/Makefile
new file mode 100644
index 0000000..b666967
--- /dev/null
+++ b/ext/lib/mraa/examples/aio-read/src/Makefile
@@ -0,0 +1 @@
+obj-y += main.o
diff --git a/ext/lib/mraa/examples/aio-read/src/main.c b/ext/lib/mraa/examples/aio-read/src/main.c
new file mode 100644
index 0000000..77a508e
--- /dev/null
+++ b/ext/lib/mraa/examples/aio-read/src/main.c
@@ -0,0 +1,75 @@
+/*
+ * Author: Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <malloc.h>
+#include <misc/util.h>
+#include <mraa/aio.h>
+#include <pinmux.h>
+#include <sys_clock.h>
+#include <zephyr.h>
+
+#define SLEEPTICKS SECONDS(1)
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT printf
+#else
+#include <misc/printk.h>
+#define PRINT printk
+#endif
+
+void
+main(void)
+{
+    struct nano_timer timer;
+    void* timer_data[1];
+    nano_timer_init(&timer, timer_data);
+    // Calling the MRAA init function which initializes the board specific details
+    if (mraa_init() != MRAA_SUCCESS) {
+        printf("Unable to init MRAA successfully\n");
+    }
+    // Initializing the MRAA AIO layer
+    mraa_aio_context dev = mraa_aio_init(0);
+    int val;
+    for (int i = 0; i < 10; i++) {
+        val = mraa_aio_read(dev);
+        printf("AIO Value: %d\n", val);
+        // adding a delay of 1 sec between consecutive reads
+        nano_timer_start(&timer, SLEEPTICKS);
+        nano_timer_test(&timer, TICKS_UNLIMITED);
+    }
+    // increasing to 12 bits, it is 10 bits by default
+    if (mraa_aio_set_bit(dev, 12) != MRAA_SUCCESS) {
+        printf("Unable to set bits to 12\n");
+    }
+    for (int i = 0; i < 10; i++) {
+        val = mraa_aio_read(dev);
+        printf("AIO Value: %d\n", val);
+        // adding a delay of 1 sec between consecutive reads
+        nano_timer_start(&timer, SLEEPTICKS);
+        nano_timer_test(&timer, TICKS_UNLIMITED);
+    }
+    if (mraa_aio_close(dev) != MRAA_SUCCESS) {
+        printf("error closing analog port\n");
+    }
+}
diff --git a/ext/lib/mraa/examples/bmi160-spi/Makefile b/ext/lib/mraa/examples/bmi160-spi/Makefile
new file mode 100755
index 0000000..4b37835
--- /dev/null
+++ b/ext/lib/mraa/examples/bmi160-spi/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = nano
+BOARD ?= arduino_101_sss_factory
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/bmi160-spi/README.txt b/ext/lib/mraa/examples/bmi160-spi/README.txt
new file mode 100755
index 0000000..297b610
--- /dev/null
+++ b/ext/lib/mraa/examples/bmi160-spi/README.txt
@@ -0,0 +1,17 @@
+Title: Synchronisation
+
+Description:
+
+A simple SPI example using the SPI API from ZMRAA.
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+This nanokernel project outputs to the console the chip ID that it reads from
+the onboard BMI160 on the Arduino 101.  It can be built and executed
+on as follows:
+
+    make BOARD=arduino_101_sss_factory
+    dfu-util -a sensor_core -D outdir/zephyr.bin -R
+
diff --git a/ext/lib/mraa/examples/bmi160-spi/prj.conf b/ext/lib/mraa/examples/bmi160-spi/prj.conf
new file mode 100755
index 0000000..087446b
--- /dev/null
+++ b/ext/lib/mraa/examples/bmi160-spi/prj.conf
@@ -0,0 +1,19 @@
+# console related
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+# timer configuration
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
+# Enable Zephyr SPI driver
+CONFIG_SPI=y
+CONFIG_SPI_DW_ARC_AUX_REGS=y
+CONFIG_SPI_DW_INTERRUPT_SEPARATED_LINES=y
+# Enable malloc/free support
+CONFIG_NEWLIB_LIBC=y
+# Enable Zephyr GPIO
+CONFIG_GPIO=y
+# set up MRAA
+CONFIG_MRAA=y
+CONFIG_MRAA_SPI=y
+CONFIG_MRAA_GPIO=y
diff --git a/ext/lib/mraa/examples/bmi160-spi/prj.mdef b/ext/lib/mraa/examples/bmi160-spi/prj.mdef
new file mode 100755
index 0000000..6c33f79
--- /dev/null
+++ b/ext/lib/mraa/examples/bmi160-spi/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : Hello demo
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/ext/lib/mraa/examples/bmi160-spi/src/Makefile b/ext/lib/mraa/examples/bmi160-spi/src/Makefile
new file mode 100755
index 0000000..00066e1
--- /dev/null
+++ b/ext/lib/mraa/examples/bmi160-spi/src/Makefile
@@ -0,0 +1 @@
+obj-y = main.o
diff --git a/ext/lib/mraa/examples/bmi160-spi/src/main.c b/ext/lib/mraa/examples/bmi160-spi/src/main.c
new file mode 100644
index 0000000..3da0c31
--- /dev/null
+++ b/ext/lib/mraa/examples/bmi160-spi/src/main.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (c) 2012-2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "mraa/spi.h"
+#include <device.h>
+#include <malloc.h>
+#include <spi.h>
+#include <sys_clock.h>
+#include <zephyr.h>
+
+#define BMI160_REG_CHIPID 0x00
+#define BMI160_CMD_SOFT_RESET 0xB6
+#define BMI160_REG_CMD 0x7E
+#define BMI160_CHIP_ID 0xD1
+#define BMI160_REG_DATA_ACC_X 0x12
+#define BMI160_REG_DATA_ACC_Y 0x14
+#define BMI160_REG_DATA_ACC_Z 0x16
+
+#define BMI160_REG_ACC_CONF 0x40
+#define BMI160_REG_ACC_RANGE 0x41
+
+#define SPI_DRV_NAME "SPI_1"
+#define SPI_SLAVE 1
+
+#define SET_MODE_MASK 0xfffffffc
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT printf
+#else
+#include <misc/printk.h>
+#define PRINT printk
+#endif
+
+void
+main(void)
+{
+    PRINT("This is the MRAA example which accesses the interal\n");
+    PRINT("BMI160 on the Arduino 101 board. The chip is internally\n");
+    PRINT("connected only to the ARC core SPI bus.\n");
+    PRINT("The example reads the chip ID from the chip and prints and confirms it\n");
+
+    // on both the cores, spi bus 1 seems to be the bus of choice for now
+    mraa_spi_context dev = mraa_spi_init(1);
+    if (dev == NULL) {
+        printf("An error has occured while setting up the SPI bus\n");
+        return;
+    }
+    if (mraa_spi_frequency(dev, 360000) != MRAA_SUCCESS) {
+        printf("Unable to set up the SPI frequency\n");
+        return;
+    }
+
+    // adding a 1ms delay
+    sys_thread_busy_wait(1000);
+
+    uint8_t tx_buf[2] = { BMI160_REG_CMD & 0x7f, BMI160_CMD_SOFT_RESET };
+    mraa_spi_write_buf(dev, tx_buf, 2);
+
+    sys_thread_busy_wait(1000);
+    uint8_t rx_buf[2];
+    uint8_t tx[3] = { 0 };
+    tx[0] = 0x7f | (1 << 7);
+    if (mraa_spi_transfer_buf(dev, tx, rx_buf, 2) != MRAA_SUCCESS) {
+        printf("Unable to transfer data over the SPI bus\n");
+    }
+
+    sys_thread_busy_wait(1000);
+    uint8_t rx[3];
+    uint8_t tx_buffer[3] = { 0 };
+    tx_buffer[0] = BMI160_REG_CHIPID | (1 << 7);
+    if (mraa_spi_transfer_buf(dev, tx_buffer, rx, 3) != MRAA_SUCCESS) {
+        printf("Unable to transfer data over the SPI bus\n");
+    }
+
+    sys_thread_busy_wait(1000);
+
+    if (rx[1] == BMI160_CHIP_ID) {
+        printf("The chip ID is: %x\n", rx[1]);
+    } else {
+        printf("The chip ID is: %x which is incorrect, actual chip ID is: 0xd1\n", rx[1]);
+    }
+}
diff --git a/ext/lib/mraa/examples/d2k-crb/Makefile b/ext/lib/mraa/examples/d2k-crb/Makefile
new file mode 100644
index 0000000..ed8050c
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = nano
+BOARD = quark_d2000_crb
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/d2k-crb/prj.conf b/ext/lib/mraa/examples/d2k-crb/prj.conf
new file mode 100644
index 0000000..6bb1ab0
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/prj.conf
@@ -0,0 +1,15 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_GPIO=y
+CONFIG_I2C=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_MRAA_I2C=y
+
+CONFIG_SYS_LOG=y
+CONFIG_BMC150_MAGN_SYS_LOG_LEVEL=4
+CONFIG_BMC150_MAGN_I2C_ADDR_12=y
+
+# From bmc150 sensor sample
+CONFIG_NANO_TIMEOUTS=y
+CONFIG_SENSOR=y
+CONFIG_BMC150_MAGN=y
\ No newline at end of file
diff --git a/ext/lib/mraa/examples/d2k-crb/prj.mdef b/ext/lib/mraa/examples/d2k-crb/prj.mdef
new file mode 100644
index 0000000..604a9f9
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : mraa quark d000 crb test app
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/ext/lib/mraa/examples/d2k-crb/src/Makefile b/ext/lib/mraa/examples/d2k-crb/src/Makefile
new file mode 100644
index 0000000..1ab9ac6
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/src/Makefile
@@ -0,0 +1 @@
+obj-y = main.o bmc150.o
diff --git a/ext/lib/mraa/examples/d2k-crb/src/bmc150.c b/ext/lib/mraa/examples/d2k-crb/src/bmc150.c
new file mode 100644
index 0000000..8ec8ffa
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/src/bmc150.c
@@ -0,0 +1,592 @@
+///* sensor_bmc150_magn.c - Driver for Bosch BMC150 magnetometer sensor */
+
+/*
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * This code is based on bmm050.c from:
+ * https://github.com/BoschSensortec/BMM050_driver
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define SYS_LOG_DOMAIN "BMC150_MAGN"
+#define SYS_LOG_LEVEL CONFIG_BMC150_MAGN_SYS_LOG_LEVEL
+
+#include <nanokernel.h>
+#include <errno.h>
+#include <misc/byteorder.h>
+#include <misc/util.h>
+#include <misc/sys_log.h>
+#include "bmc150.h"
+
+struct bmc150_magn_trim_regs {
+	int8_t x1;
+	int8_t y1;
+	uint16_t reserved1;
+	uint8_t reserved2;
+	int16_t z4;
+	int8_t x2;
+	int8_t y2;
+	uint16_t reserved3;
+	int16_t z2;
+	uint16_t z1;
+	uint16_t xyz1;
+	int16_t z3;
+	int8_t xy2;
+	uint8_t xy1;
+} __packed;
+
+
+struct _upm_bmc150_magn {
+	mraa_i2c_context i2c;
+	struct nano_sem sem;
+#if defined(CONFIG_BMC150_MAGN_TRIGGER)
+	char __stack fiber_stack[CONFIG_BMC150_MAGN_TRIGGER_FIBER_STACK];
+#endif
+#if defined(CONFIG_BMC150_MAGN_TRIGGER_DRDY)
+	struct device *gpio_drdy;
+	struct device *dev;
+	struct gpio_callback gpio_cb;
+	struct sensor_trigger trigger_drdy;
+	sensor_trigger_handler_t handler_drdy;
+#endif
+	struct bmc150_magn_trim_regs tregs;
+	int rep_xy, rep_z, odr, max_odr;
+	int sample_x, sample_y, sample_z;
+};
+
+static const struct {
+	int freq;
+	uint8_t reg_val;
+} bmc150_magn_samp_freq_table[] = { {2, 0x01},
+				    {6, 0x02},
+				    {8, 0x03},
+				    {10, 0x00},
+				    {15, 0x04},
+				    {20, 0x05},
+				    {25, 0x06},
+				    {30, 0x07} };
+
+static const struct bmc150_magn_preset {
+	uint8_t rep_xy;
+	uint8_t rep_z;
+	uint8_t odr;
+} bmc150_magn_presets_table[] = {
+	[LOW_POWER_PRESET] = {3, 3, 10},
+	[REGULAR_PRESET] = {9, 15, 10},
+	[ENHANCED_REGULAR_PRESET] = {15, 27, 10},
+	[HIGH_ACCURACY_PRESET] = {47, 83, 20}
+};
+
+static struct _upm_bmc150_magn upm_bmc150_magn_dev;
+
+static mraa_result_t bmc150_magn_set_power_mode(upm_bmc150_magn dev,
+				      enum bmc150_magn_power_modes mode,
+				      int state)
+{
+	mraa_result_t res = MRAA_SUCCESS;
+
+	switch (mode) {
+	case BMC150_MAGN_POWER_MODE_SUSPEND:
+		res = mraa_i2c_update_byte_data(dev->i2c,
+					BMC150_MAGN_MASK_POWER_CTL,
+					!state,
+					BMC150_MAGN_REG_POWER);
+		if (res == MRAA_SUCCESS)
+			sys_thread_busy_wait(5 * USEC_PER_MSEC);
+		return res;
+	case BMC150_MAGN_POWER_MODE_SLEEP:
+		return mraa_i2c_update_byte_data(dev->i2c,
+					   BMC150_MAGN_MASK_OPMODE,
+					   BMC150_MAGN_MODE_SLEEP <<
+					   BMC150_MAGN_SHIFT_OPMODE,
+					   BMC150_MAGN_REG_OPMODE_ODR);
+	case BMC150_MAGN_POWER_MODE_NORMAL:
+		return mraa_i2c_update_byte_data(dev->i2c,
+					   BMC150_MAGN_MASK_OPMODE,
+					   BMC150_MAGN_MODE_NORMAL <<
+					   BMC150_MAGN_SHIFT_OPMODE,
+					   BMC150_MAGN_REG_OPMODE_ODR);
+		break;
+	}
+
+	return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+}
+
+static mraa_result_t bmc150_magn_set_odr(upm_bmc150_magn dev, uint8_t val)
+{
+	uint8_t i;
+
+	for (i = 0; i < ARRAY_SIZE(bmc150_magn_samp_freq_table); ++i) {
+		if (val <= bmc150_magn_samp_freq_table[i].freq) {
+			return mraa_i2c_update_byte_data(dev->i2c,
+						BMC150_MAGN_MASK_ODR,
+						bmc150_magn_samp_freq_table[i].
+						reg_val << BMC150_MAGN_SHIFT_ODR,
+						BMC150_MAGN_REG_OPMODE_ODR);
+		}
+	}
+
+	return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+}
+
+
+#if defined(BMC150_MAGN_SET_ATTR)
+static int bmc150_magn_read_rep_xy(upm_bmc150_magn dev)
+{
+	int reg_val = mraa_i2c_read_byte_data(dev->i2c, BMC150_MAGN_REG_REP_XY);
+	if (reg_val < 0)
+		return -EIO;
+	dev->rep_xy = BMC150_MAGN_REGVAL_TO_REPXY(reg_val);
+	return 0;
+}
+
+static int bmc150_magn_read_rep_z(upm_bmc150_magn dev)
+{
+	int reg_val = mraa_i2c_read_byte_data(dev->i2c, BMC150_MAGN_REG_REP_Z);
+	if (reg_val < 0)
+		return -EIO;
+	dev->rep_xy = BMC150_MAGN_REGVAL_TO_REPZ(reg_val);
+	return 0;
+}
+
+static int bmc150_magn_compute_max_odr(upm_bmc150_magn dev, int rep_xy,
+				       int rep_z, int *max_odr)
+{
+	if (rep_xy == 0) {
+		if (data->rep_xy <= 0) {
+			if (bmc150_magn_read_rep_xy(dev) < 0) {
+				return -EIO;
+			}
+		}
+		rep_xy = data->rep_xy;
+	}
+
+	if (rep_z == 0) {
+		if (data->rep_z <= 0) {
+			if (bmc150_magn_read_rep_z(dev) < 0) {
+				return -EIO;
+			}
+		}
+		rep_z = data->rep_z;
+	}
+
+	*max_odr = 1000000 / (145 * rep_xy + 500 * rep_z + 980);
+
+	return 0;
+}
+#endif
+
+
+#if defined(BMC150_MAGN_SET_ATTR_REP)
+static int bmc150_magn_read_odr(upm_bmc150_magn dev)
+{
+	uint8_t i, odr_val, reg_val;
+
+	if (mraa_i2c_read_bytes_data(dev->i2c, BMC150_MAGN_REG_OPMODE_ODR,
+		                         reg_val, 1) != 1) {
+		return -EIO;
+	}
+
+	odr_val = (reg_val & BMC150_MAGN_MASK_ODR) >> BMC150_MAGN_SHIFT_ODR;
+
+	for (i = 0; i < ARRAY_SIZE(bmc150_magn_samp_freq_table); ++i) {
+		if (bmc150_magn_samp_freq_table[i].reg_val == odr_val) {
+			dev->odr = bmc150_magn_samp_freq_table[i].freq;
+			return 0;
+		}
+	}
+
+	return -ENOTSUP;
+}
+#endif
+
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_REP_XY)
+static int bmc150_magn_write_rep_xy(upm_bmc150_magn dev, int val)
+{
+	if (mraa_i2c_update_byte_data(dev->i2c,
+				BMC150_MAGN_REG_REP_DATAMASK,
+				BMC150_MAGN_REPXY_TO_REGVAL(val),
+				BMC150_MAGN_REG_REP_XY) != MRAA_SUCCESS) {
+		return -EIO;
+	}
+	dev->rep_xy = val;
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_REP_Z)
+static int bmc150_magn_write_rep_z(upm_bmc150_magn dev, int val)
+{
+	if (mraa_i2c_update_byte_data(dev->i2c,
+				BMC150_MAGN_REG_REP_DATAMASK,
+				BMC150_MAGN_REPZ_TO_REGVAL(val),
+				BMC150_MAGN_REG_REP_Z) != MRAA_SUCCESS) {
+		return -EIO;
+	}
+	dev->rep_z = val;
+	return 0;
+}
+#endif
+
+/*
+ * Datasheet part 4.3.4, provided by Bosch here:
+ * https://github.com/BoschSensortec/BMM050_driver
+ */
+static int32_t bmc150_magn_compensate_xy(struct bmc150_magn_trim_regs *tregs,
+					int16_t xy, uint16_t rhall, bool is_x)
+{
+	int8_t txy1, txy2;
+	int16_t val;
+
+	if (xy == BMC150_MAGN_XY_OVERFLOW_VAL) {
+		return INT32_MIN;
+	}
+
+	if (!rhall) {
+		rhall = tregs->xyz1;
+	}
+
+	if (is_x) {
+		txy1 = tregs->x1;
+		txy2 = tregs->x2;
+	} else {
+		txy1 = tregs->y1;
+		txy2 = tregs->y2;
+	}
+
+	val = ((int16_t)(((uint16_t)((((int32_t)tregs->xyz1) << 14) / rhall)) -
+	      ((uint16_t)0x4000)));
+	val = ((int16_t)((((int32_t)xy) * ((((((((int32_t)tregs->xy2) *
+	      ((((int32_t)val) * ((int32_t)val)) >> 7)) + (((int32_t)val) *
+	      ((int32_t)(((int16_t)tregs->xy1) << 7)))) >> 9) +
+	      ((int32_t)0x100000)) * ((int32_t)(((int16_t)txy2) +
+	      ((int16_t)0xA0)))) >> 12)) >> 13)) + (((int16_t)txy1) << 3);
+
+	return (int32_t)val;
+}
+
+static int32_t bmc150_magn_compensate_z(struct bmc150_magn_trim_regs *tregs,
+					int16_t z, uint16_t rhall)
+{
+	int32_t val;
+
+	if (z == BMC150_MAGN_Z_OVERFLOW_VAL) {
+		return INT32_MIN;
+	}
+
+	val = (((((int32_t)(z - tregs->z4)) << 15) - ((((int32_t)tregs->z3) *
+	      ((int32_t)(((int16_t)rhall) - ((int16_t)tregs->xyz1)))) >> 2)) /
+	      (tregs->z2 + ((int16_t)(((((int32_t)tregs->z1) *
+	      ((((int16_t)rhall) << 1))) + (1 << 15)) >> 16))));
+
+	return val;
+}
+
+
+static void bmc150_magn_convert(double *val, int raw_val)
+{
+	// val->type = SENSOR_VALUE_TYPE_DOUBLE;
+	*val = (double)(raw_val) * (1.0/1600.0);
+}
+
+mraa_result_t upm_bmc150_magn_get_value(upm_bmc150_magn dev, double *x, double *y, double *z)
+{
+	uint16_t values[BMC150_MAGN_AXIS_XYZR_MAX];
+	int16_t raw_x, raw_y, raw_z;
+	uint16_t rhall;
+
+	// __ASSERT(chan == SENSOR_CHAN_ALL || chan == SENSOR_CHAN_MAGN_ANY);
+
+    mraa_i2c_address(dev->i2c, BMC150_MAGN_I2C_ADDR);
+	if (mraa_i2c_read_bytes_data(dev->i2c,
+			   BMC150_MAGN_REG_X_L, (uint8_t *)values,
+			   sizeof(values)) != sizeof(values)) {
+		SYS_LOG_DBG("failed to read sample");
+		return -EIO;
+	}
+
+	raw_x = (int16_t)sys_le16_to_cpu(values[BMC150_MAGN_AXIS_X]) >>
+		BMC150_MAGN_SHIFT_XY_L;
+	raw_y = (int16_t)sys_le16_to_cpu(values[BMC150_MAGN_AXIS_Y]) >>
+		BMC150_MAGN_SHIFT_XY_L;
+	raw_z = (int16_t)sys_le16_to_cpu(values[BMC150_MAGN_AXIS_Z]) >>
+		BMC150_MAGN_SHIFT_Z_L;
+	rhall = sys_le16_to_cpu(values[BMC150_MAGN_RHALL]) >>
+		BMC150_MAGN_SHIFT_RHALL_L;
+
+	dev->sample_x = bmc150_magn_compensate_xy(&dev->tregs, raw_x, rhall,
+						   true);
+	dev->sample_y = bmc150_magn_compensate_xy(&dev->tregs, raw_y, rhall,
+						   false);
+	dev->sample_z = bmc150_magn_compensate_z(&dev->tregs, raw_z, rhall);
+
+	bmc150_magn_convert(x, dev->sample_x);
+	bmc150_magn_convert(y, dev->sample_y);
+	bmc150_magn_convert(z, dev->sample_z);
+
+
+	return 0;
+}
+
+
+/*
+static int bmc150_magn_channel_get(upm_bmc150_magn dev,
+
+				   struct sensor_value *val)
+{
+	switch (chan) {
+	case SENSOR_CHAN_MAGN_X:
+		bmc150_magn_convert(val, dev->sample_x);
+		break;
+	case SENSOR_CHAN_MAGN_Y:
+		bmc150_magn_convert(val, dev->sample_y);
+		break;
+	case SENSOR_CHAN_MAGN_Z:
+		bmc150_magn_convert(val, dev->sample_z);
+		break;
+	case SENSOR_CHAN_MAGN_ANY:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+*/
+
+#if defined(BMC150_MAGN_SET_ATTR_REP)
+static inline int bmc150_magn_attr_set_rep(upm_bmc150_magn dev,
+					   enum sensor_channel chan,
+					   const struct sensor_value *val)
+{
+	int max_odr;
+
+	switch (chan) {
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_REP_XY)
+	case SENSOR_CHAN_MAGN_X:
+	case SENSOR_CHAN_MAGN_Y:
+		if (val->val1 < 1 || val->val1 > 511) {
+			return -EINVAL;
+		}
+
+		if (bmc150_magn_compute_max_odr(dev, val->val1, 0,
+						&max_odr) < 0) {
+			return -EIO;
+		}
+
+		if (data->odr <= 0b) {
+			if (bmc150_magn_read_odr(dev) < 0) {
+				return -EIO;
+			}
+		}
+
+		if (data->odr > max_odr) {
+			return -EINVAL;
+		}
+
+		if (bmc150_magn_write_rep_xy(dev, val->val1) < 0) {
+			return -EIO;
+		}
+		break;
+#endif
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_REP_Z)
+	case SENSOR_CHAN_MAGN_Z:
+		if (val->val1 < 1 || val->val1 > 256) {
+			return -EINVAL;
+		}
+
+		if (bmc150_magn_compute_max_odr(dev, 0, val->val1,
+						&max_odr) < 0) {
+			return -EIO;
+		}
+
+		if (data->odr <= 0) {
+			if (bmc150_magn_read_odr(dev) < 0) {
+				return -EIO;
+			}
+		}
+
+		if (data->odr > max_odr) {
+			return -EINVAL;
+		}
+
+		if (bmc150_magn_write_rep_z(dev, val->val1) < 0) {
+			return -EIO;
+		}
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(BMC150_MAGN_SET_ATTR)
+static int bmc150_magn_attr_set(upm_bmc150_magn dev,
+				enum sensor_channel chan,
+				enum sensor_attribute attr,
+				const struct sensor_value *val)
+{
+	switch (attr) {
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_RATE_RUNTIME)
+	case SENSOR_ATTR_SAMPLING_FREQUENCY:
+		if (val->type != SENSOR_VALUE_TYPE_INT) {
+			SYS_LOG_DBG("invalid parameter type");
+			return -ENOTSUP;
+		}
+
+		if (data->max_odr <= 0) {
+			if (bmc150_magn_compute_max_odr(dev, 0, 0,
+							&dev->max_odr) < 0) {
+				return -EIO;
+			}
+		}
+
+		if (dev->max_odr < val->val1) {
+			SYS_LOG_DBG("not supported with current oversampling");
+			return -ENOTSUP;
+		}
+
+		if (bmc150_magn_set_odr(dev, (uint8_t)(val->val1)) < 0) {
+			return -EIO;
+		}
+		break;
+#endif
+#if defined(BMC150_MAGN_SET_ATTR_REP)
+	case SENSOR_ATTR_OVERSAMPLING:
+		if (val->type != SENSOR_VALUE_TYPE_INT) {
+			SYS_LOG_DBG("invalid parameter type");
+			return -ENOTSUP;
+		}
+
+		bmc150_magn_attr_set_rep(dev, chan, val);
+
+		break;
+#endif
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}b
+#endif
+
+
+static int bmc150_magn_init_chip(upm_bmc150_magn dev)
+{
+	uint8_t chip_id;
+	struct bmc150_magn_preset preset;
+
+    mraa_i2c_address(dev->i2c, BMC150_MAGN_I2C_ADDR);
+	bmc150_magn_set_power_mode(dev, BMC150_MAGN_POWER_MODE_NORMAL, 0);
+	bmc150_magn_set_power_mode(dev, BMC150_MAGN_POWER_MODE_SUSPEND, 1);
+
+	if (bmc150_magn_set_power_mode(dev, BMC150_MAGN_POWER_MODE_SUSPEND, 0)
+				       != MRAA_SUCCESS) {
+		SYS_LOG_DBG("failed to bring up device from suspend mode");
+		return -EIO;
+	}
+
+	if (mraa_i2c_read_bytes_data(dev->i2c, BMC150_MAGN_REG_CHIP_ID, &chip_id, 1) != 1) {
+		SYS_LOG_DBG("failed reading chip id");
+		goto err_poweroff;
+	}
+	if (chip_id != BMC150_MAGN_CHIP_ID_VAL) {
+		SYS_LOG_DBG("invalid voidchip id 0x%x", chip_id);
+		goto err_poweroff;
+	}
+	SYS_LOG_DBG("chip id 0x%x", chip_id);
+
+	preset = bmc150_magn_presets_table[BMC150_MAGN_DEFAULT_PRESET];
+	if (bmc150_magn_set_odr(dev, preset.odr) < 0) {
+		SYS_LOG_DBG("failed to set ODR to %d",
+			    preset.odr);
+		goto err_poweroff;
+	}
+
+	if (mraa_i2c_write_byte_data(dev->i2c,
+			       BMC150_MAGN_REPXY_TO_REGVAL(preset.rep_xy),
+			       BMC150_MAGN_REG_REP_XY)
+			       != MRAA_SUCCESS) {
+		SYS_LOG_DBG("failed to set REP XY to %d", preset.rep_xy);
+		goto err_poweroff;
+	}
+
+	if (mraa_i2c_write_byte_data(dev->i2c,
+			       BMC150_MAGN_REPZ_TO_REGVAL(preset.rep_z),
+			       BMC150_MAGN_REG_REP_Z) != MRAA_SUCCESS) {
+		SYS_LOG_DBG("failed to set REP Z to %d", preset.rep_z);
+		goto err_poweroff;
+	}
+
+	if (bmc150_magn_set_power_mode(dev, BMC150_MAGN_POWER_MODE_NORMAL, 1)
+				       < 0) {
+		SYS_LOG_DBG("failed to power on device");
+		goto err_poweroff;
+	}
+
+	if (mraa_i2c_read_bytes_data(dev->i2c,
+			   BMC150_MAGN_REG_TRIM_START, (uint8_t *)&dev->tregs,
+			   sizeof(dev->tregs)) != sizeof(dev->tregs)) {
+		SYS_LOG_DBG("failed to read trim regs");
+		goto err_poweroff;
+	}
+
+	dev->rep_xy = 0;
+	dev->rep_z = 0;
+	dev->odr = 0;
+	dev->max_odr = 0;
+	dev->sample_x = 0;
+	dev->sample_y = 0;
+	dev->sample_z = 0;
+
+	dev->tregs.xyz1 = sys_le16_to_cpu(dev->tregs.xyz1);
+	dev->tregs.z1 = sys_le16_to_cpu(dev->tregs.z1);
+	dev->tregs.z2 = sys_le16_to_cpu(dev->tregs.z2);
+	dev->tregs.z3 = sys_le16_to_cpu(dev->tregs.z3);
+	dev->tregs.z4 = sys_le16_to_cpu(dev->tregs.z4);
+
+	return 0;
+
+err_poweroff:
+	bmc150_magn_set_power_mode(dev, BMC150_MAGN_POWER_MODE_NORMAL, 0);
+	bmc150_magn_set_power_mode(dev, BMC150_MAGN_POWER_MODE_SUSPEND, 1);
+	return -EIO;
+}
+
+upm_bmc150_magn upm_bmc150_magn_init(int bus)
+{
+	upm_bmc150_magn dev = &upm_bmc150_magn_dev;
+
+    dev->i2c = mraa_i2c_init(bus);
+    if (dev->i2c == NULL) {
+    	SYS_LOG_DBG("Failed to open i2c bus %d\n", bus);
+    	return NULL;
+    }
+	if (bmc150_magn_init_chip(dev) < 0) {
+		SYS_LOG_DBG("failed to initialize chip");
+		return NULL;
+	}
+
+#if defined(CONFIG_BMC150_MAGN_TRIGGER_DRDY)
+	if (bmc150_magn_init_interrupt(dev) < 0) {
+		SYS_LOG_DBG("failed to initialize interrupts");
+		return NULL;
+	}
+#endif
+
+	return dev;
+}
diff --git a/ext/lib/mraa/examples/d2k-crb/src/bmc150.h b/ext/lib/mraa/examples/d2k-crb/src/bmc150.h
new file mode 100644
index 0000000..5304ade
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/src/bmc150.h
@@ -0,0 +1,160 @@
+/* sensor_bmc150_magn.h - header file for BMC150 magnetometer sensor driver */
+
+/*
+* Copyright (c) 2016 Intel Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+#ifndef __UPM_BMC150_MAGN_H__
+#define __UPM_BMC150_MAGN_H__
+
+#include <stdint.h>
+#include "mraa/i2c.h"
+
+#define BMC150_MAGN_REG_CHIP_ID		0x40
+#define BMC150_MAGN_CHIP_ID_VAL		0x32
+
+#define BMC150_MAGN_REG_X_L		0x42
+#define BMC150_MAGN_REG_X_M		0x43
+#define BMC150_MAGN_REG_Y_L		0x44
+#define BMC150_MAGN_REG_Y_M		0x45
+#define BMC150_MAGN_SHIFT_XY_L		3
+#define BMC150_MAGN_REG_Z_L		0x46
+#define BMC150_MAGN_REG_Z_M		0x47
+#define BMC150_MAGN_SHIFT_Z_L		1
+#define BMC150_MAGN_REG_RHALL_L		0x48
+#define BMC150_MAGN_REG_RHALL_M		0x49
+#define BMC150_MAGN_SHIFT_RHALL_L	2
+
+#define BMC150_MAGN_REG_INT_STATUS	0x4A
+
+#define BMC150_MAGN_REG_POWER		0x4B
+#define BMC150_MAGN_MASK_POWER_CTL	BIT(0)
+
+#define BMC150_MAGN_REG_OPMODE_ODR	0x4C
+#define BMC150_MAGN_MASK_OPMODE		(BIT(2) | BIT(1))
+#define BMC150_MAGN_SHIFT_OPMODE	1
+#define BMC150_MAGN_MODE_NORMAL		0x00
+#define BMC150_MAGN_MODE_FORCED		0x01
+#define BMC150_MAGN_MODE_SLEEP		0x03
+#define BMC150_MAGN_MASK_ODR		(BIT(5) | BIT(4) | BIT(3))
+#define BMC150_MAGN_SHIFT_ODR		3
+
+#define BMC150_MAGN_REG_LOW_THRESH	0x4F
+#define BMC150_MAGN_REG_HIGH_THRESH	0x50
+#define BMC150_MAGN_REG_REP_XY		0x51
+#define BMC150_MAGN_REG_REP_Z		0x52
+#define BMC150_MAGN_REG_REP_DATAMASK	0xFF
+
+#define BMC150_MAGN_REG_TRIM_START	0x5D
+#define BMC150_MAGN_REG_TRIM_END	0x71
+
+#define BMC150_MAGN_XY_OVERFLOW_VAL	-4096
+#define BMC150_MAGN_Z_OVERFLOW_VAL	-16384
+
+#define BMC150_MAGN_REGVAL_TO_REPXY(regval)	(((regval) * 2) + 1)
+#define BMC150_MAGN_REGVAL_TO_REPZ(regval)	((regval) + 1)
+#define BMC150_MAGN_REPXY_TO_REGVAL(rep)	(((rep) - 1) / 2)
+#define BMC150_MAGN_REPZ_TO_REGVAL(rep)		((rep) - 1)
+
+#define BMC150_MAGN_REG_INT                     0x4D
+
+#define BMC150_MAGN_REG_INT_DRDY                0x4E
+#define BMC150_MAGN_MASK_DRDY_EN                BIT(7)
+#define BMC150_MAGN_SHIFT_DRDY_EN               7
+#define BMC150_MAGN_MASK_DRDY_INT3              BIT(6)
+#define BMC150_MAGN_MASK_DRDY_Z_EN              BIT(5)
+#define BMC150_MAGN_MASK_DRDY_Y_EN              BIT(4)
+#define BMC150_MAGN_MASK_DRDY_X_EN              BIT(3)
+#define BMC150_MAGN_MASK_DRDY_DR_POLARITY       BIT(2)
+#define BMC150_MAGN_SHIFT_DRDY_DR_POLARITY      2
+#define BMC150_MAGN_MASK_DRDY_LATCHING          BIT(1)
+#define BMC150_MAGN_MASK_DRDY_INT3_POLARITY     BIT(0)
+
+#if defined(CONFIG_BMC150_MAGN_I2C_ADDR_12)
+	#define BMC150_MAGN_I2C_ADDR		0x12
+#elif defined(CONFIG_BMC150_MAGN_I2C_ADDR_13)
+	#define BMC150_MAGN_I2C_ADDR		0x13
+#endif
+
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_REP_XY) || \
+	defined(CONFIG_BMC150_MAGN_SAMPLING_REP_Z)
+	#define BMC150_MAGN_SET_ATTR_REP
+#endif
+
+#if defined(CONFIG_BMC150_MAGN_SAMPLING_RATE_RUNTIME) || \
+	defined(BMC150_MAGN_SET_ATTR_REP)
+	#define BMC150_MAGN_SET_ATTR
+#endif
+
+/*
+struct bmc150_magn_config {
+	char *i2c_master_dev_name;
+	uint16_t i2c_slave_addr;
+#if defined(CONFIG_BMC150_MAGN_TRIGGER_DRDY)
+	char *gpio_drdy_dev_name;
+	uint8_t gpio_drdy_int_pin;
+#endif
+};
+*/
+
+
+
+enum bmc150_magn_power_modes {
+	BMC150_MAGN_POWER_MODE_SUSPEND,
+	BMC150_MAGN_POWER_MODE_SLEEP,
+	BMC150_MAGN_POWER_MODE_NORMAL,
+};
+
+enum bmc150_magn_presets {
+	LOW_POWER_PRESET,
+	REGULAR_PRESET,
+	ENHANCED_REGULAR_PRESET,
+	HIGH_ACCURACY_PRESET
+};
+
+#if defined(CONFIG_BMC150_MAGN_PRESET_LOW_POWER)
+	#define BMC150_MAGN_DEFAULT_PRESET LOW_POWER_PRESET
+#elif defined(CONFIG_BMC150_MAGN_PRESET_REGULAR)
+	#define BMC150_MAGN_DEFAULT_PRESET REGULAR_PRESET
+#elif defined(CONFIG_BMC150_MAGN_PRESET_ENHANCED_REGULAR)
+	#define BMC150_MAGN_DEFAULT_PRESET ENHANCED_REGULAR_PRESET
+#elif defined(CONFIG_BMC150_MAGN_PRESET_HIGH_ACCURACY)
+	#define BMC150_MAGN_DEFAULT_PRESET HIGH_ACCURACY_PRESET
+#endif
+
+enum bmc150_magn_axis {
+	BMC150_MAGN_AXIS_X,
+	BMC150_MAGN_AXIS_Y,
+	BMC150_MAGN_AXIS_Z,
+	BMC150_MAGN_RHALL,
+	BMC150_MAGN_AXIS_XYZ_MAX = BMC150_MAGN_RHALL,
+	BMC150_MAGN_AXIS_XYZR_MAX,
+};
+
+
+// Public definitions
+typedef struct _upm_bmc150_magn* upm_bmc150_magn;
+upm_bmc150_magn upm_bmc150_magn_init(int bus);
+mraa_result_t upm_bmc150_magn_get_value(upm_bmc150_magn dev, double *x, double *y, double *z);
+
+#if defined(CONFIG_BMC150_MAGN_TRIGGER)
+int bmc150_magn_trigger_set(struct device *dev,
+			    const struct sensor_trigger *trig,
+			    sensor_trigger_handler_t handler);
+int bmc150_magn_init_interrupt(struct device *dev);
+#endif
+
+
+#endif /* __UPM_BMC150_MAGN_H__ */
diff --git a/ext/lib/mraa/examples/d2k-crb/src/main.c b/ext/lib/mraa/examples/d2k-crb/src/main.c
new file mode 100644
index 0000000..6f7b0e1
--- /dev/null
+++ b/ext/lib/mraa/examples/d2k-crb/src/main.c
@@ -0,0 +1,60 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <nanokernel.h>
+#include "bmc150.h"
+
+static void upm_print_driver_sample(upm_bmc150_magn dev)
+{
+    double value_x, value_y, value_z;
+    mraa_result_t ret = upm_bmc150_magn_get_value(dev, &value_x, &value_y, &value_z);
+    if (ret == MRAA_SUCCESS) {
+        printf("magn = ( %f  %f  %f )\n", value_x, value_y, value_z);
+    } else {
+        printf("upm_bmc150_magn_get_value failed. Code = %d\n", ret);
+        return;
+    }
+}
+
+void
+main(void)
+{
+    mraa_result_t status = mraa_init();
+    if (status == MRAA_SUCCESS) {
+        printf("Version %s on %s\n", mraa_get_version(), mraa_get_platform_name());
+        upm_bmc150_magn upm_dev = upm_bmc150_magn_init(0);
+        if (upm_dev == NULL) {
+            printf("upm_bmc150_magn_init failed\n");
+            return;
+        }
+        while (1) {
+            upm_print_driver_sample(upm_dev);
+            task_sleep(sys_clock_ticks_per_sec/20);
+        }
+    } else
+        printf("mraa_init() failed with error code %d\n", status);
+}
diff --git a/ext/lib/mraa/examples/i2c-detect/Makefile b/ext/lib/mraa/examples/i2c-detect/Makefile
new file mode 100644
index 0000000..4b2f047
--- /dev/null
+++ b/ext/lib/mraa/examples/i2c-detect/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = nano
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/i2c-detect/README.txt b/ext/lib/mraa/examples/i2c-detect/README.txt
new file mode 100644
index 0000000..6096cd3
--- /dev/null
+++ b/ext/lib/mraa/examples/i2c-detect/README.txt
@@ -0,0 +1,33 @@
+Title: Synchronisation
+
+Description:
+
+mraa sample console app using the microkernel.
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+This microkernel project outputs to the console.  It can be built and executed
+on QEMU as follows:
+
+    make qemu
+
+--------------------------------------------------------------------------------
+
+Troubleshooting:
+
+Problems caused by out-dated project information can be addressed by
+issuing one of the following commands then rebuilding the project:
+
+    make clean          # discard results of previous builds
+                        # but keep existing configuration info
+or
+    make pristine       # discard results of previous builds
+                        # and restore pre-defined configuration info
+
+--------------------------------------------------------------------------------
+
+Sample Output:
+
+Hello World!
diff --git a/ext/lib/mraa/examples/i2c-detect/prj.conf b/ext/lib/mraa/examples/i2c-detect/prj.conf
new file mode 100644
index 0000000..780f45f
--- /dev/null
+++ b/ext/lib/mraa/examples/i2c-detect/prj.conf
@@ -0,0 +1,4 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_I2C=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
diff --git a/ext/lib/mraa/examples/i2c-detect/prj.mdef b/ext/lib/mraa/examples/i2c-detect/prj.mdef
new file mode 100644
index 0000000..68b82dd
--- /dev/null
+++ b/ext/lib/mraa/examples/i2c-detect/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : mraa i2c-detect nano-kernel app
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/ext/lib/mraa/examples/i2c-detect/src/Makefile b/ext/lib/mraa/examples/i2c-detect/src/Makefile
new file mode 100644
index 0000000..00066e1
--- /dev/null
+++ b/ext/lib/mraa/examples/i2c-detect/src/Makefile
@@ -0,0 +1 @@
+obj-y = main.o
diff --git a/ext/lib/mraa/examples/i2c-detect/src/main.c b/ext/lib/mraa/examples/i2c-detect/src/main.c
new file mode 100644
index 0000000..7690351
--- /dev/null
+++ b/ext/lib/mraa/examples/i2c-detect/src/main.c
@@ -0,0 +1,92 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "mraa/i2c.h"
+
+
+void
+print_version()
+{
+    printf("Version %s on %s\n", mraa_get_version(), mraa_get_platform_name());
+}
+
+mraa_result_t
+i2c_get(int bus, uint8_t device_address, uint8_t register_address, uint8_t* data)
+{
+    mraa_result_t status = MRAA_SUCCESS;
+    mraa_i2c_context i2c = mraa_i2c_init(bus);
+    if (i2c == NULL) {
+        return MRAA_ERROR_NO_RESOURCES;
+    }
+    status = mraa_i2c_address(i2c, device_address);
+    if (status != MRAA_SUCCESS) {
+        goto i2c_get_exit;
+    }
+    int value = mraa_i2c_read_byte_data(i2c, register_address);
+    if (value != -1) {
+        *data = value & 0xFF;
+        status = MRAA_SUCCESS;
+    } else status = MRAA_ERROR_UNSPECIFIED;
+i2c_get_exit:
+    mraa_i2c_stop(i2c);
+    return status;
+}
+
+
+static void
+i2c_detect_devices(int bus)
+{
+    mraa_i2c_context i2c = mraa_i2c_init(bus);
+    if (i2c == NULL) {
+        printf("mraa_i2c_init() failed for bus %d\n", bus);
+        return;
+    }
+    int addr;
+    for (addr = 0x0; addr < 0x80; ++addr) {
+        uint8_t value;
+        if ((addr) % 16 == 0)
+            printf("%02x: ", addr);
+        if (i2c_get(bus, addr, 0, &value) == MRAA_SUCCESS)
+            printf("%02x ", addr);
+        else
+            printf("-- ");
+        if ((addr + 1) % 16 == 0)
+            printf("\n");
+    }
+}
+
+void
+main(void)
+{
+    mraa_result_t status = mraa_init();
+    if (status == MRAA_SUCCESS) {
+        print_version();
+        i2c_detect_devices(0);
+    } else {
+        printf("mraa_init() failed with error code %d\n", status);
+    }
+}
diff --git a/ext/lib/mraa/examples/mbed-app-shield/Makefile b/ext/lib/mraa/examples/mbed-app-shield/Makefile
new file mode 100644
index 0000000..4b2f047
--- /dev/null
+++ b/ext/lib/mraa/examples/mbed-app-shield/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = nano
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/mbed-app-shield/README.txt b/ext/lib/mraa/examples/mbed-app-shield/README.txt
new file mode 100644
index 0000000..8f6b630
--- /dev/null
+++ b/ext/lib/mraa/examples/mbed-app-shield/README.txt
@@ -0,0 +1,33 @@
+Title: mbed-app-shield
+
+Description:
+
+mraa sample app to exercise sensor and actuators on mbed "application shield"
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+This microkernel project outputs to the console.  It can be built and executed
+on QEMU as follows:
+
+    make qemu
+
+--------------------------------------------------------------------------------
+
+Troubleshooting:
+
+Problems caused by out-dated project information can be addressed by
+issuing one of the following commands then rebuilding the project:
+
+    make clean          # discard results of previous builds
+                        # but keep existing configuration info
+or
+    make pristine       # discard results of previous builds
+                        # and restore pre-defined configuration info
+
+--------------------------------------------------------------------------------
+
+Sample Output:
+
+Hello World!
diff --git a/ext/lib/mraa/examples/mbed-app-shield/prj.conf b/ext/lib/mraa/examples/mbed-app-shield/prj.conf
new file mode 100644
index 0000000..ee02c99
--- /dev/null
+++ b/ext/lib/mraa/examples/mbed-app-shield/prj.conf
@@ -0,0 +1,7 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_I2C=y
+CONFIG_GPIO=y
+
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_MRAA_GPIO=y
diff --git a/ext/lib/mraa/examples/mbed-app-shield/prj.mdef b/ext/lib/mraa/examples/mbed-app-shield/prj.mdef
new file mode 100644
index 0000000..68b82dd
--- /dev/null
+++ b/ext/lib/mraa/examples/mbed-app-shield/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : mraa i2c-detect nano-kernel app
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/ext/lib/mraa/examples/mbed-app-shield/src/Makefile b/ext/lib/mraa/examples/mbed-app-shield/src/Makefile
new file mode 100644
index 0000000..00066e1
--- /dev/null
+++ b/ext/lib/mraa/examples/mbed-app-shield/src/Makefile
@@ -0,0 +1 @@
+obj-y = main.o
diff --git a/ext/lib/mraa/examples/mbed-app-shield/src/main.c b/ext/lib/mraa/examples/mbed-app-shield/src/main.c
new file mode 100644
index 0000000..52bdd66
--- /dev/null
+++ b/ext/lib/mraa/examples/mbed-app-shield/src/main.c
@@ -0,0 +1,100 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <nanokernel.h>
+#include "mraa.h"
+
+#define SLEEPTICKS  SECONDS(1)
+
+#define GPIO_SW_CENTER                  4
+#define GPIO_SW_LED                     5
+
+#define LM75B_ADDRESS                   0x48
+#define LM75B_REGISTER_TEMPERATURE      0x00
+#define LM75B_REGISTER_CONFIGURATION    0x01
+#define LM75B_CONFIG_SHUTDOWN_MASK      0x01
+#define LM75B_CONFIG_SHUTDOWN_POWERON   0x00
+#define LM75B_CONFIG_SHUTDOWN_SHUTDOWN  0x01
+
+static void
+get_temperature(mraa_i2c_context i2c)
+{
+    mraa_i2c_address(i2c, LM75B_ADDRESS);
+    mraa_result_t status = mraa_i2c_write_byte_data(i2c, LM75B_CONFIG_SHUTDOWN_POWERON, LM75B_REGISTER_CONFIGURATION);
+    if (status != MRAA_SUCCESS) {
+        printf("mraa_i2c_write_byte %x failed\n", LM75B_REGISTER_CONFIGURATION);
+        return;
+    }
+    int regValue = mraa_i2c_read_word_data(i2c, LM75B_REGISTER_TEMPERATURE);
+    if (regValue == -1) {
+        printf("Failed to read temperature\n");
+        return;
+    }
+    int temperature = regValue & 0xFF;
+    printf("Temperature = %d\n", temperature);
+}
+
+void
+main(void)
+{
+    struct nano_timer timer;
+    void *timer_data[1];
+    nano_timer_init(&timer, timer_data);
+
+    printf("mbed application shield test\n");
+    mraa_result_t status = mraa_init();
+    if (status != MRAA_SUCCESS) {
+        printf("mraa_i2c_init failed\n");
+        return;
+    }
+    printf("mraa version %s on %s\n", mraa_get_version(), mraa_get_platform_name());
+    mraa_gpio_context gpio_sw_center = mraa_gpio_init(GPIO_SW_CENTER);
+    if (gpio_sw_center == NULL) {
+        printf("mraa_gpio_init for pin %d failed\n", GPIO_SW_CENTER);
+        return;
+    }
+    mraa_gpio_context gpio_sw_led = mraa_gpio_init(GPIO_SW_LED);
+    if (gpio_sw_led == NULL) {
+        printf("mraa_gpio_init for pin %d failed\n", GPIO_SW_LED);
+        return;
+    }
+    mraa_i2c_context i2c = mraa_i2c_init(0);
+    if (i2c == NULL) {
+        printf("mraa_i2c_init failed\n");
+        return;
+    }
+
+    mraa_boolean_t led_on = 1;
+    while (1) {
+        get_temperature(i2c);
+        printf("sw_center=%d\n", mraa_gpio_read(gpio_sw_center));
+        mraa_gpio_write(gpio_sw_led, led_on);
+        led_on = !led_on;
+        nano_timer_start(&timer, SLEEPTICKS);
+        nano_timer_test(&timer, TICKS_UNLIMITED);
+    }
+}
diff --git a/ext/lib/mraa/examples/shell/Makefile b/ext/lib/mraa/examples/shell/Makefile
new file mode 100644
index 0000000..0d56ce6
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/shell/README.txt b/ext/lib/mraa/examples/shell/README.txt
new file mode 100644
index 0000000..6096cd3
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/README.txt
@@ -0,0 +1,33 @@
+Title: Synchronisation
+
+Description:
+
+mraa sample console app using the microkernel.
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+This microkernel project outputs to the console.  It can be built and executed
+on QEMU as follows:
+
+    make qemu
+
+--------------------------------------------------------------------------------
+
+Troubleshooting:
+
+Problems caused by out-dated project information can be addressed by
+issuing one of the following commands then rebuilding the project:
+
+    make clean          # discard results of previous builds
+                        # but keep existing configuration info
+or
+    make pristine       # discard results of previous builds
+                        # and restore pre-defined configuration info
+
+--------------------------------------------------------------------------------
+
+Sample Output:
+
+Hello World!
diff --git a/ext/lib/mraa/examples/shell/prj.conf b/ext/lib/mraa/examples/shell/prj.conf
new file mode 100644
index 0000000..783eb1b
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+CONFIG_I2C=y
+CONFIG_GPIO=y
+
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_MRAA_GPIO=y
diff --git a/ext/lib/mraa/examples/shell/prj.mdef b/ext/lib/mraa/examples/shell/prj.mdef
new file mode 100644
index 0000000..ab2f097
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : mraa console app
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/ext/lib/mraa/examples/shell/src/Makefile b/ext/lib/mraa/examples/shell/src/Makefile
new file mode 100644
index 0000000..fe2110e
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/Makefile
@@ -0,0 +1 @@
+obj-y = atoi.o strtol.o gpio-cmd.o i2c-cmd.o main.o
diff --git a/ext/lib/mraa/examples/shell/src/atoi.c b/ext/lib/mraa/examples/shell/src/atoi.c
new file mode 100644
index 0000000..e63516c
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/atoi.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright Â© 2005-2014 Rich Felker, et al.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* From: http://fossies.org/dox/musl-1.0.5/atoi_8c_source.html */
+
+#include <stdlib.h>
+#include <ctype.h>
+
+int atoi(const char *s)
+{
+	int n = 0;
+	int neg = 0;
+
+	while (isspace(*s)) {
+		s++;
+	}
+	switch (*s) {
+	case '-':
+		neg = 1;
+	case '+':
+		s++;
+	}
+	/* Compute n as a negative number to avoid overflow on INT_MIN */
+	while (isdigit(*s)) {
+		n = 10*n - (*s++ - '0');
+	}
+	return neg ? n : -n;
+}
diff --git a/ext/lib/mraa/examples/shell/src/gpio-cmd.c b/ext/lib/mraa/examples/shell/src/gpio-cmd.c
new file mode 100644
index 0000000..5e42a0f
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/gpio-cmd.c
@@ -0,0 +1,208 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "mraa/gpio.h"
+
+
+static void
+print_help()
+{
+    printf("list              List pins\n");
+    printf("set pin level     Set pin to level (0/1)\n");
+    printf("get pin           Get pin level\n");
+    printf("monitor pin [off] Monitor pin level changes\n");
+    printf("version           Get mraa version and board name\n");
+}
+
+static void
+print_command_error()
+{
+    printf("Invalid command, options are:\n");
+    print_help();
+}
+
+static int
+list_platform_pins(uint8_t platform_offset)
+{
+    int pin_count = mraa_get_platform_pin_count(platform_offset);
+    int i;
+    for (i = 0; i < pin_count; ++i) {
+        int pin_id = platform_offset > 0 ? mraa_get_sub_platform_id(i) : i;
+        char* pin_name = mraa_get_pin_name(pin_id);
+        if (strcmp(pin_name, "INVALID") != 0) {
+            printf("%02d ", pin_id);
+            printf("%*s: ", (MRAA_PIN_NAME_SIZE - 1), pin_name);
+            if (mraa_pin_mode_test(pin_id, MRAA_PIN_GPIO))
+                printf("GPIO ");
+            if (mraa_pin_mode_test(pin_id, MRAA_PIN_I2C))
+                printf("I2C  ");
+            if (mraa_pin_mode_test(pin_id, MRAA_PIN_SPI))
+                printf("SPI  ");
+            if (mraa_pin_mode_test(pin_id, MRAA_PIN_PWM))
+                printf("PWM  ");
+            if (mraa_pin_mode_test(pin_id, MRAA_PIN_AIO))
+                printf("AIO  ");
+            if (mraa_pin_mode_test(pin_id, MRAA_PIN_UART))
+                printf("UART ");
+            printf("\n");
+        }
+    }
+    return pin_count;
+}
+
+static int
+list_pins()
+{
+    int pin_count = 0;
+    pin_count += list_platform_pins(MRAA_MAIN_PLATFORM_OFFSET);
+    if (pin_count == 0) {
+        printf("No Pins\n");
+    }
+    return pin_count;
+}
+
+static mraa_result_t
+gpio_set(int pin, int level)
+{
+    mraa_gpio_context gpio = mraa_gpio_init(pin);
+    if (gpio != NULL) {
+        mraa_gpio_dir(gpio, MRAA_GPIO_OUT);
+        mraa_gpio_write(gpio, level);
+        return MRAA_SUCCESS;
+    }
+    return MRAA_ERROR_INVALID_RESOURCE;
+}
+
+static mraa_result_t
+gpio_get(int pin, int* level)
+{
+    mraa_gpio_context gpio = mraa_gpio_init(pin);
+    if (gpio != NULL) {
+        mraa_gpio_dir(gpio, MRAA_GPIO_IN);
+        *level = mraa_gpio_read(gpio);
+        return MRAA_SUCCESS;
+    }
+    return MRAA_ERROR_INVALID_RESOURCE;
+}
+
+static void
+gpio_isr_handler(void* args)
+{
+    mraa_gpio_context dev = (mraa_gpio_context)args;
+    int level = mraa_gpio_read(dev);
+    printf("Pin %d = %d\n", mraa_gpio_get_pin_raw(dev), level);
+}
+
+static mraa_result_t
+gpio_isr_start(int pin)
+{
+    mraa_gpio_context dev = mraa_gpio_init(pin);
+    if (dev != NULL) {
+        mraa_result_t status = mraa_gpio_dir(dev, MRAA_GPIO_IN);
+        if (status == MRAA_SUCCESS) {
+            status = mraa_gpio_isr(dev, MRAA_GPIO_EDGE_BOTH, &gpio_isr_handler, dev);
+        }
+        return status;
+    } else {
+        return MRAA_ERROR_INVALID_RESOURCE;
+    }
+}
+
+static mraa_result_t
+gpio_isr_stop(int pin)
+{
+    mraa_gpio_context dev = mraa_gpio_init(pin);
+    if (dev != NULL) {
+        mraa_gpio_isr_exit(dev);
+        mraa_gpio_close(dev);
+    }
+    return MRAA_SUCCESS;
+}
+
+void
+gpio_cmd_help(int argc, char* argv[])
+{
+    print_help();
+}
+
+void
+gpio_cmd_list(int argc, char* argv[])
+{
+    list_pins();
+}
+
+void
+gpio_cmd_set(int argc, char* argv[])
+{
+    if (argc == 3) {
+        int pin = atoi(argv[1]);
+        if (gpio_set(pin, atoi(argv[2])) != MRAA_SUCCESS)
+            printf("Could not set gpio %d\n", pin);
+    } else {
+        printf("Invalid command\n");
+    }
+}
+
+void
+gpio_cmd_get(int argc, char* argv[])
+{
+    if (argc == 2) {
+        int pin = atoi(argv[1]);
+        int level;
+        if (gpio_get(pin, &level) == MRAA_SUCCESS) {
+            printf("Pin %d = %d\n", pin, level);
+        } else {
+            printf("Could not read gpio %d\n", pin);
+        }
+    } else {
+        printf("Invalid command\n");
+    }
+}
+
+void
+gpio_cmd_monitor(int argc, char* argv[])
+{
+    if (argc == 2) {
+        int pin = atoi(argv[1]);
+        if (gpio_isr_start(pin) == MRAA_SUCCESS) {
+            printf("Monitoring level changes to pin %d\n", pin);
+            // gpio_isr_handler(mraa_gpio_init(pin));
+        } else {
+            printf("Failed to register ISR for pin %d\n", pin);
+        }
+    } else if (argc == 3) {
+        int pin = atoi(argv[1]);
+        if (gpio_isr_stop(pin) == MRAA_SUCCESS) {
+            printf("Stopped monitoring level changes to pin %d\n", pin);
+        } else {
+            printf("Failed to deregister ISR for pin %d\n", pin);
+        }
+    } else {
+        printf("Invalid command\n");
+    }
+}
+
diff --git a/ext/lib/mraa/examples/shell/src/gpio-cmd.h b/ext/lib/mraa/examples/shell/src/gpio-cmd.h
new file mode 100644
index 0000000..81900ed
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/gpio-cmd.h
@@ -0,0 +1,7 @@
+#pragma once
+
+void gpio_cmd_help(int argc, char* argv[]);
+void gpio_cmd_list(int argc, char* argv[]);
+void gpio_cmd_set(int argc, char* argv[]);
+void gpio_cmd_get(int argc, char* argv[]);
+void gpio_cmd_monitor(int argc, char* argv[]);
diff --git a/ext/lib/mraa/examples/shell/src/i2c-cmd.c b/ext/lib/mraa/examples/shell/src/i2c-cmd.c
new file mode 100644
index 0000000..c5d42c3
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/i2c-cmd.c
@@ -0,0 +1,203 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "mraa/i2c.h"
+#include "../source/mraa_internal.h"
+#include "../source/mraa_internal_types.h"
+
+
+
+void
+print_help()
+{
+    printf("list                      List available busses\n");
+    printf("detect bus                List detected devices on specified bus\n");
+    printf("get bus device reg        Get value from specified device register\n");
+    printf("set bus device reg value  Set specified device register to value\n");
+}
+
+void
+print_command_error()
+{
+    printf("Invalid command, options are:\n");
+    print_help();
+}
+
+void
+print_busses()
+{
+    int i, bus;
+    for (i = 0; i < plat->i2c_bus_count; ++i) {
+        bus = i;
+        char* busType = "internal";
+        int id = plat->i2c_bus[i].bus_id;
+        printf("Bus %3d: id=%02d type=%s ", bus, id, busType);
+        if (i == plat->def_i2c_bus)
+            printf(" default");
+        if (id == -1)
+            printf(" disabled");
+
+        printf("\n");
+    }
+}
+
+mraa_result_t
+i2c_get(int bus, uint8_t device_address, uint8_t register_address, uint8_t* data)
+{
+    mraa_result_t status = MRAA_SUCCESS;
+    mraa_i2c_context i2c = mraa_i2c_init(bus);
+    if (i2c == NULL) {
+        return MRAA_ERROR_NO_RESOURCES;
+    }
+    status = mraa_i2c_address(i2c, device_address);
+    if (status != MRAA_SUCCESS) {
+        goto i2c_get_exit;
+    }
+    int value = mraa_i2c_read_byte_data(i2c, register_address);
+    if (value != -1) {
+        *data = value & 0xFF;
+        status = MRAA_SUCCESS;
+    } else
+        status = MRAA_ERROR_UNSPECIFIED;
+i2c_get_exit:
+    mraa_i2c_stop(i2c);
+    return status;
+}
+
+mraa_result_t
+i2c_set(int bus, uint8_t device_address, uint8_t register_address, uint8_t data)
+{
+    mraa_result_t status = MRAA_SUCCESS;
+    mraa_i2c_context i2c = mraa_i2c_init(bus);
+    if (i2c == NULL) {
+        return MRAA_ERROR_NO_RESOURCES;
+    }
+    status = mraa_i2c_address(i2c, device_address);
+    if (status != MRAA_SUCCESS) {
+        printf("Could not set i2c device address\n");
+        goto i2c_set_exit;
+    }
+    status = mraa_i2c_write_byte_data(i2c, data, register_address);
+    if (status != MRAA_SUCCESS) {
+        printf("Could not write to i2c register. Status = %d\n", status);
+        goto i2c_set_exit;
+    }
+i2c_set_exit:
+    mraa_i2c_stop(i2c);
+    return status;
+}
+
+void
+i2c_detect_devices(int bus)
+{
+    mraa_i2c_context i2c = mraa_i2c_init(bus);
+    if (i2c == NULL) {
+        return;
+    }
+    int addr;
+    for (addr = 0x0; addr < 0x80; ++addr) {
+        uint8_t value;
+        if ((addr) % 16 == 0)
+            printf("%02x: ", addr);
+        if (i2c_get(bus, addr, 0, &value) == MRAA_SUCCESS)
+            printf("%02x ", addr);
+        else
+            printf("-- ");
+        if ((addr + 1) % 16 == 0)
+            printf("\n");
+    }
+}
+
+int
+i2c_process_command(int argc, char** argv)
+{
+    int status = 0;
+    if (strcmp(argv[1], "help") == 0) {
+        print_help();
+        return 0;
+    } else if (strcmp(argv[1], "list") == 0) {
+        print_busses();
+        return 0;
+    } else if (strcmp(argv[1], "detect") == 0) {
+        if (argc == 3) {
+            int bus = strtol(argv[2], NULL, 0);
+            i2c_detect_devices(bus);
+            return 0;
+        } else {
+            print_command_error();
+            return 1;
+        }
+    } else if ((strcmp(argv[1], "get") == 0) || (strcmp(argv[1], "getrpt") == 0)) {
+        if (argc == 5) {
+            int interation = 0;
+            mraa_boolean_t should_repeat = strcmp(argv[1], "getrpt") == 0;
+            int bus = strtol(argv[2], NULL, 0);
+            uint8_t device_address = strtol(argv[3], NULL, 0);
+            uint8_t register_address = strtol(argv[4], NULL, 0);
+            // printf("Device %02X, Register = %02X\n", device_address, register_address);
+            uint8_t data;
+            do {
+                if (i2c_get(bus, device_address, register_address, &data) == MRAA_SUCCESS) {
+                    if (should_repeat)
+                        printf("%4d: ", interation);
+                    printf("Register %#02X = %#02X\n", register_address, data);
+                    status = 0;
+                } else {
+                    printf("i2c get failed\n");
+                    status = 1;
+                }
+                interation++;
+                // usleep(10000);
+            } while (should_repeat && status == 0);
+        } else {
+            print_command_error();
+            status = 1;
+        }
+        return status;
+    } else if ((strcmp(argv[1], "set") == 0)) {
+        if (argc == 6) {
+            int bus = strtol(argv[2], NULL, 0);
+            uint8_t device_address = strtol(argv[3], NULL, 0);
+            uint8_t register_address = strtol(argv[4], NULL, 0);
+            uint8_t value = strtol(argv[5], NULL, 0);
+            printf("Device %02X, Register = %02X, Value = %02X\n", device_address,
+                    register_address, value);
+            if (i2c_set(bus, device_address, register_address, value) != MRAA_SUCCESS) {
+                printf("i2c set failed\n");
+                return 0;
+            }
+            return 1;
+        } else {
+            print_command_error();
+            return 1;
+        }
+    } else {
+        print_command_error();
+        return 1;
+    }
+}
+
diff --git a/ext/lib/mraa/examples/shell/src/i2c-cmd.h b/ext/lib/mraa/examples/shell/src/i2c-cmd.h
new file mode 100644
index 0000000..9d7bedf
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/i2c-cmd.h
@@ -0,0 +1,32 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+int i2c_process_command(int argc, char* argv[]);
+void i2c_cmd_help(int argc, char* argv[]);
+void i2c_cmd_list(int argc, char* argv[]);
+void i2c_cmd_set(int argc, char* argv[]);
+void i2c_cmd_get(int argc, char* argv[]);
+void i2c_cmd_detect(int argc, char* argv[]);
diff --git a/ext/lib/mraa/examples/shell/src/main.c b/ext/lib/mraa/examples/shell/src/main.c
new file mode 100644
index 0000000..516c48e
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/main.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <misc/shell.h>
+#include "mraa/common.h"
+#include "gpio-cmd.h"
+#include "i2c-cmd.h"
+
+
+void
+print_version()
+{
+    printf("Version %s on %s\n", mraa_get_version(), mraa_get_platform_name());
+}
+
+static void
+shell_cmd_version(int argc, char* argv[])
+{
+    print_version();
+}
+
+static void
+shell_cmd_gpio(int argc, char* argv[])
+{
+    argc--;
+    for (int i = 0; i < argc; ++i)
+        argv[i] = argv[i+1];
+    if (argc > 0) {
+        if (strcmp(argv[0], "help") == 0)
+            gpio_cmd_help(argc, argv);
+        else if (strcmp(argv[0], "list") == 0)
+            gpio_cmd_list(argc, argv);
+        else if (strcmp(argv[0], "get") == 0)
+            gpio_cmd_get(argc, argv);
+        else if (strcmp(argv[0], "set") == 0)
+            gpio_cmd_set(argc, argv);
+        else if (strcmp(argv[0], "monitor") == 0)
+            gpio_cmd_monitor(argc, argv);
+        else {
+            printf("Unknown gpio command.\n");
+            gpio_cmd_help(argc, argv);
+        }
+    } else
+        printf("Must specify gpio command. \n");
+}
+
+static void
+shell_cmd_i2c(int argc, char* argv[])
+{
+    i2c_process_command(argc, argv);
+}
+
+
+
+const struct shell_cmd commands[] = { { "version", shell_cmd_version },
+                                      { "gpio", shell_cmd_gpio },
+                                      { "i2c", shell_cmd_i2c },
+                                      { NULL, NULL } };
+
+void
+main(void)
+{
+    mraa_result_t status = mraa_init();
+    if (status == MRAA_SUCCESS) {
+        print_version();
+        shell_init("mraa> ", commands);
+    } else {
+        printf("mraa_init() failed with error code %d\n", status);
+    }
+}
diff --git a/ext/lib/mraa/examples/shell/src/strtol.c b/ext/lib/mraa/examples/shell/src/strtol.c
new file mode 100644
index 0000000..9617c2b
--- /dev/null
+++ b/ext/lib/mraa/examples/shell/src/strtol.c
@@ -0,0 +1,119 @@
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <limits.h>
+#include <ctype.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/*
+ * Convert a string to a long integer.
+ *
+ * Ignores `locale' stuff.  Assumes that the upper and lower case
+ * alphabets and digits are each contiguous.
+ */
+long strtol(const char *nptr, char **endptr, register int base)
+{
+	register const char *s = nptr;
+	register unsigned long acc;
+	register int c;
+	register unsigned long cutoff;
+	register int neg = 0, any, cutlim;
+
+	/*
+	 * Skip white space and pick up leading +/- sign if any.
+	 * If base is 0, allow 0x for hex and 0 for octal, else
+	 * assume decimal; if base is already 16, allow 0x.
+	 */
+	do {
+		c = *s++;
+	} while (isspace(c));
+	if (c == '-') {
+		neg = 1;
+		c = *s++;
+	} else if (c == '+')
+		c = *s++;
+	if ((base == 0 || base == 16) &&
+	    c == '0' && (*s == 'x' || *s == 'X')) {
+		c = s[1];
+		s += 2;
+		base = 16;
+	}
+	if (base == 0)
+		base = c == '0' ? 8 : 10;
+
+	/*
+	 * Compute the cutoff value between legal numbers and illegal
+	 * numbers.  That is the largest legal value, divided by the
+	 * base.  An input number that is greater than this value, if
+	 * followed by a legal input character, is too big.  One that
+	 * is equal to this value may be valid or not; the limit
+	 * between valid and invalid numbers is then based on the last
+	 * digit.  For instance, if the range for longs is
+	 * [-2147483648..2147483647] and the input base is 10,
+	 * cutoff will be set to 214748364 and cutlim to either
+	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
+	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
+	 * the number is too big, and we will return a range error.
+	 *
+	 * Set any if any `digits' consumed; make it negative to indicate
+	 * overflow.
+	 */
+	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
+	cutlim = cutoff % (unsigned long)base;
+	cutoff /= (unsigned long)base;
+	for (acc = 0, any = 0;; c = *s++) {
+		if (isdigit(c))
+			c -= '0';
+		else if (isalpha(c))
+			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
+		else
+			break;
+		if (c >= base)
+			break;
+		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
+			any = -1;
+		else {
+			any = 1;
+			acc *= base;
+			acc += c;
+		}
+	}
+	if (any < 0) {
+		acc = neg ? LONG_MIN : LONG_MAX;
+		errno = ERANGE;
+	} else if (neg)
+		acc = -acc;
+	if (endptr != 0)
+		*endptr = (char *)(any ? s - 1 : nptr);
+	return acc;
+}
diff --git a/ext/lib/mraa/examples/uart-write/Makefile b/ext/lib/mraa/examples/uart-write/Makefile
new file mode 100644
index 0000000..7513c05
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = micro
+BOARD ?= arduino_101_factory
+CONF_FILE = prj_1.4.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/ext/lib/mraa/examples/uart-write/README.txt b/ext/lib/mraa/examples/uart-write/README.txt
new file mode 100644
index 0000000..77988b9
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/README.txt
@@ -0,0 +1,47 @@
+Title: Synchronisation
+
+Description:
+
+A simple UART program which runs on the microkernel.
+
+--------------------------------------------------------------------------------
+
+Building and Running Project:
+
+This UART project runs with both Zephyr v1.4 and v1.5. The outputs would
+differ slightly on both. On 1.4 you would be able to see the output from the
+nanokernel side as well, however on v1.5 you would only see some scrambled
+characters from the nanokernel side. In order to run the project:
+
+V1.4:
+In the Makefile for the project change the config file to point to the
+1.4 config file:
+CONF_FILE = prj_1.4.conf
+
+V1.5:
+Change the config file to point to the 1.5 config file:
+CONF_FILE = prj_1.5.conf
+
+make pristine
+
+make BOARD=arduino_101_factory
+
+if using DFU-UTIL:
+dfu-util -a x86_app -D outdir/zephyr.bin -R
+
+if using JTAG/Flyswatter:
+make BOARD=arduino_101_factory flash
+
+--------------------------------------------------------------------------------
+
+Sample Output:
+
+V1.4:
+ipm_console0: 'Hello World!'
+Kernel: 1.4
+Baudrate: 9600
+
+V1.5
+(scrambled characters)
+Kernel: 1.5
+Baudrate: 9600
diff --git a/ext/lib/mraa/examples/uart-write/prj.mdef b/ext/lib/mraa/examples/uart-write/prj.mdef
new file mode 100644
index 0000000..6c33f79
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : Hello demo
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/ext/lib/mraa/examples/uart-write/prj_1.4.conf b/ext/lib/mraa/examples/uart-write/prj_1.4.conf
new file mode 100644
index 0000000..09bd051
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/prj_1.4.conf
@@ -0,0 +1,14 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
+CONFIG_SERIAL=y
+CONFIG_UART_QMSI=y
+CONFIG_UART_QMSI_1=y
+CONFIG_MRAA=y
+CONFIG_MRAA_UART=y
+CONFIG_NEWLIB_LIBC=y
+#CONFIG_UART_LINE_CTRL=y
+CONFIG_UART_QMSI_1_BAUDRATE=9600
+CONFIG_MRAA=y
diff --git a/ext/lib/mraa/examples/uart-write/prj_1.5.conf b/ext/lib/mraa/examples/uart-write/prj_1.5.conf
new file mode 100644
index 0000000..8399a74
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/prj_1.5.conf
@@ -0,0 +1,14 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
+CONFIG_SERIAL=y
+CONFIG_UART_QMSI=y
+CONFIG_UART_QMSI_1=y
+CONFIG_MRAA=y
+CONFIG_MRAA_UART=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_UART_LINE_CTRL=y
+#CONFIG_UART_QMSI_1_BAUDRATE=9600
+CONFIG_MRAA=y
diff --git a/ext/lib/mraa/examples/uart-write/src/Makefile b/ext/lib/mraa/examples/uart-write/src/Makefile
new file mode 100644
index 0000000..00066e1
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/src/Makefile
@@ -0,0 +1 @@
+obj-y = main.o
diff --git a/ext/lib/mraa/examples/uart-write/src/main.c b/ext/lib/mraa/examples/uart-write/src/main.c
new file mode 100644
index 0000000..d8bf402
--- /dev/null
+++ b/ext/lib/mraa/examples/uart-write/src/main.c
@@ -0,0 +1,77 @@
+/*
+ * Author: Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "version.h"
+#include <device.h>
+#include <mraa/uart.h>
+#include <string.h>
+#include <sys_clock.h>
+#include <zephyr.h>
+
+#define UART_DEVICE "UART_1"
+#define SLEEPTICKS SECONDS(1)
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT printf
+#else
+#include <misc/printk.h>
+#define PRINT printk
+#endif
+
+void
+main(void)
+{
+    struct nano_timer timer;
+    void* timer_data[1];
+    nano_timer_init(&timer, timer_data);
+    if (mraa_init() != MRAA_SUCCESS) {
+        printf("Unable to init MRAA");
+    }
+    mraa_uart_context dev = mraa_uart_init(1);
+#if KERNELVERSION == 0x1040000
+    if (mraa_uart_write(dev, "Kernel: 1.4\n", 12) != 12) {
+        printf("Error occured while writing bytes to UART\n");
+    }
+    if (mraa_uart_write(dev, "Baudrate: 9600\n", 15) != 15) {
+        printf("Error occured while writing bytes to UART\n");
+    }
+    // adding a delay of 100 ms
+    nano_timer_start(&timer, MSEC(100));
+    nano_timer_test(&timer, TICKS_UNLIMITED);
+#elif KERNELVERSION >= 0x1050000
+    // function only available with Zephyr 1.5 and above
+    mraa_uart_set_baudrate(dev, 9600);
+    if (mraa_uart_write(dev, "Kernel: 1.5\n", 12) != 12) {
+        printf("Error occured while writing bytes to UART\n");
+    }
+    if (mraa_uart_write(dev, "Baudrate: 9600\n", 15) != 15) {
+        printf("Error occured while writing bytes to UART\n");
+    }
+    // adding a delay of 100 ms
+    nano_timer_start(&timer, MSEC(100));
+    nano_timer_test(&timer, TICKS_UNLIMITED);
+#endif
+    mraa_uart_stop(dev);
+}
diff --git a/ext/lib/mraa/include/mraa.h b/ext/lib/mraa/include/mraa.h
new file mode 100644
index 0000000..edfdd1c
--- /dev/null
+++ b/ext/lib/mraa/include/mraa.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2015, Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MRAA_H__
+#define __MRAA_H__
+
+#include "mraa/aio.h"
+// #include "mraa/common.h"
+#include "mraa/spi.h"
+#include "mraa/i2c.h"
+#include "mraa/gpio.h"
+#include "mraa/pwm.h"
+#include "mraa/uart.h"
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/aio.h b/ext/lib/mraa/include/mraa/aio.h
new file mode 100644
index 0000000..6674104
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/aio.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2016, Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MRAA_AIO_H__
+#define __MRAA_AIO_H__
+
+#include "common.h"
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Opaque pointer definition to the internal struct _aio. This context refers
+ * to one single AIO pin on the board.
+ */
+typedef struct _aio* mraa_aio_context;
+
+/**
+ * Initialise an Analog input device, connected to the specified pin
+ *
+ * @param pin Channel number to read ADC inputs
+ * @returns aio context or NULL
+ */
+mraa_aio_context mraa_aio_init(unsigned int pin);
+
+/**
+ * Read the input voltage. By default mraa will shift the raw value up or down
+ * to a 10 bit value.
+ *
+ * @param dev The AIO context
+ * @returns The current input voltage or -1 for error
+ */
+int mraa_aio_read(mraa_aio_context dev);
+
+/**
+ * Read the input voltage and return it as a normalized float (0.0f-1.0f).
+ *
+ * @param dev The AIO context
+ * @returns The current input voltage as a normalized float (0.0f-1.0f), error
+ * will be signaled by -1.0f
+ */
+float mraa_aio_read_float(mraa_aio_context dev);
+
+/**
+ * Close the analog input context, this will free the memory for the context
+ *
+ * @param dev The AIO context
+ * @return Result of operation
+ */
+mraa_result_t mraa_aio_close(mraa_aio_context dev);
+
+/**
+ * Set the bit value which mraa will shift the raw reading
+ * from the ADC to. I.e. 10bits
+ * @param dev the analog input context
+ * @param bits the bits the return from read should be i.e 10
+ *
+ * @return mraa result type
+ */
+mraa_result_t mraa_aio_set_bit(mraa_aio_context dev, int bits);
+
+/**
+ * Gets the bit value mraa is shifting the analog read to.
+ * @param dev the analog input context
+ *
+ * @return bit value mraa is set return from the read function
+ */
+int mraa_aio_get_bit(mraa_aio_context dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/common.h b/ext/lib/mraa/include/mraa/common.h
new file mode 100644
index 0000000..c324261
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/common.h
@@ -0,0 +1,279 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Copyright Â© 2014 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __MRAA_COMMON_H__
+#define __MRAA_COMMON_H__
+
+#include <stdint.h>
+#include "types.h"
+
+#define MRAA_PLATFORM_NAME_MAX_SIZE 64
+#define MRAA_PIN_NAME_SIZE 8
+
+#define MRAA_SUB_PLATFORM_BIT_SHIFT 9
+#define MRAA_SUB_PLATFORM_MASK (1<<MRAA_SUB_PLATFORM_BIT_SHIFT)
+
+#define MRAA_MAIN_PLATFORM_OFFSET 0
+#define MRAA_SUB_PLATFORM_OFFSET 1
+
+/** Executes function func and returns its result in case of error
+ */
+#define MRAA_RETURN_FOR_ERROR(func) do { \
+                                      mraa_result_t res; \
+                                      res = func; \
+                                      if (res != MRAA_SUCCESS) \
+                                      return res;} while(0)
+
+/** @file
+ *
+ * This file defines the basic shared values for libmraa
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Initialise MRAA
+ *
+ * Detects running platform and attempts to use included pinmap, this is run on
+ * module/library init/load but is handy to rerun to check board initialised
+ * correctly. MRAA_SUCCESS inidicates correct initialisation.
+ *
+ * @return Result of operation
+ */
+mraa_result_t mraa_init();
+
+/**
+ * De-Initilise MRAA
+ *
+ * This is not a strict requirement but useful to test memory leaks and for
+ * people who like super clean code. If dynamically loading & unloading
+ * libmraa you need to call this before unloading the library.
+ */
+void mraa_deinit();
+
+/**
+ * Checks if a pin is able to use the passed in mode.
+ *
+ * @param pin Physical Pin to be checked.
+ * @param mode the mode to be tested.
+ * @return boolean if the mode is supported, 0=false.
+ */
+mraa_boolean_t mraa_pin_mode_test(int pin, mraa_pinmodes_t mode);
+
+/**
+ * Check the board's  bit size when reading the value
+ *
+ * @return raw bits being read from kernel module. zero if no ADC
+ */
+unsigned int mraa_adc_raw_bits();
+
+/**
+ * Check the specified board's bit size when reading the value
+ *
+ * @param specified platform offset; 0 for main platform, 1 foor sub platform
+ * @return raw bits being read from kernel module. zero if no ADC
+ */
+unsigned int mraa_get_platform_adc_raw_bits(uint8_t platform_offset);
+
+/**
+ * Return value that the raw value should be shifted to. Zero if no ADC
+ *
+ * @return return actual bit size the adc value should be understood as.
+ */
+unsigned int mraa_adc_supported_bits();
+
+/**
+ * Return value that the raw value should be shifted to. Zero if no ADC
+ *
+ * @param specified platform offset; 0 for main platform, 1 foor sub platform
+ * @return return actual bit size the adc value should be understood as.
+ */
+unsigned int mraa_get_platform_adc_supported_bits(int platform_offset);
+
+/**
+ * Sets the log level to use from 0-7 where 7 is very verbose. These are the
+ * syslog log levels, see syslog(3) for more information on the levels.
+ *
+ * @return Result of operation
+ */
+mraa_result_t mraa_set_log_level(int level);
+
+/**
+ * Return the Platform's Name, If no platform detected return NULL
+ *
+ * @return platform name
+ */
+const char* mraa_get_platform_name();
+
+/**
+ * Return the platform's versioning info, the information given depends per
+ * platform and can be NULL. platform_offset has to be given. Do not modify
+ * this pointer
+ *
+ * @param specified platform offset; 0 for main platform, 1 fMRAA_PIN_NAME_SIZEor sub platform
+ * @return platform's versioning string
+ */
+const char* mraa_get_platform_version(int platform_offset);
+
+/**
+ * This function attempts to set the mraa process to a given priority and the
+ * scheduler to SCHED_RR. Highest * priority is typically 99 and minimum is 0.
+ * This function * will set to MAX if * priority is > MAX. Function will return
+ * -1 on failure.
+ *
+ * @param priority Value from typically 0 to 99
+ * @return The priority value set
+ */
+int mraa_set_priority(const unsigned int priority);
+
+/** Get the version string of mraa autogenerated from git tag
+ *
+ * The version returned may not be what is expected however it is a reliable
+ * number associated with the git tag closest to that version at build time
+ *
+ * @return version string from version.h
+ */
+const char* mraa_get_version();
+
+/**
+ * Print a textual representation of the mraa_result_t
+ *
+ * @param result the result to print
+ */
+void mraa_result_print(mraa_result_t result);
+
+/**
+ * Get platform type, board must be initialised.
+ *
+ * @return mraa_platform_t Platform type enum
+ */
+mraa_platform_t mraa_get_platform_type();
+
+/**
+ * Get combined platform type, board must be initialised.
+ * The combined type is represented as
+ * (sub_platform_type << 8) | main_platform_type
+ *
+ * @return int combined platform type
+ */
+int mraa_get_platform_combined_type();
+
+/**
+ * Get platform pincount, board must be initialised.
+ *
+ * @return uint of physical pin count on the in-use platform
+ */
+unsigned int mraa_get_pin_count();
+
+/**
+ * Get platform usable I2C bus count, board must be initialised.
+ *
+ * @return number f usable I2C bus count on the current platform. Function will
+ * return -1 on failure
+ */
+int mraa_get_i2c_bus_count();
+
+/**
+ * Get I2C adapter number in sysfs.
+ *
+ * @param i2c_bus the logical I2C bus number
+ * @return I2C adapter number in sysfs. Function will return -1 on failure
+ */
+int mraa_get_i2c_bus_id(unsigned int i2c_bus);
+
+/**
+ * Get specified platform pincount, board must be initialised.
+ *
+ * @param specified platform offset; 0 for main platform, 1 foor sub platform
+ * @return uint of physical pin count on the in-use platform
+ */
+unsigned int mraa_get_platform_pin_count(uint8_t platform_offset);
+
+/**
+* Get name of pin, board must be initialised.
+*
+* @param pin number
+* @return char* of pin name
+*/
+char* mraa_get_pin_name(int pin);
+
+/**
+ * Get default i2c bus, board must be initialised.
+ *
+ * @return int default i2c bus index
+ */
+int mraa_get_default_i2c_bus(uint8_t platform_offset);
+
+/**
+ * Detect presence of sub platform.
+ *
+ * @return mraa_boolean_t 1 if sub platform is present and initialized, 0 otherwise
+ */
+mraa_boolean_t mraa_has_sub_platform();
+
+
+/**
+ * Check if pin or bus id includes sub platform mask.
+ *
+ * @param int pin or bus number
+ *
+ * @return mraa_boolean_t 1 if pin or bus is for sub platform, 0 otherwise
+ */
+mraa_boolean_t mraa_is_sub_platform_id(int pin_or_bus_id);
+
+/**
+ * Convert pin or bus index to corresponding sub platform id.
+ *
+ * @param int pin or bus index
+ *
+ * @return int sub platform pin or bus number
+ */
+int mraa_get_sub_platform_id(int pin_or_bus_index);
+
+/**
+ * Convert pin or bus sub platform id to index.
+ *
+ * @param int sub platform pin or bus id
+ *
+ * @return int pin or bus index
+ */
+int mraa_get_sub_platform_index(int pin_or_bus_id);
+
+/**
+ * Add mraa subplatform
+ *
+ * @param subplatform type
+ * @param uart device subplatform is on
+ *
+ * @return mraa_result_t indicating success
+ */
+mraa_result_t mraa_add_subplatform(mraa_platform_t subplatformtype, const char* uart_dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/gpio.h b/ext/lib/mraa/include/mraa/gpio.h
new file mode 100644
index 0000000..98a6263
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/gpio.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2015, Intel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its contributors
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MRAA_GPIO_H__
+#define __MRAA_GPIO_H__
+
+#include "common.h"
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _gpio* mraa_gpio_context;
+
+/**
+ * Gpio Output modes
+ */
+typedef enum {
+    MRAA_GPIO_STRONG = 0,   /**< Default. Strong high and low */
+    MRAA_GPIO_PULLUP = 1,   /**< Resistive High */
+    MRAA_GPIO_PULLDOWN = 2, /**< Resistive Low */
+    MRAA_GPIO_HIZ = 3       /**< High Z State */
+} mraa_gpio_mode_t;
+
+/**
+ * Gpio Direction options
+ */
+typedef enum {
+    MRAA_GPIO_OUT = 0,      /**< Output. A Mode can also be set */
+    MRAA_GPIO_IN = 1,       /**< Input */
+    MRAA_GPIO_OUT_HIGH = 2, /**< Output. Init High */
+    MRAA_GPIO_OUT_LOW = 3   /**< Output. Init Low */
+} mraa_gpio_dir_t;
+
+/**
+ * Gpio Edge types for interupts
+ */
+typedef enum {
+    MRAA_GPIO_EDGE_NONE = 0,   /**< No interrupt on Gpio */
+    MRAA_GPIO_EDGE_BOTH = 1,   /**< Interupt on rising & falling */
+    MRAA_GPIO_EDGE_RISING = 2, /**< Interupt on rising only */
+    MRAA_GPIO_EDGE_FALLING = 3 /**< Interupt on falling only */
+} mraa_gpio_edge_t;
+
+/**
+ * Initialise a gpio
+ *
+ * @param pin the pin number
+ * @param ss whether gpio is on ARC/SS or not
+ */
+mraa_gpio_context mraa_gpio_init_raw(int pin);
+
+/**
+ * Initialise a gpio
+ *
+ * @param pin the pin number
+ */
+mraa_gpio_context mraa_gpio_init(int pin);
+
+/**
+ * Set an interupt on pin
+ *
+ * @param dev The Gpio context
+ * @param edge The edge mode to set the gpio into
+ * @param fptr Function pointer to function to be called when interupt is
+ * triggered
+ * @param args Arguments passed to the interrupt handler (fptr)
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_isr(mraa_gpio_context dev, mraa_gpio_edge_t edge, void (*fptr)(void*), void* args);
+
+/**
+ * Stop the current interupt watcher on this Gpio, and set the Gpio edge mode
+ * to MRAA_GPIO_EDGE_NONE
+ *
+ * @param dev The Gpio context
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_isr_exit(mraa_gpio_context dev);
+
+/**
+ * Set Gpio Output Mode,
+ *
+ * @param dev The Gpio context
+ * @param mode The Gpio Output Mode
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode);
+
+/**
+ * Set the edge mode on the gpio
+ *
+#include "mraa/common.h"
+ * @param dev The Gpio context
+ * @param mode The edge mode to set the gpio into
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_edge_mode(mraa_gpio_context dev, mraa_gpio_edge_t mode);
+
+/**
+ * Close the Gpio context
+ * - Will free the memory for the context and unexport the Gpio
+ *
+ * @param dev The Gpio context
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_close(mraa_gpio_context dev);
+
+/**
+ * Set Gpio direction
+ *
+ * @param dev The Gpio context
+ * @param dir The direction of the Gpio
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir);
+
+/**
+ * Write to the Gpio Value.
+ *
+ * @param dev The Gpio context
+ * @param value Integer value to write
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_write(mraa_gpio_context dev, int val);
+
+/**
+ * Read the Gpio value. This can be 0 or 1. A resonse of -1 means that there
+ * was a fatal error.
+ *
+ * @param dev The Gpio context
+ * @return Result of operation
+ */
+int mraa_gpio_read(mraa_gpio_context dev);
+
+/**
+ * Get a pin number of the gpio, invalid will return -1
+ *
+ * @param dev The Gpio context
+ * @return Pin number
+ */
+int mraa_gpio_get_pin(mraa_gpio_context dev);
+
+/**
+ * Change ownership of the context.
+ *
+ * @param dev The Gpio context
+ * @param owner Does this context own the pin
+ * @return Result of operation
+ */
+mraa_result_t mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t owner);
+
+/**
+ * Get a pin number of the gpio, invalid will return -1
+ *
+ * @param dev The Gpio context
+ * @return Pin number
+ */
+int mraa_gpio_get_pin(mraa_gpio_context dev);
+
+/**
+ * Get a gpio number as used within sysfs, invalid will return -1
+ *
+ * @param dev The Gpio context
+ * @return gpio number
+ */
+int mraa_gpio_get_pin_raw(mraa_gpio_context dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/i2c.h b/ext/lib/mraa/include/mraa/i2c.h
new file mode 100644
index 0000000..51d9042
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/i2c.h
@@ -0,0 +1,198 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __MRAA_I2C_H__
+#define __MRAA_I2C_H__
+
+/**
+ * @file
+ * @brief Inter-Integrated Circuit
+ *
+ * An i2c context represents a master on an i2c bus and that context can
+ * communicate to multiple i2c slaves by configuring the address.
+ * @htmlinclude i2c.txt
+ *
+ * @snippet i2c_HMC5883L.c Interesting
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include "common.h"
+// #include "gpio.h"
+
+/**
+ * Opaque pointer definition to the internal struct _i2c
+ */
+typedef struct _i2c* mraa_i2c_context;
+
+/**
+ * Initialise i2c context, using board defintions
+ *
+ * @param bus i2c bus to use
+ * @return i2c context or NULL
+ */
+mraa_i2c_context mraa_i2c_init(int bus);
+
+/**
+ * Initialise i2c context, passing in the i2c bus to use.
+ *
+ * @param bus The i2c bus to use i.e. /dev/i2c-2 would be "2"
+ * @return i2c context or NULL
+ */
+mraa_i2c_context mraa_i2c_init_raw(unsigned int bus);
+
+/**
+ * Sets the frequency of the i2c context. Most platforms do not support this.
+ *
+ * @param dev The i2c context
+ * @param mode The bus mode
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_frequency(mraa_i2c_context dev, mraa_i2c_mode_t mode);
+
+/**
+ * Simple bulk read from an i2c context
+ *
+ * @param dev The i2c context
+ * @param data pointer to the byte array to read data in to
+ * @param length max number of bytes to read
+ * @return length of the read in bytes or -1
+ */
+int mraa_i2c_read(mraa_i2c_context dev, uint8_t* data, int length);
+
+/**
+ * Simple read for a single byte from the i2c context
+ *
+ * @param dev The i2c context
+ * @return The result of the read or -1 if failed
+ */
+int mraa_i2c_read_byte(mraa_i2c_context dev);
+
+/**
+ * Read a single byte from i2c context, from designated register
+ *
+ * @param dev The i2c context
+ * @param command The register
+ * @return The result of the read or -1 if failed
+ */
+int mraa_i2c_read_byte_data(mraa_i2c_context dev, const uint8_t command);
+
+/**
+ * Read a single word from i2c context, from designated register
+ *
+ * @param dev The i2c context
+ * @param command The register
+ * @return The result of the read or -1 if failed
+ */
+int mraa_i2c_read_word_data(mraa_i2c_context dev, const uint8_t command);
+
+/**
+ * Bulk read from i2c context, starting from designated register
+ *
+ * @param dev The i2c context
+ * @param command The register
+ * @param data pointer to the byte array to read data in to
+ * @param length max number of bytes to read
+ * @return The length in bytes passed to the function or -1
+ */
+int mraa_i2c_read_bytes_data(mraa_i2c_context dev, uint8_t command, uint8_t* data, int length);
+
+/**
+ * Write length bytes to the bus, the first byte in the array is the
+ * command/register to write
+ *
+ * @param dev The i2c context
+ * @param data pointer to the byte array to be written
+ * @param length the number of bytes to transmit
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_write(mraa_i2c_context dev, const uint8_t* data, int length);
+
+/**
+ * Write a single byte to an i2c context
+ *
+ * @param dev The i2c context
+ * @param data The byte to write
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_write_byte(mraa_i2c_context dev, const uint8_t data);
+
+/**
+ * Write a single byte to an i2c context
+ *
+ * @param dev The i2c context
+ * @param data The byte to write
+ * @param command The register
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_write_byte_data(mraa_i2c_context dev, const uint8_t data, const uint8_t command);
+
+/**
+ * Write a single word to an i2c context
+ *
+ * @param dev The i2c context
+ * @param data The word to write
+ * @param command The register
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_write_word_data(mraa_i2c_context dev, const uint16_t data, const uint8_t command);
+
+/**
+ * Update a single byte using specified register and mask
+ *
+ * @param dev The i2c context
+ * @param mask The mask
+ * @param data The data
+ * @param command The register
+ * @return Result of operation
+ */
+ mraa_result_t mraa_i2c_update_byte_data(mraa_i2c_context dev, const uint16_t mask, const uint8_t data, const uint8_t command);
+
+/**
+ * Sets the i2c slave address.
+ *
+ * @param dev The i2c context
+ * @param address The address to set for the slave (7-bit address)
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_address(mraa_i2c_context dev, uint8_t address);
+
+/**
+ * De-inits an mraa_i2c_context device
+ *
+ * @param dev The i2c context
+ * @return Result of operation
+ */
+mraa_result_t mraa_i2c_stop(mraa_i2c_context dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/pwm.h b/ext/lib/mraa/include/mraa/pwm.h
new file mode 100644
index 0000000..e81b503
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/pwm.h
@@ -0,0 +1,188 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __MRAA_PWM_H__
+#define __MRAA_PWM_H__
+
+/**
+ * @file
+ * @brief Pulse Width Modulation module
+ *
+ * PWM is the Pulse Width Modulation interface to libmraa. It allows the
+ * generation of a signal on a pin. Some boards may have higher or lower levels
+ * of resolution so make sure you check the board & pin you are using before
+ * hand.
+ *
+ * @snippet cycle-pwm3.c Interesting
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include "mraa/common.h"
+
+typedef struct _pwm* mraa_pwm_context;
+
+/**
+ * Initialise pwm_context, uses board mapping
+ *
+ * @param pin The PWM PIN
+ * @return pwm context or NULL
+ */
+mraa_pwm_context mraa_pwm_init(int pin);
+
+/**
+ * Initialise pwm_context, raw mode
+ *
+ * @param chipid The chip inwhich the PWM is under in SYSFS
+ * @param pin The PWM PIN.
+ * @return pwm context or NULL
+ */
+mraa_pwm_context mraa_pwm_init_raw(int chipid, int pin);
+
+/**
+ * Set the output duty-cycle percentage, as a float
+ *
+ * @param dev The Pwm context to use
+ * @param percentage A floating-point value representing percentage of output.
+ *    The value should lie between 0.0f (representing on 0%) and 1.0f
+ *    Values above or below this range will be set at either 0.0f or 1.0f
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_write(mraa_pwm_context dev, float percentage);
+
+/**
+ * Read the output duty-cycle percentage, as a float
+ *
+ * @param dev The Pwm context to use
+ * @return percentage A floating-point value representing percentage of output.
+ *    The value should lie between 0.0f (representing on 0%) and 1.0f
+ *    Values above or below this range will be set at either 0.0f or 1.0f
+ */
+float mraa_pwm_read(mraa_pwm_context dev);
+
+/**
+ * Set the PWM period as seconds represented in a float
+ *
+ * @param dev The Pwm context to use
+ * @param seconds Period represented as a float in seconds
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_period(mraa_pwm_context dev, float seconds);
+
+/**
+ * Set period, milliseconds.
+ *
+ * @param dev The Pwm context to use
+ * @param ms Milliseconds for period
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_period_ms(mraa_pwm_context dev, int ms);
+
+/**
+ * Set period, microseconds
+ *
+ * @param dev The Pwm context to use
+ * @param us Microseconds as period
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_period_us(mraa_pwm_context dev, int us);
+
+/**
+ * Set pulsewidth, As represnted by seconds in a (float)
+ *
+ * @param dev The Pwm context to use
+ * @param seconds The duration of a pulse
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_pulsewidth(mraa_pwm_context dev, float seconds);
+
+/**
+ * Set pulsewidth, milliseconds
+ *
+ * @param dev The Pwm context to use
+ * @param ms Milliseconds for pulsewidth
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_pulsewidth_ms(mraa_pwm_context dev, int ms);
+
+/**
+ * Set pulsewidth, microseconds
+ *
+ * @param dev The Pwm context to use
+ * @param us Microseconds for pulsewidth
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_pulsewidth_us(mraa_pwm_context dev, int us);
+
+/**
+ * Set the enable status of the PWM pin. None zero will assume on with output being driven.
+ *   and 0 will disable the output.
+ *
+ * @param dev The pwm context to use
+ * @param enable Toggle status of pin
+ * @return Result of operation.
+ */
+mraa_result_t mraa_pwm_enable(mraa_pwm_context dev, int enable);
+
+/**
+ * Change ownership of context
+ *
+ * @param dev the context
+ * @param owner Ownership boolean
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_owner(mraa_pwm_context dev, mraa_boolean_t owner);
+
+/**
+ * Close and unexport the PWM pin
+ *
+ * @param dev The pwm context to use
+ * @return Result of operation
+ */
+mraa_result_t mraa_pwm_close(mraa_pwm_context dev);
+
+/**
+ * Get the maximum pwm period in us
+ *
+ * @param dev The pwm context to use
+ * @return max pwm in us
+ */
+int mraa_pwm_get_max_period(mraa_pwm_context dev);
+
+/**
+ * Get the minimum pwm period in us
+ *
+ * @param dev The pwm context to use
+ * @return min pwm in us
+ */
+int mraa_pwm_get_min_period(mraa_pwm_context dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/spi.h b/ext/lib/mraa/include/mraa/spi.h
new file mode 100644
index 0000000..d805d6b
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/spi.h
@@ -0,0 +1,199 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __MRAA_SPI_H__
+#define __MRAA_SPI_H__
+
+/**
+ * @file
+ * @brief Serial Peripheral Interface
+ *
+ * This file defines the spi interface for libmraa. A Spi object in libmraa
+ * represents a spi device in Zephyr. Zephyr spi devices can be created per
+ * spi bus.
+ * Depending on the platform, different number of SPI buses may be
+ * exposed, for example, the Arduino 101 has 3 buses, however only one
+ * bus is exposed through the external pins.
+ *
+ * @snippet spi_mcp4261.c Interesting
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdint.h>
+
+#include "common.h"
+
+/**
+ * MRAA SPI Modes
+ */
+typedef enum {
+    MRAA_SPI_MODE0 = 0, /**< CPOL = 0, CPHA = 0, Clock idle low, data is clocked in on rising edge,
+                           output data (change) on falling edge */
+    MRAA_SPI_MODE1 = 1, /**< CPOL = 0, CPHA = 1, Clock idle low, data is clocked in on falling edge,
+                           output data (change) on rising edge */
+    MRAA_SPI_MODE2 = 2, /**< CPOL = 1, CPHA = 0, Clock idle low, data is clocked in on falling edge,
+                           output data (change) on rising edge */
+    MRAA_SPI_MODE3 = 3, /**< CPOL = 1, CPHA = 1, Clock idle low, data is clocked in on rising, edge
+                           output data (change) on falling edge */
+} mraa_spi_mode_t;
+
+/**
+ * Opaque pointer definition to the internal struct _spi
+ */
+typedef struct _spi* mraa_spi_context;
+
+/**
+ * Initialise SPI_context, uses board mapping. Sets the muxes
+ *
+ * @param bus Bus to use, as listed in platform definition, normally 0
+ * @return Spi context or NULL
+ */
+mraa_spi_context mraa_spi_init(int bus);
+
+/**
+ * Initialise SPI_context without any board configuration, selects a bus and a mux.
+ *
+ * @param bus Bus to use as listed in kernel config
+ * @param cs Chip select to use as listed in kernel config
+ * @return Spi context or NULL
+ */
+mraa_spi_context mraa_spi_init_raw(unsigned int bus, unsigned int cs);
+
+/**
+ * Set the SPI device mode.
+ *
+ * @param dev The Spi context
+ * @param mode The SPI mode
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_mode(mraa_spi_context dev, mraa_spi_mode_t mode);
+
+/**
+ * Set the SPI device operating clock frequency.
+ *
+ * @param dev the Spi context
+ * @param hz the frequency in hz
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_frequency(mraa_spi_context dev, int hz);
+
+/**
+ * Write Single Byte to the SPI device.
+ *
+ * @param dev The Spi context
+ * @param data Data to send
+ * @return Data received on the miso line or -1 in case of error
+ */
+int mraa_spi_write(mraa_spi_context dev, uint8_t data);
+
+/**
+ * Write Two Bytes to the SPI device.
+ *
+ * @param dev The Spi context
+ * @param data Data to send
+ * @return Data received on the miso line
+ */
+int mraa_spi_write_word(mraa_spi_context dev, uint16_t data);
+
+/**
+ * Write Buffer of bytes to the SPI device. The pointer return has to be
+ * free'd by the caller. It will return a NULL pointer in cases of error.
+ *
+ * @param dev The Spi context
+ * @param data to send
+ * @param length elements within buffer, Max 4096
+ * @return Data received on the miso line, same length as passed in
+ */
+uint8_t* mraa_spi_write_buf(mraa_spi_context dev, uint8_t* data, int length);
+
+/**
+ * Write Buffer of uint16 to the SPI device. The pointer return has to be
+ * free'd by the caller. It will return a NULL pointer in cases of error.
+ *
+ * @param dev The Spi context
+ * @param data to send
+ * @param length elements (in bytes) within buffer, Max 4096
+ * @return Data received on the miso line, same length as passed in
+ */
+uint16_t* mraa_spi_write_buf_word(mraa_spi_context dev, uint16_t* data, int length);
+
+/**
+ * Transfer Buffer of bytes to the SPI device. Both send and recv buffers
+ * are passed in
+ *
+ * @param dev The Spi context
+ * @param data to send
+ * @param rxbuf buffer to recv data back, may be NULL
+ * @param length elements within buffer, Max 4096
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length);
+
+/**
+ * Transfer Buffer of uint16 to the SPI device. Both send and recv buffers
+ * are passed in
+ *
+ * @param dev The Spi context
+ * @param data to send
+ * @param rxbuf buffer to recv data back, may be NULL
+ * @param length elements (in bytes) within buffer, Max 4096
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_transfer_buf_word(mraa_spi_context dev, uint16_t* data, uint16_t* rxbuf, int length);
+
+/**
+ * Change the SPI lsb mode
+ *
+ * @param dev The Spi context
+ * @param lsb Use least significant bit transmission. 0 for msbi
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_lsbmode(mraa_spi_context dev, mraa_boolean_t lsb);
+
+/**
+ * Set bits per mode on transaction, defaults at 8
+ *
+ * @param dev The Spi context
+ * @param bits bits per word
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_bit_per_word(mraa_spi_context dev, unsigned int bits);
+
+/**
+ * De-inits an mraa_spi_context device
+ *
+ * @param dev The Spi context
+ * @return Result of operation
+ */
+mraa_result_t mraa_spi_stop(mraa_spi_context dev);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/types.h b/ext/lib/mraa/include/mraa/types.h
new file mode 100644
index 0000000..68ef35b
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/types.h
@@ -0,0 +1,116 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * Copyright Â© 2014 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __MRAA_TYPES_H__
+#define __MRAA_TYPES_H__
+
+/** @file
+ *
+ * This file defines the basic shared types for libmraa
+ * this file is different to common.h in that swig takes this as an input
+ */
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * MRAA boolean type
+ * 1 For TRUE
+ */
+typedef uint8_t mraa_boolean_t;
+
+/**
+ * MRAA supported platform types
+ */
+typedef enum {
+    MRAA_INTEL_ARDUINO_101 = 200,    /**< Arduino 101 */
+    MRAA_INTEL_ARDUINO_101_SSS = 201,    /**< Arduino 101 */
+    MRAA_INTEL_D2000_CRB = 202,      /**< Quark D2K CRB */
+    MRAA_UNKNOWN_PLATFORM =
+   299 /**< An unknown platform type, typically will load INTEL_GALILEO_GEN1 */
+} mraa_platform_t;
+
+
+/**
+ * MRAA return codes
+ */
+typedef enum {
+    MRAA_SUCCESS = 0,                             /**< Expected response */
+    MRAA_ERROR_FEATURE_NOT_IMPLEMENTED = 1,       /**< Feature TODO */
+    MRAA_ERROR_FEATURE_NOT_SUPPORTED = 2,         /**< Feature not supported by HW */
+    MRAA_ERROR_INVALID_VERBOSITY_LEVEL = 3,       /**< Verbosity level wrong */
+    MRAA_ERROR_INVALID_PARAMETER = 4,             /**< Parameter invalid */
+    MRAA_ERROR_INVALID_HANDLE = 5,                /**< Handle invalid */
+    MRAA_ERROR_NO_RESOURCES = 6,                  /**< No resource of that type avail */
+    MRAA_ERROR_INVALID_RESOURCE = 7,              /**< Resource invalid */
+    MRAA_ERROR_INVALID_QUEUE_TYPE = 8,            /**< Queue type incorrect */
+    MRAA_ERROR_NO_DATA_AVAILABLE = 9,             /**< No data available */
+    MRAA_ERROR_INVALID_PLATFORM = 10,             /**< Platform not recognised */
+    MRAA_ERROR_PLATFORM_NOT_INITIALISED = 11,     /**< Board information not initialised */
+    MRAA_ERROR_PLATFORM_ALREADY_INITIALISED = 0,  /**< Board is already initialised, same as MRAA_SUCESS */
+
+    MRAA_ERROR_UNSPECIFIED = 99 /**< Unknown Error */
+} mraa_result_t;
+
+/**
+ * Enum representing different possible modes for a pin.
+ */
+typedef enum {
+    MRAA_PIN_VALID = 0,     /**< Pin Valid */
+    MRAA_PIN_GPIO = 1,      /**< General Purpose IO */
+    MRAA_PIN_PWM = 2,       /**< Pulse Width Modulation */
+    MRAA_PIN_FAST_GPIO = 3, /**< Faster GPIO */
+    MRAA_PIN_SPI = 4,       /**< SPI */
+    MRAA_PIN_I2C = 5,       /**< I2C */
+    MRAA_PIN_AIO = 6,       /**< Analog in */
+    MRAA_PIN_UART = 7       /**< UART */
+} mraa_pinmodes_t;
+
+/**
+ * Enum reprensenting different i2c speeds/modes
+ */
+typedef enum {
+    MRAA_I2C_STD = 0,  /**< up to 100Khz */
+    MRAA_I2C_FAST = 1, /**< up to 400Khz */
+    MRAA_I2C_HIGH = 2  /**< up to 3.4Mhz */
+} mraa_i2c_mode_t;
+
+typedef enum {
+    MRAA_UART_PARITY_NONE = 0,
+    MRAA_UART_PARITY_EVEN = 1,
+    MRAA_UART_PARITY_ODD = 2,
+    MRAA_UART_PARITY_MARK = 3,
+    MRAA_UART_PARITY_SPACE = 4
+} mraa_uart_parity_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/include/mraa/uart.h b/ext/lib/mraa/include/mraa/uart.h
new file mode 100644
index 0000000..ec9d4de
--- /dev/null
+++ b/ext/lib/mraa/include/mraa/uart.h
@@ -0,0 +1,184 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Contributions: Jon Trulson <jtrulson@ics.com>
+ *                Brendan Le Foll <brendan.le.foll@intel.com>
+ * Copyright (c) 2014 - 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __MRAA_UART_H__
+#define __MRAA_UART_H__
+
+/**
+ * @file
+ * @brief UART module
+ *
+ * UART is the Universal asynchronous receiver/transmitter interface to
+ * libmraa. It allows the exposure of UART pins on supported boards.
+ * With functionality to expand at a later date.
+ *
+ * @snippet uart.c Interesting
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+
+#include "common.h"
+
+typedef struct _uart* mraa_uart_context;
+
+/**
+ * Initialise uart_context, uses board mapping
+ *
+ * @param uart the index of the uart set to use
+ * @return uart context or NULL
+ */
+mraa_uart_context mraa_uart_init(int uart);
+
+/**
+ * Initialise a raw uart_context. No board setup.
+ *
+ * @param path for example "/dev/ttyS0"
+ * @return uart context or NULL
+ */
+mraa_uart_context mraa_uart_init_raw(const char* path);
+
+/**
+ * Flush the outbound data.
+ * Blocks until complete.
+ *
+ * @param dev The UART context
+ * @return Result of operation
+ */
+mraa_result_t mraa_uart_flush(mraa_uart_context dev);
+
+/**
+ * Set the baudrate.
+ * Takes an int and will attempt to decide what baudrate  is
+ * to be used on the UART hardware.
+ *
+ * @param dev The UART context
+ * @param baud unsigned int of baudrate i.e. 9600
+ * @return Result of operation
+ */
+mraa_result_t mraa_uart_set_baudrate(mraa_uart_context dev, unsigned int baud);
+
+/**
+ * Set the transfer mode
+ * For example setting the mode to 8N1 would be
+ * "mraa_uart_set_mode(dev, 8,MRAA_UART_PARITY_NONE , 1)"
+ *
+ * @param dev The UART context
+ * @param bytesize data bits
+ * @param parity Parity bit setting
+ * @param stopbits stop bits
+ * @return Result of operation
+ */
+mraa_result_t mraa_uart_set_mode(mraa_uart_context dev, int bytesize, mraa_uart_parity_t parity, int stopbits);
+
+/**
+ * Set the flowcontrol
+ *
+ * @param dev The UART context
+ * @param xonxoff XON/XOFF Software flow control.
+ * @param rtscts RTS/CTS out of band hardware flow control
+ * @return Result of operation
+ */
+mraa_result_t mraa_uart_set_flowcontrol(mraa_uart_context dev, mraa_boolean_t xonxoff, mraa_boolean_t rtscts);
+
+/**
+ * Set the timeout for read and write operations
+ * <= 0 will disable that timeout
+ *
+ * @param dev The UART context
+ * @param read read timeout
+ * @param write write timeout
+ * @param interchar inbetween char timeout
+ * @return Result of operation
+ */
+mraa_result_t mraa_uart_set_timeout(mraa_uart_context dev, int read, int write, int interchar);
+
+/**
+ * Set the blocking state for write operations
+ *
+ * @param dev The UART context
+ * @param nonblock new nonblocking state
+ * @return Result of operation
+ */
+mraa_result_t mraa_uart_set_non_blocking(mraa_uart_context dev, mraa_boolean_t nonblock);
+
+/**
+ * Get Char pointer with tty device path within Linux
+ * For example. Could point to "/dev/ttyS0"
+ *
+ * @param dev uart context
+ * @return char pointer of device path
+ */
+
+mraa_result_t mraa_uart_get_dev_path(mraa_uart_context dev);
+
+/**
+ * Destroy a mraa_uart_context
+ *
+ * @param dev uart context
+ * @return mraa_result_t
+ */
+mraa_result_t mraa_uart_stop(mraa_uart_context dev);
+
+/**
+ * Read bytes from the device into a buffer
+ *
+ * @param dev uart context
+ * @param buf buffer pointer
+ * @param length maximum size of buffer
+ * @return the number of bytes read, or -1 if an error occurred
+ */
+int mraa_uart_read(mraa_uart_context dev, char* buf, size_t length);
+
+/**
+ * Write bytes in buffer to a device
+ *
+ * @param dev uart context
+ * @param buf buffer pointer
+ * @param length maximum size of buffer
+ * @return the number of bytes written, or -1 if an error occurred
+ */
+int mraa_uart_write(mraa_uart_context dev, const char* buf, size_t length);
+
+/**
+ * Check to see if data is available on the device for reading
+ *
+ * @param dev uart context
+ * @param millis number of milliseconds to wait, or 0 to return immediately
+ * @return 1 if there is data available to read, 0 otherwise
+ */
+mraa_boolean_t mraa_uart_data_available(mraa_uart_context dev, unsigned int millis);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ext/lib/mraa/source/aio.c b/ext/lib/mraa/source/aio.c
new file mode 100644
index 0000000..49936e6
--- /dev/null
+++ b/ext/lib/mraa/source/aio.c
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <adc.h>
+#include <misc/util.h>
+#include <pinmux.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "mraa/aio.h"
+#include "mraa_internal.h"
+#include "mraa_internal_types.h"
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#else
+#include <misc/printk.h>
+#define printf printk
+#endif
+
+#if defined(CONFIG_ADC)
+#define ADC_DEVICE_NAME "ADC_0"
+#endif
+
+#define DEFAULT_BITS 10
+
+static int raw_bits;
+
+typedef struct adc_seq_entry* adc_seq_entry_ptr;
+typedef struct adc_seq_table* adc_seq_table_ptr;
+
+mraa_aio_context
+mraa_aio_init(unsigned int pin)
+{
+    mraa_board_t* board = plat;
+    if (board == NULL) {
+        return NULL;
+    }
+
+    if (pin < 0 || pin >= board->phy_pin_count) {
+        return NULL;
+    }
+
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux\n");
+        return NULL;
+    }
+
+#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
+    d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    // confused about the numbering of digital pins lower than 6
+    // This needs to be resolved.
+    if (pin == 7) {
+        pinmux_pin_set(d2k_pinmux_dev, 8, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 7, 8, "IO7", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 8) {
+        pinmux_pin_set(d2k_pinmux_dev, 9, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 8, 9, "IO8", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 10) {
+        pinmux_pin_set(d2k_pinmux_dev, 0, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 10, 0, "IO10", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 11) {
+        pinmux_pin_set(d2k_pinmux_dev, 17, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 11, 17, "IO11", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 12) {
+        pinmux_pin_set(d2k_pinmux_dev, 18, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 12, 18, "IO12", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 13) {
+        pinmux_pin_set(d2k_pinmux_dev, 16, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 13, 16, "IO13", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    }
+#endif
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS)
+    if (pin == 0) {
+        pinmux_pin_set(pinmux_dev, 10, PINMUX_FUNC_B);
+    } else if (pin == 1) {
+        pinmux_pin_set(pinmux_dev, 11, PINMUX_FUNC_B);
+    } else if (pin == 2) {
+        pinmux_pin_set(pinmux_dev, 12, PINMUX_FUNC_B);
+    } else if (pin == 3) {
+        pinmux_pin_set(pinmux_dev, 13, PINMUX_FUNC_B);
+    } else if (pin == 4) {
+        pinmux_pin_set(pinmux_dev, 14, PINMUX_FUNC_B);
+    } else if (pin == 5) {
+        pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_B);
+    } else if (pin == 10) {
+        pinmux_pin_set(pinmux_dev, 0, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 10, 0, "A8", (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 11) {
+        pinmux_pin_set(pinmux_dev, 3, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 11, 3, "A9", (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 12) {
+        pinmux_pin_set(pinmux_dev, 1, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 12, 1, "A10", (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 13) {
+        pinmux_pin_set(pinmux_dev, 2, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 13, 2, "A11", (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 1, 0 });
+    } else {
+        printf("Pin %d not enabled/Can't be enabled\n", pin);
+        return NULL;
+    }
+#endif
+
+    if (board->pins[pin].capabilites.aio != 1) {
+        return NULL;
+    }
+
+    mraa_aio_context dev = (mraa_aio_context) malloc(sizeof(struct _aio));
+    dev->phy_pin = board->pins[pin].aio.pinmap;
+    dev->zdev = device_get_binding(ADC_DEVICE_NAME);
+    if (dev->zdev == NULL)
+        return NULL;
+
+    dev->value_bit = DEFAULT_BITS;
+
+    adc_seq_entry_ptr sample = (adc_seq_entry_ptr) malloc(sizeof(struct adc_seq_entry));
+    adc_seq_table_ptr table = (adc_seq_table_ptr) malloc(sizeof(struct adc_seq_table));
+    sample->sampling_delay = 12;
+    sample->channel_id = dev->phy_pin;
+    sample->buffer_length = 4;
+    uint8_t* seq_buffer;
+    seq_buffer = (uint8_t*) malloc(sizeof(uint8_t) * 4);
+    sample->buffer = seq_buffer;
+    table->entries = sample;
+    table->num_entries = 1;
+    dev->table = table;
+    adc_enable(dev->zdev);
+    dev->pin = pin;
+
+    raw_bits = mraa_adc_raw_bits();
+
+    return dev;
+}
+
+mraa_result_t
+mraa_aio_close(mraa_aio_context dev)
+{
+    adc_disable(dev->zdev);
+    free(dev->table->entries->buffer);
+    free(dev->table->entries);
+    free(dev->table);
+    free(dev);
+    return MRAA_SUCCESS;
+}
+
+int
+mraa_aio_read(mraa_aio_context dev)
+{
+    uint32_t value;
+    uint32_t shifter_value;
+
+    if (adc_read(dev->zdev, dev->table))
+        return -1;
+    value = dev->table->entries->buffer[1] * 256 + dev->table->entries->buffer[0];
+
+    if (dev->value_bit != raw_bits) {
+        if (raw_bits > dev->value_bit) {
+            shifter_value = raw_bits - dev->value_bit;
+            value = value >> shifter_value;
+        } else {
+            shifter_value = dev->value_bit - raw_bits;
+            value = value << shifter_value;
+        }
+    }
+
+    return value;
+}
+
+float
+mraa_aio_read_float(mraa_aio_context dev)
+{
+    if (dev == NULL)
+        return -1.0;
+
+    int32_t analog_value_int = mraa_aio_read(dev);
+    if (analog_value_int < 0)
+        return -1.0;
+
+    float max_analog_value = (1 << dev->value_bit) - 1;
+    return analog_value_int / max_analog_value;
+}
+
+mraa_result_t
+mraa_aio_set_bit(mraa_aio_context dev, int bits)
+{
+    if (dev == NULL || bits < 1)
+        return MRAA_ERROR_INVALID_RESOURCE;
+
+    dev->value_bit = bits;
+    return MRAA_SUCCESS;
+}
+
+int
+mraa_aio_get_bit(mraa_aio_context dev)
+{
+    if (dev == NULL)
+        return 0;
+
+    return dev->value_bit;
+}
diff --git a/ext/lib/mraa/source/arduino_101.c b/ext/lib/mraa/source/arduino_101.c
new file mode 100644
index 0000000..d91ed63
--- /dev/null
+++ b/ext/lib/mraa/source/arduino_101.c
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* From drivers/pinmux/quark_mcu/pinmux_board_arduino_101.c
+ * This is the full pinmap that we have available on the board for configuration
+ * including the ball position and the various modes that can be set.  In the
+ * _pinmux_defaults we do not spend any time setting values that are using mode
+ * A as the hardware brings up all devices by default in mode A.
+ */
+
+/* pin, ball, mode A, mode B, mode C */
+/* 0  F02, gpio_0, ain_0, spi_s_cs */			/* IO10 */
+/* 1  G04, gpio_1, ain_1, spi_s_miso */			/* IO12 */
+/* 2  H05, gpio_2, ain_2, spi_s_sck */			/* IO13 */
+/* 3  J06, gpio_3, ain_3, spi_s_mosi */			/* IO11 */
+/* 4  K06, gpio_4, ain_4, NA */
+/* 5  L06, gpio_5, ain_5, NA */
+/* 6  H04, gpio_6, ain_6, NA */
+/* 7  G03, gpio_7, ain_7, NA */
+/* 8  L05, gpio_ss_0, ain_8, uart1_cts */
+/* 9  M05, gpio_ss_1, ain_9, uart1_rts */		/* AD5 */
+/* 10 K05, gpio_ss_2, ain_10 */				/* AD0 */
+/* 11 G01, gpio_ss_3, ain_11 */				/* AD1 */
+/* 12 J04, gpio_ss_4, ain_12 */				/* AD2 */
+/* 13 G02, gpio_ss_5, ain_13 */				/* AD3 */
+/* 14 F01, gpio_ss_6, ain_14 */				/* AD4 */
+/* 15 J05, gpio_ss_7, ain_15 */
+/* 16 L04, gpio_ss_8, ain_16, uart1_txd */		/* IO1 */
+/* 17 M04, gpio_ss_9, ain_17, uart1_rxd */		/* IO0 */
+/* 18 K04, uart0_rx, ain_18, NA */
+/* 19 B02, uart0_tx, gpio_31, NA */
+/* 20 C01, i2c0_scl, NA, NA */
+/* 21 C02, i2c0_sda, NA, NA */
+/* 22 D01, i2c1_scl, NA, NA */
+/* 23 D02, i2c1_sda, NA, NA */
+/* 24 E01, i2c0_ss_sda, NA, NA */
+/* 25 E02, i2c0_ss_scl, NA, NA */
+/* 26 B03, i2c1_ss_sda, NA, NA */
+/* 27 A03, i2c1_ss_scl, NA, NA */
+/* 28 C03, spi0_ss_miso, NA, NA */
+/* 29 E03, spi0_ss_mosi, NA, NA */
+/* 30 D03, spi0_ss_sck, NA, NA */
+/* 31 D04, spi0_ss_cs0, NA, NA */
+/* 32 C04, spi0_ss_cs1, NA, NA */
+/* 33 B04, spi0_ss_cs2, gpio_29, NA */
+/* 34 A04, spi0_ss_cs3, gpio_30, NA */
+/* 35 B05, spi1_ss_miso, NA, NA */
+/* 36 C05, spi1_ss_mosi, NA, NA */
+/* 37 D05, spi1_ss_sck, NA, NA */
+/* 38 E05, spi1_ss_cs0, NA, NA */
+/* 39 E04, spi1_ss_cs1, NA, NA */
+/* 40 A06, spi1_ss_cs2, uart0_cts, NA */
+/* 41 B06, spi1_ss_cs3, uart0_rts, NA */
+/* 42 C06, gpio_8, spi1_m_sck, NA */
+/* 43 D06, gpio_9, spi1_m_miso, NA */
+/* 44 E06, gpio_10, spi1_m_mosi, NA */
+/* 45 D07, gpio_11, spi1_m_cs0, NA */
+/* 46 C07, gpio_12, spi1_m_cs1, NA */
+/* 47 B07, gpio_13, spi1_m_cs2, NA */
+/* 48 A07, gpio_14, spi1_m_cs3, NA */
+/* 49 B08, gpio_15, i2s_rxd, NA */			/* IO5 */
+/* 50 A08, gpio_16, i2s_rscki, NA */			/* IO8 */
+/* 51 B09, gpio_17, i2s_rws, NA */			/* IO3 */
+/* 52 A09, gpio_18, i2s_tsck, NA */			/* IO2 */
+/* 53 C09, gpio_19, i2s_twsi, NA */			/* IO4 */
+/* 54 D09, gpio_20, i2s_txd, NA */			/* IO7 */
+/* 55 D08, gpio_21, spi0_m_sck, NA */
+/* 56 E07, gpio_22, spi0_m_miso, NA */
+/* 57 E09, gpio_23, spi0_m_mosi, NA */
+/* 58 E08, gpio_24, spi0_m_cs0, NA */
+/* 59 A10, gpio_25, spi0_m_cs1, NA */
+/* 60 B10, gpio_26, spi0_m_cs2, NA */
+/* 61 C10, gpio_27, spi0_m_cs3, NA */
+/* 62 D10, gpio_28, NA, NA */
+/* 63 E10, gpio_ss_10, pwm_0, NA */			/* IO3 */
+/* 64 D11, gpio_ss_11, pwm_1, NA */			/* IO5 */
+/* 65 C11, gpio_ss_12, pwm_2, NA */			/* IO6 */
+/* 66 B11, gpio_ss_13, pwm_3, NA */			/* IO9 */
+/* 67 D12, gpio_ss_14, clkout_32khz, NA */
+/* 68 C12, gpio_ss_15, clkout_16mhz, NA */
+
+/* Note:
+ * 1. I2C pins on the shield are connected to i2c0_ss_sda and i2c_0_ss_scl,
+ *    which are on the sensor subsystem. They are also tied to AD4 and AD5.
+ *    Therefore, to use I2C, pin 9 (ain_9) and (ain_14) both need to be set
+ *    to PINMUX_FUNC_B, so they will not interfere with I2C operations.
+ *    Also, there is no internal pull-up on I2c bus, and thus external
+ *    pull-up resistors are needed.
+ * 2. IO3/PWM0 is connected to pin 51 and 63.
+ * 3. IO5/PWM1 is connected to pin 49 and 64.
+ */
+
+#include <stdio.h>
+
+#include <pinmux.h>
+#include "mraa_internal.h"
+#include "mraa/gpio.h"
+
+static mraa_board_t _board;
+
+mraa_board_t* mraa_intel_arduino_101()
+{
+    mraa_board_t* b = &_board;
+    mraa_set_board_config(b);
+    b->platform_name = "Arduino 101 x86";
+    b->platform_type = MRAA_INTEL_ARDUINO_101;
+    mraa_set_pininfo(b,  0,  0, "IO0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });
+    mraa_set_pininfo(b,  1,  3, "IO1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });
+    mraa_set_pininfo(b,  2, 18, "IO2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  3,  0, "IO3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  4, 19, "IO4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  5,  1, "IO5",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  6,  2, "IO6",  (mraa_pincapabilities_t){ 0, 0, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  7, 20, "IO7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  8, 16, "IO8",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  9,  3, "IO9",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 10,  0, "IO10", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 11,  3, "IO11", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 12,  1, "IO12", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 13,  2, "IO13", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 14,  0, "A0  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 15,  0, "A1  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 16,  0, "A2  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 17,  0, "A3  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 18, 14, "A4  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 });
+    mraa_set_pininfo(b, 19,  9, "A5  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 });
+    b->def_i2c_bus = 0;
+    b->i2c_bus[0].bus_id = 0;
+    b->pins[18].i2c.mux_total = 0;
+    b->pins[19].i2c.mux_total = 0;
+    b->i2c_bus[0].sda = 18;
+    b->i2c_bus[0].scl = 19;
+#if defined (CONFIG_SPI_0)
+    b->spi_bus[0].bus_id = 0;
+#elif defined (CONFIG_SPI_1)
+    b->spi_bus[0].bus_id = 1;
+#elif defined (CONFIG_SPI_2)
+    b->spi_bus[0].bus_id = 2;
+#endif
+    b->spi_bus[0].sclk = 13;
+    b->spi_bus[0].mosi = 11;
+    b->spi_bus[0].miso = 12;
+    b->spi_bus[0].cs = 10;
+
+    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
+    struct device* zdev = device_get_binding("GPIO_0");
+    if (zdev != NULL) {
+        for (int i = 0; i<4; ++i) {
+            int ret = gpio_pin_configure(zdev, i2c_raw_gpios[i], GPIO_PUD_PULL_UP);
+            if (ret) {
+                //printf("Failed to set pull up for pin %d\n", i2c_raw_gpios[i]);
+            }
+        }
+    }
+/*
+    for (int i = 0; i<4; ++i) {
+        mraa_gpio_context gpio = mraa_gpio_init_raw(i2c_raw_gpios[i]);
+        mraa_gpio_dir(gpio, MRAA_GPIO_IN);
+    }
+*/
+
+
+#if 0
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for %s\n", CONFIG_PINMUX_NAME);
+        return NULL;
+    }
+    if (pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_B)) {
+        printf("Failed to set pinmux for %d\n", 9);
+        return NULL;
+    }
+    if (pinmux_pin_set(pinmux_dev, 14, PINMUX_FUNC_B)) {
+        printf("Failed to set pinmux for %d\n", 14);
+        return NULL;
+    }
+    if (pinmux_pin_set(pinmux_dev, 24, PINMUX_FUNC_A)) {
+        printf("Failed to set pinmux for %d\n", 24);
+        return NULL;
+    }
+    if (pinmux_pin_set(pinmux_dev, 25, PINMUX_FUNC_A)) {
+        printf("Failed to set pinmux for %d\n", 25);
+        return NULL;
+    }
+#endif
+
+    return b;
+}
diff --git a/ext/lib/mraa/source/arduino_101.h b/ext/lib/mraa/source/arduino_101.h
new file mode 100644
index 0000000..6584cea
--- /dev/null
+++ b/ext/lib/mraa/source/arduino_101.h
@@ -0,0 +1,39 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mraa_internal_types.h"
+
+
+mraa_board_t*
+mraa_intel_arduino_101();
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/mraa/source/arduino_101_sss.c b/ext/lib/mraa/source/arduino_101_sss.c
new file mode 100644
index 0000000..16f0793
--- /dev/null
+++ b/ext/lib/mraa/source/arduino_101_sss.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* From drivers/pinmux/quark_mcu/pinmux_board_arduino_101.c
+ * This is the full pinmap that we have available on the board for configuration
+ * including the ball position and the various modes that can be set.  In the
+ * _pinmux_defaults we do not spend any time setting values that are using mode
+ * A as the hardware brings up all devices by default in mode A.
+ */
+
+/* pin, ball, mode A, mode B, mode C */
+/* 0  F02, gpio_0, ain_0, spi_s_cs */			/* IO10 */
+/* 1  G04, gpio_1, ain_1, spi_s_miso */			/* IO12 */
+/* 2  H05, gpio_2, ain_2, spi_s_sck */			/* IO13 */
+/* 3  J06, gpio_3, ain_3, spi_s_mosi */			/* IO11 */
+/* 4  K06, gpio_4, ain_4, NA */
+/* 5  L06, gpio_5, ain_5, NA */
+/* 6  H04, gpio_6, ain_6, NA */
+/* 7  G03, gpio_7, ain_7, NA */
+/* 8  L05, gpio_ss_0, ain_8, uart1_cts */
+/* 9  M05, gpio_ss_1, ain_9, uart1_rts */		/* AD5 */
+/* 10 K05, gpio_ss_2, ain_10 */				/* AD0 */
+/* 11 G01, gpio_ss_3, ain_11 */				/* AD1 */
+/* 12 J04, gpio_ss_4, ain_12 */				/* AD2 */
+/* 13 G02, gpio_ss_5, ain_13 */				/* AD3 */
+/* 14 F01, gpio_ss_6, ain_14 */				/* AD4 */
+/* 15 J05, gpio_ss_7, ain_15 */
+/* 16 L04, gpio_ss_8, ain_16, uart1_txd */		/* IO1 */
+/* 17 M04, gpio_ss_9, ain_17, uart1_rxd */		/* IO0 */
+/* 18 K04, uart0_rx, ain_18, NA */
+/* 19 B02, uart0_tx, gpio_31, NA */
+/* 20 C01, i2c0_scl, NA, NA */
+/* 21 C02, i2c0_sda, NA, NA */
+/* 22 D01, i2c1_scl, NA, NA */
+/* 23 D02, i2c1_sda, NA, NA */
+/* 24 E01, i2c0_ss_sda, NA, NA */
+/* 25 E02, i2c0_ss_scl, NA, NA */
+/* 26 B03, i2c1_ss_sda, NA, NA */
+/* 27 A03, i2c1_ss_scl, NA, NA */
+/* 28 C03, spi0_ss_miso, NA, NA */
+/* 29 E03, spi0_ss_mosi, NA, NA */
+/* 30 D03, spi0_ss_sck, NA, NA */
+/* 31 D04, spi0_ss_cs0, NA, NA */
+/* 32 C04, spi0_ss_cs1, NA, NA */
+/* 33 B04, spi0_ss_cs2, gpio_29, NA */
+/* 34 A04, spi0_ss_cs3, gpio_30, NA */
+/* 35 B05, spi1_ss_miso, NA, NA */
+/* 36 C05, spi1_ss_mosi, NA, NA */
+/* 37 D05, spi1_ss_sck, NA, NA */
+/* 38 E05, spi1_ss_cs0, NA, NA */
+/* 39 E04, spi1_ss_cs1, NA, NA */
+/* 40 A06, spi1_ss_cs2, uart0_cts, NA */
+/* 41 B06, spi1_ss_cs3, uart0_rts, NA */
+/* 42 C06, gpio_8, spi1_m_sck, NA */
+/* 43 D06, gpio_9, spi1_m_miso, NA */
+/* 44 E06, gpio_10, spi1_m_mosi, NA */
+/* 45 D07, gpio_11, spi1_m_cs0, NA */
+/* 46 C07, gpio_12, spi1_m_cs1, NA */
+/* 47 B07, gpio_13, spi1_m_cs2, NA */
+/* 48 A07, gpio_14, spi1_m_cs3, NA */
+/* 49 B08, gpio_15, i2s_rxd, NA */			/* IO5 */
+/* 50 A08, gpio_16, i2s_rscki, NA */			/* IO8 */
+/* 51 B09, gpio_17, i2s_rws, NA */			/* IO3 */
+/* 52 A09, gpio_18, i2s_tsck, NA */			/* IO2 */
+/* 53 C09, gpio_19, i2s_twsi, NA */			/* IO4 */
+/* 54 D09, gpio_20, i2s_txd, NA */			/* IO7 */
+/* 55 D08, gpio_21, spi0_m_sck, NA */
+/* 56 E07, gpio_22, spi0_m_miso, NA */
+/* 57 E09, gpio_23, spi0_m_mosi, NA */
+/* 58 E08, gpio_24, spi0_m_cs0, NA */
+/* 59 A10, gpio_25, spi0_m_cs1, NA */
+/* 60 B10, gpio_26, spi0_m_cs2, NA */
+/* 61 C10, gpio_27, spi0_m_cs3, NA */
+/* 62 D10, gpio_28, NA, NA */
+/* 63 E10, gpio_ss_10, pwm_0, NA */			/* IO3 */
+/* 64 D11, gpio_ss_11, pwm_1, NA */			/* IO5 */
+/* 65 C11, gpio_ss_12, pwm_2, NA */			/* IO6 */
+/* 66 B11, gpio_ss_13, pwm_3, NA */			/* IO9 */
+/* 67 D12, gpio_ss_14, clkout_32khz, NA */
+/* 68 C12, gpio_ss_15, clkout_16mhz, NA */
+
+/* Note:
+ * 1. I2C pins on the shield are connected to i2c0_ss_sda and i2c_0_ss_scl,
+ *    which are on the sensor subsystem. They are also tied to AD4 and AD5.
+ *    Therefore, to use I2C, pin 9 (ain_9) and (ain_14) both need to be set
+ *    to PINMUX_FUNC_B, so they will not interfere with I2C operations.
+ *    Also, there is no internal pull-up on I2c bus, and thus external
+ *    pull-up resistors are needed.
+ * 2. IO3/PWM0 is connected to pin 51 and 63.
+ * 3. IO5/PWM1 is connected to pin 49 and 64.
+ */
+
+#include <pinmux.h>
+#include "mraa_internal.h"
+#include "mraa/aio.h"
+
+static mraa_board_t _board;
+
+mraa_board_t* mraa_intel_arduino_101_sss()
+{
+    mraa_board_t* b = &_board;
+    mraa_set_board_config(b);
+    b->platform_name = "Arduino 101 SSS";
+    b->platform_type = MRAA_INTEL_ARDUINO_101_SSS;
+    mraa_set_pininfo(b,  0,  0, "IO0",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  1,  3, "IO1",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  2, 18, "IO2",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  3,  0, "IO3",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  4, 19, "IO4",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  5,  1, "IO5",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  6,  2, "IO6",  (mraa_pincapabilities_t){ 0, 0, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  7, 20, "IO7",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  8, 16, "IO8",  (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b,  9,  3, "IO9",  (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 10,  0, "IO10", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 11,  3, "IO11", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 12,  1, "IO12", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 13,  2, "IO13", (mraa_pincapabilities_t){ 1, 1, 0, 0, 1, 0, 0, 0 });
+    mraa_set_pininfo(b, 0, 10, "A0  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 1, 11, "A1  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 2, 12, "A2  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 3, 13, "A3  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 4, 14, "A4  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    mraa_set_pininfo(b, 5,  9, "A5  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    b->def_i2c_bus = 0;
+    b->i2c_bus[0].bus_id = 0;
+    b->pins[18].i2c.mux_total = 0;
+    b->pins[19].i2c.mux_total = 0;
+    b->i2c_bus[0].sda = 18;
+    b->i2c_bus[0].scl = 19;
+    b->adc_raw = 12;
+    b->adc_supported = 12;
+
+// sss will have a different configuration
+#if 0
+    int i2c_raw_gpios[] = { 9, 14, 24, 25 };
+    struct device* zdev = device_get_binding("GPIO_0");
+    if (zdev != NULL) {
+        for (int i = 0; i<4; ++i) {
+            int ret = gpio_pin_configure(zdev, i2c_raw_gpios[i], GPIO_PUD_PULL_UP);
+            if (ret) {
+                printf("Failed to set pull up for pin %d\n", i2c_raw_gpios[i]);
+            }
+        }
+    } else
+        printf("Failed to open gpio driver\n");
+#endif
+    return b;
+}
diff --git a/ext/lib/mraa/source/arduino_101_sss.h b/ext/lib/mraa/source/arduino_101_sss.h
new file mode 100644
index 0000000..7a9e483
--- /dev/null
+++ b/ext/lib/mraa/source/arduino_101_sss.h
@@ -0,0 +1,39 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mraa_internal_types.h"
+
+
+mraa_board_t*
+mraa_intel_arduino_101_sss();
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/mraa/source/board_config.h b/ext/lib/mraa/source/board_config.h
new file mode 100644
index 0000000..9ca6fe0
--- /dev/null
+++ b/ext/lib/mraa/source/board_config.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#if defined(CONFIG_BOARD_ARDUINO_101)
+#define CONFIG_MRAA_PIN_COUNT 20
+#define CONFIG_MRAA_GPIO_COUNT 20
+#define CONFIG_MRAA_AIO_COUNT 0
+#define CONFIG_MRAA_I2C_COUNT 1
+#define CONFIG_MRAA_PWM_COUNT 2
+#define CONFIG_MRAA_SPI_COUNT 1
+#define CONFIG_MRAA_UART_COUNT 2
+#define CONFIG_MRAA_PINMUX_COUNT 1
+#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
+#define CONFIG_MRAA_PIN_COUNT 20
+#define CONFIG_MRAA_GPIO_COUNT 20
+#define CONFIG_MRAA_AIO_COUNT 6
+#define CONFIG_MRAA_I2C_COUNT 1
+#define CONFIG_MRAA_PWM_COUNT 2
+#define CONFIG_MRAA_SPI_COUNT 1
+#define CONFIG_MRAA_UART_COUNT 0
+#define CONFIG_MRAA_PINMUX_COUNT 1
+#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
+#define CONFIG_MRAA_PIN_COUNT 20
+#define CONFIG_MRAA_GPIO_COUNT 20
+#define CONFIG_MRAA_AIO_COUNT 19
+#define CONFIG_MRAA_I2C_COUNT 1
+#define CONFIG_MRAA_PWM_COUNT 2
+#define CONFIG_MRAA_SPI_COUNT 1
+#define CONFIG_MRAA_UART_COUNT 1
+#define CONFIG_MRAA_PINMUX_COUNT 1
+#endif
+
diff --git a/ext/lib/mraa/source/gpio.c b/ext/lib/mraa/source/gpio.c
new file mode 100644
index 0000000..aeebaa5
--- /dev/null
+++ b/ext/lib/mraa/source/gpio.c
@@ -0,0 +1,352 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#else
+#include <misc/printk.h>
+#define printf printk
+#endif
+#include "mraa/gpio.h"
+#include "mraa_internal.h"
+#include "mraa_internal_types.h"
+#include <gpio.h>
+#include <misc/util.h>
+#include <pinmux.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+#if defined(CONFIG_GPIO_QMSI)
+#define GPIO_DRV_NAME CONFIG_GPIO_QMSI_0_NAME
+#elif defined(CONFIG_GPIO_QMSI_SS_0)
+#define GPIO_DRV_NAME CONFIG_GPIO_QMSI_SS_0_NAME
+#elif defined(CONFIG_GPIO_QMSI_SS_1)
+#define GPIO_DRV_NAME CONFIG_GPIO_QMSI_SS_1_NAME
+#else
+#define GPIO_DRV_NAME "GPIO_0"
+#endif
+static int edge_flags = 0;
+
+
+/*
+ * Use container_of macro to get gpio context as per advice from
+ * ivan.briano@intel.com on 5/13/16.
+ *
+ * henry.bruce: Callback function signatures usually include a "user
+ *  data" parameter so callback can be given some context.  This is
+ *  missing from gpio_callback_handler_t. Is this by design or an
+ *  omission?
+ *
+ * ivan.briano: By design, use the callback_handler as a field in your
+ *  struct and get it in the callback with container_of()
+ */
+static void
+gpio_internal_callback(struct device* port, struct gpio_callback* cb, uint32_t pins)
+{
+    mraa_gpio_context dev = CONTAINER_OF(cb, struct _gpio, zcallback);
+    if (dev->isr != NULL)
+        dev->isr(dev->isr_args);
+}
+
+mraa_gpio_context
+mraa_gpio_init(int pin)
+{
+    mraa_board_t* board = plat;
+    if (board == NULL) {
+        printf("gpio: platform not initialised\n");
+        return NULL;
+    }
+
+    if (pin < 0 || pin >= board->phy_pin_count) {
+        printf("gpio: pin %i beyond platform definition\n", pin);
+        return NULL;
+    }
+
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux\n");
+        return NULL;
+    }
+
+#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
+    d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pin == 14) {
+        pinmux_pin_set(d2k_pinmux_dev, 3, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 14, 3, "A0", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 15) {
+        pinmux_pin_set(d2k_pinmux_dev, 4, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 15, 4, "A1", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 16) {
+        pinmux_pin_set(d2k_pinmux_dev, 14, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 16, 14, "A2", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 17) {
+        pinmux_pin_set(d2k_pinmux_dev, 15, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 17, 15, "A3", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 18) {
+        pinmux_pin_set(d2k_pinmux_dev, 7, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 18, 7, "A4", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 });
+    } else if (pin == 19) {
+        pinmux_pin_set(d2k_pinmux_dev, 6, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 19, 6, "A5", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 });
+    } else if (pin < 2 || pin >= 20) {
+        printf("Pin %d not enabled/Can't be enabled\n", pin);
+        return NULL;
+    }
+#endif
+#if defined(CONFIG_BOARD_ARDUINO_101)
+    if (pin == 3) {
+        pinmux_pin_set(pinmux_dev, 63, PINMUX_FUNC_C);
+        mraa_set_pininfo(board, 3, 17, "IO3", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else if (pin == 5) {
+        pinmux_pin_set(pinmux_dev, 64, PINMUX_FUNC_C);
+        mraa_set_pininfo(board, 5, 15, "IO5", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else if (pin == 10) {
+        pinmux_pin_set(pinmux_dev, 0, PINMUX_FUNC_A);
+    } else if (pin == 11) {
+        pinmux_pin_set(pinmux_dev, 3, PINMUX_FUNC_A);
+    } else if (pin == 12) {
+        pinmux_pin_set(pinmux_dev, 1, PINMUX_FUNC_A);
+    } else if (pin == 13) {
+        pinmux_pin_set(pinmux_dev, 2, PINMUX_FUNC_A);
+    } else if (pin == 6 || pin == 9 || (pin >= 14 && pin <= 19)) {
+        printf("Pin %d not enabled/Can't be enabled\n", pin);
+        return NULL;
+    }
+#endif
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS)
+    if (pin == 14) {
+        pinmux_pin_set(pinmux_dev, 10, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 14, 2, "A0  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 15) {
+        pinmux_pin_set(pinmux_dev, 11, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 15, 3, "A1  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 16) {
+        pinmux_pin_set(pinmux_dev, 12, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 16, 4, "A2  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 17) {
+        pinmux_pin_set(pinmux_dev, 13, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 17, 5, "A3  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    } else if (pin == 18) {
+        pinmux_pin_set(pinmux_dev, 14, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 18, 6, "A4  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    } else if (pin == 19) {
+        pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_A);
+        mraa_set_pininfo(board, 19, 1, "A5  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    } else {
+        printf("Pin %d not enabled/Can't be enabled\n", pin);
+        return NULL;
+    }
+#endif
+
+    if (board->pins[pin].capabilites.gpio != 1) {
+        printf("gpio: pin %i not capable of gpio\n", pin);
+        return NULL;
+    }
+    if (board->pins[pin].gpio.mux_total > 0) {
+        if (mraa_setup_mux_mapped(board->pins[pin].gpio) != MRAA_SUCCESS) {
+            return NULL;
+        }
+    }
+    mraa_gpio_context dev = mraa_gpio_init_raw(board->pins[pin].gpio.pinmap);
+    if (dev) {
+        dev->pin = pin;
+    }
+    return dev;
+}
+
+mraa_gpio_context
+mraa_gpio_init_raw(int gpiopin)
+{
+    mraa_gpio_context dev = (mraa_gpio_context) malloc(sizeof(struct _gpio));
+    if (!dev) {
+        printf("%s: context allocation failed\n", __FUNCTION__);
+        return NULL;
+    }
+
+    dev->phy_pin = gpiopin;
+    dev->zdev = device_get_binding(GPIO_DRV_NAME);
+    if (dev->zdev == NULL) {
+        free(dev);
+        return NULL;
+    }
+    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, GPIO_DIR_OUT);
+    if (ret) {
+        printf("Error %d configuring %s pin %d\n", ret, GPIO_DRV_NAME, dev->phy_pin);
+        free(dev);
+        return NULL;
+    }
+    return dev;
+}
+
+mraa_result_t
+mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
+{
+    int flags = 0;
+    uint32_t value = 0;
+    switch (dir) {
+        case MRAA_GPIO_OUT:
+            flags = GPIO_DIR_OUT;
+            break;
+        case MRAA_GPIO_IN:
+            flags = GPIO_DIR_IN;
+            break;
+        case MRAA_GPIO_OUT_HIGH:
+            flags = GPIO_DIR_OUT;
+            value = 1;
+            break;
+        case MRAA_GPIO_OUT_LOW:
+            flags = GPIO_DIR_OUT;
+            value = 0;
+            break;
+        default:
+            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+    }
+    if (gpio_pin_configure(dev->zdev, dev->phy_pin, flags))
+        return MRAA_ERROR_UNSPECIFIED;
+    if (dir == MRAA_GPIO_OUT_HIGH || dir == MRAA_GPIO_OUT_LOW) {
+        if (gpio_pin_write(dev->zdev, dev->phy_pin, value))
+            return MRAA_ERROR_UNSPECIFIED;
+    }
+    return MRAA_SUCCESS;
+}
+
+
+mraa_result_t
+mraa_gpio_edge_mode(mraa_gpio_context dev, mraa_gpio_edge_t mode)
+{
+    switch (mode) {
+        case MRAA_GPIO_EDGE_NONE:
+            edge_flags = 0;
+            break;
+        case MRAA_GPIO_EDGE_BOTH:
+            edge_flags = GPIO_INT_EDGE | GPIO_INT_DOUBLE_EDGE;
+            break;
+        case MRAA_GPIO_EDGE_RISING:
+            edge_flags = GPIO_INT_EDGE | GPIO_INT_ACTIVE_HIGH;
+            break;
+        case MRAA_GPIO_EDGE_FALLING:
+            edge_flags = GPIO_INT_EDGE | GPIO_INT_ACTIVE_LOW;
+            break;
+        default:
+            return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
+
+int
+mraa_gpio_read(mraa_gpio_context dev)
+{
+    uint32_t value;
+    if (gpio_pin_read(dev->zdev, dev->phy_pin, &value))
+        return -1;
+    else
+        return (int) value;
+}
+
+mraa_result_t
+mraa_gpio_write(mraa_gpio_context dev, int value)
+{
+    if (gpio_pin_write(dev->zdev, dev->phy_pin, (uint32_t) value))
+        return MRAA_ERROR_UNSPECIFIED;
+    return MRAA_SUCCESS;
+}
+
+
+mraa_result_t
+mraa_gpio_isr(mraa_gpio_context dev, mraa_gpio_edge_t edge_mode, void (*fptr)(void*), void* args)
+{
+    if (MRAA_SUCCESS != mraa_gpio_edge_mode(dev, edge_mode)) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+    int flags = GPIO_DIR_IN | GPIO_INT | GPIO_INT_DEBOUNCE | edge_flags;
+    // printf("isr addr = %x, args = %x\n", fptr, args);
+    int ret = gpio_pin_configure(dev->zdev, dev->phy_pin, flags);
+    if (ret) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+    dev->isr = fptr;
+    dev->isr_args = args;
+    gpio_init_callback(&(dev->zcallback), gpio_internal_callback, BIT(dev->phy_pin));
+    ret = gpio_add_callback(dev->zdev, &(dev->zcallback));
+    if (ret) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+    ret = gpio_pin_enable_callback(dev->zdev, dev->phy_pin);
+    if (ret) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_gpio_isr_exit(mraa_gpio_context dev)
+{
+    return gpio_pin_disable_callback(dev->zdev, dev->phy_pin) ? MRAA_ERROR_UNSPECIFIED : MRAA_SUCCESS;
+}
+
+
+mraa_result_t
+mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
+{
+    if (dev == NULL) {
+        return MRAA_ERROR_INVALID_RESOURCE;
+    }
+    dev->owner = own;
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_gpio_mode(mraa_gpio_context dev, mraa_gpio_mode_t mode)
+{
+    return MRAA_SUCCESS;
+}
+
+int
+mraa_gpio_get_pin(mraa_gpio_context dev)
+{
+    if (dev == NULL) {
+        return -1;
+    }
+    return dev->phy_pin;
+}
+
+int
+mraa_gpio_get_pin_raw(mraa_gpio_context dev)
+{
+    if (dev == NULL) {
+        return -1;
+    }
+    return dev->pin;
+}
+
+mraa_result_t
+mraa_gpio_close(mraa_gpio_context dev)
+{
+    free(dev);
+
+    return MRAA_SUCCESS;
+}
diff --git a/ext/lib/mraa/source/i2c.c b/ext/lib/mraa/source/i2c.c
new file mode 100644
index 0000000..6280fc6
--- /dev/null
+++ b/ext/lib/mraa/source/i2c.c
@@ -0,0 +1,240 @@
+/*
+ * Author: Abhishek Malik <abhishek.malik@intel.com>
+ * Contributions: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <i2c.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pinmux.h>
+#include "mraa_internal.h"
+#include "mraa_internal_types.h"
+#include "mraa/i2c.h"
+
+
+mraa_i2c_context
+mraa_i2c_init(int bus)
+{
+    mraa_board_t* board = plat;
+    if (board == NULL) {
+        // syslog(LOG_ERR, "i2c: Platform Not Initialised");
+        return NULL;
+    }
+
+    if (bus >= board->i2c_bus_count) {
+        // syslog(LOG_ERR, "Above i2c bus count");
+        return NULL;
+    }
+
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux\n");
+        return NULL;
+    }
+
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS)
+    if (bus == 0) {
+        pinmux_pin_set(pinmux_dev, 14, PINMUX_FUNC_B);
+        pinmux_pin_set(pinmux_dev, 9, PINMUX_FUNC_B);
+        pinmux_pin_pullup(pinmux_dev, 14, PINMUX_FUNC_B);
+        pinmux_pin_pullup(pinmux_dev, 9, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 4, 14, "A4  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+        mraa_set_pininfo(board, 5, 9, "A5  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    }
+#endif
+
+    if (board->i2c_bus[bus].bus_id == -1) {
+        // syslog(LOG_ERR, "Invalid i2c bus, moving to default i2c bus");
+        bus = board->def_i2c_bus;
+    }
+    if (!board->no_bus_mux) {
+        int pos = board->i2c_bus[bus].sda;
+        if (board->pins[pos].i2c.mux_total > 0) {
+            if (mraa_setup_mux_mapped(board->pins[pos].i2c) != MRAA_SUCCESS) {
+                // syslog(LOG_ERR, "i2c: Failed to set-up i2c sda multiplexer");
+                return NULL;
+            }
+        }
+
+        pos = board->i2c_bus[bus].scl;
+        if (board->pins[pos].i2c.mux_total > 0) {
+            if (mraa_setup_mux_mapped(board->pins[pos].i2c) != MRAA_SUCCESS) {
+                // syslog(LOG_ERR, "i2c: Failed to set-up i2c scl multiplexer");
+                return NULL;
+            }
+        }
+    }
+
+    return mraa_i2c_init_raw(plat->i2c_bus[bus].bus_id);
+}
+
+
+mraa_i2c_context
+mraa_i2c_init_raw(unsigned int bus)
+{
+    char device_name[8];
+    mraa_i2c_context dev = (mraa_i2c_context) malloc(sizeof(struct _i2c));
+    if (!dev)
+    {
+        printf("%s: context allocation failed\n", __FUNCTION__);
+        return NULL;
+    }
+
+    sprintf(device_name, "I2C_%d", bus);
+    dev->zdev = device_get_binding(device_name);
+    if (dev->zdev == NULL) {
+        printf("Failed to get binding for %s\n", device_name);
+        free(dev);
+        return NULL;
+    }
+    dev->busnum = bus;
+    dev->zcfg.raw = 0;
+    dev->zcfg.bits.use_10_bit_addr = 0;
+    dev->zcfg.bits.speed = I2C_SPEED_STANDARD;
+    dev->zcfg.bits.is_master_device = 1;
+    if (i2c_configure(dev->zdev, dev->zcfg.raw) != 0)
+    {
+        free(dev);
+        return NULL;
+    }
+    return dev;
+}
+
+
+mraa_result_t
+mraa_i2c_frequency(mraa_i2c_context dev, mraa_i2c_mode_t mode)
+{
+    switch (mode) {
+        case MRAA_I2C_STD: /**< up to 100Khz */
+            dev->zcfg.bits.speed = I2C_SPEED_STANDARD;
+            break;
+        case MRAA_I2C_FAST: /**< up to 400Khz */
+            dev->zcfg.bits.speed = I2C_SPEED_FAST;
+            break;
+        case MRAA_I2C_HIGH: /**< up to 3.4Mhz */
+            dev->zcfg.bits.speed = I2C_SPEED_HIGH;
+            break;
+    }
+    return i2c_configure(dev->zdev, dev->zcfg.raw) == 0 ? MRAA_SUCCESS : MRAA_ERROR_UNSPECIFIED;
+}
+
+
+mraa_result_t
+mraa_i2c_address(mraa_i2c_context dev, uint8_t addr)
+{
+    dev->addr = addr;
+    return MRAA_SUCCESS;
+}
+
+
+int
+mraa_i2c_read(mraa_i2c_context dev, uint8_t* data, int length)
+{
+    int status = i2c_read(dev->zdev, data, length, dev->addr);
+    return status ? 0 : length;
+}
+
+mraa_result_t
+mraa_i2c_write(mraa_i2c_context dev, const uint8_t* data, int bytesToWrite)
+{
+    int status = i2c_write(dev->zdev, (uint8_t *)data, bytesToWrite, dev->addr);
+    return status == 0 ? MRAA_SUCCESS : MRAA_ERROR_INVALID_HANDLE;
+}
+
+
+int
+mraa_i2c_read_byte(mraa_i2c_context dev)
+{
+    uint8_t data;
+    int bytes_read = mraa_i2c_read(dev, &data, 1);
+    return bytes_read == 1 ? data : -1;
+}
+
+int
+mraa_i2c_read_byte_data(mraa_i2c_context dev, uint8_t command)
+{
+    uint8_t data;
+    return i2c_reg_read_byte(dev->zdev, dev->addr, command, &data) ? -1 : data;
+}
+
+int
+mraa_i2c_read_word_data(mraa_i2c_context dev, uint8_t command)
+{
+    uint16_t data;
+    if (mraa_i2c_read_bytes_data(dev, command, (uint8_t*)&data, 2) == 2)
+        return data;
+    else
+        return -1;
+}
+
+int
+mraa_i2c_read_bytes_data(mraa_i2c_context dev, uint8_t command, uint8_t* data, int length)
+{
+    return i2c_burst_read(dev->zdev, dev->addr, command, data, length) == 0 ? length : 0;
+}
+
+
+mraa_result_t
+mraa_i2c_write_byte(mraa_i2c_context dev, uint8_t data)
+{
+    mraa_result_t status = mraa_i2c_write(dev, &data, 1);
+    return status;
+}
+
+
+mraa_result_t
+mraa_i2c_write_byte_data(mraa_i2c_context dev, const uint8_t data, const uint8_t command)
+{
+    uint8_t buf[2];
+    buf[0] = command;
+    buf[1] = data;
+    mraa_result_t status = mraa_i2c_write(dev, buf, 2);
+    return status;
+}
+
+mraa_result_t
+mraa_i2c_write_word_data(mraa_i2c_context dev, const uint16_t data, const uint8_t command)
+{
+    uint8_t buf[3];
+    buf[0] = command;
+    buf[1] = (uint8_t) data;
+    buf[2] = (uint8_t)(data >> 8);
+    mraa_result_t status = mraa_i2c_write(dev, buf, 3);
+    return status;
+}
+
+mraa_result_t
+mraa_i2c_update_byte_data(mraa_i2c_context dev, const uint16_t mask, const uint8_t data, const uint8_t command)
+{
+    int status = i2c_reg_update_byte(dev->zdev, dev->addr, command, mask, data);
+    return status == 0 ? MRAA_SUCCESS : MRAA_ERROR_UNSPECIFIED;
+}
+
+
+mraa_result_t
+mraa_i2c_stop(mraa_i2c_context dev)
+{
+    free(dev);
+    return MRAA_SUCCESS;
+}
+
diff --git a/ext/lib/mraa/source/intel_d2k_crb.c b/ext/lib/mraa/source/intel_d2k_crb.c
new file mode 100644
index 0000000..fbc60f4
--- /dev/null
+++ b/ext/lib/mraa/source/intel_d2k_crb.c
@@ -0,0 +1,135 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* From drivers/pinmux/quark_mcu/pinmux_board_quark_d2000.c
+ * This is the full pinmap that we have available on the board for configuration
+ * including the ball position and the various modes that can be set.  In the
+ * _pinmux_defaults we do not spend any time setting values that are using mode
+ * A as the hardware brings up all devices by default in mode A.
+ */
+
+/***************************
+ * PINMUX mapping
+ *
+ * The following lines detail the possible options for the pinmux and their
+ * associated pins and ball points.
+ * This is the full pinmap that we have available on the board for configuration
+ * including the ball position and the various modes that can be set.  In the
+ * _pinmux_defaults we do not spend any time setting values that are using mode
+ * A as the hardware brings up all devices by default in mode A.
+ */
+/* pin, ball, mode A, mode B,      mode C       */
+/*  0   F00, gpio_0,  ai_0,        spi_m_ss0    */
+/*  1   F01, gpio_1,  ai_1,        spi_m_ss1    */
+/*  2   F02, gpio_2,  ai_2,        spi_m_ss2    */
+/*  3   F03, gpio_3,  ai_3,        spi_m_ss3    */
+/*  4   F04, gpio_4,  ai_4,        rtc_clk_out  */
+/*  5   F05, gpio_5,  ai_5,        sys_clk_out  */
+/*  6   F06, gpio_6,  ai_6,        i2c_scl      */
+/*  7   F07, gpio_7,  ai_7,        i2c_sda      */
+/*  8   F08, gpio_8,  ai_8,        spi_s_sclk   */
+/*  9   F09, gpio_9,  ai_9,        spi_s_sdin   */
+/* 10   F10, gpio_10, ai_10,       spi_s_sdout  */
+/* 11   F11, gpio_11, ai_11,       spi_s_scs    */
+/* 12   F12, gpio_12, ai_12,       uart_a_txd   */
+/* 13   F13, gpio_13, ai_13,       uart_a_rxd   */
+/* 14   F14, gpio_14, ai_14,       uart_a_rts   */
+/* 15   F15, gpio_15, ai_15,       uart_a_cts   */
+/* 16   F16, gpio_16, ai_16,       spi_m_sclk   */
+/* 17   F17, gpio_17, ai_17,       spi_m_mosi   */
+/* 18   F18, gpio_18, ai_18,       spi_m_miso   */
+/* 19   F19, tdo,     gpio_19,     pwm0         */
+/* 20   F20, trst_n,  gpio_20,     uart_b_txd   */
+/* 21   F21, tck,     gpio_21,     uart_b_rxd   */
+/* 22   F22, tms,     gpio_22,     uart_b_rts   */
+/* 23   F23, tdi,     gpio_23,     uart_b_cts   */
+/* 24   F24, gpio_24, lpd_sig_out, pwm1         */
+
+/******** End PINMUX mapping **************************/
+
+#include "mraa_internal.h"
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#else
+#include <misc/printk.h>
+#define printf printk
+#endif
+
+static mraa_board_t _board;
+
+mraa_board_t*
+mraa_intel_d2k_crb()
+{
+    d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (d2k_pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux for D2000\n");
+        return NULL;
+    }
+
+    // setting up defaults for the d2000 board
+    pinmux_pin_set(d2k_pinmux_dev, 19, PINMUX_FUNC_B); // IO6
+    pinmux_pin_set(d2k_pinmux_dev, 24, PINMUX_FUNC_A); // IO9
+    pinmux_pin_set(d2k_pinmux_dev, 0, PINMUX_FUNC_A);  // IO10
+    pinmux_pin_set(d2k_pinmux_dev, 3, PINMUX_FUNC_B);  // A0
+    pinmux_pin_set(d2k_pinmux_dev, 4, PINMUX_FUNC_B);  // A1
+    pinmux_pin_set(d2k_pinmux_dev, 14, PINMUX_FUNC_B); // A2
+    pinmux_pin_set(d2k_pinmux_dev, 15, PINMUX_FUNC_B); // A3
+    // on the d2000 the analog pins a4 and a5 are not configured as analog by default
+    // because they don't need to be configured as analog by default
+    // a4 and a5 work as analog pins even in the i2c mode
+    // both haven't yet been tested together
+
+    mraa_board_t* b = &_board;
+    mraa_set_board_config(b);
+    b->platform_name = "Intel D2000 CRB";
+    b->platform_type = MRAA_INTEL_D2000_CRB;
+    mraa_set_pininfo(b, 0, 13, "IO0", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });
+    mraa_set_pininfo(b, 1, 12, "IO1", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 });
+    mraa_set_pininfo(b, 2, 11, "IO2", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 3, 10, "IO3", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 4, 5, "IO4", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 5, 2, "IO5", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 6, 19, "IO6", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 7, 8, "IO7", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 8, 9, "IO8", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 9, 24, "IO9", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 10, 0, "IO10", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 11, 17, "IO11", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 12, 18, "IO12", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 13, 16, "IO13", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 });
+    mraa_set_pininfo(b, 0, 3, "A0  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 1, 4, "A1  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 2, 14, "A2  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 3, 15, "A3  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 0 });
+    mraa_set_pininfo(b, 4, 7, "A4  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    mraa_set_pininfo(b, 5, 6, "A5  ", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 1, 0 });
+    b->def_i2c_bus = 0;
+    b->i2c_bus[0].bus_id = 0;
+    b->pins[18].i2c.mux_total = 0;
+    b->pins[19].i2c.mux_total = 0;
+    b->i2c_bus[0].sda = 18;
+    b->i2c_bus[0].scl = 19;
+    b->adc_raw = 12;
+    return b;
+}
diff --git a/ext/lib/mraa/source/intel_d2k_crb.h b/ext/lib/mraa/source/intel_d2k_crb.h
new file mode 100644
index 0000000..dad0724
--- /dev/null
+++ b/ext/lib/mraa/source/intel_d2k_crb.h
@@ -0,0 +1,38 @@
+/*
+ * Author: Henry Bruce <henry.bruce@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mraa_internal_types.h"
+
+mraa_board_t*
+mraa_intel_d2k_crb();
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/mraa/source/mraa.c b/ext/lib/mraa/source/mraa.c
new file mode 100644
index 0000000..4a32b43
--- /dev/null
+++ b/ext/lib/mraa/source/mraa.c
@@ -0,0 +1,441 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "board_config.h"
+#include "mraa_internal_types.h"
+#include <mraa.h>
+#include <stdio.h>
+#include <string.h>
+
+#if defined(CONFIG_BOARD_ARDUINO_101)
+#include "arduino_101.h"
+#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
+#include "arduino_101_sss.h"
+#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
+#include "intel_d2k_crb.h"
+#else
+#error Board not defined
+#endif
+
+
+mraa_board_t* plat = NULL;
+struct _gpio _internalgpios[4];
+
+mraa_result_t
+mraa_init()
+{
+#if defined(CONFIG_BOARD_ARDUINO_101)
+    plat = mraa_intel_arduino_101();
+#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
+    plat = mraa_intel_arduino_101_sss();
+#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
+    plat = mraa_intel_d2k_crb();
+#endif
+    return plat != NULL ? MRAA_SUCCESS : MRAA_ERROR_NO_RESOURCES;
+}
+
+
+const char*
+mraa_get_platform_name()
+{
+    return plat != NULL ? plat->platform_name : "Unknown";
+}
+
+const char*
+mraa_get_version()
+{
+    return "v0.0.3";
+}
+
+
+mraa_platform_t
+mraa_get_platform_type()
+{
+    return plat != NULL ? plat->platform_type : MRAA_UNKNOWN_PLATFORM;
+}
+
+mraa_boolean_t
+mraa_has_sub_platform()
+{
+    return false;
+}
+
+mraa_result_t
+mraa_setup_mux_mapped(mraa_pin_t meta)
+{
+    int mi;
+    mraa_result_t ret;
+    mraa_gpio_context mux_i = NULL;
+    int last_pin = -1;
+
+    for (mi = 0; mi < meta.mux_total; mi++) {
+
+        switch (meta.mux[mi].pincmd) {
+            case PINCMD_UNDEFINED: // used for backward compatibility
+                if (meta.mux[mi].pin != last_pin) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
+                    if (mux_i == NULL)
+                        return MRAA_ERROR_INVALID_HANDLE;
+                    last_pin = meta.mux[mi].pin;
+                }
+                // this function will sometimes fail, however this is not critical as
+                // long as the write succeeds - Test case galileo gen2 pin2
+                mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
+                ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
+                if (ret != MRAA_SUCCESS) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    return MRAA_ERROR_INVALID_RESOURCE;
+                }
+                break;
+
+            case PINCMD_SET_VALUE:
+                if (meta.mux[mi].pin != last_pin) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
+                    if (mux_i == NULL)
+                        return MRAA_ERROR_INVALID_HANDLE;
+                    last_pin = meta.mux[mi].pin;
+                }
+
+                ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
+
+                if (ret != MRAA_SUCCESS) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    return MRAA_ERROR_INVALID_RESOURCE;
+                }
+                break;
+
+            case PINCMD_SET_DIRECTION:
+                if (meta.mux[mi].pin != last_pin) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
+                    if (mux_i == NULL)
+                        return MRAA_ERROR_INVALID_HANDLE;
+                    last_pin = meta.mux[mi].pin;
+                }
+
+                ret = mraa_gpio_dir(mux_i, meta.mux[mi].value);
+
+                if (ret != MRAA_SUCCESS) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    return MRAA_ERROR_INVALID_RESOURCE;
+                }
+                break;
+
+            case PINCMD_SET_IN_VALUE:
+                if (meta.mux[mi].pin != last_pin) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
+                    if (mux_i == NULL)
+                        return MRAA_ERROR_INVALID_HANDLE;
+                    last_pin = meta.mux[mi].pin;
+                }
+
+                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_IN);
+
+                if (ret == MRAA_SUCCESS)
+                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
+
+                if (ret != MRAA_SUCCESS) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    return MRAA_ERROR_INVALID_RESOURCE;
+                }
+                break;
+
+            case PINCMD_SET_OUT_VALUE:
+                if (meta.mux[mi].pin != last_pin) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
+                    if (mux_i == NULL)
+                        return MRAA_ERROR_INVALID_HANDLE;
+                    last_pin = meta.mux[mi].pin;
+                }
+
+                ret = mraa_gpio_dir(mux_i, MRAA_GPIO_OUT);
+
+                if (ret == MRAA_SUCCESS)
+                    ret = mraa_gpio_write(mux_i, meta.mux[mi].value);
+
+                if (ret != MRAA_SUCCESS) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    return MRAA_ERROR_INVALID_RESOURCE;
+                }
+                break;
+
+            case PINCMD_SET_MODE:
+                if (meta.mux[mi].pin != last_pin) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    mux_i = mraa_gpio_init_raw(meta.mux[mi].pin);
+                    if (mux_i == NULL)
+                        return MRAA_ERROR_INVALID_HANDLE;
+                    last_pin = meta.mux[mi].pin;
+                }
+
+                ret = mraa_gpio_mode(mux_i, meta.mux[mi].value);
+
+                if (ret != MRAA_SUCCESS) {
+                    if (mux_i != NULL) {
+                        mraa_gpio_owner(mux_i, 0);
+                        mraa_gpio_close(mux_i);
+                    }
+                    return MRAA_ERROR_INVALID_RESOURCE;
+                }
+                break;
+
+            case PINCMD_SKIP:
+                break;
+
+            default:
+                // syslog(LOG_NOTICE, "mraa_setup_mux_mapped: wrong command %d on pin %d with value
+                // %d", meta.mux[mi].pincmd, meta.mux[mi].pin, meta.mux[mi].value);
+                break;
+        }
+    }
+
+    if (mux_i != NULL) {
+        mraa_gpio_owner(mux_i, 0);
+        mraa_gpio_close(mux_i);
+    }
+    return MRAA_SUCCESS;
+}
+
+mraa_boolean_t
+mraa_pin_mode_test(int pin, mraa_pinmodes_t mode)
+{
+    if (plat == NULL)
+        return 0;
+    mraa_board_t* current_plat = plat;
+    if (current_plat->platform_type == MRAA_UNKNOWN_PLATFORM) {
+        return 0;
+    }
+    if (pin > (current_plat->phy_pin_count - 1) || pin < 0)
+        return 0;
+
+    switch (mode) {
+        case MRAA_PIN_VALID:
+            if (current_plat->pins[pin].capabilites.valid == 1)
+                return 1;
+            break;
+        case MRAA_PIN_GPIO:
+            if (current_plat->pins[pin].capabilites.gpio == 1)
+                return 1;
+            break;
+        case MRAA_PIN_PWM:
+            if (current_plat->pins[pin].capabilites.pwm == 1)
+                return 1;
+            break;
+        case MRAA_PIN_FAST_GPIO:
+            if (current_plat->pins[pin].capabilites.fast_gpio == 1)
+                return 1;
+            break;
+        case MRAA_PIN_SPI:
+            if (current_plat->pins[pin].capabilites.spi == 1)
+                return 1;
+            break;
+        case MRAA_PIN_I2C:
+            if (current_plat->pins[pin].capabilites.i2c == 1)
+                return 1;
+            break;
+        case MRAA_PIN_AIO:
+            if (current_plat->pins[pin].capabilites.aio == 1)
+                return 1;
+            break;
+        case MRAA_PIN_UART:
+            if (current_plat->pins[pin].capabilites.uart == 1)
+                return 1;
+            break;
+        default:
+            // syslog(LOG_NOTICE, "requested pinmode invalid");
+            break;
+    }
+    return 0;
+}
+
+unsigned int
+mraa_adc_raw_bits()
+{
+    if (plat == NULL)
+        return 0;
+
+    if (plat->aio_count == 0)
+        return 0;
+
+    return plat->adc_raw;
+}
+
+unsigned int
+mraa_adc_supported_bits()
+{
+    if (plat == NULL)
+        return 0;
+
+    if (plat->aio_count == 0)
+        return 0;
+
+    return plat->adc_supported;
+}
+
+int
+mraa_get_i2c_bus_count()
+{
+    if (plat == NULL) {
+        return -1;
+    }
+    return plat->i2c_bus_count;
+}
+
+int
+mraa_get_i2c_bus_id(unsigned i2c_bus)
+{
+    if (plat == NULL) {
+        return -1;
+    }
+
+    if (i2c_bus >= plat->i2c_bus_count) {
+        return -1;
+    }
+
+    return plat->i2c_bus[i2c_bus].bus_id;
+}
+
+unsigned int
+mraa_get_pin_count()
+{
+    if (plat == NULL) {
+        return 0;
+    }
+    return plat->phy_pin_count;
+}
+
+unsigned int
+mraa_get_platform_pin_count(uint8_t platform_offset)
+{
+    if (platform_offset == MRAA_MAIN_PLATFORM_OFFSET)
+        return mraa_get_pin_count();
+    else
+        return 0;
+}
+
+
+char*
+mraa_get_pin_name(int pin)
+{
+    if (plat == NULL)
+        return NULL;
+    if (pin > (plat->phy_pin_count - 1) || pin < 0)
+        return NULL;
+    return (char*) plat->pins[pin].name;
+}
+
+int
+mraa_get_default_i2c_bus(uint8_t platform_offset)
+{
+    if (plat == NULL)
+        return -1;
+    return plat->def_i2c_bus;
+}
+
+mraa_boolean_t
+mraa_is_sub_platform_id(int pin_or_bus)
+{
+    return 0;
+}
+
+int
+mraa_get_sub_platform_id(int pin_or_bus)
+{
+    return -1;
+}
+
+int
+mraa_get_sub_platform_index(int pin_or_bus)
+{
+    return -1;
+}
+
+
+// Internal functions
+mraa_result_t
+mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps)
+{
+    mraa_pininfo_t* pin_info = &board->pins[mraa_pin];
+    pin_info->gpio.pinmap = zephyr_pin;
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS) || defined(CONFIG_BOARD_QUARK_D2000_CRB)
+    pin_info->aio.pinmap = zephyr_pin;
+#endif
+#if defined(CONFIG_BOARD_ARDUINO_101) || defined(CONFIG_BOARD_QUARK_D2000_CRB)
+    pin_info->uart.pinmap = zephyr_pin;
+#endif
+    pin_info->pwm.pinmap = zephyr_pin;
+    pin_info->gpio.mux_total = 0;
+    pin_info->name = name;
+    pin_info->capabilites = caps;
+    return MRAA_SUCCESS;
+}
+
+
+void
+mraa_set_board_config(mraa_board_t* board)
+{
+    memset(board, 0, sizeof(mraa_board_t));
+    board->phy_pin_count = CONFIG_MRAA_PIN_COUNT;
+    board->gpio_count = CONFIG_MRAA_GPIO_COUNT;
+    board->aio_count = CONFIG_MRAA_AIO_COUNT;
+    board->i2c_bus_count = CONFIG_MRAA_I2C_COUNT;
+    board->spi_bus_count = CONFIG_MRAA_SPI_COUNT;
+    board->uart_dev_count = CONFIG_MRAA_UART_COUNT;
+}
diff --git a/ext/lib/mraa/source/mraa_internal.h b/ext/lib/mraa/source/mraa_internal.h
new file mode 100644
index 0000000..641e09d
--- /dev/null
+++ b/ext/lib/mraa/source/mraa_internal.h
@@ -0,0 +1,55 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mraa/common.h"
+#include "mraa_internal_types.h"
+
+extern mraa_board_t* plat;
+
+#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
+static struct device* d2k_pinmux_dev;
+#endif
+
+/**
+ * Takes in pin information and sets up the multiplexors.
+ *
+ * @param meta
+ * @return mraa result type indicating success of actions.
+ */
+mraa_result_t mraa_setup_mux_mapped(mraa_pin_t meta);
+
+mraa_result_t mraa_set_pininfo(mraa_board_t* board, int mraa_pin, int zephyr_pin, char* name, mraa_pincapabilities_t caps);
+
+void mraa_set_board_config(mraa_board_t* board);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/mraa/source/mraa_internal_types.h b/ext/lib/mraa/source/mraa_internal_types.h
new file mode 100644
index 0000000..effcbc2
--- /dev/null
+++ b/ext/lib/mraa/source/mraa_internal_types.h
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "board_config.h"
+#include "mraa/common.h"
+#include <adc.h>
+#include <gpio.h>
+#include <i2c.h>
+#include <pinmux.h>
+
+/**
+ * A structure representing a gpio pin.
+ */
+struct _gpio {
+    /*@{*/
+    uint8_t pin;                    /**< the pin number, as known to the os. */
+    int8_t phy_pin;                 /**< pin passed to clean init. -1 none and raw*/
+    struct device* zdev;            /**< Zephyr device driver object */
+    struct gpio_callback zcallback; /**< Zephyr gpio callback object */
+    mraa_boolean_t owner;           /**< If this context originally exported the pin */
+    void (*isr)(void*);             /**< the interupt service request */
+    void* isr_args;                 /**< args return when interupt service request triggered */
+    /*@}*/
+};
+
+
+/**
+ * A structure representing a I2C bus
+ */
+struct _i2c {
+    /*@{*/
+    int8_t busnum; /**< the bus number of the /dev/i2c-* device */
+    uint8_t addr;  /**< the address of the i2c slave */
+    struct device* zdev;
+    union dev_config zcfg;
+    /*@}*/
+};
+
+/**
+ * A structure representing a PWM pin
+ */
+struct _pwm {
+    /*@{*/
+    int pin;        /**< the pin number, as known to the os. */
+    int8_t phy_pin; /**< pin passed to clean init. -1 none and raw*/
+    int period;     /**< Cache the period to speed up setting duty */
+    float duty_percentage;
+    struct device* zdev;
+    /*@}*/
+};
+
+/**
+ * A structure representing uart.
+ */
+struct _uart {
+    /*@{*/
+    uint8_t block;       /**< the uart block number, as known to the os. */
+    int8_t phy_pin;      /**< pin passed to clean init. -1 none and raw */
+    struct device* zdev; /**< Zephyr device driver object */
+    /*@}*/
+};
+
+/**
+ * A structure representing a spi bus.
+ */
+struct _spi {
+    /*@{*/
+    int8_t busnum;             /**< the bus number of the /dev/i2c-* device */
+    struct spi_config* config; /**< struct to hold the SPI configurations */
+    struct device* zdev;       /**< Zephyr device driver object */
+    struct device* pinmux_dev; /**< pinmux device driver object */
+    /*@}*/
+};
+
+/**
+ * A structure representing aio pin.
+ */
+struct _aio {
+    /*@{*/
+    uint8_t pin;                 /**< the pin number, as known to the os. */
+    int8_t phy_pin;              /**< pin passed to clean init. -1 none and raw*/
+    struct device* zdev;         /**< Zephyr device driver object */
+    int value_bit;               /**< 10 bits by default. Can be increased based on board */
+    struct adc_seq_table* table; /** struct to hold list of samples */
+    uint8_t seq_buffer[4];       /** buffer to save the analog values that have been read */
+    /*@}*/
+};
+
+/**
+ * A bitfield representing the capabilities of a pin.
+ */
+typedef struct {
+    /*@{*/
+    mraa_boolean_t valid : 1;     /**< Is the pin valid at all */
+    mraa_boolean_t gpio : 1;      /**< Is the pin gpio capable */
+    mraa_boolean_t pwm : 1;       /**< Is the pin pwm capable */
+    mraa_boolean_t fast_gpio : 1; /**< Is the pin fast gpio capable */
+    mraa_boolean_t spi : 1;       /**< Is the pin spi capable */
+    mraa_boolean_t i2c : 1;       /**< Is the pin i2c capable */
+    mraa_boolean_t aio : 1;       /**< Is the pin analog input capable */
+    mraa_boolean_t uart : 1;      /**< Is the pin uart capable */
+    /*@}*/
+} mraa_pincapabilities_t;
+
+
+/**
+ *  Pin commands definition for mraa_mux_t struc
+ */
+
+typedef enum {
+    PINCMD_UNDEFINED = 0, // do not modify, default command for zero value, used for backward
+                          // compatibility with boards where pincmd is not defined (it will be
+                          // deleted later)
+    PINCMD_SET_VALUE = 1, // set a pin's value
+    PINCMD_SET_DIRECTION =
+    2, // set a pin's direction (value like MRAA_GPIO_OUT, MRAA_GPIO_OUT_HIGH...)
+    PINCMD_SET_IN_VALUE = 3,  // set input direction and value
+    PINCMD_SET_OUT_VALUE = 4, // set output direction and value
+    PINCMD_SET_MODE = 5,      // set pin's mode
+    PINCMD_SKIP = 6           // just skip this command, do not apply pin and value
+} pincmd_t;
+
+
+/**
+ * A Structure representing a multiplexer and the required value
+ */
+typedef struct {
+    /*@{*/
+    uint8_t pincmd; /**< Pin command pincmd_xxxx */
+                    /**< At this time not all boards will support it -> TO DO */
+    uint8_t pin;    /**< Raw GPIO pin id */
+    uint8_t value;  /**< Raw GPIO value */
+    /*@}*/
+} mraa_mux_t;
+
+typedef struct {
+    mraa_boolean_t complex_pin : 1;
+    mraa_boolean_t output_en : 1;
+    mraa_boolean_t output_en_high : 1;
+    mraa_boolean_t pullup_en : 1;
+    mraa_boolean_t pullup_en_hiz : 1;
+} mraa_pin_cap_complex_t;
+
+typedef struct {
+    /*@{*/
+    uint8_t pinmap;                           /**< Zephyr pin */
+    uint8_t parent_id;                        /**< Zephyr driver id */
+    uint8_t mux_total;                        /** Numfer of muxes needed for operation of pin */
+    mraa_mux_t mux[CONFIG_MRAA_PINMUX_COUNT]; /** Array holding information about mux */
+    uint8_t output_enable;                    /** Output Enable GPIO, for level shifting */
+    int pinmux;
+    /*@}*/
+} mraa_pin_t;
+
+/**
+ * A Structure representing a physical Pin.
+ */
+typedef struct {
+    /*@{*/
+    char* name;                         /**< Pin's real world name */
+    mraa_pincapabilities_t capabilites; /**< Pin Capabiliites */
+#if CONFIG_MRAA_GPIO_COUNT > 0
+    mraa_pin_t gpio; /**< GPIO structure */
+#endif
+#if CONFIG_MRAA_PWM_COUNT > 0
+    mraa_pin_t pwm; /**< PWM structure */
+#endif
+#if CONFIG_MRAA_AIO_COUNT > 0
+    mraa_pin_t aio; /**< Anaglog Pin */
+#endif
+#if CONFIG_MRAA_I2C_COUNT > 0
+    mraa_pin_t i2c; /**< i2c bus/pin */
+#endif
+#if CONFIG_MRAA_SPI_COUNT > 0
+    mraa_pin_t spi; /**< spi bus/pin */
+#endif
+#if CONFIG_MRAA_UART_COUNT > 0
+    mraa_pin_t uart; /**< uart module/pin */
+#endif
+    /*@}*/
+} mraa_pininfo_t;
+
+/**
+ * A Structure representing the physical properties of a i2c bus.
+ */
+typedef struct {
+    /*@{*/
+    uint8_t bus_id; /**< ID as exposed in the system */
+    uint8_t scl;    /**< i2c SCL */
+    uint8_t sda;    /**< i2c SDA */
+    // mraa_drv_api_t drv_type; /**< Driver type */
+    /*@}*/
+} mraa_i2c_bus_t;
+
+/**
+ * A Structure representing the physical properties of a spi bus.
+ */
+typedef struct {
+    /*@{*/
+    uint8_t bus_id;            /**< The Bus ID as exposed to the system. */
+    uint8_t slave_s;           /**< Slave select */
+    mraa_boolean_t three_wire; /**< Is the bus only a three wire system */
+    uint8_t sclk;              /**< Serial Clock */
+    uint8_t mosi;              /**< Master Out, Slave In. */
+    uint8_t miso;              /**< Master In, Slave Out. */
+    uint8_t cs;                /**< Chip Select, used when the board is a spi slave */
+    /*@}*/
+} mraa_spi_bus_t;
+
+/**
+ * A Structure representing a uart device.
+ */
+typedef struct {
+    /*@{*/
+    uint8_t index;           /**< ID as exposed in the system */
+    int8_t rx;               /**< uart rx */
+    int8_t tx;               /**< uart tx */
+    const char* device_path; /**< To store "/dev/ttyS1" for example */
+    /*@}*/
+} mraa_uart_dev_t;
+
+
+/**
+ * A Structure representing a platform/board.
+ */
+
+typedef struct _board_t {
+    /*@{*/
+    uint8_t phy_pin_count;                            /**< The Total IO pins on board */
+    uint8_t gpio_count;                               /**< GPIO Count */
+    uint8_t aio_count;                                /**< Analog side Count */
+    uint8_t i2c_bus_count;                            /**< Usable i2c Count */
+    mraa_i2c_bus_t i2c_bus[CONFIG_MRAA_I2C_COUNT];    /**< Array of i2c */
+    uint8_t def_i2c_bus;                              /**< Position in array of default i2c bus */
+    uint8_t spi_bus_count;                            /**< Usable spi Count */
+    mraa_spi_bus_t spi_bus[CONFIG_MRAA_SPI_COUNT];    /**< Array of spi */
+    uint8_t def_spi_bus;                              /**< Position in array of defult spi bus */
+    uint8_t adc_raw;                                  /**< ADC raw bit value */
+    uint8_t adc_supported;                            /**< ADC supported bit value */
+    uint8_t def_uart_dev;                             /**< Position in array of defult uart */
+    uint8_t uart_dev_count;                           /**< Usable spi Count */
+    mraa_uart_dev_t uart_dev[CONFIG_MRAA_UART_COUNT]; /**< Array of UARTs */
+    mraa_boolean_t no_bus_mux; /**< i2c/spi/adc/pwm/uart bus muxing setup not required */
+#if CONFIG_MRAA_PWM_COUNT > 0
+    int pwm_default_period; /**< The default PWM period is US */
+    int pwm_max_period;     /**< Maximum period in us */
+    int pwm_min_period;     /**< Minimum period in us */
+#endif
+    mraa_platform_t platform_type;              /**< Platform type */
+    const char* platform_name;                  /**< Platform Name pointer */
+    const char* platform_version;               /**< Platform versioning info */
+    mraa_pininfo_t pins[CONFIG_MRAA_PIN_COUNT]; /**< Pointer to pin array */
+    /*@}*/
+} mraa_board_t;
+
diff --git a/ext/lib/mraa/source/pwm.c b/ext/lib/mraa/source/pwm.c
new file mode 100644
index 0000000..8a9fbc0
--- /dev/null
+++ b/ext/lib/mraa/source/pwm.c
@@ -0,0 +1,273 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * Author: Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014, 2015, 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "mraa/pwm.h"
+#include "mraa_internal.h"
+#include "mraa_internal_types.h"
+#include "version.h"
+#include <misc/util.h>
+#include <pinmux.h>
+#include <pwm.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#else
+#include <misc/printk.h>
+#define printf printk
+#endif
+
+/* about 1 second
+   this calculation is based on that fact that
+   one clock cycle comes to be about 31.25 ns */
+#define MAX_PERIOD 32000000
+#define DEFAULT_DUTY_CYCLE 0.5
+
+#if defined(CONFIG_PWM)
+#if defined(CONFIG_PWM_QMSI)
+#define PWM_DEVICE_NAME CONFIG_PWM_QMSI_DEV_NAME
+#elif defined(CONFIG_PWM_DW)
+#define PWM_DEVICE_NAME CONFIG_PWM_DW_0_DRV_NAME
+#endif
+#endif
+
+mraa_pwm_context
+mraa_pwm_init(int pin)
+{
+    mraa_board_t* board = plat;
+    if (board == NULL) {
+        return NULL;
+    }
+
+    if (pin < 0 || pin >= board->phy_pin_count) {
+        return NULL;
+    }
+
+#if defined(CONFIG_BOARD_QUARK_D2000_CRB)
+    d2k_pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pin == 6) {
+        pinmux_pin_set(d2k_pinmux_dev, 19, PINMUX_FUNC_C);
+        mraa_set_pininfo(board, 6, 0, "IO6", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else if (pin == 9) {
+        pinmux_pin_set(d2k_pinmux_dev, 24, PINMUX_FUNC_C);
+        mraa_set_pininfo(board, 9, 1, "IO9", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    }
+#endif
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS) || defined(CONFIG_BOARD_ARDUINO_101)
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux\n");
+        return NULL;
+    }
+
+    if (pin == 3) {
+        pinmux_pin_set(pinmux_dev, 63, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 3, 0, "IO3", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else if (pin == 5) {
+        pinmux_pin_set(pinmux_dev, 64, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 5, 1, "IO5", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else if (pin == 6) {
+        pinmux_pin_set(pinmux_dev, 65, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 6, 2, "IO6", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else if (pin == 9) {
+        pinmux_pin_set(pinmux_dev, 66, PINMUX_FUNC_B);
+        mraa_set_pininfo(board, 9, 3, "IO9", (mraa_pincapabilities_t){ 1, 1, 1, 0, 0, 0, 0, 0 });
+    } else {
+        printf("Pin %d not enabled/Can't be enabled\n", pin);
+        return NULL;
+    }
+#endif
+
+    if (board->pins[pin].capabilites.pwm != 1) {
+        return NULL;
+    }
+
+    mraa_pwm_context dev = (mraa_pwm_context) malloc(sizeof(struct _pwm));
+    dev->pin = pin;
+    dev->phy_pin = board->pins[pin].pwm.pinmap;
+    dev->zdev = device_get_binding("PWM_0");
+    if (dev->zdev == NULL)
+        return NULL;
+    dev->period = MAX_PERIOD;
+    dev->duty_percentage = DEFAULT_DUTY_CYCLE;
+    printf("successfully completed init\n");
+    return dev;
+}
+
+mraa_pwm_context
+mraa_pwm_init_raw(int chipid, int pin)
+{
+    return NULL;
+}
+
+mraa_result_t
+mraa_pwm_write(mraa_pwm_context dev, float percentage)
+{
+    if (percentage < 0.0) {
+        percentage = 0.0;
+    } else if (percentage > 1.0) {
+        percentage = 1.0;
+    }
+    dev->duty_percentage = percentage;
+
+#if defined(CONFIG_PWM_QMSI)
+    uint8_t pwm_duty_val = (uint8_t)(100 * percentage);
+    if (pwm_pin_set_duty_cycle(dev->zdev, dev->phy_pin, pwm_duty_val) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+#elif defined(CONFIG_PWM_DW)
+    uint32_t on_time = (uint32_t)(percentage * dev->period);
+    uint32_t off_time = dev->period - on_time;
+    if (pwm_pin_set_values(dev->zdev, dev->phy_pin, on_time, off_time) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+#endif
+    dev->duty_percentage = percentage;
+    return MRAA_SUCCESS;
+}
+
+float
+mraa_pwm_read(mraa_pwm_context dev)
+{
+    if (dev->duty_percentage > 1.0) {
+        return 1.0;
+    } else if (dev->duty_percentage < 0.0) {
+        return 0.0;
+    } else {
+        return dev->duty_percentage;
+    }
+}
+
+mraa_result_t
+mraa_pwm_period(mraa_pwm_context dev, float seconds)
+{
+    return mraa_pwm_period_ms(dev, seconds * 1000);
+}
+
+mraa_result_t
+mraa_pwm_period_ms(mraa_pwm_context dev, int ms)
+{
+    return mraa_pwm_period_us(dev, ms * 1000);
+}
+
+mraa_result_t
+mraa_pwm_period_us(mraa_pwm_context dev, int us)
+{
+    dev->period = 32 * us;
+#if defined(CONFIG_PWM_QMSI)
+/**
+ * the qmsi function deals in us so we don't need the
+ * number of cycles for this calculation.
+ * API CHANGES FROM 1.4 TO 1.5
+ */
+#if KERNELVERSION >= 0x1050000
+    if (pwm_pin_set_period(dev->zdev, dev->phy_pin, us) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+#endif
+#elif defined(CONFIG_PWM_DW)
+    // nothing to do as of now
+    // need to figure out if they put in a function for the
+    // dw driver
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+#endif
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_pwm_pulsewidth(mraa_pwm_context dev, float seconds)
+{
+    return mraa_pwm_pulsewidth_ms(dev, seconds * 1000);
+}
+
+mraa_result_t
+mraa_pwm_pulsewidth_ms(mraa_pwm_context dev, int ms)
+{
+    return mraa_pwm_pulsewidth_us(dev, ms * 1000);
+}
+
+mraa_result_t
+mraa_pwm_pulsewidth_us(mraa_pwm_context dev, int us)
+{
+    uint32_t on_time = 32 * us;
+    if (on_time > dev->period) {
+        // the pulsewidth cannot be greater than the period
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+// API CHANGES FROM 1.4 TO 1.5
+#if KERNELVERSION >= 0x1050000
+    int ret = pwm_pin_set_values(dev->zdev, dev->phy_pin, 0, on_time);
+#elif KERNELVERSION <= 0x1040000
+    int ret = pwm_pin_set_values(dev->zdev, dev->phy_pin, on_time, dev->period - on_time);
+#endif
+    if (ret != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_pwm_enable(mraa_pwm_context dev, int enable)
+{
+    /**
+     * this functionality is not supported by either qmsi
+     * or dw, however, it is used a lot by the upm drivers
+     * hence, returning success now, but need to come up with a
+     * proper solution
+     */
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_pwm_owner(mraa_pwm_context dev, mraa_boolean_t owner)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+mraa_result_t
+mraa_pwm_close(mraa_pwm_context dev)
+{
+    free(dev);
+    return MRAA_SUCCESS;
+}
+
+int
+mraa_pwm_get_max_period(mraa_pwm_context dev)
+{
+    return (int) dev->period;
+}
+
+int
+mraa_pwm_get_min_period(mraa_pwm_context dev)
+{
+    /**
+     * returning period for now, might need to add another field
+     * for min period
+     */
+    return (int) dev->period;
+}
diff --git a/ext/lib/mraa/source/spi.c b/ext/lib/mraa/source/spi.c
new file mode 100644
index 0000000..12e772b
--- /dev/null
+++ b/ext/lib/mraa/source/spi.c
@@ -0,0 +1,284 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Contributions: Abhishek Malik <abhishek.malik@intel.com>
+ *                Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <spi.h>
+#include <string.h>
+
+#include "mraa_internal.h"
+#include "mraa_internal_types.h"
+#include <device.h>
+#include <malloc.h>
+#include <pinmux.h>
+#include <sys_clock.h>
+#include <zephyr.h>
+
+#include "mraa/spi.h"
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT printf
+#else
+#include <misc/printk.h>
+#define PRINT printk
+#endif
+
+#define SPI_SLAVE 1
+
+#define SET_MODE_MASK 0xfffffffc
+
+// Arduino 101 has a 32 MHz clock
+// D2000 has a 32 MHz clock
+#if defined(CONFIG_BOARD_ARDUINO_101)
+#define SPI_DRV_NAME "SPI_1"
+#define SPI_MAX_CLK_FREQ_250KHZ 128
+#elif defined(CONFIG_BOARD_ARDUINO_101_SSS)
+#define SPI_DRV_NAME "SPI_1"
+#define SPI_MAX_CLK_FREQ_250KHZ 128
+#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
+#define SPI_DRV_NAME "SPI_0"
+#define SPI_MAX_CLK_FREQ_250KHZ 128
+#endif
+
+typedef struct spi_config* spi_config_ptr;
+
+mraa_spi_context
+mraa_spi_init(int bus)
+{
+    mraa_spi_context dev = (mraa_spi_context) malloc(sizeof(struct _spi));
+
+// SPI is available by default on the ARC core
+#if defined(CONFIG_BOARD_ARDUINO_101)
+    // pinmux configuring required here
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux\n");
+        free(dev);
+        return NULL;
+    }
+    pinmux_pin_set(pinmux_dev, 42, PINMUX_FUNC_B);
+    pinmux_pin_set(pinmux_dev, 43, PINMUX_FUNC_B);
+    pinmux_pin_set(pinmux_dev, 44, PINMUX_FUNC_B);
+    pinmux_pin_set(pinmux_dev, 45, PINMUX_FUNC_B);
+
+    dev->pinmux_dev = pinmux_dev;
+#endif
+
+    dev->busnum = bus;
+    dev->zdev = device_get_binding(SPI_DRV_NAME);
+    spi_config_ptr conf = (spi_config_ptr) malloc(sizeof(struct spi_config));
+    // only default settings, can be changed by using the other functions provided
+    conf->config = SPI_MODE_CPOL | SPI_MODE_CPHA | (8 << 4);
+    conf->max_sys_freq = SPI_MAX_CLK_FREQ_250KHZ;
+    dev->config = conf;
+
+    if (spi_configure(dev->zdev, dev->config) != 0) {
+        printf("Unable to configure the SPI Driver\n");
+        free(conf);
+        free(dev);
+        return NULL;
+    }
+
+    spi_slave_select(dev->zdev, SPI_SLAVE);
+
+    return dev;
+}
+
+mraa_result_t
+mraa_spi_mode(mraa_spi_context dev, mraa_spi_mode_t mode)
+{
+    switch (mode) {
+        case MRAA_SPI_MODE0:
+            dev->config->config = SET_MODE_MASK & dev->config->config;
+            break;
+        case MRAA_SPI_MODE1:
+            dev->config->config = (SET_MODE_MASK | SPI_MODE_CPHA) & dev->config->config;
+            break;
+        case MRAA_SPI_MODE2:
+            dev->config->config = (SET_MODE_MASK | SPI_MODE_CPOL) & dev->config->config;
+        case MRAA_SPI_MODE3:
+            dev->config->config = (SET_MODE_MASK | SPI_MODE_CPOL | SPI_MODE_CPHA) & dev->config->config;
+            break;
+        default:
+            dev->config->config = SET_MODE_MASK & dev->config->config;
+            break;
+    }
+    if (spi_configure(dev->zdev, dev->config) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_spi_frequency(mraa_spi_context dev, int hz)
+{
+    uint32_t freq = 0;
+    if (hz > 0) {
+        freq = sys_clock_hw_cycles_per_sec / hz;
+    } else {
+        return MRAA_ERROR_INVALID_PARAMETER;
+    }
+
+    dev->config->max_sys_freq = freq;
+    if (spi_configure(dev->zdev, dev->config) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_spi_lsbmode(mraa_spi_context dev, mraa_boolean_t lsb)
+{
+    if (lsb == 0) {
+        dev->config->config = (dev->config->config & ~(SPI_TRANSFER_MASK)) | SPI_TRANSFER_MSB;
+    } else {
+        dev->config->config = (dev->config->config & ~(SPI_TRANSFER_MASK)) | SPI_TRANSFER_LSB;
+    }
+    if (spi_configure(dev->zdev, dev->config) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
+int
+mraa_spi_write(mraa_spi_context dev, uint8_t data)
+{
+    // assuming that the data read back is in the same format
+    // as the data being sent in and also of the same length
+    int ret;
+    uint8_t ret_data;
+    // in case nothing is being read back, sending in NULL would be a
+    // good idea, otherwise the SPI bus will probably hang and block
+    // further execution of code.
+    ret = spi_transceive(dev->zdev, &data, 1, &ret_data, 1);
+    if (ret == 0) {
+        return ret_data;
+    }
+
+    return -1;
+}
+
+int
+mraa_spi_write_word(mraa_spi_context dev, uint16_t data)
+{
+    // setting the number of bits per packet to 16
+    if (mraa_spi_bit_per_word(dev, 16) != MRAA_SUCCESS) {
+        return -1;
+    }
+
+    uint16_t ret_data;
+    int ret;
+    ret = spi_transceive(dev->zdev, &data, 1, &ret_data, 1);
+
+    // setting the number of packets back to 8
+    if (mraa_spi_bit_per_word(dev, 8) != MRAA_SUCCESS) {
+        return -1;
+    }
+
+    if (ret == 0) {
+        return ret_data;
+    }
+
+    return -1;
+}
+
+uint8_t*
+mraa_spi_write_buf(mraa_spi_context dev, uint8_t* data, int length)
+{
+    // Since this is a write function only the return will be NULL
+    int ret;
+    ret = spi_transceive(dev->zdev, data, length, NULL, 0);
+
+    return NULL;
+}
+
+uint16_t*
+mraa_spi_write_buf_word(mraa_spi_context dev, uint16_t* data, int length)
+{
+    // setting number of bits per packet to 16
+    if (mraa_spi_bit_per_word(dev, 16) != MRAA_SUCCESS) {
+        return NULL;
+    }
+    // might/might not use this
+    // uint16_t* recv = malloc(sizeof(uint16_t) * length);
+    int ret;
+    ret = spi_transceive(dev->zdev, data, length, NULL, 0);
+
+    // setting the number of packets back to 8
+    if (mraa_spi_bit_per_word(dev, 8) != MRAA_SUCCESS) {
+        return NULL;
+    }
+
+    return NULL;
+}
+
+mraa_result_t
+mraa_spi_bit_per_word(mraa_spi_context dev, unsigned int bits)
+{
+    dev->config->config = (~(SPI_WORD_SIZE_MASK) &dev->config->config) | (bits << 4);
+    if (spi_configure(dev->zdev, dev->config) != 0) {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
+mraa_result_t
+mraa_spi_transfer_buf(mraa_spi_context dev, uint8_t* data, uint8_t* rxbuf, int length)
+{
+    mraa_result_t ret;
+    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
+
+    return ret;
+}
+
+mraa_result_t
+mraa_spi_transfer_buf_word(mraa_spi_context dev, uint16_t* data, uint16_t* rxbuf, int length)
+{
+    // setting number of bits per packet to 16
+    if (mraa_spi_bit_per_word(dev, 16) != MRAA_SUCCESS) {
+        return -1;
+    }
+
+    mraa_result_t ret;
+    ret = spi_transceive(dev->zdev, data, length, rxbuf, length);
+
+    // setting the number of packets back to 8
+    if (mraa_spi_bit_per_word(dev, 8) != MRAA_SUCCESS) {
+        return -1;
+    }
+
+    return ret;
+}
+
+mraa_result_t
+mraa_spi_stop(mraa_spi_context dev)
+{
+    free(dev);
+    return MRAA_SUCCESS;
+}
diff --git a/ext/lib/mraa/source/uart.c b/ext/lib/mraa/source/uart.c
new file mode 100644
index 0000000..89db72b
--- /dev/null
+++ b/ext/lib/mraa/source/uart.c
@@ -0,0 +1,205 @@
+/*
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Contributions: Jon Trulson <jtrulson@ics.com>
+ *                Brendan le Foll <brendan.le.foll@intel.com>
+ *                Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 - 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "mraa_internal.h"
+#include "mraa_internal_types.h"
+#include "version.h"
+#include <device.h>
+#include <pinmux.h>
+#include <string.h>
+#include <sys_clock.h>
+#include <uart.h>
+#include <zephyr.h>
+
+#include "mraa/uart.h"
+
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS) || defined(CONFIG_BOARD_ARDUINO_101)
+#define UART_DEVICE "UART_1"
+#elif defined(CONFIG_BOARD_QUARK_D2000_CRB)
+#define UART_DEVICE "UART_0"
+#endif
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT printf
+#else
+#include <misc/printk.h>
+#define PRINT printk
+#endif
+
+mraa_uart_context
+mraa_uart_init(int uart)
+{
+
+    mraa_board_t* board = plat;
+
+    if (board == NULL) {
+        printf("uart: platform not initialised\n");
+        return NULL;
+    }
+
+    struct device* pinmux_dev = device_get_binding(CONFIG_PINMUX_DEV_NAME);
+    if (pinmux_dev == NULL) {
+        printf("Failed to get binding for pinmux\n");
+        return NULL;
+    }
+
+#if defined(CONFIG_BOARD_ARDUINO_101_SSS) || defined(CONFIG_BOARD_ARDUINO_101)
+    if (uart == 0) {
+        pinmux_pin_set(pinmux_dev, 17, PINMUX_FUNC_C);
+        pinmux_pin_set(pinmux_dev, 16, PINMUX_FUNC_C);
+        mraa_set_pininfo(board, 0, 17, "IO0", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 1 });
+        mraa_set_pininfo(board, 1, 16, "IO1", (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 1, 1 });
+    }
+#endif
+
+    mraa_uart_context dev = (mraa_uart_context) malloc(sizeof(struct _uart));
+    dev->zdev = device_get_binding(UART_DEVICE);
+    dev->block = 1;
+
+    return dev;
+}
+
+mraa_uart_context
+mraa_uart_init_raw(const char* path)
+{
+    return NULL;
+}
+
+int
+mraa_uart_write(mraa_uart_context dev, const char* buf, size_t length)
+{
+    // this isn't the expected implementation, it should be length
+    // instead of length+1. However, the output gets completely
+    // screwed up with the actual length. Need to look into this
+    // to find RC and fix. Current implementation works though.
+    unsigned char ret[length + 1];
+    unsigned char temp;
+    int i = 0;
+    for (i = 0; i < length + 1; i++) {
+        temp = buf[i];
+        ret[i] = uart_poll_out(dev->zdev, temp);
+        if (ret[i] != temp) {
+            return i;
+        }
+    }
+
+    return length;
+}
+
+mraa_result_t
+mraa_uart_get_dev_path(mraa_uart_context dev)
+{
+    return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+}
+
+// you have to set the uart line control flag in the config file
+// to be able to use this function
+mraa_result_t
+mraa_uart_set_baudrate(mraa_uart_context dev, unsigned int baud)
+{
+#if KERNELVERSION >= 0x1050000
+    int ret = uart_line_ctrl_set(dev->zdev, LINE_CTRL_BAUD_RATE, baud);
+    if (ret == 0) {
+        return MRAA_SUCCESS;
+    } else {
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+#else
+    return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
+#endif
+}
+
+// to be set from config file for now, maybe in the future if the line control
+// implements this functionality, then this can be implemented
+mraa_result_t
+mraa_uart_set_flowcontrol(mraa_uart_context dev, mraa_boolean_t xonxoff, mraa_boolean_t rtscts)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+int
+mraa_uart_read(mraa_uart_context dev, char* buf, size_t length)
+{
+    unsigned char store;
+    int ret, i = 0;
+    for (i = 0; i < length; i++) {
+        ret = uart_poll_in(dev->zdev, &store);
+        if (ret == -1) {
+            return i;
+        } else if (ret == 0) {
+            buf[i] = store;
+        } else {
+            return i;
+        }
+    }
+
+    return length;
+}
+
+// currently not implemented/ to be implemented once there is more clarity about zephyr API
+mraa_result_t
+mraa_uart_flush(mraa_uart_context dev)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+// this can possibly be set from the uart_qmsi_init fn, however
+// there is no direct access to the fn, hence this feature might have to wait
+mraa_result_t
+mraa_uart_set_mode(mraa_uart_context dev, int bytesize, mraa_uart_parity_t parity, int stopbits)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+// need to check the irq part
+mraa_result_t
+mraa_uart_set_timeout(mraa_uart_context dev, int read, int write, int interchar)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+// couldn't find any implementation in zephyr
+mraa_result_t
+mraa_uart_set_non_blocking(mraa_uart_context dev, mraa_boolean_t nonblock)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
+
+mraa_result_t
+mraa_uart_stop(mraa_uart_context dev)
+{
+    free(dev);
+    return MRAA_SUCCESS;
+}
+
+// need to check the irq functions
+mraa_boolean_t
+mraa_uart_data_available(mraa_uart_context dev, unsigned int millis)
+{
+    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+}
diff --git a/ext/lib/upm/Kbuild b/ext/lib/upm/Kbuild
new file mode 100644
index 0000000..488ff72
--- /dev/null
+++ b/ext/lib/upm/Kbuild
@@ -0,0 +1,61 @@
+# UPM Kbuild configuration
+obj-$(CONFIG_UPM_a110x) += src/a110x/
+obj-$(CONFIG_UPM_ad8232) += src/ad8232/
+obj-$(CONFIG_UPM_apa102) += src/apa102/
+obj-$(CONFIG_UPM_bh1750) += src/bh1750/
+obj-$(CONFIG_UPM_collision) += src/collision/
+obj-$(CONFIG_UPM_dfrorp) += src/dfrorp/
+obj-$(CONFIG_UPM_dfrph) += src/dfrph/
+obj-$(CONFIG_UPM_emg) += src/emg/
+obj-$(CONFIG_UPM_flex) += src/flex/
+obj-$(CONFIG_UPM_gas) += src/gas/
+obj-$(CONFIG_UPM_gp2y0a) += src/gp2y0a/
+obj-$(CONFIG_UPM_gsr) += src/gsr/
+obj-$(CONFIG_UPM_hka5) += src/hka5/
+obj-$(CONFIG_UPM_joystick12) += src/joystick12/
+obj-$(CONFIG_UPM_ldt0028) += src/ldt0028/
+obj-$(CONFIG_UPM_led) += src/led/
+obj-$(CONFIG_UPM_light) += src/light/
+obj-$(CONFIG_UPM_loudness) += src/loudness/
+obj-$(CONFIG_UPM_m24lr64e) += src/m24lr64e/
+obj-$(CONFIG_UPM_mic) += src/mic/
+obj-$(CONFIG_UPM_mma7361) += src/mma7361/
+obj-$(CONFIG_UPM_moisture) += src/moisture/
+obj-$(CONFIG_UPM_mpr121) += src/mpr121/
+obj-$(CONFIG_UPM_mq303a) += src/mq303a/
+obj-$(CONFIG_UPM_nmea_gps) += src/nmea_gps/
+obj-$(CONFIG_UPM_o2) += src/o2/
+obj-$(CONFIG_UPM_relay) += src/relay/
+obj-$(CONFIG_UPM_rotary) += src/rotary/
+obj-$(CONFIG_UPM_servo) += src/servo/
+obj-$(CONFIG_UPM_sht1x) += src/sht1x/
+obj-$(CONFIG_UPM_slide) += src/slide/
+obj-$(CONFIG_UPM_temperature) += src/temperature/
+obj-$(CONFIG_UPM_tsl2561) += src/tsl2561/
+obj-$(CONFIG_UPM_ttp223) += src/ttp223/
+obj-$(CONFIG_UPM_urm37) += src/urm37/
+obj-$(CONFIG_UPM_utilities) += src/utilities/
+obj-$(CONFIG_UPM_vdiv) += src/vdiv/
+obj-$(CONFIG_UPM_water) += src/water/
+obj-$(CONFIG_UPM_yg1006) += src/yg1006/
+obj-$(CONFIG_UPM_biss0001) += src/biss0001/
+obj-$(CONFIG_UPM_bmi160) += src/bmi160/
+obj-$(CONFIG_UPM_lcm1602) += src/lcm1602/
+obj-$(CONFIG_UPM_jhd1313m1) += src/jhd1313m1/
+obj-$(CONFIG_UPM_lm35) += src/lm35/
+obj-$(CONFIG_UPM_rotaryencoder) += src/rotaryencoder/
+obj-$(CONFIG_UPM_rpr220) += src/rpr220/
+obj-$(CONFIG_UPM_md) += src/md/
+obj-$(CONFIG_UPM_linefinder) += src/linefinder/
+obj-$(CONFIG_UPM_uln200xa) += src/uln200xa/
+obj-$(CONFIG_UPM_mma7660) += src/mma7660/
+obj-$(CONFIG_UPM_buzzer) += src/buzzer/
+obj-$(CONFIG_UPM_ppd42ns) += src/ppd42ns/
+obj-$(CONFIG_UPM_guvas12d) += src/guvas12d/
+obj-$(CONFIG_UPM_otp538u) += src/otp538u/
+obj-$(CONFIG_UPM_my9221) += src/my9221/
+obj-$(CONFIG_UPM_ms5803) += src/ms5803/
+obj-$(CONFIG_UPM_ims) += src/ims/
+obj-$(CONFIG_UPM_ecezo) += src/ecezo/
+obj-$(CONFIG_UPM_button) += src/button/
+obj-$(CONFIG_UPM_mb704x) += src/mb704x/
diff --git a/ext/lib/upm/Kconfig b/ext/lib/upm/Kconfig
new file mode 100644
index 0000000..ba563e4
--- /dev/null
+++ b/ext/lib/upm/Kconfig
@@ -0,0 +1,70 @@
+menu "UPM"
+config UPM
+    bool
+    prompt "UPM Support"
+    select NEWLIB_LIBC
+    default n
+    help
+        This option enables the UPM sensor libraries
+
+source "ext/lib/upm/src/a110x/Kconfig"
+source "ext/lib/upm/src/ad8232/Kconfig"
+source "ext/lib/upm/src/apa102/Kconfig"
+source "ext/lib/upm/src/bh1750/Kconfig"
+source "ext/lib/upm/src/collision/Kconfig"
+source "ext/lib/upm/src/dfrorp/Kconfig"
+source "ext/lib/upm/src/dfrph/Kconfig"
+source "ext/lib/upm/src/emg/Kconfig"
+source "ext/lib/upm/src/flex/Kconfig"
+source "ext/lib/upm/src/gas/Kconfig"
+source "ext/lib/upm/src/gp2y0a/Kconfig"
+source "ext/lib/upm/src/gsr/Kconfig"
+source "ext/lib/upm/src/hka5/Kconfig"
+source "ext/lib/upm/src/joystick12/Kconfig"
+source "ext/lib/upm/src/ldt0028/Kconfig"
+source "ext/lib/upm/src/led/Kconfig"
+source "ext/lib/upm/src/light/Kconfig"
+source "ext/lib/upm/src/loudness/Kconfig"
+source "ext/lib/upm/src/m24lr64e/Kconfig"
+source "ext/lib/upm/src/mic/Kconfig"
+source "ext/lib/upm/src/mma7361/Kconfig"
+source "ext/lib/upm/src/moisture/Kconfig"
+source "ext/lib/upm/src/mpr121/Kconfig"
+source "ext/lib/upm/src/mq303a/Kconfig"
+source "ext/lib/upm/src/nmea_gps/Kconfig"
+source "ext/lib/upm/src/o2/Kconfig"
+source "ext/lib/upm/src/relay/Kconfig"
+source "ext/lib/upm/src/rotary/Kconfig"
+source "ext/lib/upm/src/servo/Kconfig"
+source "ext/lib/upm/src/sht1x/Kconfig"
+source "ext/lib/upm/src/slide/Kconfig"
+source "ext/lib/upm/src/temperature/Kconfig"
+source "ext/lib/upm/src/tsl2561/Kconfig"
+source "ext/lib/upm/src/ttp223/Kconfig"
+source "ext/lib/upm/src/urm37/Kconfig"
+source "ext/lib/upm/src/utilities/Kconfig"
+source "ext/lib/upm/src/vdiv/Kconfig"
+source "ext/lib/upm/src/water/Kconfig"
+source "ext/lib/upm/src/yg1006/Kconfig"
+source "ext/lib/upm/src/biss0001/Kconfig"
+source "ext/lib/upm/src/bmi160/Kconfig"
+source "ext/lib/upm/src/lcm1602/Kconfig"
+source "ext/lib/upm/src/jhd1313m1/Kconfig"
+source "ext/lib/upm/src/lm35/Kconfig"
+source "ext/lib/upm/src/rotaryencoder/Kconfig"
+source "ext/lib/upm/src/rpr220/Kconfig"
+source "ext/lib/upm/src/md/Kconfig"
+source "ext/lib/upm/src/linefinder/Kconfig"
+source "ext/lib/upm/src/uln200xa/Kconfig"
+source "ext/lib/upm/src/mma7660/Kconfig"
+source "ext/lib/upm/src/buzzer/Kconfig"
+source "ext/lib/upm/src/ppd42ns/Kconfig"
+source "ext/lib/upm/src/guvas12d/Kconfig"
+source "ext/lib/upm/src/otp538u/Kconfig"
+source "ext/lib/upm/src/my9221/Kconfig"
+source "ext/lib/upm/src/ms5803/Kconfig"
+source "ext/lib/upm/src/ims/Kconfig"
+source "ext/lib/upm/src/ecezo/Kconfig"
+source "ext/lib/upm/src/button/Kconfig"
+source "ext/lib/upm/src/mb704x/Kconfig"
+endmenu
diff --git a/ext/lib/upm/Makefile b/ext/lib/upm/Makefile
new file mode 100644
index 0000000..71bbdb2
--- /dev/null
+++ b/ext/lib/upm/Makefile
@@ -0,0 +1,64 @@
+# UPM top-level Makefile
+ifdef CONFIG_UPM
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/include
+endif
+include $(srctree)/ext/lib/upm/src/a110x/Makefile
+include $(srctree)/ext/lib/upm/src/ad8232/Makefile
+include $(srctree)/ext/lib/upm/src/apa102/Makefile
+include $(srctree)/ext/lib/upm/src/bh1750/Makefile
+include $(srctree)/ext/lib/upm/src/collision/Makefile
+include $(srctree)/ext/lib/upm/src/dfrorp/Makefile
+include $(srctree)/ext/lib/upm/src/dfrph/Makefile
+include $(srctree)/ext/lib/upm/src/emg/Makefile
+include $(srctree)/ext/lib/upm/src/flex/Makefile
+include $(srctree)/ext/lib/upm/src/gas/Makefile
+include $(srctree)/ext/lib/upm/src/gp2y0a/Makefile
+include $(srctree)/ext/lib/upm/src/gsr/Makefile
+include $(srctree)/ext/lib/upm/src/hka5/Makefile
+include $(srctree)/ext/lib/upm/src/joystick12/Makefile
+include $(srctree)/ext/lib/upm/src/ldt0028/Makefile
+include $(srctree)/ext/lib/upm/src/led/Makefile
+include $(srctree)/ext/lib/upm/src/light/Makefile
+include $(srctree)/ext/lib/upm/src/loudness/Makefile
+include $(srctree)/ext/lib/upm/src/m24lr64e/Makefile
+include $(srctree)/ext/lib/upm/src/mic/Makefile
+include $(srctree)/ext/lib/upm/src/mma7361/Makefile
+include $(srctree)/ext/lib/upm/src/moisture/Makefile
+include $(srctree)/ext/lib/upm/src/mpr121/Makefile
+include $(srctree)/ext/lib/upm/src/mq303a/Makefile
+include $(srctree)/ext/lib/upm/src/nmea_gps/Makefile
+include $(srctree)/ext/lib/upm/src/o2/Makefile
+include $(srctree)/ext/lib/upm/src/relay/Makefile
+include $(srctree)/ext/lib/upm/src/rotary/Makefile
+include $(srctree)/ext/lib/upm/src/servo/Makefile
+include $(srctree)/ext/lib/upm/src/sht1x/Makefile
+include $(srctree)/ext/lib/upm/src/slide/Makefile
+include $(srctree)/ext/lib/upm/src/temperature/Makefile
+include $(srctree)/ext/lib/upm/src/tsl2561/Makefile
+include $(srctree)/ext/lib/upm/src/ttp223/Makefile
+include $(srctree)/ext/lib/upm/src/urm37/Makefile
+include $(srctree)/ext/lib/upm/src/utilities/Makefile
+include $(srctree)/ext/lib/upm/src/vdiv/Makefile
+include $(srctree)/ext/lib/upm/src/water/Makefile
+include $(srctree)/ext/lib/upm/src/yg1006/Makefile
+include $(srctree)/ext/lib/upm/src/biss0001/Makefile
+include $(srctree)/ext/lib/upm/src/bmi160/Makefile
+include $(srctree)/ext/lib/upm/src/lcm1602/Makefile
+include $(srctree)/ext/lib/upm/src/jhd1313m1/Makefile
+include $(srctree)/ext/lib/upm/src/lm35/Makefile
+include $(srctree)/ext/lib/upm/src/rotaryencoder/Makefile
+include $(srctree)/ext/lib/upm/src/rpr220/Makefile
+include $(srctree)/ext/lib/upm/src/md/Makefile
+include $(srctree)/ext/lib/upm/src/linefinder/Makefile
+include $(srctree)/ext/lib/upm/src/uln200xa/Makefile
+include $(srctree)/ext/lib/upm/src/mma7660/Makefile
+include $(srctree)/ext/lib/upm/src/buzzer/Makefile
+include $(srctree)/ext/lib/upm/src/ppd42ns/Makefile
+include $(srctree)/ext/lib/upm/src/guvas12d/Makefile
+include $(srctree)/ext/lib/upm/src/otp538u/Makefile
+include $(srctree)/ext/lib/upm/src/my9221/Makefile
+include $(srctree)/ext/lib/upm/src/ms5803/Makefile
+include $(srctree)/ext/lib/upm/src/ims/Makefile
+include $(srctree)/ext/lib/upm/src/ecezo/Makefile
+include $(srctree)/ext/lib/upm/src/button/Makefile
+include $(srctree)/ext/lib/upm/src/mb704x/Makefile
diff --git a/ext/lib/upm/README.md b/ext/lib/upm/README.md
new file mode 100644
index 0000000..8f8f9d1
--- /dev/null
+++ b/ext/lib/upm/README.md
@@ -0,0 +1,87 @@
+## Synopsis
+
+ZUPM is a UPM C source repo for use with the [Zephyr Project](http://zephyrproject.org).
+
+## Requirements
+
+- [Zephyr Project](https://gerrit.zephyrproject.org)
+- [ZMRAA](https://github.com/intel-iot-devkit/zmraa)
+
+## Zephyr Target Versions
+
+- Zephyr v1.6.0 - [ZUPM version v1.6.0 - Complete](https://github.com/intel-iot-devkit/zupm/tree/master)
+- Zephyr v1.5.0 - [ZUPM version v1.5.0 - Complete](https://github.com/intel-iot-devkit/upm/tree/v1.5.0)
+
+## Installation
+
+### Method 1 (clone from zephyr/zmraa/zupm and patch)
+
+#### Clone Zephyr (requires Zephyr SDK)
+```sh
+git clone https://gerrit.zephyrproject.org/r/zephyr && cd zephyr && git checkout tags/v1.6.0-rc3
+
+export ZEPHYR_GCC_VARIANT=zephyr
+export ZEPHYR_SDK_INSTALL_DIR=<path to your sdk installation directory>
+
+source zephyr-env.sh
+```
+
+#### Clone ZMRAA
+```sh
+git clone https://github.com/intel-iot-devkit/zmraa.git $ZEPHYR_BASE/ext/lib/mraa
+```
+
+#### Clone ZUPM
+```sh
+git clone https://github.com/intel-iot-devkit/zupm.git $ZEPHYR_BASE/ext/lib/upm
+```
+
+#### Setup Kbuild to include MRAA and UPM, link UPM examples to Zephry samples
+```sh
+cd $ZEPHYR_BASE
+patch -p1 < $ZEPHYR_BASE/ext/lib/upm/zupm_2_zephyr.patch
+ln -s $ZEPHYR_BASE/ext/lib/upm/samples/upm $ZEPHYR_BASE/samples/
+```
+
+### Method 2 (clone zephyr, patch to create zmraa and zupm)
+
+#### Clone Zephyr (currently 1.6.0-rc3)
+```sh
+git clone https://gerrit.zephyrproject.org/r/zephyr zephyr_1.6.0-rc3 && cd zephyr_1.6.0-rc3 && git checkout tags/v1.6.0-rc3
+```
+
+#### Clone ZUPM and apply patch
+```sh
+git clone https://github.com/intel-iot-devkit/zupm.git
+patch -p1 < zupm/add_mraa_upm_to_zephyr-1.6.0-rc3.patch
+```
+
+## Code Example
+
+#### AIO:
+```sh
+# DFRobot pH Sensor
+cd $ZEPHYR_BASE/samples/upm/dfrph
+make BOARD=arduino_101_sss
+```
+
+#### GPIO:
+```sh
+# Onboard LED (pin 13)
+cd $ZEPHYR_BASE/samples/upm/led
+make BOARD=arduino_101
+```
+
+#### SPI:
+```sh
+# Onboard Accel, Gyro, Magno
+cd $ZEPHYR_BASE/samples/upm/bmi160
+make BOARD=arduino_101_sss
+```
+
+#### I2C:
+```sh
+# LCD display
+cd $ZEPHYR_BASE/samples/upm/jhd1313m1
+make BOARD=arduino_101_sss
+```
diff --git a/ext/lib/upm/include/upm.h b/ext/lib/upm/include/upm.h
new file mode 100644
index 0000000..f5f49c5
--- /dev/null
+++ b/ext/lib/upm/include/upm.h
@@ -0,0 +1,45 @@
+/*
+ * Authors:
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef UPM_H_
+#define UPM_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if __STDC_VERSION__ >= 199901L
+#define C99
+#endif
+
+#include <upm_types.h>
+#include <upm_math.h>
+#include <upm_utilities.h>
+
+#define upm_perror(...) perror(args, __VA_ARGS__)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* UPM_H_ */
diff --git a/ext/lib/upm/include/upm_internal.h b/ext/lib/upm/include/upm_internal.h
new file mode 100644
index 0000000..ee99d28
--- /dev/null
+++ b/ext/lib/upm/include/upm_internal.h
@@ -0,0 +1,27 @@
+/*
+ * Authors:
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef UPM_INTERNAL_H_
+#define UPM_INTERNAL_H_
+
+#endif /* UPM_INTERNAL_H_ */
diff --git a/ext/lib/upm/include/upm_math.h b/ext/lib/upm/include/upm_math.h
new file mode 100644
index 0000000..7b8122b
--- /dev/null
+++ b/ext/lib/upm/include/upm_math.h
@@ -0,0 +1,46 @@
+/*
+ * Authors:
+ *          Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef UPM_MATH_H_
+#define UPM_MATH_H_
+
+#include <upm_platform.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(UPM_PLATFORM_LINUX) || defined(UPM_PLATFORM_ZEPHYR)
+#include <math.h>
+#endif
+
+#ifndef M_PI
+#define M_PI           (3.14159265358979323846)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* UPM_MATH_H_ */
diff --git a/ext/lib/upm/include/upm_platform.h b/ext/lib/upm/include/upm_platform.h
new file mode 100644
index 0000000..f68da5c
--- /dev/null
+++ b/ext/lib/upm/include/upm_platform.h
@@ -0,0 +1,46 @@
+/*
+ * Authors: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef UPM_PLATFORM_H_
+#define UPM_PLATFORM_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(linux)
+# define UPM_PLATFORM_LINUX (1)
+#elif defined(CONFIG_BOARD_ARDUINO_101) || \
+    defined(CONFIG_BOARD_ARDUINO_101_SSS) || \
+    defined(CONFIG_BOARD_QUARK_D2000_CRB)
+# define UPM_PLATFORM_ZEPHYR (1)
+#else
+# error "UPM: Unknown Platform!"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* UPM_PLATFORM_H_ */
diff --git a/ext/lib/upm/include/upm_types.h b/ext/lib/upm/include/upm_types.h
new file mode 100644
index 0000000..ecb9b16
--- /dev/null
+++ b/ext/lib/upm/include/upm_types.h
@@ -0,0 +1,60 @@
+/*
+ * Authors:
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef UPM_TYPES_H_
+#define UPM_TYPES_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef C99
+#include <stdbool.h>
+#elif __cplusplus
+#else
+typedef enum {
+    false = 0,
+    true = 1
+} bool;
+#endif
+
+typedef enum {
+    UPM_SUCCESS = 0,                        /* Operation is successful, expected response */
+    UPM_ERROR_NOT_IMPLEMENTED = 1,          /* Trying to access a feature or mode that is not implemented */
+    UPM_ERROR_NOT_SUPPORTED = 2,            /* Trying to access a feature or mode that is not supported */
+    UPM_ERROR_NO_RESOURCES = 3,             /* No resources to perform operation */
+    UPM_ERROR_NO_DATA = 4,                  /* No data received or available from the sensor */
+    UPM_ERROR_INVALID_PARAMETER = 5,        /* Invalid parameter passed to the function*/
+    UPM_ERROR_INVALID_SIZE = 6,             /* Invalid buffer size */
+    UPM_ERROR_OUT_OF_RANGE = 7,             /* When the input to drive is too high/low or -ve */
+    UPM_ERROR_OPERATION_FAILED = 8,         /* When a function isn't able to perform as expected */
+    UPM_ERROR_TIMED_OUT = 9,                /* Timed out while communicating with the sensor */
+
+    UPM_ERROR_UNSPECIFIED = 99              /* Unspecified/Unknown error */
+} upm_result_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* UPM_TYPES_H_ */
diff --git a/ext/lib/upm/src/a110x/Kbuild b/ext/lib/upm/src/a110x/Kbuild
new file mode 100644
index 0000000..8b4d46e
--- /dev/null
+++ b/ext/lib/upm/src/a110x/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_a110x) += a110x.o
diff --git a/ext/lib/upm/src/a110x/Kconfig b/ext/lib/upm/src/a110x/Kconfig
new file mode 100644
index 0000000..cce1925
--- /dev/null
+++ b/ext/lib/upm/src/a110x/Kconfig
@@ -0,0 +1,9 @@
+config UPM_a110x
+    bool "a110x"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm a110x sensor module
+
diff --git a/ext/lib/upm/src/a110x/Makefile b/ext/lib/upm/src/a110x/Makefile
new file mode 100644
index 0000000..cd845d3
--- /dev/null
+++ b/ext/lib/upm/src/a110x/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_a110x
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/a110x
+endif
diff --git a/ext/lib/upm/src/a110x/a110x.c b/ext/lib/upm/src/a110x/a110x.c
new file mode 100644
index 0000000..9f492b6
--- /dev/null
+++ b/ext/lib/upm/src/a110x/a110x.c
@@ -0,0 +1,74 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "a110x.h"
+
+a110x_context a110x_init(uint8_t pin){
+    a110x_context dev =
+      (a110x_context) malloc(sizeof(struct _a110x_context));
+
+    if (!dev)
+      {
+        return NULL;
+      }
+
+    dev->gpio_pin = pin;
+    dev->gpio = mraa_gpio_init(dev->gpio_pin);
+    if (mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN) != MRAA_SUCCESS){
+        free(dev);
+        return NULL;
+    }
+    dev->isr_installed = false;
+    return dev;
+}
+
+void a110x_close(a110x_context dev){
+    free(dev);
+}
+
+upm_result_t a110x_magnet_detected(a110x_context dev, bool* res){
+    int val = mraa_gpio_read(dev->gpio);
+    if (val == 0)
+        *res = false;
+    else
+        *res = true;
+    return UPM_SUCCESS;
+}
+
+upm_result_t a110x_install_isr(a110x_context dev,
+                               mraa_gpio_edge_t edge_level,
+                               void (*isr)(void *), void *arg){
+    if (dev->isr_installed)
+        a110x_uninstall_isr(dev);
+
+    mraa_gpio_isr(dev->gpio, edge_level, isr, arg);
+    dev->isr_installed = true;
+    return UPM_SUCCESS;
+}
+
+upm_result_t a110x_uninstall_isr(a110x_context dev){
+    mraa_gpio_isr_exit(dev->gpio);
+    dev->isr_installed = false;
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/a110x/a110x.h b/ext/lib/upm/src/a110x/a110x.h
new file mode 100644
index 0000000..bc27e9f
--- /dev/null
+++ b/ext/lib/upm/src/a110x/a110x.h
@@ -0,0 +1,120 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef A110X_A110X_H_
+#define A110X_A110X_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "upm.h"
+#include "mraa/gpio.h"
+
+/**
+ * @brief A110X Hall Effect library
+ * @defgroup a110x libupm-a110x
+ * @ingroup gpio electric robok
+ */
+
+/**
+ * @library a110x
+ * @sensor a110x
+ * @comname A110X Hall Effect Sensor
+ * @altname Grove Hall Sensor
+ * @altid A1101, A1102, A1103, A1004, A1106
+ * @type electric
+ * @web http://www.allegromicro.com/en/Products/Magnetic-Digital-Position-Sensor-ICs/Hall-Effect-Unipolar-Switches/A1101-2-3-4-6.aspx
+ * @con gpio
+ * @kit robok
+ *
+ * @brief API for the A110X Hall Effect sensors
+ *
+ * UPM module for the A110X (A1101, A1102, A1103, A1104, and A1106)
+ * Hall Effect sensors.  It outputs a digital signal indicating
+ * whether it is detecting a magnetic field with south polarity
+ * perpendicular to the sensor element.
+ *
+ * @image html a110x.jpg
+ * An example showing a simple test for the presence of a field
+ * @snippet a110x.cxx Interesting
+ * An example demonstrating the use of an interrupt handler to count pulses
+ * @snippet a110x-intr.cxx Interesting
+ */
+
+/**
+ * device context
+ */
+typedef struct _a110x_context {
+    mraa_gpio_context      gpio;
+    uint8_t                gpio_pin;
+    bool                   isr_installed;
+} *a110x_context;
+
+/**
+ * A110X Initialization function
+ *
+ * @param pin GPIO pin to use
+ * @return device context pointer
+ */
+a110x_context a110x_init(uint8_t pin);
+
+/**
+ * A110X Initialization function
+ *
+ * @param dev a110x_context pointer
+ */
+void a110x_close(a110x_context dev);
+
+/**
+ * Determines whether a magnetic field of south polarity has been detected
+ *
+ * @param dev a110x_context pointer
+ * @param bool* to note the response
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t a110x_magnet_detected(a110x_context dev, bool* res);
+
+/**
+ * Installs an interrupt service routine (ISR) to be called when
+ * the appropriate magnetic field is detected
+ *
+ * @param dev a110x_context pointer
+ * @param mraa_gpio_edge_t edge trigger level
+ * @param isr ISR callback function
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t a110x_install_isr(a110x_context dev,
+                               mraa_gpio_edge_t edge_level,
+                               void (*isr)(void *), void *arg);
+
+/**
+ * Uninstalls the previously installed ISR
+ *
+ * @param dev a110x_context pointer
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t a110x_uninstall_isr(a110x_context dev);
+
+#endif /* A110X_A110X_H_ */
diff --git a/ext/lib/upm/src/ad8232/Kbuild b/ext/lib/upm/src/ad8232/Kbuild
new file mode 100644
index 0000000..1a31976
--- /dev/null
+++ b/ext/lib/upm/src/ad8232/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ad8232) += ad8232.o
diff --git a/ext/lib/upm/src/ad8232/Kconfig b/ext/lib/upm/src/ad8232/Kconfig
new file mode 100644
index 0000000..68fdeb7
--- /dev/null
+++ b/ext/lib/upm/src/ad8232/Kconfig
@@ -0,0 +1,9 @@
+config UPM_ad8232
+    bool "ad8232"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm ad8232sensor module
+
diff --git a/ext/lib/upm/src/ad8232/Makefile b/ext/lib/upm/src/ad8232/Makefile
new file mode 100644
index 0000000..8d3df71
--- /dev/null
+++ b/ext/lib/upm/src/ad8232/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ad8232
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ad8232
+endif
diff --git a/ext/lib/upm/src/ad8232/ad8232.c b/ext/lib/upm/src/ad8232/ad8232.c
new file mode 100644
index 0000000..02a4fb1
--- /dev/null
+++ b/ext/lib/upm/src/ad8232/ad8232.c
@@ -0,0 +1,87 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "ad8232.h"
+
+ad8232_context ad8232_init(int lo_plus, int lo_minus, int output,
+                           float a_ref) {
+    ad8232_context dev =
+      (ad8232_context) malloc(sizeof(struct _ad8232_context));
+
+    if(dev == NULL){
+        printf("Unable to assign memory to the Heart Rate Monitor structure");
+        return NULL;
+    }
+
+    dev->gpio_lo_plus_pin = lo_plus;
+    dev->gpio_lo_minus_pin = lo_minus;
+    dev->aio_pin = output;
+
+    dev->aio = mraa_aio_init(dev->aio_pin);
+    dev->gpio_lo_plus = mraa_gpio_init(dev->gpio_lo_plus_pin);
+    dev->gpio_lo_minus = mraa_gpio_init(dev->gpio_lo_minus_pin);
+
+    if (dev->aio == NULL || dev->gpio_lo_minus == NULL ||
+        dev->gpio_lo_plus == NULL){
+        printf("The pins did not initialize correctly");
+        return NULL;
+    }
+
+    if (mraa_gpio_dir(dev->gpio_lo_minus, MRAA_GPIO_IN) != MRAA_SUCCESS ||
+        mraa_gpio_dir(dev->gpio_lo_plus, MRAA_GPIO_IN) != MRAA_SUCCESS){
+        printf("Couldn't set the direction for the GPIO pins");
+        return NULL;
+    }
+
+    dev->a_res = (1 << mraa_aio_get_bit(dev->aio));
+    return dev;
+}
+
+void ad8232_close(ad8232_context dev){
+    if (dev->gpio_lo_minus != NULL)
+        mraa_gpio_close(dev->gpio_lo_minus);
+    if (dev->gpio_lo_plus != NULL)
+        mraa_gpio_close(dev->gpio_lo_plus);
+    if (dev->aio != NULL)
+        mraa_aio_close(dev->aio);
+
+    free(dev);
+}
+
+upm_result_t ad8232_get_value(ad8232_context dev, int* value) {
+    int reading = 0;
+
+    if (mraa_gpio_read(dev->gpio_lo_minus) ||
+        mraa_gpio_read(dev->gpio_lo_plus)) {
+        reading = 0;
+    }
+    else {
+        reading = mraa_aio_read(dev->aio);
+    }
+
+    *value = reading;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/ad8232/ad8232.h b/ext/lib/upm/src/ad8232/ad8232.h
new file mode 100644
index 0000000..862f085
--- /dev/null
+++ b/ext/lib/upm/src/ad8232/ad8232.h
@@ -0,0 +1,61 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef AD8232_H_
+#define AD8232_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "upm.h"
+#include "mraa/aio.h"
+#include "mraa/gpio.h"
+
+#define AD8232_DEFAULT_AREF  3.3
+
+/**
+ * device context
+ */
+typedef struct _ad8232_context {
+    mraa_aio_context        aio;
+    mraa_gpio_context       gpio_lo_plus;
+    mraa_gpio_context       gpio_lo_minus;
+    uint8_t                 aio_pin;
+    uint8_t                 gpio_lo_plus_pin;
+    uint8_t                 gpio_lo_minus_pin;
+    int                     a_res;
+} *ad8232_context;
+
+/**
+ * Sensor Init function
+ */
+ad8232_context ad8232_init(int lo_plus, int lo_minus, int output, float a_ref);
+
+void ad8232_close(ad8232_context dev);
+
+upm_result_t ad8232_get_value(ad8232_context dev, int* value);
+
+#endif /* AD8232_H_ */
\ No newline at end of file
diff --git a/ext/lib/upm/src/apa102/Kbuild b/ext/lib/upm/src/apa102/Kbuild
new file mode 100644
index 0000000..f584f24
--- /dev/null
+++ b/ext/lib/upm/src/apa102/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_apa102) += apa102.o
diff --git a/ext/lib/upm/src/apa102/Kconfig b/ext/lib/upm/src/apa102/Kconfig
new file mode 100644
index 0000000..41ac9ef
--- /dev/null
+++ b/ext/lib/upm/src/apa102/Kconfig
@@ -0,0 +1,9 @@
+config UPM_apa102
+    bool "apa102"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM driver for DFRobot HKA5 PM2.5 particle sensor
+
diff --git a/ext/lib/upm/src/apa102/Makefile b/ext/lib/upm/src/apa102/Makefile
new file mode 100644
index 0000000..8ae3510
--- /dev/null
+++ b/ext/lib/upm/src/apa102/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_apa102
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/apa102
+endif
diff --git a/ext/lib/upm/src/apa102/apa102.c b/ext/lib/upm/src/apa102/apa102.c
new file mode 100644
index 0000000..a5eb3ce
--- /dev/null
+++ b/ext/lib/upm/src/apa102/apa102.c
@@ -0,0 +1,134 @@
+/*
+ * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+
+#include "apa102.h"
+
+apa102_context apa102_init(int ledcount, int bus, int cs) {
+
+    apa102_context dev = (apa102_context)malloc(sizeof(struct _apa102_context));
+
+    if(!dev)
+        return NULL;
+
+    dev->leds = ledcount;
+
+    // Try to allocate and zero out buffer
+    uint16_t endframelength = (dev->leds + 15) / 16;
+    dev->framelength = 4 * (1 + dev->leds) + endframelength;
+    if ((dev->buffer = (uint8_t*)malloc(dev->framelength))) {
+        memset(dev->buffer, 0x00, dev->framelength - endframelength);
+        memset(&dev->buffer[dev->framelength - endframelength], 0xFF, endframelength);
+        int i;
+        for (i = 1; i <= dev->leds; i++) {
+            dev->buffer[i * 4] = 224;
+        }
+    } else {
+        printf("%s: Failed to allocate LED buffer.\n", __FUNCTION__);
+        apa102_close(dev);
+        return NULL;
+    }
+
+    dev->spi = NULL;
+    dev->cs = NULL;
+
+    // Initialize MRAA contexts
+    if (!(dev->spi = mraa_spi_init(bus))) {
+        printf("%s: mraa_spi_init(bus) failed.\n", __FUNCTION__);
+        apa102_close(dev);
+        return NULL;
+    }
+
+    if (cs >= 0) {
+        if (!(dev->cs = mraa_gpio_init(cs))) {
+          printf("%s: mraa_gpio_init(cs) failed.\n", __FUNCTION__);
+          apa102_close(dev);
+          return NULL;
+        }
+        mraa_gpio_dir(dev->cs, MRAA_GPIO_OUT);
+    }
+
+    return dev;
+}
+
+void apa102_close(apa102_context dev) {
+    assert(dev != NULL);
+
+    if (dev->spi)
+        mraa_spi_stop(dev->spi);
+    if (dev->cs)
+        mraa_gpio_close(dev->cs);
+    if(dev->buffer)
+        free(dev->buffer);
+    free(dev);
+}
+
+upm_result_t apa102_set_led(apa102_context dev, uint16_t index, uint8_t brightness, uint8_t r, uint8_t g, uint8_t b) {
+    return apa102_set_leds(dev, index, index, brightness, r, g, b);
+}
+
+upm_result_t apa102_set_led_brightness(apa102_context dev, uint16_t index, uint8_t brightness) {
+    return apa102_set_leds_brightness(dev, index, index, brightness);
+}
+
+upm_result_t apa102_set_leds(apa102_context dev, uint16_t s_index, uint16_t e_index, uint8_t brightness, uint8_t r, uint8_t g, uint8_t b) {
+    assert(dev != NULL);
+    int i;
+    uint16_t s_idx = (s_index + 1) * 4;
+    uint16_t e_idx = (e_index + 1) * 4;
+
+    for (i = s_idx; i <= e_idx; i += 4) {
+        dev->buffer[i] = brightness | 224;
+        dev->buffer[i + 1] = b;
+        dev->buffer[i + 2] = g;
+        dev->buffer[i + 3] = r;
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t apa102_set_leds_brightness(apa102_context dev, uint16_t s_index, uint16_t e_index, uint8_t brightness) {
+    assert(dev != NULL);
+    int i;
+    uint16_t s_idx = (s_index + 1) * 4;
+    uint16_t e_idx = (e_index + 1) * 4;
+
+    for (i = s_idx; i <= e_idx; i += 4) {
+        dev->buffer[i] = brightness | 224;
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t apa102_refresh(apa102_context dev) {
+    assert(dev != NULL);
+    if(!dev->cs) {
+        mraa_spi_write_buf(dev->spi, dev->buffer, dev->framelength);
+    } else {
+        mraa_gpio_write(dev->cs, 1);
+        mraa_spi_write_buf(dev->spi, dev->buffer, dev->framelength);
+        mraa_gpio_write(dev->cs, 0);
+    }
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/apa102/apa102.h b/ext/lib/upm/src/apa102/apa102.h
new file mode 100644
index 0000000..1288bbf
--- /dev/null
+++ b/ext/lib/upm/src/apa102/apa102.h
@@ -0,0 +1,134 @@
+/*
+ * Author: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
+ * Copyright (c) 2016 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/gpio.h"
+#include "mraa/spi.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief API for controlling APA102/DotStar RGB LED Strips
+ *
+ * APA102 LED Strips provide individually controllable LEDs through a SPI interface.
+ * For each LED, brightness (0-31) and RGB (0-255) values can be set.
+ *
+ * @snippet apa102.c Interesting
+ */
+
+/**
+ * Device context
+ */
+typedef struct _apa102_context {
+    mraa_spi_context        spi;
+
+    // optional chip select
+    mraa_gpio_context       cs;
+
+    uint8_t*    buffer;
+    int         leds;
+    int         framelength;
+} *apa102_context;
+
+
+/**
+ * Instantiates a new APA102 LED Strip
+ *
+ * @param ledcount  Number of LEDs on the strip
+ * @param bus       SPI bus to use
+ * @param cs        Pin to use for chip select. -1 if not used.
+ * @return an initialized apa102 context on success, NULL on error.
+ */
+apa102_context apa102_init(int ledcount, int bus, int cs);
+
+/**
+ * APA102 close function
+ *
+ * @param dev The apa102_context to close
+ */
+void apa102_close(apa102_context dev);
+
+/**
+ * Sets the color and brightness for one LED in the buffer
+ *
+ * @param dev           The apa102_context to use
+ * @param index         Index of the LED (0 based)
+ * @param brightness    Brightness value (0-31)
+ * @param r             Red component (0-255)
+ * @param g             Green component (0-255)
+ * @param b             Blue component (0-255)
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t apa102_set_led(apa102_context dev, uint16_t index, uint8_t brightness, uint8_t r, uint8_t g, uint8_t b);
+
+/**
+ * Sets the brightness for one LED in the buffer
+ *
+ * @param dev           The apa102_context to use
+ * @param index         Index of the LED (0 based)
+ * @param brightness    Brightness value (0-31)
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t apa102_set_led_brightness(apa102_context dev, uint16_t index, uint8_t brightness);
+
+/**
+ * Sets the color and brightness for multiple LEDs in the buffer
+ *
+ * @param dev           The apa102_context to use
+ * @param s_index       The start Index of the LED range (0 based)
+ * @param e_index       The end Index of the LED range (0 based)
+ * @param brightness    Brightness value (0-31)
+ * @param r             Red component (0-255)
+ * @param g             Green component (0-255)
+ * @param b             Blue component (0-255)
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t apa102_set_leds(apa102_context dev, uint16_t s_index, uint16_t e_index, uint8_t brightness, uint8_t r, uint8_t g, uint8_t b);
+
+/**
+ * Sets the brightness for multiple LEDs in the buffer
+ *
+ * @param dev           The apa102_context to use
+ * @param s_index       The start Index of the LED range (0 based)
+ * @param e_index       The end Index of the LED range (0 based)
+ * @param brightness    Brightness value (0-31)
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t apa102_set_leds_brightness(apa102_context dev, uint16_t s_index, uint16_t e_index, uint8_t brightness);
+
+/**
+ * Writes the buffer to the SPI bus thus updating the LED Strip
+ *
+ * @param dev The apa102_context to use
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t apa102_refresh(apa102_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/bh1750/Kbuild b/ext/lib/upm/src/bh1750/Kbuild
new file mode 100644
index 0000000..903172a
--- /dev/null
+++ b/ext/lib/upm/src/bh1750/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_bh1750) += bh1750.o
diff --git a/ext/lib/upm/src/bh1750/Kconfig b/ext/lib/upm/src/bh1750/Kconfig
new file mode 100644
index 0000000..38ecb69
--- /dev/null
+++ b/ext/lib/upm/src/bh1750/Kconfig
@@ -0,0 +1,9 @@
+config UPM_bh1750
+    bool "bh1750"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm dfrobot BH1750 I2C Digital Light Sensor
+
diff --git a/ext/lib/upm/src/bh1750/Makefile b/ext/lib/upm/src/bh1750/Makefile
new file mode 100644
index 0000000..a9e9989
--- /dev/null
+++ b/ext/lib/upm/src/bh1750/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_bh1750
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/bh1750
+endif
diff --git a/ext/lib/upm/src/bh1750/bh1750.c b/ext/lib/upm/src/bh1750/bh1750.c
new file mode 100644
index 0000000..c20097e
--- /dev/null
+++ b/ext/lib/upm/src/bh1750/bh1750.c
@@ -0,0 +1,299 @@
+/*
+ * Authors: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <assert.h>
+
+#include "bh1750.h"
+#include "upm_utilities.h"
+
+bh1750_context bh1750_init(int bus, uint8_t addr, BH1750_OPMODES_T mode)
+{
+  bh1750_context dev =
+    (bh1750_context)malloc(sizeof(struct _bh1750_context));
+
+  if (!dev)
+    {
+      printf("%s: context allocation failed.\n", __FUNCTION__);
+
+      return NULL;
+    }
+
+  dev->bus = bus;
+  dev->is_continuous = false;
+
+  // init the i2c context
+  if (!(dev->i2c = mraa_i2c_init(dev->bus)))
+    {
+      printf("%s: mraa_i2c_init failed.\n", __FUNCTION__);
+      free(dev);
+
+      return NULL;
+    }
+
+  // now check the address...
+  if (mraa_i2c_address(dev->i2c, addr) != MRAA_SUCCESS)
+    {
+      printf("%s: mraa_i2c_address failed.\n", __FUNCTION__);
+
+      bh1750_close(dev);
+
+      return NULL;
+    }
+
+  // set the mode
+  if (bh1750_set_opmode(dev, mode) != UPM_SUCCESS)
+    {
+      printf("%s: bh1750_set_mode failed.\n", __FUNCTION__);
+
+      bh1750_close(dev);
+
+      return NULL;
+    }
+
+  return dev;
+}
+
+void bh1750_close(const bh1750_context dev)
+{
+  assert(dev != NULL);
+
+  if (dev->i2c)
+    mraa_i2c_stop(dev->i2c);
+
+  free(dev);
+}
+
+upm_result_t bh1750_get_lux(const bh1750_context dev, float* lux)
+{
+  assert(dev != NULL);
+
+  // from the datasheet, page 7
+  static const float coeff = 1.2;
+
+  uint16_t raw_lux = 0;
+
+  upm_result_t rv;
+  if ((rv = bh1750_read_data(dev, &raw_lux)) != UPM_SUCCESS)
+    {
+      printf("%s: bh1750_read_data failed.\n", __FUNCTION__);
+
+      return rv;
+    }
+
+  *lux = (float)raw_lux;
+  *lux /= coeff;
+
+  return rv;
+}
+
+bool bh1750_power_up(const bh1750_context dev)
+{
+  assert(dev != NULL);
+  
+  if (bh1750_send_command(dev, BH1750_CMD_POWER_UP))
+    {
+      printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
+      
+      return false;
+    }
+
+  return true;
+}
+  
+bool bh1750_power_down(const bh1750_context dev)
+{
+  assert(dev != NULL);
+  
+  if (bh1750_send_command(dev, BH1750_CMD_POWER_DOWN))
+    {
+      printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
+      
+      return false;
+    }
+
+  return true;
+}
+
+bool bh1750_reset(const bh1750_context dev)
+{
+  assert(dev != NULL);
+  
+  if (bh1750_send_command(dev, BH1750_CMD_RESET))
+    {
+      printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
+      
+      return false;
+    }
+
+  return true;
+}
+
+upm_result_t bh1750_send_command(const bh1750_context dev, uint8_t cmd)
+{
+  assert(dev != NULL);
+
+  if (mraa_i2c_write_byte(dev->i2c, cmd))
+    {
+      printf("%s: mraa_i2c_write_byte failed.\n", __FUNCTION__);
+      
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t bh1750_read_data(const bh1750_context dev, uint16_t* data)
+{
+  assert(dev != NULL);
+
+  // if we are in a non-continuous mode, we need to power up the
+  // device and send the measurement mode command we are interested
+  // in.  After the measurement has been read, the device will then
+  // power down again.
+
+  if (!dev->is_continuous)
+    {
+      // power up
+      if (!bh1750_power_up(dev))
+        {
+          printf("%s: bh1750_power_up failed.\n", __FUNCTION__);
+          
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      // send the command, and delay appropriately
+      if (bh1750_send_command(dev, dev->opmode))
+        {
+          printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
+          
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      upm_delay_ms(dev->delayms);
+    }
+
+  // now get our data...
+  const int num_bytes = 2;
+  uint8_t bytes[num_bytes];
+
+  int bytes_read = 0;
+  if ((bytes_read = mraa_i2c_read(dev->i2c, bytes, num_bytes)) != num_bytes)
+    {
+      printf("%s: mraa_i2c_read failed.\n", __FUNCTION__);
+      
+      return UPM_ERROR_NO_DATA;
+    }
+
+  // uncompensated, raw data
+  *data = (bytes[0] << 8) | bytes[1];
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t bh1750_set_opmode(const bh1750_context dev,
+                               BH1750_OPMODES_T mode)
+{
+  assert(dev != NULL);
+
+  switch(mode)
+    {
+    case BH1750_OPMODE_H1_CONT:
+      dev->is_continuous = true;
+      dev->delayms = BH1750_MAX_MEAS_TIME_H;
+      dev->opmode = BH1750_CMD_CONT_H_RES_MODE1;
+      break;
+
+    case BH1750_OPMODE_H2_CONT:
+      dev->is_continuous = true;
+      dev->delayms = BH1750_MAX_MEAS_TIME_H;
+      dev->opmode = BH1750_CMD_CONT_H_RES_MODE2;
+      break;
+
+    case BH1750_OPMODE_H1_ONCE:
+      dev->is_continuous = false;
+      dev->delayms = BH1750_MAX_MEAS_TIME_H;
+      dev->opmode = BH1750_CMD_ONETIME_H_RES_MODE1;
+      break;
+
+    case BH1750_OPMODE_H2_ONCE:
+      dev->is_continuous = false;
+      dev->delayms = BH1750_MAX_MEAS_TIME_H;
+      dev->opmode = BH1750_CMD_ONETIME_H_RES_MODE2;
+      break;
+
+    case BH1750_OPMODE_L_CONT:
+      dev->is_continuous = true;
+      dev->delayms = BH1750_MAX_MEAS_TIME_L;
+      dev->opmode = BH1750_CMD_CONT_L_RES_MODE;
+      break;
+
+    case BH1750_OPMODE_L_ONCE:
+      dev->is_continuous = false;
+      dev->delayms = BH1750_MAX_MEAS_TIME_L;
+      dev->opmode = BH1750_CMD_ONETIME_L_RES_MODE;
+      break;
+
+    default:
+      printf("%s: Invalid mode.\n", __FUNCTION__);
+      return UPM_ERROR_INVALID_PARAMETER;
+    }
+
+  // If we are in a continuous mode, power on the device and start
+  // measuring.
+  
+  if (dev->is_continuous)
+    {
+      if (!bh1750_power_up(dev))
+        {
+          printf("%s: bh1750_power_up failed.\n", __FUNCTION__);
+          
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      if (bh1750_send_command(dev, dev->opmode))
+        {
+          printf("%s: bh1750_send_command failed.\n", __FUNCTION__);
+          
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      upm_delay_ms(dev->delayms);
+    }
+  else
+    {
+      // if we are not in a continuous mode, power the device off
+      if (!bh1750_power_down(dev))
+        {
+          printf("%s: bh1750_power_down failed.\n", __FUNCTION__);
+          
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+    }
+
+  return UPM_SUCCESS;
+}
+
+
+
diff --git a/ext/lib/upm/src/bh1750/bh1750.h b/ext/lib/upm/src/bh1750/bh1750.h
new file mode 100644
index 0000000..9d04df0
--- /dev/null
+++ b/ext/lib/upm/src/bh1750/bh1750.h
@@ -0,0 +1,181 @@
+/*
+ * Authors: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+
+#include "mraa/i2c.h"
+
+#include "upm.h"
+#include "upm_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+/**
+ * @brief UPM C API for the DFRobot I2C BH1750 Light Sensor
+ *
+ * This driver was developed with the DFRobot Light Sensor based on
+ * the BH1750.  It has a sensitivity of .5 10 65535 Lux.  It supports
+ * voltages from 3-5vdc and is connected via I2C.
+ *
+ * @snippet bh1750.c Interesting
+ */
+
+#define BH1750_DEFAULT_I2C_BUS              0
+#define BH1750_DEFAULT_I2C_ADDR             0x23
+
+// BH1750 commands
+
+#define BH1750_CMD_POWER_DOWN               0x00
+#define BH1750_CMD_POWER_UP                 0x01
+
+#define BH1750_CMD_RESET                    0x07
+
+// continuous modes
+#define BH1750_CMD_CONT_H_RES_MODE1         0x10 // 1 lx resolution
+#define BH1750_CMD_CONT_H_RES_MODE2         0x11 // .5 lx resolution
+#define BH1750_CMD_CONT_L_RES_MODE          0x13 // 4 lx resolution
+
+// one-time modes
+#define BH1750_CMD_ONETIME_H_RES_MODE1      0x20
+#define BH1750_CMD_ONETIME_H_RES_MODE2      0x21
+#define BH1750_CMD_ONETIME_L_RES_MODE       0x23
+
+// max measurement time in ms (for H modes)
+#define BH1750_MAX_MEAS_TIME_H              180
+
+// max measurement time in ms (for L modes)
+#define BH1750_MAX_MEAS_TIME_L              30
+
+// an enum for the operating mode to pass to init
+typedef enum {
+  BH1750_OPMODE_H1_CONT, // continuous 1 lx high resolution
+  BH1750_OPMODE_H2_CONT, // continuous .5 lx high resolution
+  BH1750_OPMODE_L_CONT,  // continuous 4 lx low resolution
+  BH1750_OPMODE_H1_ONCE, // onetime 1 lx high resolution
+  BH1750_OPMODE_H2_ONCE, // onetime .5 lx high resolution
+  BH1750_OPMODE_L_ONCE,  // onetime 4 lx low resolution
+} BH1750_OPMODES_T;
+    
+/**
+ * device context
+ */
+typedef struct _bh1750_context
+{
+  int                 bus;
+  mraa_i2c_context    i2c;
+  
+  // these are set by bh1750_set_opmode()
+  uint8_t             opmode;
+  bool                is_continuous;
+  int                 delayms;
+} *bh1750_context;
+
+/**
+ * Initialize the BH1750
+ *
+ * @param bus I2C bus
+ * @param addr I2C address
+ * @param mode operating mode, one of the BH1750_OPMODES_T values
+ * @return bh1750_context for the new device context
+ */
+bh1750_context bh1750_init(int bus, uint8_t addr, BH1750_OPMODES_T mode);
+
+/**
+ * Sensor destructor function.  Frees any allocated resources.
+ *
+ * @param dev The device context
+ */
+void bh1750_close(const bh1750_context dev);
+
+/**
+ * Gets the Lux value.
+ *
+ * @param dev The device context
+ * @param lux float pointer in which to store the lux value
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t bh1750_get_lux(const bh1750_context dev, float* lux);
+
+/**
+ * Power up the device.
+ *
+ * @param dev The device context
+ * @return true if the command was successful, false otherwise
+ */
+bool bh1750_power_up(const bh1750_context dev);
+
+/**
+ * Power down the device.
+ *
+ * @param dev The device context
+ * @return true if the command was successful, false otherwise
+ */
+bool bh1750_power_down(const bh1750_context dev);
+
+/**
+ * Reset the device.  This doesn't really have much purpose.  The
+ * device must be powered up for this command to work.  In addition,
+ * this command will simply clear the measurement register to 0.
+ *
+ * @param dev The device context
+ * @return true if the command was successful, false otherwise
+ */
+bool bh1750_reset(const bh1750_context dev);
+
+/**
+ * Write a command to the device via I2C.
+ *
+ * @param dev The device context
+ * @param cmd The command to write, one of the BH1750_CMD* values
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t bh1750_send_command(const bh1750_context dev, uint8_t cmd);
+
+/**
+ * Read the 2 result bytes from the device via I2C.
+ *
+ * @param dev The device context
+ * @param data Data read in from the device as a uint16_t
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t bh1750_read_data(const bh1750_context dev, uint16_t* data);
+
+/**
+ * Setup the device context parameters and the device to match the
+ * selected operating mode.
+ *
+ * @param dev The device context
+ * @param mode operating mode, one of the BH1750_OPMODES_T values
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t bh1750_set_opmode(const bh1750_context dev,
+                               BH1750_OPMODES_T mode);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
diff --git a/ext/lib/upm/src/biss0001/Kbuild b/ext/lib/upm/src/biss0001/Kbuild
new file mode 100644
index 0000000..50ad5b6
--- /dev/null
+++ b/ext/lib/upm/src/biss0001/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_biss0001) += biss0001.o
diff --git a/ext/lib/upm/src/biss0001/Kconfig b/ext/lib/upm/src/biss0001/Kconfig
new file mode 100644
index 0000000..f3a87ab
--- /dev/null
+++ b/ext/lib/upm/src/biss0001/Kconfig
@@ -0,0 +1,8 @@
+config UPM_biss0001
+    bool "biss0001"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm biss0001 PIR motion sensor
diff --git a/ext/lib/upm/src/biss0001/Makefile b/ext/lib/upm/src/biss0001/Makefile
new file mode 100644
index 0000000..02156b4
--- /dev/null
+++ b/ext/lib/upm/src/biss0001/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_biss0001
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/biss0001
+endif
diff --git a/ext/lib/upm/src/biss0001/biss0001.c b/ext/lib/upm/src/biss0001/biss0001.c
new file mode 100644
index 0000000..958f38f
--- /dev/null
+++ b/ext/lib/upm/src/biss0001/biss0001.c
@@ -0,0 +1,77 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Zion Orent <zorent@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include "biss0001.h"
+
+biss0001_context biss0001_init(unsigned int pin)
+{
+    biss0001_context dev =
+        (biss0001_context)malloc(sizeof(struct _biss0001_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->gpio = NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        biss0001_close(dev);
+        return NULL;
+    }
+
+    // initialize the MRAA context
+
+    if (!(dev->gpio = mraa_gpio_init(pin)))
+    {
+        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
+        biss0001_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+    return dev;
+}
+
+void biss0001_close(biss0001_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->gpio)
+        mraa_gpio_close(dev->gpio);
+
+    free(dev);
+}
+
+bool biss0001_motion_detected(const biss0001_context dev)
+{
+    assert(dev != NULL);
+
+    return (mraa_gpio_read(dev->gpio) ? true : false);
+}
diff --git a/ext/lib/upm/src/biss0001/biss0001.h b/ext/lib/upm/src/biss0001/biss0001.h
new file mode 100644
index 0000000..a08cbae
--- /dev/null
+++ b/ext/lib/upm/src/biss0001/biss0001.h
@@ -0,0 +1,76 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Zion Orent <zorent@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @brief BISS0001 PIR Motion Sensor
+     *
+     * This module tests for movement in it's detecting range.
+     *
+     * @snippet biss0001.c Interesting
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _biss0001_context {
+        mraa_gpio_context        gpio;
+    } *biss0001_context;
+
+    /**
+     * BISS0001 initilaizer
+     *
+     * @param pin Digital pin to use.
+     * @return an initialized device context on success, NULL on error.
+     */
+    biss0001_context biss0001_init(unsigned int pin);
+
+    /**
+     * BISS0001 close function
+     *
+     * @param dev The device context.
+     */
+    void biss0001_close(biss0001_context dev);
+
+    /**
+     * Gets the motion value from the sensor
+     *
+     * @param dev The device context.
+     * @return true if motion was detected, false otherwise
+     */
+    bool biss0001_motion_detected(const biss0001_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/bmi160/Kbuild b/ext/lib/upm/src/bmi160/Kbuild
new file mode 100644
index 0000000..f984eac
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_bmi160) += bmi160.o bosch_bmi160.o
diff --git a/ext/lib/upm/src/bmi160/Kconfig b/ext/lib/upm/src/bmi160/Kconfig
new file mode 100644
index 0000000..c8ff419
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/Kconfig
@@ -0,0 +1,8 @@
+config UPM_bmi160
+    bool "bmi160"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm BMI160 Accelerometer/Gyroscope
diff --git a/ext/lib/upm/src/bmi160/Makefile b/ext/lib/upm/src/bmi160/Makefile
new file mode 100644
index 0000000..fef874a
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_bmi160
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/bmi160
+endif
diff --git a/ext/lib/upm/src/bmi160/bmi160.c b/ext/lib/upm/src/bmi160/bmi160.c
new file mode 100644
index 0000000..9eff13d
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/bmi160.c
@@ -0,0 +1,586 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+#include <mraa/i2c.h>
+#include <mraa/spi.h>
+#include <mraa/gpio.h>
+
+#include "bmi160.h"
+
+#include <upm_utilities.h>
+
+// we have to do it the old skool way.  Note, this also means that
+// only one instance of the bmi160 driver can be active at a time.
+static mraa_i2c_context i2cContext = NULL;
+static mraa_spi_context spiContext = NULL;
+/* this is used for chip-select when using SPI */
+static mraa_gpio_context gpioContext = NULL;
+
+// whether we are doing I2C or SPI
+static bool isSPI = false;
+
+// Our bmi160 info structure
+struct bmi160_t s_bmi160;
+
+// For SPI, these are our CS on/off functions, if needed
+static void bmi160_cs_on()
+{
+    if (gpioContext)
+        mraa_gpio_write(gpioContext, 0);
+}
+
+static void bmi160_cs_off()
+{
+    if (gpioContext)
+        mraa_gpio_write(gpioContext, 1);
+}
+
+// i2c bus read and write functions for use with the bmi driver code
+s8 bmi160_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
+{
+    if (isSPI)
+    {
+        if (!spiContext)
+        {
+            printf("%s: spiContext is NULL.\n", __FUNCTION__);
+            return 1;
+        }
+
+        reg_addr |= 0x80; // needed for read
+
+        uint8_t sbuf[cnt + 1];
+        memset((char *)sbuf, 0, cnt + 1);
+        sbuf[0] = reg_addr;
+
+        bmi160_cs_on();
+
+        if (mraa_spi_transfer_buf(spiContext, sbuf, sbuf, cnt + 1))
+        {
+            bmi160_cs_off();
+            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
+            return 1;
+        }
+        bmi160_cs_off();
+
+      // now copy it into user buffer
+        int i;
+        for (i=0; i<cnt; i++)
+            reg_data[i] = sbuf[i + 1];
+
+        return 0;
+    }
+
+    // doing I2C
+
+    if (!i2cContext)
+    {
+        printf("%s: i2cContext is NULL.\n", __FUNCTION__);
+        return 1;
+    }
+
+    if (mraa_i2c_read_bytes_data(i2cContext, reg_addr, reg_data, cnt) < 0)
+    {
+        printf("%s: mraa_i2c_read_bytes() failed.\n", __FUNCTION__);
+        return 1;
+    }
+
+    return 0;
+}
+
+s8 bmi160_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt)
+{
+    if (isSPI)
+    {
+        if (!spiContext)
+        {
+            printf("%s: spiContext is NULL.\n", __FUNCTION__);
+            return 1;
+        }
+
+        reg_addr &= 0x7f; // mask off 0x80 for writing
+
+        uint8_t sbuf[cnt + 1];
+        memset((char *)sbuf, 0, cnt + 1);
+        sbuf[0] = reg_addr;
+
+        // copy in the data to write...
+        int i;
+        for (i=0; i<cnt; i++)
+            sbuf[i + 1] = reg_data[i];
+
+        bmi160_cs_on();
+
+        if (mraa_spi_transfer_buf(spiContext, sbuf, sbuf, cnt + 1))
+        {
+            bmi160_cs_off();
+            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
+            return 1;
+        }
+        bmi160_cs_off();
+
+        return 0;
+    }
+
+    // I2C...
+    if (!i2cContext)
+    {
+        printf("%s: i2cContext is NULL.\n", __FUNCTION__);
+        return 1;
+    }
+
+    uint8_t buffer[cnt + 1];
+
+    buffer[0] = reg_addr;
+    int i;
+    for (i=0; i<cnt; i++)
+        buffer[i+1] = reg_data[i];
+
+    mraa_result_t rv = mraa_i2c_write(i2cContext, buffer, cnt+1);
+
+    if (rv != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
+        return 1;
+    }
+
+    return 0;
+}
+
+// delay for some milliseconds
+void bmi160_delay_ms(u32 msek)
+{
+  upm_delay_ms(msek);
+}
+
+
+bmi160_context bmi160_init(unsigned int bus, int address, int cs_pin,
+                           bool enable_mag)
+{
+    bmi160_context dev =
+        (bmi160_context)malloc(sizeof(struct _bmi160_context));
+
+    if (!dev)
+        return NULL;
+
+    // zero out context
+    memset((void *)dev, 0, sizeof(struct _bmi160_context));
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        bmi160_close(dev);
+        return NULL;
+    }
+
+    if (address > 0)
+    {
+        // we are doing I2C
+        isSPI = false;
+
+        if (!(i2cContext = mraa_i2c_init(bus)))
+        {
+            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
+            bmi160_close(dev);
+            return NULL;
+        }
+
+        if (mraa_i2c_address(i2cContext, address) != MRAA_SUCCESS)
+        {
+            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
+            bmi160_close(dev);
+            return NULL;
+        }
+    }
+    else
+    {
+        // we are doing SPI
+        isSPI = true;
+
+        if (!(spiContext = mraa_spi_init(bus)))
+        {
+            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
+            bmi160_close(dev);
+            return NULL;
+        }
+
+        // Only create cs context if we are actually using a valid pin.
+        // A hardware controlled pin should specify cs as -1.
+        if (cs_pin >= 0)
+        {
+            if (!(gpioContext = mraa_gpio_init(cs_pin)))
+            {
+                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
+                bmi160_close(dev);
+                return NULL;
+            }
+
+            mraa_gpio_dir(gpioContext, MRAA_GPIO_OUT);
+            bmi160_cs_off();
+        }
+
+        if (mraa_spi_mode(spiContext, MRAA_SPI_MODE0))
+        {
+            printf("%s: mraa_spi_mode() failed.\n", __FUNCTION__);
+            bmi160_close(dev);
+            return NULL;
+        }
+
+        if (mraa_spi_frequency(spiContext, 5000000))
+        {
+            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
+            bmi160_close(dev);
+            return NULL;
+        }
+    }
+
+    // init the driver interface functions
+    s_bmi160.bus_write = bmi160_bus_write;
+    s_bmi160.bus_read = bmi160_bus_read;
+    s_bmi160.delay_msec = bmi160_delay_ms;
+    if (isSPI)
+        s_bmi160.dev_addr = 0;
+    else
+        s_bmi160.dev_addr = address & 0xff;
+
+    // Init our driver interface pointers
+    if (bmi160_init_bus(&s_bmi160))
+    {
+        printf("%s: bmi160_bus_init() failed.\n", __FUNCTION__);
+        bmi160_close(dev);
+        return NULL;
+    }
+
+    // bmi160_init_bus will read the chip Id and deposit into our
+    // interface struct.  So, check it out and make sure it's correct.
+    if (s_bmi160.chip_id != BMI160_CHIP_ID)
+    {
+        printf("%s: Warning: expected chip id %02x, but got %02x.\n",
+               __FUNCTION__, BMI160_CHIP_ID, s_bmi160.chip_id);
+    }
+
+    dev->accelScale = 1.0;
+    dev->gyroScale = 1.0;
+    dev->magEnabled = false;
+
+    // This should be interesting...
+    const u32 C_BMI160_THIRTY_U8X = 30;
+
+    bmi160_enable_magnetometer(dev, enable_mag);
+
+    /* Set the accel mode as Normal write in the register 0x7E */
+    bmi160_set_command_register(ACCEL_MODE_NORMAL);
+
+    /* bmi160_delay_ms in ms */
+    bmi160_delay_ms(C_BMI160_THIRTY_U8X);
+
+    /* Set the gyro mode as Normal write in the register 0x7E */
+    bmi160_set_command_register(GYRO_MODE_NORMAL);
+
+    /* bmi160_delay_ms in ms */
+    bmi160_delay_ms(C_BMI160_THIRTY_U8X);
+
+    /* Set the accel bandwidth as OSRS4 */
+    bmi160_set_accel_bw(BMI160_ACCEL_OSR4_AVG1);
+    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+
+    /* Set the gryo bandwidth as Normal */
+    bmi160_set_gyro_bw(BMI160_GYRO_NORMAL_MODE);
+    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+
+    /* set gyro data rate as 200Hz */
+    bmi160_set_gyro_output_data_rate(BMI160_GYRO_OUTPUT_DATA_RATE_200HZ);
+    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+
+    /* set accel data rate as 200Hz */
+    bmi160_set_accel_output_data_rate(BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ,
+                                      BMI160_ACCEL_OSR4_AVG1);
+    bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+
+    bmi160_set_accelerometer_scale(dev, BMI160_ACC_RANGE_2G);
+    bmi160_set_gyroscope_scale(dev, BMI160_GYRO_RANGE_125);
+
+    return dev;
+}
+
+void bmi160_close(bmi160_context dev)
+{
+    assert(dev != NULL);
+
+    if (i2cContext)
+        mraa_i2c_stop(i2cContext);
+    i2cContext = NULL;
+
+    if (spiContext)
+        mraa_spi_stop(spiContext);
+    spiContext = NULL;
+
+    if (gpioContext)
+        mraa_gpio_close(gpioContext);
+    gpioContext = NULL;
+
+    free(dev);
+}
+
+void bmi160_update(const bmi160_context dev)
+{
+    assert(dev != NULL);
+
+    struct bmi160_gyro_t gyroxyz;
+    struct bmi160_accel_t accelxyz;
+    struct bmi160_mag_xyz_s32_t magxyz;
+
+    // read gyro data
+    bmi160_read_gyro_xyz(&gyroxyz);
+
+    // read accel data
+    bmi160_read_accel_xyz(&accelxyz);
+
+    // read mag data
+    if (dev->magEnabled)
+        bmi160_bmm150_mag_compensate_xyz(&magxyz);
+
+    // read the sensor time
+    u32 v_sensor_time;
+    bmi160_get_sensor_time(&v_sensor_time);
+    dev->sensorTime = (unsigned int)v_sensor_time;
+
+    dev->accelX = (float)accelxyz.x;
+    dev->accelY = (float)accelxyz.y;
+    dev->accelZ = (float)accelxyz.z;
+
+    dev->gyroX = (float)gyroxyz.x;
+    dev->gyroY = (float)gyroxyz.y;
+    dev->gyroZ = (float)gyroxyz.z;
+
+    if (dev->magEnabled)
+    {
+        dev->magX = (float)magxyz.x;
+        dev->magY = (float)magxyz.y;
+        dev->magZ = (float)magxyz.z;
+    }
+}
+
+void bmi160_set_accelerometer_scale(const bmi160_context dev,
+                                    BMI160_ACC_RANGE_T scale)
+{
+    assert(dev != NULL);
+
+    s8 v_range = BMI160_ACCEL_RANGE_2G;
+    // store scaling factor
+
+    switch (scale)
+    {
+    case BMI160_ACC_RANGE_2G:
+        v_range = BMI160_ACCEL_RANGE_2G;
+        dev->accelScale = 16384.0;
+        break;
+
+    case BMI160_ACC_RANGE_4G:
+        v_range = BMI160_ACCEL_RANGE_4G;
+        dev->accelScale = 8192.0;
+        break;
+
+    case BMI160_ACC_RANGE_8G:
+        v_range = BMI160_ACCEL_RANGE_8G;
+        dev->accelScale = 4096.0;
+        break;
+
+    case BMI160_ACC_RANGE_16G:
+        v_range = BMI160_ACCEL_RANGE_16G;
+        dev->accelScale = 2048.0;
+        break;
+
+    default: // should never occur, but...
+        dev->accelScale = 1.0;        // set a safe, though incorrect value
+        printf("%s: internal error, unsupported scale.\n", __FUNCTION__);
+        break;
+    }
+
+    bmi160_set_accel_range(v_range);
+
+    return;
+}
+
+void bmi160_set_gyroscope_scale(const bmi160_context dev,
+                                BMI160_GYRO_RANGE_T scale)
+{
+    assert(dev != NULL);
+
+    u8 v_range = BMI160_GYRO_RANGE_2000_DEG_SEC;
+
+    // store scaling factor
+
+    switch (scale)
+    {
+    case BMI160_GYRO_RANGE_125:
+        v_range = BMI160_GYRO_RANGE_125_DEG_SEC;
+        dev->gyroScale = 262.4;
+        break;
+
+    case BMI160_GYRO_RANGE_250:
+        v_range = BMI160_GYRO_RANGE_250_DEG_SEC;
+        dev->gyroScale = 131.2;
+        break;
+
+    case BMI160_GYRO_RANGE_500:
+        v_range = BMI160_GYRO_RANGE_500_DEG_SEC;
+        dev->gyroScale = 65.6;
+        break;
+
+    case BMI160_GYRO_RANGE_1000:
+        v_range = BMI160_GYRO_RANGE_1000_DEG_SEC;
+        dev->gyroScale = 32.8;
+        break;
+
+    case BMI160_GYRO_RANGE_2000:
+        v_range = BMI160_GYRO_RANGE_2000_DEG_SEC;
+        dev->gyroScale = 16.4;
+        break;
+
+    default: // should never occur, but...
+        dev->gyroScale = 1.0;        // set a safe, though incorrect value
+        printf("%s: internal error, unsupported scale.\n", __FUNCTION__);
+        break;
+    }
+
+    bmi160_set_gyro_range(v_range);
+
+    return;
+}
+
+void bmi160_get_accelerometer(const bmi160_context dev, float *x, float *y,
+                              float *z)
+{
+    assert(dev != NULL);
+
+    if (x)
+        *x = dev->accelX / dev->accelScale;
+
+    if (y)
+        *y = dev->accelY / dev->accelScale;
+
+    if (z)
+        *z = dev->accelZ / dev->accelScale;
+}
+
+void bmi160_get_gyroscope(const bmi160_context dev, float *x, float *y,
+                          float *z)
+{
+    assert(dev != NULL);
+
+    if (x)
+        *x = dev->gyroX / dev->gyroScale;
+
+    if (y)
+        *y = dev->gyroY / dev->gyroScale;
+
+    if (z)
+        *z = dev->gyroZ / dev->gyroScale;
+}
+
+void bmi160_get_magnetometer(const bmi160_context dev, float *x, float *y,
+                             float *z)
+{
+    assert(dev != NULL);
+
+    if (x)
+        *x = dev->magX;
+
+    if (y)
+        *y = dev->magY;
+
+    if (z)
+        *z = dev->magZ;
+}
+
+#if 0
+float *bmi160_get_ccelerometer()
+{
+    float *values = new float[3]; // x, y, and then z
+
+    getAccelerometer(&values[0], &values[1], &values[2]);
+
+    return values;
+}
+
+float *bmi160_getGyroscope()
+{
+    float *values = new float[3]; // x, y, and then z
+
+    getGyroscope(&values[0], &values[1], &values[2]);
+
+    return values;
+}
+
+float *bmi160_getMagnetometer()
+{
+    float *values = new float[3]; // x, y, and then z
+
+    getMagnetometer(&values[0], &values[1], &values[2]);
+
+    return values;
+}
+#endif
+
+void bmi160_enable_magnetometer(const bmi160_context dev, bool enable)
+{
+    assert(dev != NULL);
+
+    // butchered from support example
+    if (!enable)
+    {
+        bmi160_set_bmm150_mag_and_secondary_if_power_mode(MAG_SUSPEND_MODE);
+        bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+        bmi160_set_if_mode(0x00);
+        bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+
+        dev->magEnabled = false;
+        dev->magX = 0;
+        dev->magY = 0;
+        dev->magZ = 0;
+    }
+    else
+    {
+        u8 v_bmm_chip_id_u8 = BMI160_INIT_VALUE;
+        /* Init the magnetometer */
+        bmi160_bmm150_mag_interface_init(&v_bmm_chip_id_u8);
+
+        /* bmi160_delay_ms in ms*/
+        bmi160_delay_ms(BMI160_GEN_READ_WRITE_DELAY);
+
+        dev->magEnabled = true;
+    }
+}
+
+unsigned int bmi160_get_time(const bmi160_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->sensorTime;
+}
diff --git a/ext/lib/upm/src/bmi160/bmi160.h b/ext/lib/upm/src/bmi160/bmi160.h
new file mode 100644
index 0000000..37640d2
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/bmi160.h
@@ -0,0 +1,250 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "bosch_bmi160.h"
+
+#define BMI160_CHIP_ID 0xd1
+
+  /**
+   * @brief BMI160 3-axis Accelerometer, Gyroscope and (optionally) a
+   * Magnetometer
+   *
+   * The Bosch BMI160 is a 3-axis Accelerometer and Gyroscope.
+   * Additionally it supports an external Magnetometer, accessed
+   * through the BMI160's register interface.  This driver was
+   * developed with a BMI160 "Shuttle" board, which included a BMM150
+   * Magnetometer.
+   *
+   * The device is driven by either 1.8v or 3.3vdc.  This driver
+   * incorporates the Bosch BMI160 driver code at
+   * https://github.com/BoschSensortec/BMI160_driver
+   *
+   * The Bosch driver code does not provide a mechanism for passing
+   * user data around (like the device context).  For this reason,
+   * only one instance of this driver can be used in a given process,
+   * due to the use of static data in the driver.
+   *
+   * While not all of the functionality of this device is supported
+   * initially, the inclusion of the Bosch driver in the source code
+   * makes it possible to support whatever features are required that
+   * the driver can support.
+   *
+   * @snippet bmi160.c Interesting
+   */
+
+    typedef struct _bmi160_context {
+        // uncompensated accelerometer and gyroscope values
+        float accelX;
+        float accelY;
+        float accelZ;
+
+        float gyroX;
+        float gyroY;
+        float gyroZ;
+
+        float magX;
+        float magY;
+        float magZ;
+
+        unsigned int sensorTime;
+
+        // accelerometer and gyro scaling factors, depending on their Full
+        // Scale (Range) settings.
+        float accelScale;
+        float gyroScale;
+
+        // is the magnetometer enabled?
+        bool magEnabled;
+
+    } *bmi160_context;
+
+    typedef enum {
+      BMI160_ACC_RANGE_2G                        = 0, // 2 Gravities
+      BMI160_ACC_RANGE_4G,
+      BMI160_ACC_RANGE_8G,
+      BMI160_ACC_RANGE_16G
+    } BMI160_ACC_RANGE_T;
+
+    typedef enum {
+      BMI160_GYRO_RANGE_125                      = 0, // 125 degrees/sec
+      BMI160_GYRO_RANGE_250,
+      BMI160_GYRO_RANGE_500,
+      BMI160_GYRO_RANGE_1000,
+      BMI160_GYRO_RANGE_2000
+    } BMI160_GYRO_RANGE_T;
+
+    /**
+     * bmi160 constructor
+     *
+     * @param bus i2c/spi bus to use
+     * @param address The address for this device if using I2C.  If
+     * using SPI, supply -1 for this parameter.
+     * @param cs_pin The GPIO to use for Chip Select (CS).  This is
+     * only needed for SPI, and only if your SPI implementation
+     * requires it.  Otherwise, just pass -1 if not using SPI, or your
+     * CS is handled automatically by your SPI implementation.
+     * @param enable_mag True, if you want to enable the magnetometer
+     * @return an initialized device context on success, NULL on error.
+     */
+    bmi160_context bmi160_init(unsigned int bus, int address, int cs_pin,
+                               bool enable_mag);
+
+    /**
+     * BMI160 Destructor
+     *
+     * @param dev Device context.
+     */
+    void bmi160_close(bmi160_context dev);
+
+    /**
+     * Take a measurement and store the current sensor values
+     * internally.  This function must be called prior to retrieving
+     * any sensor values, for example getAccelerometer().
+     *
+     * @param dev Device context.
+     * @param dev sensor context
+     */
+    void bmi160_update(const bmi160_context dev);
+
+    /**
+     * set the scaling mode of the accelerometer
+     *
+     * @param dev Device context.
+     * @param scale one of the ACCEL_RANGE_T values
+     */
+    void bmi160_set_accelerometer_scale(const bmi160_context dev,
+                                        BMI160_ACC_RANGE_T scale);
+
+    /**
+     * set the scaling mode of the gyroscope
+     *
+     * @param dev Device context.
+     * @param scale one of the GYRO_RANGE_T values
+     */
+    void bmi160_set_gyroscope_scale(const bmi160_context dev,
+                                    BMI160_GYRO_RANGE_T scale);
+
+    /**
+     * Get the Accelerometer values.  The values returned are in
+     * gravities.  update() must have been called prior to calling
+     * this method.
+     *
+     * @param dev Device context.
+     * @param x A pointer into which the X value will be returned
+     * @param y A pointer into which the Y value will be returned
+     * @param z A pointer into which the Z value will be returned
+     */
+    void bmi160_get_accelerometer(const bmi160_context dev,
+                                  float *x, float *y, float *z);
+
+    /**
+     * Get the Gyroscope values.  The values returned are in degrees
+     * per second.  update() must have been called prior to calling
+     * this method.
+     *
+     * @param dev Device context.
+     * @param x A pointer into which the X value will be returned
+     * @param y A pointer into which the Y value will be returned
+     * @param z A pointer into which the Z value will be returned
+     */
+    void bmi160_get_gyroscope(const bmi160_context dev,
+                              float *x, float *y, float *z);
+
+    /**
+     * Get the Magnetometer values.  The values returned are in micro
+     * Teslas.  update() must have been called prior to calling this
+     * method.
+     *
+     * @param dev Device context.
+     * @param x A pointer into which the X value will be returned
+     * @param y A pointer into which the Y value will be returned
+     * @param z A pointer into which the Z value will be returned
+     */
+    void bmi160_get_magnetometer(const bmi160_context dev,
+                                 float *x, float *y, float *z);
+
+    /**
+     * Enable or disable the Magnetometer.  By default, the
+     * magnetometer is enabled.
+     *
+     * @param dev Device context.
+     * @param enable true to enable the magnetometer, false to disable.
+     */
+    void bmi160_enable_magnetometer(const bmi160_context dev, bool enable);
+
+    /**
+     * Return the sensor time.  This is a 24bit value that increments
+     * every 39us.  It will wrap around once the 24b resolution is
+     * exceeded.
+     *
+     * @param dev Device context.
+     * @return The current sensor time.
+     */
+    unsigned int bmi160_get_time(const bmi160_context dev);
+
+    /**
+     * Perform a bus read.  This function is bus agnostic, and is used
+     * by the bosch code to perform bus reads.  It is exposed here for
+     * those users wishing to perform their own low level accesses.
+     * This is a low level function, and should not be used unless you
+     * know what you are doing.
+     *
+     * @param dev_addr For I2C operation, this is the I2C address.
+     * For SPI, this argument is ignored.
+     * @param reg_addr The register address to access.
+     * @param reg_data A pointer to a buffer in which data will be read into.
+     * @param cnt The number of bytes to read.
+     * @return A return of 0 indicates no errors, non-zero indicates an error.
+     */
+    s8 bmi160_bus_read(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt);
+
+    /**
+     * Perform a bus write.  This function is bus agnostic, and is used
+     * by the bosch code to perform bus writes.  It is exposed here for
+     * those users wishing to perform their own low level accesses.
+     * This is a low level function, and should not be used unless you
+     * know what you are doing.
+     *
+     * @param dev_addr For I2C operation, this is the I2C address.
+     * For SPI, this argument is ignored.
+     * @param reg_addr The register address to access.
+     * @param reg_data A pointer to a buffer containing data to write.
+     * @param cnt The number of bytes to write.
+     * @return A return of 0 indicates no errors, non-zero indicates an error.
+     */
+    s8 bmi160_bus_write(u8 dev_addr, u8 reg_addr, u8 *reg_data, u8 cnt);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/bmi160/bosch_bmi160.c b/ext/lib/upm/src/bmi160/bosch_bmi160.c
new file mode 100644
index 0000000..6fd8489
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/bosch_bmi160.c
@@ -0,0 +1,20468 @@
+/*
+****************************************************************************
+* Copyright (C) 2015 Bosch Sensortec GmbH
+*
+* bosch_bmi160.c
+* Date: 2014/10/27
+* Revision: 2.0.6 $
+*
+* Usage: Sensor Driver for BMI160 sensor
+*
+****************************************************************************
+* License:
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*   Redistributions of source code must retain the above copyright
+*   notice, this list of conditions and the following disclaimer.
+*
+*   Redistributions in binary form must reproduce the above copyright
+*   notice, this list of conditions and the following disclaimer in the
+*   documentation and/or other materials provided with the distribution.
+*
+*   Neither the name of the copyright holder nor the names of the
+*   contributors may be used to endorse or promote products derived from
+*   this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
+* OR CONTRIBUTORS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+* OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
+* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+* ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+*
+* The information provided is believed to be accurate and reliable.
+* The copyright holder assumes no responsibility
+* for the consequences of use
+* of such information nor for any infringement of patents or
+* other rights of third parties which may result from its use.
+* No license is granted by implication or otherwise under any patent or
+* patent rights of the copyright holder.
+**************************************************************************/
+/*! file <BMI160 >
+    brief <Sensor driver for BMI160> */
+#include "bosch_bmi160.h"
+/* user defined code to be added here ... */
+struct bmi160_t *p_bmi160;
+/* used for reading the mag trim values for compensation*/
+struct trim_data_t mag_trim;
+/* the following variable used for avoiding the selecting of auto mode
+when it is running in the manual mode of BMM150 mag interface*/
+u8 V_bmm150_maual_auto_condition_u8 = BMI160_INIT_VALUE;
+/* used for reading the AKM compensating data */
+struct bst_akm_sensitivity_data_t akm_asa_data;
+/* FIFO data read for 1024 bytes of data */
+u8 v_fifo_data_u8[FIFO_FRAME] = {BMI160_INIT_VALUE,};
+/* YAMAHA-YAS532*/
+/* value of coeff*/
+static const int yas532_version_ac_coef[] = {YAS532_VERSION_AC_COEF_X,
+YAS532_VERSION_AC_COEF_Y1, YAS532_VERSION_AC_COEF_Y2};
+/* used for reading the yas532 calibration data*/
+struct yas532_t yas532_data;
+/* used for reading the yas537 calibration data*/
+struct yas537_t yas537_data;
+struct bmi160_mag_fifo_data_t mag_data;
+struct bmi160_mag_xyz_s32_t processed_data;
+struct yas532_vector fifo_xyz_data;
+struct yas_vector fifo_vector_xyz;
+
+
+
+/*!
+ *	@brief
+ *	This function is used for initialize
+ *	bus read and bus write functions
+ *	assign the chip id and device address
+ *	chip id is read in the register 0x00 bit from 0 to 7
+ *
+ *	@param bmi160 : structure pointer
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *	@note
+ *	While changing the parameter of the bmi160_t
+ *	consider the following point:
+ *	Changing the reference value of the parameter
+ *	will changes the local copy or local reference
+ *	make sure your changes will not
+ *	affect the reference value of the parameter
+ *	(Better case don't change the reference value of the parameter)
+ *
+*/
+/* JET - renamed from bmi160_init to avoid conflict with UPM code */
+BMI160_RETURN_FUNCTION_TYPE bmi160_init_bus(struct bmi160_t *bmi160)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 v_pmu_data_u8 = BMI160_INIT_VALUE;
+	/* assign bmi160 ptr */
+	p_bmi160 = bmi160;
+	com_rslt =
+	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+	BMI160_USER_CHIP_ID__REG,
+	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* read Chip Id */
+	p_bmi160->chip_id = v_data_u8;
+	/* To avoid gyro wakeup it is required to write 0x00 to 0x6C*/
+	com_rslt += bmi160_write_reg(BMI160_USER_PMU_TRIGGER_ADDR,
+	&v_pmu_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	return com_rslt;
+}
+/*!
+ * @brief
+ *	This API write the data to
+ *	the given register
+ *
+ *
+ *	@param v_addr_u8 -> Address of the register
+ *	@param v_data_u8 -> The data from the register
+ *	@param v_len_u8 -> no of bytes to read
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_write_reg(u8 v_addr_u8,
+u8 *v_data_u8, u8 v_len_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write data from register*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			v_addr_u8, v_data_u8, v_len_u8);
+		}
+	return com_rslt;
+}
+/*!
+ * @brief
+ *	This API reads the data from
+ *	the given register
+ *
+ *
+ *	@param v_addr_u8 -> Address of the register
+ *	@param v_data_u8 -> The data from the register
+ *	@param v_len_u8 -> no of bytes to read
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_reg(u8 v_addr_u8,
+u8 *v_data_u8, u8 v_len_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* Read data from register*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			v_addr_u8, v_data_u8, v_len_u8);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to reads the fatal error
+ *	from the Register 0x02 bit 0
+ *	This flag will be reset only by power-on-reset and soft reset
+ *
+ *
+ *  @param v_fatal_err_u8 : The status of fatal error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fatal_err(u8
+*v_fatal_err_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* reading the fatal error status*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FATAL_ERR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fatal_err_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FATAL_ERR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to read the error code
+ *	from register 0x02 bit 1 to 4
+ *
+ *
+ *  @param v_err_code_u8 : The status of error codes
+ *	error_code  |    description
+ *  ------------|---------------
+ *	0x00        |no error
+ *	0x01        |ACC_CONF error (accel ODR and bandwidth not compatible)
+ *	0x02        |GYR_CONF error (Gyroscope ODR and bandwidth not compatible)
+ *	0x03        |Under sampling mode and interrupt uses pre filtered data
+ *	0x04        |reserved
+ *	0x05        |Selected trigger-readout offset in
+ *    -         |MAG_IF greater than selected ODR
+ *	0x06        |FIFO configuration error for header less mode
+ *	0x07        |Under sampling mode and pre filtered data as FIFO source
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_err_code(u8
+*v_err_code_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ERR_CODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_err_code_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ERR_CODE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API Reads the i2c error code from the
+ *	Register 0x02 bit 5.
+ *	This error occurred in I2C master detected
+ *
+ *  @param v_i2c_err_code_u8 : The status of i2c fail error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_fail_err(u8
+*v_i2c_err_code_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_I2C_FAIL_ERR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_i2c_err_code_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_I2C_FAIL_ERR);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API Reads the dropped command error
+ *	from the register 0x02 bit 6
+ *
+ *
+ *  @param v_drop_cmd_err_u8 : The status of drop command error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_drop_cmd_err(u8
+*v_drop_cmd_err_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DROP_CMD_ERR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_drop_cmd_err_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_DROP_CMD_ERR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the magnetometer data ready
+ *	interrupt not active.
+ *	It reads from the error register 0x0x2 bit 7
+ *
+ *
+ *
+ *
+ *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_dada_rdy_err(
+u8 *v_mag_data_rdy_err_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_MAG_DADA_RDY_ERR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_data_rdy_err_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_DADA_RDY_ERR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the error status
+ *	from the error register 0x02 bit 0 to 7
+ *
+ *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
+ *  @param v_fatal_er_u8r : The status of fatal error
+ *  @param v_err_code_u8 : The status of error code
+ *  @param v_i2c_fail_err_u8 : The status of I2C fail error
+ *  @param v_drop_cmd_err_u8 : The status of drop command error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_error_status(u8 *v_fatal_er_u8r,
+u8 *v_err_code_u8, u8 *v_i2c_fail_err_u8,
+u8 *v_drop_cmd_err_u8, u8 *v_mag_data_rdy_err_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the error codes*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_ERR_STAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			/* fatal error*/
+			*v_fatal_er_u8r =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FATAL_ERR);
+			/* user error*/
+			*v_err_code_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ERR_CODE);
+			/* i2c fail error*/
+			*v_i2c_fail_err_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_I2C_FAIL_ERR);
+			/* drop command error*/
+			*v_drop_cmd_err_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_DROP_CMD_ERR);
+			/* mag data ready error*/
+			*v_mag_data_rdy_err_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_DADA_RDY_ERR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the magnetometer power mode from
+ *	PMU status register 0x03 bit 0 and 1
+ *
+ *  @param v_mag_power_mode_stat_u8 : The value of mag power mode
+ *	mag_powermode    |   value
+ * ------------------|----------
+ *    SUSPEND        |   0x00
+ *    NORMAL         |   0x01
+ *   LOW POWER       |   0x02
+ *
+ *
+ * @note The power mode of mag set by the 0x7E command register
+ * @note using the function "bmi160_set_command_register()"
+ *  value    |   mode
+ *  ---------|----------------
+ *   0x18    | MAG_MODE_SUSPEND
+ *   0x19    | MAG_MODE_NORMAL
+ *   0x1A    | MAG_MODE_LOWPOWER
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_power_mode_stat(u8
+*v_mag_power_mode_stat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_POWER_MODE_STAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_power_mode_stat_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_POWER_MODE_STAT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the gyroscope power mode from
+ *	PMU status register 0x03 bit 2 and 3
+ *
+ *  @param v_gyro_power_mode_stat_u8 :	The value of gyro power mode
+ *	gyro_powermode   |   value
+ * ------------------|----------
+ *    SUSPEND        |   0x00
+ *    NORMAL         |   0x01
+ *   FAST POWER UP   |   0x03
+ *
+ * @note The power mode of gyro set by the 0x7E command register
+ * @note using the function "bmi160_set_command_register()"
+ *  value    |   mode
+ *  ---------|----------------
+ *   0x14    | GYRO_MODE_SUSPEND
+ *   0x15    | GYRO_MODE_NORMAL
+ *   0x17    | GYRO_MODE_FASTSTARTUP
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_power_mode_stat(u8
+*v_gyro_power_mode_stat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_POWER_MODE_STAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_power_mode_stat_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_GYRO_POWER_MODE_STAT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the accelerometer power mode from
+ *	PMU status register 0x03 bit 4 and 5
+ *
+ *
+ *  @param v_accel_power_mode_stat_u8 :	The value of accel power mode
+ *	accel_powermode  |   value
+ * ------------------|----------
+ *    SUSPEND        |   0x00
+ *    NORMAL         |   0x01
+ *  LOW POWER        |   0x02
+ *
+ * @note The power mode of accel set by the 0x7E command register
+ * @note using the function "bmi160_set_command_register()"
+ *  value    |   mode
+ *  ---------|----------------
+ *   0x11    | ACCEL_MODE_NORMAL
+ *   0x12    | ACCEL_LOWPOWER
+ *   0x10    | ACCEL_SUSPEND
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_power_mode_stat(u8
+*v_accel_power_mode_stat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_POWER_MODE_STAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_power_mode_stat_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ACCEL_POWER_MODE_STAT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API switch mag interface to normal mode
+ *	and confirm whether the mode switching done successfully or not
+*
+ *	@return results of bus communication function and current MAG_PMU result
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_interface_normal(void)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
+	/* aim to check the result of switching mag normal */
+	u8 v_try_times_u8 = BMI160_MAG_NOAMRL_SWITCH_TIMES;
+	u8 v_mag_pum_status_u8 = BMI160_INIT_VALUE;
+
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt = bmi160_set_command_register(MAG_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	while (v_try_times_u8) {
+		com_rslt = bmi160_get_mag_power_mode_stat(&v_mag_pum_status_u8);
+		if (v_mag_pum_status_u8 == MAG_INTERFACE_PMU_ENABLE)
+			break;
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		v_try_times_u8--;
+	}
+	if (v_mag_pum_status_u8 == MAG_INTERFACE_PMU_ENABLE)
+		com_rslt += SUCCESS;
+	else
+		com_rslt += E_BMI160_COMM_RES;
+
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads magnetometer data X values
+ *	from the register 0x04 and 0x05
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param v_mag_x_s16 : The value of mag x
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_x(s16 *v_mag_x_s16,
+u8 v_sensor_select_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the mag X lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_MAG_X_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_sensor_select_u8) {
+		case BST_BMM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DATA_MAG_X_LSB__REG,
+			v_data_u8, BMI160_MAG_X_DATA_LENGTH);
+			/* X axis*/
+			v_data_u8[BMI160_MAG_X_LSB_BYTE] =
+			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_X_LSB_BYTE],
+			BMI160_USER_DATA_MAG_X_LSB);
+			*v_mag_x_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
+			(v_data_u8[BMI160_MAG_X_LSB_BYTE]));
+		break;
+		case BST_AKM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_0_MAG_X_LSB__REG,
+			v_data_u8, BMI160_MAG_X_DATA_LENGTH);
+			*v_mag_x_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_MAG_X_LSB_BYTE]));
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads magnetometer data Y values
+ *	from the register 0x06 and 0x07
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param v_mag_y_s16 : The value of mag y
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_y(s16 *v_mag_y_s16,
+u8 v_sensor_select_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_OUT_OF_RANGE;
+	/* Array contains the mag Y lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_MAG_Y_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_sensor_select_u8) {
+		case BST_BMM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DATA_MAG_Y_LSB__REG,
+			v_data_u8, BMI160_MAG_Y_DATA_LENGTH);
+			/*Y-axis lsb value shifting*/
+			v_data_u8[BMI160_MAG_Y_LSB_BYTE] =
+			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_Y_LSB_BYTE],
+			BMI160_USER_DATA_MAG_Y_LSB);
+			*v_mag_y_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
+			(v_data_u8[BMI160_MAG_Y_LSB_BYTE]));
+		break;
+		case BST_AKM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DATA_2_MAG_Y_LSB__REG,
+			v_data_u8, BMI160_MAG_Y_DATA_LENGTH);
+			*v_mag_y_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_MAG_Y_LSB_BYTE]));
+		break;
+		default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads magnetometer data Z values
+ *	from the register 0x08 and 0x09
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param v_mag_z_s16 : The value of mag z
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_z(s16 *v_mag_z_s16,
+u8 v_sensor_select_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the mag Z lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_MAG_Z_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_sensor_select_u8) {
+		case BST_BMM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DATA_MAG_Z_LSB__REG,
+			v_data_u8, BMI160_MAG_Z_DATA_LENGTH);
+			/*Z-axis lsb value shifting*/
+			v_data_u8[BMI160_MAG_Z_LSB_BYTE] =
+			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_Z_LSB_BYTE],
+			BMI160_USER_DATA_MAG_Z_LSB);
+			*v_mag_z_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS) |
+			(v_data_u8[BMI160_MAG_Z_LSB_BYTE]));
+		break;
+		case BST_AKM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DATA_4_MAG_Z_LSB__REG,
+			v_data_u8, BMI160_MAG_Z_DATA_LENGTH);
+			*v_mag_z_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | (
+			v_data_u8[BMI160_MAG_Z_LSB_BYTE]));
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads magnetometer data RHALL values
+ *	from the register 0x0A and 0x0B
+ *
+ *
+ *  @param v_mag_r_s16 : The value of BMM150 r data
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_r(s16 *v_mag_r_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the mag R lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_MAG_R_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_6_RHALL_LSB__REG,
+			v_data_u8, BMI160_MAG_R_DATA_LENGTH);
+			/*R-axis lsb value shifting*/
+			v_data_u8[BMI160_MAG_R_LSB_BYTE] =
+			BMI160_GET_BITSLICE(v_data_u8[BMI160_MAG_R_LSB_BYTE],
+			BMI160_USER_DATA_MAG_R_LSB);
+			*v_mag_r_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_MAG_R_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS) |
+			(v_data_u8[BMI160_MAG_R_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads magnetometer data X,Y,Z values
+ *	from the register 0x04 to 0x09
+ *
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param mag : The value of mag xyz data
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyz(
+struct bmi160_mag_t *mag, u8 v_sensor_select_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the mag XYZ lSB and MSB data
+		v_data_u8[0] - X-LSB
+		v_data_u8[1] - X-MSB
+		v_data_u8[0] - Y-LSB
+		v_data_u8[1] - Y-MSB
+		v_data_u8[0] - Z-LSB
+		v_data_u8[1] - Z-MSB
+		*/
+	u8 v_data_u8[BMI160_MAG_XYZ_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_sensor_select_u8) {
+		case BST_BMM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_DATA_MAG_X_LSB__REG,
+			v_data_u8, BMI160_MAG_XYZ_DATA_LENGTH);
+			/*X-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE] =
+			BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE],
+			BMI160_USER_DATA_MAG_X_LSB);
+			/* Data X */
+			mag->x = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
+			(v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]));
+			/* Data Y */
+			/*Y-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE] =
+			BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE],
+			BMI160_USER_DATA_MAG_Y_LSB);
+			mag->y = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS) |
+			(v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]));
+
+			/* Data Z */
+			/*Z-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]
+			= BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE],
+			BMI160_USER_DATA_MAG_Z_LSB);
+			mag->z = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS) |
+			(v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]));
+		break;
+		case BST_AKM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_0_MAG_X_LSB__REG,
+			v_data_u8, BMI160_MAG_XYZ_DATA_LENGTH);
+			/* Data X */
+			mag->x = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]));
+			/* Data Y */
+			mag->y  = ((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]));
+			/* Data Z */
+			mag->z = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]));
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+ /*!*
+ *	@brief This API reads magnetometer data X,Y,Z,r
+ *	values from the register 0x04 to 0x0B
+ *
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param mag : The value of mag-BMM150 xyzr data
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyzr(
+struct bmi160_mag_xyzr_t *mag)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8[BMI160_MAG_XYZR_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_MAG_X_LSB__REG,
+			v_data_u8, BMI160_MAG_XYZR_DATA_LENGTH);
+
+			/* Data X */
+			/*X-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]
+			= BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE],
+			BMI160_USER_DATA_MAG_X_LSB);
+			mag->x = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS)
+			| (v_data_u8[BMI160_DATA_FRAME_MAG_X_LSB_BYTE]));
+			/* Data Y */
+			/*Y-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]
+			= BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_Y_LSB_BYTE],
+			BMI160_USER_DATA_MAG_Y_LSB);
+			mag->y = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_05_BITS)
+			| (v_data_u8[
+			BMI160_DATA_FRAME_MAG_Y_LSB_BYTE]));
+
+			/* Data Z */
+			/*Z-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]
+			= BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE],
+			BMI160_USER_DATA_MAG_Z_LSB);
+			mag->z = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS)
+			| (v_data_u8[BMI160_DATA_FRAME_MAG_Z_LSB_BYTE]));
+
+			/* RHall */
+			/*R-axis lsb value shifting*/
+			v_data_u8[BMI160_DATA_FRAME_MAG_R_LSB_BYTE]
+			= BMI160_GET_BITSLICE(
+			v_data_u8[BMI160_DATA_FRAME_MAG_R_LSB_BYTE],
+			BMI160_USER_DATA_MAG_R_LSB);
+			mag->r = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_MAG_R_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
+			| (v_data_u8[BMI160_DATA_FRAME_MAG_R_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads gyro data X values
+ *	form the register 0x0C and 0x0D
+ *
+ *
+ *
+ *
+ *  @param v_gyro_x_s16 : The value of gyro x data
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_x(s16 *v_gyro_x_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the gyro X lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[MSB_ONE] - MSB*/
+	u8 v_data_u8[BMI160_GYRO_X_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_8_GYRO_X_LSB__REG,
+			v_data_u8, BMI160_GYRO_DATA_LENGTH);
+
+			*v_gyro_x_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_GYRO_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_GYRO_X_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads gyro data Y values
+ *	form the register 0x0E and 0x0F
+ *
+ *
+ *
+ *
+ *  @param v_gyro_y_s16 : The value of gyro y data
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error result of communication routines
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_y(s16 *v_gyro_y_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the gyro Y lSB and MSB data
+		v_data_u8[LSB_ZERO] - LSB
+		v_data_u8[MSB_ONE] - MSB*/
+	u8 v_data_u8[BMI160_GYRO_Y_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro y data*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_10_GYRO_Y_LSB__REG,
+			v_data_u8, BMI160_GYRO_DATA_LENGTH);
+
+			*v_gyro_y_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_GYRO_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_GYRO_Y_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads gyro data Z values
+ *	form the register 0x10 and 0x11
+ *
+ *
+ *
+ *
+ *  @param v_gyro_z_s16 : The value of gyro z data
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_z(s16 *v_gyro_z_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the gyro Z lSB and MSB data
+		v_data_u8[LSB_ZERO] - LSB
+		v_data_u8[MSB_ONE] - MSB*/
+	u8 v_data_u8[BMI160_GYRO_Z_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro z data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_12_GYRO_Z_LSB__REG,
+			v_data_u8, BMI160_GYRO_DATA_LENGTH);
+
+			*v_gyro_z_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_GYRO_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_GYRO_Z_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads gyro data X,Y,Z values
+ *	from the register 0x0C to 0x11
+ *
+ *
+ *
+ *
+ *  @param gyro : The value of gyro xyz
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_xyz(struct bmi160_gyro_t *gyro)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the mag XYZ lSB and MSB data
+		v_data_u8[0] - X-LSB
+		v_data_u8[1] - X-MSB
+		v_data_u8[0] - Y-LSB
+		v_data_u8[1] - Y-MSB
+		v_data_u8[0] - Z-LSB
+		v_data_u8[1] - Z-MSB
+		*/
+	u8 v_data_u8[BMI160_GYRO_XYZ_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the gyro xyz data*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_8_GYRO_X_LSB__REG,
+			v_data_u8, BMI160_GYRO_XYZ_DATA_LENGTH);
+
+			/* Data X */
+			gyro->x = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_GYRO_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_DATA_FRAME_GYRO_X_LSB_BYTE]));
+			/* Data Y */
+			gyro->y = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_GYRO_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_DATA_FRAME_GYRO_Y_LSB_BYTE]));
+
+			/* Data Z */
+			gyro->z = (s16)
+			((((s32)((s8)v_data_u8[
+			BMI160_DATA_FRAME_GYRO_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_DATA_FRAME_GYRO_Z_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads accelerometer data X values
+ *	form the register 0x12 and 0x13
+ *
+ *
+ *
+ *
+ *  @param v_accel_x_s16 : The value of accel x
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_x(s16 *v_accel_x_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the accel X lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_ACCEL_X_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_14_ACCEL_X_LSB__REG,
+			v_data_u8, BMI160_ACCEL_DATA_LENGTH);
+
+			*v_accel_x_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_ACCEL_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_ACCEL_X_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads accelerometer data Y values
+ *	form the register 0x14 and 0x15
+ *
+ *
+ *
+ *
+ *  @param v_accel_y_s16 : The value of accel y
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_y(s16 *v_accel_y_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the accel Y lSB and MSB data
+		v_data_u8[0] - LSB
+		v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_ACCEL_Y_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_16_ACCEL_Y_LSB__REG,
+			v_data_u8, BMI160_ACCEL_DATA_LENGTH);
+
+			*v_accel_y_s16 = (s16)
+			((((s32)((s8)v_data_u8[BMI160_ACCEL_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_data_u8[BMI160_ACCEL_Y_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads accelerometer data Z values
+ *	form the register 0x16 and 0x17
+ *
+ *
+ *
+ *
+ *  @param v_accel_z_s16 : The value of accel z
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_z(s16 *v_accel_z_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the accel Z lSB and MSB data
+		a_data_u8r[LSB_ZERO] - LSB
+		a_data_u8r[MSB_ONE] - MSB*/
+	u8 a_data_u8r[BMI160_ACCEL_Z_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_18_ACCEL_Z_LSB__REG,
+			a_data_u8r, BMI160_ACCEL_DATA_LENGTH);
+
+			*v_accel_z_s16 = (s16)
+			((((s32)((s8)a_data_u8r[BMI160_ACCEL_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (a_data_u8r[BMI160_ACCEL_Z_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads accelerometer data X,Y,Z values
+ *	from the register 0x12 to 0x17
+ *
+ *
+ *
+ *
+ *  @param accel :The value of accel xyz
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_xyz(
+struct bmi160_accel_t *accel)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the accel XYZ lSB and MSB data
+	a_data_u8r[0] - X-LSB
+	a_data_u8r[1] - X-MSB
+	a_data_u8r[0] - Y-LSB
+	a_data_u8r[1] - Y-MSB
+	a_data_u8r[0] - Z-LSB
+	a_data_u8r[1] - Z-MSB
+	*/
+	u8 a_data_u8r[BMI160_ACCEL_XYZ_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_DATA_14_ACCEL_X_LSB__REG,
+			a_data_u8r, BMI160_ACCEL_XYZ_DATA_LENGTH);
+
+			/* Data X */
+			accel->x = (s16)
+			((((s32)((s8)a_data_u8r[
+			BMI160_DATA_FRAME_ACCEL_X_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (a_data_u8r[BMI160_DATA_FRAME_ACCEL_X_LSB_BYTE]));
+			/* Data Y */
+			accel->y = (s16)
+			((((s32)((s8)a_data_u8r[
+			BMI160_DATA_FRAME_ACCEL_Y_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (a_data_u8r[BMI160_DATA_FRAME_ACCEL_Y_LSB_BYTE]));
+
+			/* Data Z */
+			accel->z = (s16)
+			((((s32)((s8)a_data_u8r[
+			BMI160_DATA_FRAME_ACCEL_Z_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (a_data_u8r[BMI160_DATA_FRAME_ACCEL_Z_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads sensor_time from the register
+ *	0x18 to 0x1A
+ *
+ *
+ *  @param v_sensor_time_u32 : The value of sensor time
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_sensor_time(u32 *v_sensor_time_u32)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the sensor time it is 32 bit data
+	a_data_u8r[0] - sensor time
+	a_data_u8r[1] - sensor time
+	a_data_u8r[0] - sensor time
+	*/
+	u8 a_data_u8r[BMI160_SENSOR_TIME_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__REG,
+			a_data_u8r, BMI160_SENSOR_TIME_LENGTH);
+
+			*v_sensor_time_u32 = (u32)
+			((((u32)a_data_u8r[BMI160_SENSOR_TIME_MSB_BYTE])
+			<< BMI160_SHIFT_BIT_POSITION_BY_16_BITS)
+			|(((u32)a_data_u8r[BMI160_SENSOR_TIME_XLSB_BYTE])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (a_data_u8r[BMI160_SENSOR_TIME_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the Gyroscope self test
+ *	status from the register 0x1B bit 1
+ *
+ *
+ *  @param v_gyro_selftest_u8 : The value of gyro self test status
+ *  value    |   status
+ *  ---------|----------------
+ *   0       | Gyroscope self test is running or failed
+ *   1       | Gyroscope self test completed successfully
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest(u8
+*v_gyro_selftest_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_GYRO_SELFTEST_OK__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_selftest_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_GYRO_SELFTEST_OK);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of
+ *	mag manual interface operation form the register 0x1B bit 2
+ *
+ *
+ *
+ *  @param v_mag_manual_stat_u8 : The value of mag manual operation status
+ *  value    |   status
+ *  ---------|----------------
+ *   0       | Indicates no manual magnetometer
+ *   -       | interface operation is ongoing
+ *   1       | Indicates manual magnetometer
+ *   -       | interface operation is ongoing
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_operation_stat(u8
+*v_mag_manual_stat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read manual operation*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_MAG_MANUAL_OPERATION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_manual_stat_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_MAG_MANUAL_OPERATION);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the fast offset compensation
+ *	status form the register 0x1B bit 3
+ *
+ *
+ *  @param v_foc_rdy_u8 : The status of fast compensation
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_rdy(u8
+*v_foc_rdy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the FOC status*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_FOC_RDY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_foc_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_FOC_RDY);
+		}
+	return com_rslt;
+}
+/*!
+ * @brief This API Reads the nvm_rdy status from the
+ *	resister 0x1B bit 4
+ *
+ *
+ *  @param v_nvm_rdy_u8 : The value of NVM ready status
+ *  value    |   status
+ *  ---------|----------------
+ *   0       | NVM write operation in progress
+ *   1       | NVM is ready to accept a new write trigger
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_rdy(u8
+*v_nvm_rdy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the nvm ready status*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_NVM_RDY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_nvm_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_NVM_RDY);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of mag data ready
+ *	from the register 0x1B bit 5
+ *	The status get reset when one mag data register is read out
+ *
+ *  @param v_data_rdy_u8 : The value of mag data ready status
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_data_rdy_mag(u8
+*v_data_rdy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_DATA_RDY_MAG__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_DATA_RDY_MAG);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of gyro data ready form the
+ *	register 0x1B bit 6
+ *	The status get reset when gyro data register read out
+ *
+ *
+ *	@param v_data_rdy_u8 :	The value of gyro data ready
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_data_rdy(u8
+*v_data_rdy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_DATA_RDY_GYRO__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_DATA_RDY_GYRO);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of accel data ready form the
+ *	register 0x1B bit 7
+ *	The status get reset when accel data register read out
+ *
+ *
+ *	@param v_data_rdy_u8 :	The value of accel data ready status
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_data_rdy(u8
+*v_data_rdy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/*reads the status of accel data ready*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STAT_DATA_RDY_ACCEL__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STAT_DATA_RDY_ACCEL);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the step detector interrupt status
+ *	from the register 0x1C bit 0
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_step_intr_u8 : The status of step detector interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_step_intr(u8
+*v_step_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_STEP_INTR__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_step_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_STEP_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the
+ *	significant motion interrupt status
+ *	from the register 0x1C bit 1
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *
+ *  @param v_significant_intr_u8 : The status of step
+ *	motion interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_significant_intr(u8
+*v_significant_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_significant_intr_u8  = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API reads the any motion interrupt status
+ *	from the register 0x1C bit 2
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *  @param v_any_motion_intr_u8 : The status of any-motion interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_any_motion_intr(u8
+*v_any_motion_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_ANY_MOTION__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_any_motion_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_ANY_MOTION);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the power mode trigger interrupt status
+ *	from the register 0x1C bit 3
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *
+ *  @param v_pmu_trigger_intr_u8 : The status of power mode trigger interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_pmu_trigger_intr(u8
+*v_pmu_trigger_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_PMU_TRIGGER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_pmu_trigger_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_PMU_TRIGGER);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the double tab status
+ *	from the register 0x1C bit 4
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_double_tap_intr_u8 :The status of double tab interrupt
+ *
+ *	@note Double tap interrupt can be configured by the following functions
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_double_tap()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat2_tap_first_x()
+ *	@note bmi160_get_stat2_tap_first_y()
+ *	@note bmi160_get_stat2_tap_first_z()
+ *	@note DURATION
+ *	@note bmi160_set_intr_tap_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_tap_thres()
+ *	@note TAP QUIET
+ *	@note bmi160_set_intr_tap_quiet()
+ *	@note TAP SHOCK
+ *	@note bmi160_set_intr_tap_shock()
+ *	@note TAP SOURCE
+ *	@note bmi160_set_intr_tap_source()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_double_tap_intr(u8
+*v_double_tap_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_double_tap_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the single tab status
+ *	from the register 0x1C bit 5
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_single_tap_intr_u8 :The status of single tap interrupt
+ *
+ *	@note Single tap interrupt can be configured by the following functions
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_single_tap()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat2_tap_first_x()
+ *	@note bmi160_get_stat2_tap_first_y()
+ *	@note bmi160_get_stat2_tap_first_z()
+ *	@note DURATION
+ *	@note bmi160_set_intr_tap_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_tap_thres()
+ *	@note TAP QUIET
+ *	@note bmi160_set_intr_tap_quiet()
+ *	@note TAP SHOCK
+ *	@note bmi160_set_intr_tap_shock()
+ *	@note TAP SOURCE
+ *	@note bmi160_set_intr_tap_source()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_single_tap_intr(u8
+*v_single_tap_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_single_tap_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the orient status
+ *	from the register 0x1C bit 6
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the orient interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_orient_intr_u8 : The status of orient interrupt
+ *
+ *	@note For orient interrupt configuration use the following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat0_orient_intr()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat3_orient_xy()
+ *	@note bmi160_get_stat3_orient_z()
+ *	@note bmi160_set_intr_orient_axes_enable()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_orient()
+ *	@note INTERRUPT OUTPUT
+ *	@note bmi160_set_intr_orient_ud_enable()
+ *	@note THETA
+ *	@note bmi160_set_intr_orient_theta()
+ *	@note HYSTERESIS
+ *	@note bmi160_set_intr_orient_hyst()
+ *	@note BLOCKING
+ *	@note bmi160_set_intr_orient_blocking()
+ *	@note MODE
+ *	@note bmi160_set_intr_orient_mode()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_orient_intr(u8
+*v_orient_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_ORIENT__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_ORIENT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the flat interrupt status
+ *	from the register 0x1C bit 7
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the flat interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_flat_intr_u8 : The status of  flat interrupt
+ *
+ *	@note For flat configuration use the following functions
+ *	@note STATS
+ *	@note bmi160_get_stat0_flat_intr()
+ *	@note bmi160_get_stat3_flat()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_flat()
+ *	@note THETA
+ *	@note bmi160_set_intr_flat_theta()
+ *	@note HOLD TIME
+ *	@note bmi160_set_intr_flat_hold()
+ *	@note HYSTERESIS
+ *	@note bmi160_set_intr_flat_hyst()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_flat_intr(u8
+*v_flat_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_0_FLAT__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_flat_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_0_FLAT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the high_g interrupt status
+ *	from the register 0x1D bit 2
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the high g  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be permanently
+ *	latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_high_g_intr_u8 : The status of high_g interrupt
+ *
+ *	@note High_g interrupt configured by following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat1_high_g_intr()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat3_high_g_first_x()
+ *	@note bmi160_get_stat3_high_g_first_y()
+ *	@note bmi160_get_stat3_high_g_first_z()
+ *	@note SIGN MAPPING
+ *	@note bmi160_get_stat3_high_g_first_sign()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_high_g()
+  *	@note HYSTERESIS
+ *	@note bmi160_set_intr_high_g_hyst()
+ *	@note DURATION
+ *	@note bmi160_set_intr_high_g_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_high_g_thres()
+ *	@note SOURCE
+ *	@note bmi160_set_intr_low_high_source()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_high_g_intr(u8
+*v_high_g_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_1_HIGH_G_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_1_HIGH_G_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the low g interrupt status
+ *	from the register 0x1D bit 3
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the low g  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_low_g_intr_u8 : The status of low_g interrupt
+ *
+ *	@note Low_g interrupt configured by following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat1_low_g_intr()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_low_g()
+ *	@note SOURCE
+ *	@note bmi160_set_intr_low_high_source()
+ *	@note DURATION
+ *	@note bmi160_set_intr_low_g_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_low_g_thres()
+ *	@note HYSTERESIS
+ *	@note bmi160_set_intr_low_g_hyst()
+ *	@note MODE
+ *	@note bmi160_set_intr_low_g_mode()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_low_g_intr(u8
+*v_low_g_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_1_LOW_G_INTR__REG, &v_data_u8,
+			 BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_low_g_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_1_LOW_G_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads data ready interrupt status
+ *	from the register 0x1D bit 4
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the  data ready  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_data_rdy_intr_u8 : The status of data ready interrupt
+ *
+ *	@note Data ready interrupt configured by following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat1_data_rdy_intr()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_data_rdy()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_data_rdy_intr(u8
+*v_data_rdy_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_data_rdy_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_1_DATA_RDY_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads data ready FIFO full interrupt status
+ *	from the register 0x1D bit 5
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the FIFO full interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will
+ *	be permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_fifo_full_intr_u8 : The status of fifo full interrupt
+ *
+ *	@note FIFO full interrupt can be configured by following functions
+ *	@note bmi160_set_intr_fifo_full()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_full_intr(u8
+*v_fifo_full_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_full_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads data
+ *	 ready FIFO watermark interrupt status
+ *	from the register 0x1D bit 6
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the FIFO watermark interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_fifo_wm_intr_u8 : The status of fifo water mark interrupt
+ *
+ *	@note FIFO full interrupt can be configured by following functions
+ *	@note bmi160_set_intr_fifo_wm()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_wm_intr(u8
+*v_fifo_wm_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_wm_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_1_FIFO_WM_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads data ready no motion interrupt status
+ *	from the register 0x1D bit 7
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the no motion  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be permanently
+ *	latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_nomotion_intr_u8 : The status of no motion interrupt
+ *
+ *	@note No motion interrupt can be configured by following function
+ *	@note STATUS
+ *	@note bmi160_get_stat1_nomotion_intr()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_nomotion()
+ *	@note DURATION
+ *	@note bmi160_set_intr_slow_no_motion_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_slow_no_motion_thres()
+ *	@note SLOW/NO MOTION SELECT
+ *	@note bmi160_set_intr_slow_no_motion_select()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_nomotion_intr(u8
+*v_nomotion_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the no motion interrupt*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_1_NOMOTION_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_nomotion_intr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_1_NOMOTION_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *@brief This API reads the status of any motion first x
+ *	from the register 0x1E bit 0
+ *
+ *
+ *@param v_anymotion_first_x_u8 : The status of any motion first x interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by x axis
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_x(u8
+*v_anymotion_first_x_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the any motion first x interrupt*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_anymotion_first_x_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of any motion first y interrupt
+ *	from the register 0x1E bit 1
+ *
+ *
+ *
+ *@param v_any_motion_first_y_u8 : The status of any motion first y interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_y(u8
+*v_any_motion_first_y_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the any motion first y interrupt*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_any_motion_first_y_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of any motion first z interrupt
+ *	from the register 0x1E bit 2
+ *
+ *
+ *
+ *
+ *@param v_any_motion_first_z_u8 : The status of any motion first z interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_z(u8
+*v_any_motion_first_z_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the any motion first z interrupt*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_any_motion_first_z_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the any motion sign status from the
+ *	register 0x1E bit 3
+ *
+ *
+ *
+ *
+ *  @param v_anymotion_sign_u8 : The status of any motion sign
+ *  value     |  sign
+ * -----------|-------------
+ *   0        | positive
+ *   1        | negative
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_sign(u8
+*v_anymotion_sign_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read any motion sign interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_anymotion_sign_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the any motion tap first x status from the
+ *	register 0x1E bit 4
+ *
+ *
+ *
+ *
+ *  @param v_tap_first_x_u8 :The status of any motion tap first x
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by x axis
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_x(u8
+*v_tap_first_x_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap first x interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_TAP_FIRST_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_first_x_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_TAP_FIRST_X);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the tap first y interrupt status from the
+ *	register 0x1E bit 5
+ *
+ *
+ *
+ *
+ *  @param v_tap_first_y_u8 :The status of tap first y interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_y(u8
+*v_tap_first_y_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap first y interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_first_y_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_TAP_FIRST_Y);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the tap first z interrupt status  from the
+ *	register 0x1E bit 6
+ *
+ *
+ *
+ *
+ *  @param v_tap_first_z_u8 :The status of tap first z interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_z(u8
+*v_tap_first_z_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap first z interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_first_z_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_TAP_FIRST_Z);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the tap sign status from the
+ *	register 0x1E bit 7
+ *
+ *
+ *
+ *
+ *  @param v_tap_sign_u8 : The status of tap sign
+ *  value     |  sign
+ * -----------|-------------
+ *   0        | positive
+ *   1        | negative
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_sign(u8
+*v_tap_sign_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap_sign interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_2_TAP_SIGN__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_sign_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_2_TAP_SIGN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the high_g first x status from the
+ *	register 0x1F bit 0
+ *
+ *
+ *
+ *
+ *  @param v_high_g_first_x_u8 :The status of high_g first x
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_x(u8
+*v_high_g_first_x_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read highg_x interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_first_x_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the high_g first y status from the
+ *	register 0x1F bit 1
+ *
+ *
+ *
+ *
+ *  @param v_high_g_first_y_u8 : The status of high_g first y
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_y(u8
+*v_high_g_first_y_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read highg_y interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_first_y_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the high_g first z status from the
+ *	register 0x1F bit 3
+ *
+ *
+ *
+ *
+ *  @param v_high_g_first_z_u8 : The status of high_g first z
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_z(u8
+*v_high_g_first_z_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read highg_z interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_first_z_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the high sign status from the
+ *	register 0x1F bit 3
+ *
+ *
+ *
+ *
+ *  @param v_high_g_sign_u8 :The status of high sign
+ *  value     |  sign
+ * -----------|-------------
+ *   0        | positive
+ *   1        | negative
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_sign(u8
+*v_high_g_sign_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read highg_sign interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_sign_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_HIGH_G_SIGN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of orient_xy plane
+ *	from the register 0x1F bit 4 and 5
+ *
+ *
+ *  @param v_orient_xy_u8 :The status of orient_xy plane
+ *  value     |  status
+ * -----------|-------------
+ *   0x00     | portrait upright
+ *   0x01     | portrait upside down
+ *   0x02     | landscape left
+ *   0x03     | landscape right
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_xy(u8
+*v_orient_xy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orient plane xy interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_ORIENT_XY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_xy_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_ORIENT_XY);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the status of orient z plane
+ *	from the register 0x1F bit 6
+ *
+ *
+ *  @param v_orient_z_u8 :The status of orient z
+ *  value     |  status
+ * -----------|-------------
+ *   0x00     | upward looking
+ *   0x01     | downward looking
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_z(u8
+*v_orient_z_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orient z plane interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_ORIENT_Z__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_z_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_ORIENT_Z);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the flat status from the register
+ *	0x1F bit 7
+ *
+ *
+ *  @param v_flat_u8 : The status of flat interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0x00     | non flat
+ *   0x01     | flat position
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_flat(u8
+*v_flat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read flat interrupt status */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_INTR_STAT_3_FLAT__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_flat_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_STAT_3_FLAT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the temperature of the sensor
+ *	from the register 0x21 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_temp_s16 : The value of temperature
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_temp(s16
+*v_temp_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the temperature lSB and MSB data
+	v_data_u8[0] - LSB
+	v_data_u8[1] - MSB*/
+	u8 v_data_u8[BMI160_TEMP_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read temperature data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_TEMP_LSB_VALUE__REG, v_data_u8,
+			BMI160_TEMP_DATA_LENGTH);
+			*v_temp_s16 =
+			(s16)(((s32)((s8) (v_data_u8[BMI160_TEMP_MSB_BYTE]) <<
+			BMI160_SHIFT_BIT_POSITION_BY_08_BITS))
+			| v_data_u8[BMI160_TEMP_LSB_BYTE]);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the  of the sensor
+ *	form the register 0x23 and 0x24 bit 0 to 7 and 0 to 2
+ *	@brief this byte counter is updated each time a complete frame
+ *	was read or writtern
+ *
+ *
+ *  @param v_fifo_length_u32 : The value of fifo byte counter
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_length(u32 *v_fifo_length_u32)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array contains the fifo length data
+	v_data_u8[0] - fifo length
+	v_data_u8[1] - fifo length*/
+	u8 a_data_u8r[BMI160_FIFO_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read fifo length*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_BYTE_COUNTER_LSB__REG, a_data_u8r,
+			 BMI160_FIFO_DATA_LENGTH);
+
+			a_data_u8r[BMI160_FIFO_LENGTH_MSB_BYTE] =
+			BMI160_GET_BITSLICE(
+			a_data_u8r[BMI160_FIFO_LENGTH_MSB_BYTE],
+			BMI160_USER_FIFO_BYTE_COUNTER_MSB);
+
+			*v_fifo_length_u32 =
+			(u32)(((u32)((u8) (
+			a_data_u8r[BMI160_FIFO_LENGTH_MSB_BYTE]) <<
+			BMI160_SHIFT_BIT_POSITION_BY_08_BITS))
+			| a_data_u8r[BMI160_FIFO_LENGTH_LSB_BYTE]);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the fifo data of the sensor
+ *	from the register 0x24
+ *	@brief Data format depends on the setting of register FIFO_CONFIG
+ *
+ *
+ *
+ *  @param v_fifodata_u8 : Pointer holding the fifo data
+ *  @param fifo_length_u16 : The value of fifo length maximum
+ *	1024
+ *
+ *	@note For reading FIFO data use the following functions
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_data(
+u8 *v_fifodata_u8, u16 v_fifo_length_u16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read fifo data*/
+			com_rslt =
+			p_bmi160->BMI160_BURST_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_DATA__REG,
+			v_fifodata_u8, v_fifo_length_u16);
+
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the
+ *	accel output date rate form the register 0x40 bit 0 to 3
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of accel output date rate
+ *  value |  output data rate
+ * -------|--------------------------
+ *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
+ *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+ *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
+ *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
+ *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
+ *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
+ *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
+ *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
+ *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
+ *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
+ *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
+ *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
+ *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_output_data_rate(
+u8 *v_output_data_rate_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel output data rate*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_output_data_rate_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the
+ *	accel output date rate form the register 0x40 bit 0 to 3
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of accel output date rate
+ *  value |  output data rate
+ * -------|--------------------------
+ *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
+ *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+ *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
+ *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
+ *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
+ *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
+ *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
+ *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
+ *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
+ *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
+ *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
+ *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
+ *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
+ *
+ *  @param  v_accel_bw_u8 :The value of accel selected accel bandwidth
+ *  value |  output data rate
+ * -------|--------------------------
+ *    0   |  BMI160_ACCEL_OSR4_AVG1
+ *    1   |  BMI160_ACCEL_OSR2_AVG2
+ *    2   |  BMI160_ACCEL_NORMAL_AVG4
+ *    3   |  BMI160_ACCEL_CIC_AVG8
+ *    4   |  BMI160_ACCEL_RES_AVG2
+ *    5   |  BMI160_ACCEL_RES_AVG4
+ *    6   |  BMI160_ACCEL_RES_AVG8
+ *    7   |  BMI160_ACCEL_RES_AVG16
+ *    8   |  BMI160_ACCEL_RES_AVG32
+ *    9   |  BMI160_ACCEL_RES_AVG64
+ *    10  |  BMI160_ACCEL_RES_AVG128
+ *
+ *
+ *
+ *
+ *
+ *	@note Verify the accel bandwidth before setting the
+ *  output data rate
+ *  bandwidth  | output data rate |  under sampling
+ *-------------|------------------|----------------
+ *   OSR4      |  12.5 TO 1600    |   0
+ *   OSR2      |  12.5 TO 1600    |   0
+ *  NORMAL     |  12.5 TO 1600    |   0
+ *   CIC       |  12.5 TO 1600    |   0
+ *   AVG2      |  0.78 TO 400     |   1
+ *   AVG4      |  0.78 TO 200     |   1
+ *   AVG8      |  0.78 TO 100     |   1
+ *   AVG16     |  0.78 TO 50      |   1
+ *   AVG32     |  0.78 TO 25      |   1
+ *   AVG64     |  0.78 TO 12.5    |   1
+ *   AVG128    |  0.78 TO 6.25    |   1
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_output_data_rate(
+u8 v_output_data_rate_u8, u8 v_accel_bw_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 v_odr_u8 = BMI160_INIT_VALUE;
+	u8 v_assign_bw = BMI160_ASSIGN_DATA;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if ((v_accel_bw_u8 >= BMI160_ACCEL_RES_AVG2) &&
+		(v_accel_bw_u8 <= BMI160_ACCEL_RES_AVG128)) {
+			/* enable the under sampling*/
+			com_rslt = bmi160_set_accel_under_sampling_parameter(
+			BMI160_US_ENABLE);
+		} else if (((v_accel_bw_u8 > BMI160_ACCEL_OSR4_AVG1) &&
+		(v_accel_bw_u8 <= BMI160_ACCEL_CIC_AVG8))
+		|| (v_accel_bw_u8 == BMI160_ACCEL_OSR4_AVG1)) {
+			/* disable the under sampling*/
+			com_rslt = bmi160_set_accel_under_sampling_parameter(
+			BMI160_US_DISABLE);
+		}
+		/* assign the output data rate*/
+		switch (v_accel_bw_u8) {
+		case BMI160_ACCEL_RES_AVG2:
+			if (v_output_data_rate_u8
+			 >= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+			&& v_output_data_rate_u8
+			 <= BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_RES_AVG4:
+			if (v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+			&& v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_RES_AVG8:
+			if (v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+			&& v_output_data_rate_u8
+			 <= BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_RES_AVG16:
+			if (v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+			&& v_output_data_rate_u8
+			 <= BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_RES_AVG32:
+			if (v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+			&& v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_RES_AVG64:
+		if (v_output_data_rate_u8
+		 >= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+		&& v_output_data_rate_u8
+		<= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ) {
+			v_odr_u8 = v_output_data_rate_u8;
+			v_assign_bw = SUCCESS;
+		 } else {
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		 }
+		break;
+		case BMI160_ACCEL_RES_AVG128:
+			if (v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+			&& v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_OSR4_AVG1:
+			if ((v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
+			&& (v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_OSR2_AVG2:
+			if ((v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
+			&& (v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_NORMAL_AVG4:
+			if ((v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
+			&& (v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		case BMI160_ACCEL_CIC_AVG8:
+			if ((v_output_data_rate_u8
+			>= BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ)
+			&& (v_output_data_rate_u8
+			<= BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ)) {
+				v_odr_u8 = v_output_data_rate_u8;
+				v_assign_bw = SUCCESS;
+			 } else {
+				com_rslt = E_BMI160_OUT_OF_RANGE;
+			 }
+		break;
+		default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+		if (v_assign_bw == SUCCESS) {
+			/* write accel output data rate */
+			com_rslt +=
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE,
+				v_odr_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the
+ *	accel bandwidth from the register 0x40 bit 4 to 6
+ *	@brief bandwidth parameter determines filter configuration(acc_us=0)
+ *	and averaging for under sampling mode(acc_us=1)
+ *
+ *
+ *  @param  v_bw_u8 : The value of accel bandwidth
+ *
+ *	@note accel bandwidth depends on under sampling parameter
+ *	@note under sampling parameter cab be set by the function
+ *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
+ *
+ *	@note Filter configuration
+ *  accel_us  | Filter configuration
+ * -----------|---------------------
+ *    0x00    |  OSR4 mode
+ *    0x01    |  OSR2 mode
+ *    0x02    |  normal mode
+ *    0x03    |  CIC mode
+ *    0x04    |  Reserved
+ *    0x05    |  Reserved
+ *    0x06    |  Reserved
+ *    0x07    |  Reserved
+ *
+ *	@note accel under sampling mode
+ *  accel_us  | Under sampling mode
+ * -----------|---------------------
+ *    0x00    |  no averaging
+ *    0x01    |  average 2 samples
+ *    0x02    |  average 4 samples
+ *    0x03    |  average 8 samples
+ *    0x04    |  average 16 samples
+ *    0x05    |  average 32 samples
+ *    0x06    |  average 64 samples
+ *    0x07    |  average 128 samples
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_bw(u8 *v_bw_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel bandwidth */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_bw_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_BW);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the
+ *	accel bandwidth from the register 0x40 bit 4 to 6
+ *	@brief bandwidth parameter determines filter configuration(acc_us=0)
+ *	and averaging for under sampling mode(acc_us=1)
+ *
+ *
+ *  @param  v_bw_u8 : The value of accel bandwidth
+ *
+ *	@note accel bandwidth depends on under sampling parameter
+ *	@note under sampling parameter cab be set by the function
+ *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
+ *
+ *	@note Filter configuration
+ *  accel_us  | Filter configuration
+ * -----------|---------------------
+ *    0x00    |  OSR4 mode
+ *    0x01    |  OSR2 mode
+ *    0x02    |  normal mode
+ *    0x03    |  CIC mode
+ *    0x04    |  Reserved
+ *    0x05    |  Reserved
+ *    0x06    |  Reserved
+ *    0x07    |  Reserved
+ *
+ *	@note accel under sampling mode
+ *  accel_us  | Under sampling mode
+ * -----------|---------------------
+ *    0x00    |  no averaging
+ *    0x01    |  average 2 samples
+ *    0x02    |  average 4 samples
+ *    0x03    |  average 8 samples
+ *    0x04    |  average 16 samples
+ *    0x05    |  average 32 samples
+ *    0x06    |  average 64 samples
+ *    0x07    |  average 128 samples
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_bw(u8 v_bw_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* select accel bandwidth*/
+		if (v_bw_u8 <= BMI160_MAX_ACCEL_BW) {
+			/* write accel bandwidth*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_ACCEL_CONFIG_ACCEL_BW,
+				v_bw_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the accel
+ *	under sampling parameter form the register 0x40 bit 7
+ *
+ *
+ *
+ *
+ *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
+ *	value    | under_sampling
+ * ----------|---------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_under_sampling_parameter(
+u8 *v_accel_under_sampling_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel under sampling parameter */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_under_sampling_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the accel
+ *	under sampling parameter form the register 0x40 bit 7
+ *
+ *
+ *
+ *
+ *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
+ *	value    | under_sampling
+ * ----------|---------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_under_sampling_parameter(
+u8 v_accel_under_sampling_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_accel_under_sampling_u8 <= BMI160_MAX_UNDER_SAMPLING) {
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+		BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			/* write the accel under sampling parameter */
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING,
+			v_accel_under_sampling_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the ranges
+ *	(g values) of the accel from the register 0x41 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param v_range_u8 : The value of accel g range
+ *	value    | g_range
+ * ----------|-----------
+ *   0x03    | BMI160_ACCEL_RANGE_2G
+ *   0x05    | BMI160_ACCEL_RANGE_4G
+ *   0x08    | BMI160_ACCEL_RANGE_8G
+ *   0x0C    | BMI160_ACCEL_RANGE_16G
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_range(
+u8 *v_range_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel range*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_RANGE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_range_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_ACCEL_RANGE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the ranges
+ *	(g values) of the accel from the register 0x41 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param v_range_u8 : The value of accel g range
+ *	value    | g_range
+ * ----------|-----------
+ *   0x03    | BMI160_ACCEL_RANGE_2G
+ *   0x05    | BMI160_ACCEL_RANGE_4G
+ *   0x08    | BMI160_ACCEL_RANGE_8G
+ *   0x0C    | BMI160_ACCEL_RANGE_16G
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_range(u8 v_range_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if ((v_range_u8 == BMI160_ACCEL_RANGE0) ||
+			(v_range_u8 == BMI160_ACCEL_RANGE1) ||
+			(v_range_u8 == BMI160_ACCEL_RANGE3) ||
+			(v_range_u8 == BMI160_ACCEL_RANGE4)) {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_RANGE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8  = BMI160_SET_BITSLICE(
+				v_data_u8, BMI160_USER_ACCEL_RANGE,
+				v_range_u8);
+				/* write the accel range*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_ACCEL_RANGE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the
+ *	gyroscope output data rate from the register 0x42 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of gyro output data rate
+ *  value     |      gyro output data rate
+ * -----------|-----------------------------
+ *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
+ *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
+ *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
+ *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
+ *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
+ *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
+ *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
+ *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
+ *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_output_data_rate(
+u8 *v_output_data_rate_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the gyro output data rate*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_output_data_rate_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the
+ *	gyroscope output data rate from the register 0x42 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of gyro output data rate
+ *  value     |      gyro output data rate
+ * -----------|-----------------------------
+ *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
+ *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
+ *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
+ *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
+ *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
+ *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
+ *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
+ *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
+ *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_output_data_rate(
+u8 v_output_data_rate_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* select the gyro output data rate*/
+		if ((v_output_data_rate_u8 <  BMI160_OUTPUT_DATA_RATE6) &&
+		(v_output_data_rate_u8 != BMI160_INIT_VALUE)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE1)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE2)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE3)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE4)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE5)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE6)
+		&& (v_output_data_rate_u8 !=  BMI160_OUTPUT_DATA_RATE7)) {
+			/* write the gyro output data rate */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE,
+				v_output_data_rate_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the
+ *	data of gyro from the register 0x42 bit 4 to 5
+ *
+ *
+ *
+ *
+ *  @param  v_bw_u8 : The value of gyro bandwidth
+ *  value     | gyro bandwidth
+ *  ----------|----------------
+ *   0x00     | BMI160_GYRO_OSR4_MODE
+ *   0x01     | BMI160_GYRO_OSR2_MODE
+ *   0x02     | BMI160_GYRO_NORMAL_MODE
+ *   0x03     | BMI160_GYRO_CIC_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_bw(u8 *v_bw_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro bandwidth*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_CONFIG_BW__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_bw_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_GYRO_CONFIG_BW);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the
+ *	data of gyro from the register 0x42 bit 4 to 5
+ *
+ *
+ *
+ *
+ *  @param  v_bw_u8 : The value of gyro bandwidth
+ *  value     | gyro bandwidth
+ *  ----------|----------------
+ *   0x00     | BMI160_GYRO_OSR4_MODE
+ *   0x01     | BMI160_GYRO_OSR2_MODE
+ *   0x02     | BMI160_GYRO_NORMAL_MODE
+ *   0x03     | BMI160_GYRO_CIC_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_bw(u8 v_bw_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_bw_u8 <= BMI160_MAX_GYRO_BW) {
+			/* write the gyro bandwidth*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_CONFIG_BW__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_CONFIG_BW, v_bw_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_GYRO_CONFIG_BW__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads the range
+ *	of gyro from the register 0x43 bit 0 to 2
+ *
+ *  @param  v_range_u8 : The value of gyro range
+ *   value    |    range
+ *  ----------|-------------------------------
+ *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
+ *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
+ *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
+ *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
+ *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_range(u8 *v_range_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the gyro range */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_RANGE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_range_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_GYRO_RANGE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API set the range
+ *	of gyro from the register 0x43 bit 0 to 2
+ *
+ *  @param  v_range_u8 : The value of gyro range
+ *   value    |    range
+ *  ----------|-------------------------------
+ *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
+ *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
+ *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
+ *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
+ *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_range(u8 v_range_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_range_u8 <= BMI160_MAX_GYRO_RANGE) {
+			/* write the gyro range value */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_GYRO_RANGE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_RANGE,
+				v_range_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_GYRO_RANGE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the
+ *	output data rate of magnetometer from the register 0x44 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rat_u8e : The value of mag output data rate
+ *  value   |    mag output data rate
+ * ---------|---------------------------
+ *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
+ *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
+ *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
+ *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
+ *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
+ *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
+ *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
+ *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
+ *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
+ *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
+ *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
+ *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
+ *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
+ *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
+ *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
+ *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_output_data_rate(
+u8 *v_output_data_rat_u8e)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the mag data output rate*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_output_data_rat_u8e = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set the
+ *	output data rate of magnetometer from the register 0x44 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rat_u8e : The value of mag output data rate
+ *  value   |    mag output data rate
+ * ---------|---------------------------
+ *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
+ *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
+ *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
+ *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
+ *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
+ *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
+ *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
+ *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
+ *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
+ *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
+ *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
+ *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
+ *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
+ *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
+ *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
+ *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_output_data_rate(
+u8 v_output_data_rat_u8e)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* select the mag data output rate*/
+		if ((v_output_data_rat_u8e
+		<= BMI160_MAX_ACCEL_OUTPUT_DATA_RATE)
+		&& (v_output_data_rat_u8e
+		!= BMI160_OUTPUT_DATA_RATE0)
+		&& (v_output_data_rat_u8e
+		!=  BMI160_OUTPUT_DATA_RATE6)
+		&& (v_output_data_rat_u8e
+		!=  BMI160_OUTPUT_DATA_RATE7)) {
+			/* write the mag data output rate*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE,
+				v_output_data_rat_u8e);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read Down sampling
+ *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_gyro(
+u8 *v_fifo_down_gyro_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the gyro fifo down*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_DOWN_GYRO__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_down_gyro_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_DOWN_GYRO);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to set Down sampling
+ *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_gyro(
+u8 v_fifo_down_gyro_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the gyro fifo down*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_DOWN_GYRO__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(
+				v_data_u8,
+				BMI160_USER_FIFO_DOWN_GYRO,
+				v_fifo_down_gyro_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_DOWN_GYRO__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read gyro fifo filter data
+ *	from the register 0x45 bit 3
+ *
+ *
+ *
+ *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
+ *  value      |  gyro_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_fifo_filter_data(
+u8 *v_gyro_fifo_filter_data_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the gyro fifo filter data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_FILTER_GYRO__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_fifo_filter_data_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_FILTER_GYRO);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set gyro fifo filter data
+ *	from the register 0x45 bit 3
+ *
+ *
+ *
+ *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
+ *  value      |  gyro_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_fifo_filter_data(
+u8 v_gyro_fifo_filter_data_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_gyro_fifo_filter_data_u8
+		<= BMI160_MAX_VALUE_FIFO_FILTER) {
+			/* write the gyro fifo filter data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_FILTER_GYRO__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(
+				v_data_u8,
+				BMI160_USER_FIFO_FILTER_GYRO,
+				v_gyro_fifo_filter_data_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_FILTER_GYRO__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read Down sampling
+ *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_u8 :The value of accel fifo down
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_accel(
+u8 *v_fifo_down_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel fifo down data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_DOWN_ACCEL__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_down_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_DOWN_ACCEL);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to set Down sampling
+ *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_u8 :The value of accel fifo down
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_accel(
+u8 v_fifo_down_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the accel fifo down data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_DOWN_ACCEL__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_DOWN_ACCEL, v_fifo_down_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_DOWN_ACCEL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read accel fifo filter data
+ *	from the register 0x45 bit 7
+ *
+ *
+ *
+ *  @param accel_fifo_filter_u8 :The value of accel filter data
+ *  value      |  accel_fifo_filter_u8
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_fifo_filter_data(
+u8 *accel_fifo_filter_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel fifo filter data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_FILTER_ACCEL__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*accel_fifo_filter_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_FILTER_ACCEL);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set accel fifo filter data
+ *	from the register 0x45 bit 7
+ *
+ *
+ *
+ *  @param v_accel_fifo_filter_u8 :The value of accel filter data
+ *  value      |  accel_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_fifo_filter_data(
+u8 v_accel_fifo_filter_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_accel_fifo_filter_u8 <= BMI160_MAX_VALUE_FIFO_FILTER) {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_FILTER_ACCEL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				/* write accel fifo filter data */
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_FILTER_ACCEL,
+				v_accel_fifo_filter_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_FILTER_ACCEL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to Trigger an interrupt
+ *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_fifo_wm_u8 : The value of fifo water mark level
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_wm(
+u8 *v_fifo_wm_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the fifo water mark level*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_WM__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_wm_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_WM);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to Trigger an interrupt
+ *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_fifo_wm_u8 : The value of fifo water mark level
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_wm(
+u8 v_fifo_wm_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the fifo water mark level*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_WM__REG,
+			&v_fifo_wm_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads fifo sensor time
+ *	frame after the last valid data frame form the register  0x47 bit 1
+ *
+ *
+ *
+ *
+ *  @param v_fifo_time_enable_u8 : The value of sensor time
+ *  value      |  fifo sensor time
+ * ------------|-------------------------
+ *    0x00     |  do not return sensortime frame
+ *    0x01     |  return sensortime frame
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_time_enable(
+u8 *v_fifo_time_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the fifo sensor time*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_TIME_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_time_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_TIME_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API set fifo sensor time
+ *	frame after the last valid data frame form the register  0x47 bit 1
+ *
+ *
+ *
+ *
+ *  @param v_fifo_time_enable_u8 : The value of sensor time
+ *  value      |  fifo sensor time
+ * ------------|-------------------------
+ *    0x00     |  do not return sensortime frame
+ *    0x01     |  return sensortime frame
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_time_enable(
+u8 v_fifo_time_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_fifo_time_enable_u8 <= BMI160_MAX_VALUE_FIFO_TIME) {
+			/* write the fifo sensor time*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_TIME_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_TIME_ENABLE,
+				v_fifo_time_enable_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_TIME_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads FIFO tag interrupt2 enable status
+ *	from the resister 0x47 bit 2
+ *
+ *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr2_enable(
+u8 *v_fifo_tag_intr2_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the fifo tag interrupt2*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_tag_intr2_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_TAG_INTR2_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API set FIFO tag interrupt2 enable status
+ *	from the resister 0x47 bit 2
+ *
+ *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr2_enable(
+u8 v_fifo_tag_intr2_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_fifo_tag_intr2_u8 <= BMI160_MAX_VALUE_FIFO_INTR) {
+			/* write the fifo tag interrupt2*/
+			com_rslt = bmi160_set_input_enable(1,
+			v_fifo_tag_intr2_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_TAG_INTR2_ENABLE,
+				v_fifo_tag_intr2_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API get FIFO tag interrupt1 enable status
+ *	from the resister 0x47 bit 3
+ *
+ *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr1_enable(
+u8 *v_fifo_tag_intr1_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read fifo tag interrupt*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_tag_intr1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_TAG_INTR1_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API set FIFO tag interrupt1 enable status
+ *	from the resister 0x47 bit 3
+ *
+ *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr1_enable(
+u8 v_fifo_tag_intr1_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_fifo_tag_intr1_u8 <= BMI160_MAX_VALUE_FIFO_INTR) {
+			/* write the fifo tag interrupt*/
+			com_rslt = bmi160_set_input_enable(BMI160_INIT_VALUE,
+			v_fifo_tag_intr1_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_TAG_INTR1_ENABLE,
+				v_fifo_tag_intr1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads FIFO frame
+ *	header enable from the register 0x47 bit 4
+ *
+ *  @param v_fifo_header_u8 :The value of fifo header
+ *	value    | fifo header
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_header_enable(
+u8 *v_fifo_header_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read fifo header */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_HEADER_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_header_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_HEADER_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API set FIFO frame
+ *	header enable from the register 0x47 bit 4
+ *
+ *  @param v_fifo_header_u8 :The value of fifo header
+ *	value    | fifo header
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_header_enable(
+u8 v_fifo_header_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_fifo_header_u8 <= BMI160_MAX_VALUE_FIFO_HEADER) {
+			/* write the fifo header */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_HEADER_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_HEADER_ENABLE,
+				v_fifo_header_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_HEADER_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read stored
+ *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
+ *
+ *  @param v_fifo_mag_u8 : The value of fifo mag enble
+ *	value    | fifo mag
+ * ----------|-------------------
+ *  0x00     |  no magnetometer data is stored
+ *  0x01     |  magnetometer data is stored
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_mag_enable(
+u8 *v_fifo_mag_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the fifo mag enable*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_MAG_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_mag_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_MAG_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set stored
+ *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
+ *
+ *  @param v_fifo_mag_u8 : The value of fifo mag enble
+ *	value    | fifo mag
+ * ----------|-------------------
+ *  0x00     |  no magnetometer data is stored
+ *  0x01     |  magnetometer data is stored
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_mag_enable(
+u8 v_fifo_mag_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			if (v_fifo_mag_u8 <= BMI160_MAX_VALUE_FIFO_MAG) {
+				/* write the fifo mag enable*/
+				com_rslt =
+				p_bmi160->BMI160_BUS_READ_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_FIFO_MAG_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+				if (com_rslt == SUCCESS) {
+					v_data_u8 =
+					BMI160_SET_BITSLICE(v_data_u8,
+					BMI160_USER_FIFO_MAG_ENABLE,
+					v_fifo_mag_u8);
+					com_rslt +=
+					p_bmi160->BMI160_BUS_WRITE_FUNC
+					(p_bmi160->dev_addr,
+					BMI160_USER_FIFO_MAG_ENABLE__REG,
+					&v_data_u8,
+					BMI160_GEN_READ_WRITE_DATA_LENGTH);
+				}
+			} else {
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read stored
+ *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
+ *
+ *  @param v_fifo_accel_u8 : The value of fifo accel enble
+ *	value    | fifo accel
+ * ----------|-------------------
+ *  0x00     |  no accel data is stored
+ *  0x01     |  accel data is stored
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_accel_enable(
+u8 *v_fifo_accel_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel fifo enable*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_ACCEL_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_accel_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_ACCEL_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set stored
+ *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
+ *
+ *  @param v_fifo_accel_u8 : The value of fifo accel enble
+ *	value    | fifo accel
+ * ----------|-------------------
+ *  0x00     |  no accel data is stored
+ *  0x01     |  accel data is stored
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_accel_enable(
+u8 v_fifo_accel_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_fifo_accel_u8 <= BMI160_MAX_VALUE_FIFO_ACCEL) {
+			/* write the fifo mag enables*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_ACCEL_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_ACCEL_ENABLE, v_fifo_accel_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_ACCEL_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read stored
+ *	 gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
+ *
+ *
+ *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
+ *	value    | fifo gyro
+ * ----------|-------------------
+ *  0x00     |  no gyro data is stored
+ *  0x01     |  gyro data is stored
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_gyro_enable(
+u8 *v_fifo_gyro_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read fifo gyro enable */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_GYRO_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_fifo_gyro_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FIFO_GYRO_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set stored
+ *	gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
+ *
+ *
+ *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
+ *	value    | fifo gyro
+ * ----------|-------------------
+ *  0x00     |  no gyro data is stored
+ *  0x01     |  gyro data is stored
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_gyro_enable(
+u8 v_fifo_gyro_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_fifo_gyro_u8 <= BMI160_MAX_VALUE_FIFO_GYRO) {
+			/* write fifo gyro enable*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_FIFO_GYRO_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FIFO_GYRO_ENABLE, v_fifo_gyro_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FIFO_GYRO_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read
+ *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
+ *
+ *
+ *
+ *
+ *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_device_addr(
+u8 *v_i2c_device_addr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the mag I2C device address*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_I2C_DEVICE_ADDR__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_i2c_device_addr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_I2C_DEVICE_ADDR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set
+ *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
+ *
+ *
+ *
+ *
+ *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_device_addr(
+u8 v_i2c_device_addr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the mag I2C device address*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_I2C_DEVICE_ADDR__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_I2C_DEVICE_ADDR,
+				v_i2c_device_addr_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_I2C_DEVICE_ADDR__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read
+ *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
+ *
+ *
+ *
+ *
+ *  @param v_mag_burst_u8 : The data of mag burst read lenth
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_burst(
+u8 *v_mag_burst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read mag burst mode length*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_BURST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_burst_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_BURST);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set
+ *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
+ *
+ *
+ *
+ *
+ *  @param v_mag_burst_u8 : The data of mag burst read lenth
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_burst(
+u8 v_mag_burst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write mag burst mode length*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_BURST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_MAG_BURST, v_mag_burst_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_MAG_BURST__REG, &v_data_u8,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read
+ *	trigger-readout offset in units of 2.5 ms. If set to zero,
+ *	the offset is maximum, i.e. after readout a trigger
+ *	is issued immediately. from the register 0x4C bit 2 to 5
+ *
+ *
+ *
+ *
+ *  @param v_mag_offset_u8 : The value of mag offset
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_offset(
+u8 *v_mag_offset_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_OFFSET__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_offset_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_OFFSET);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set
+ *	trigger-readout offset in units of 2.5 ms. If set to zero,
+ *	the offset is maximum, i.e. after readout a trigger
+ *	is issued immediately. from the register 0x4C bit 2 to 5
+ *
+ *
+ *
+ *
+ *  @param v_mag_offset_u8 : The value of mag offset
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_offset(
+u8 v_mag_offset_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+		BMI160_USER_MAG_OFFSET__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 =
+			BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_OFFSET, v_mag_offset_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_OFFSET__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API is used to read
+ *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
+ *	This implies that the DATA registers are not updated with
+ *	magnetometer values. Accessing magnetometer requires
+ *	the magnetometer in normal mode in PMU_STATUS.
+ *	from the register 0x4C bit 7
+ *
+ *
+ *
+ *  @param v_mag_manual_u8 : The value of mag manual enable
+ *	value    | mag manual
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_enable(
+u8 *v_mag_manual_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read mag manual */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_MANUAL_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_manual_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_MANUAL_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set
+ *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
+ *	This implies that the DATA registers are not updated with
+ *	magnetometer values. Accessing magnetometer requires
+ *	the magnetometer in normal mode in PMU_STATUS.
+ *	from the register 0x4C bit 7
+ *
+ *
+ *
+ *  @param v_mag_manual_u8 : The value of mag manual enable
+ *	value    | mag manual
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_manual_enable(
+u8 v_mag_manual_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* write the mag manual*/
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+		BMI160_USER_MAG_MANUAL_ENABLE__REG, &v_data_u8,
+		BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		if (com_rslt == SUCCESS) {
+			/* set the bit of mag manual enable*/
+			v_data_u8 =
+			BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_MAG_MANUAL_ENABLE, v_mag_manual_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_MAG_MANUAL_ENABLE__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		if (com_rslt == SUCCESS)
+			p_bmi160->mag_manual_enable = v_mag_manual_u8;
+		else
+			p_bmi160->mag_manual_enable = E_BMI160_COMM_RES;
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API is used to read data
+ *	magnetometer address to read from the register 0x4D bit 0 to 7
+ *	@brief It used to provide mag read address of auxiliary mag
+ *
+ *
+ *
+ *
+ *  @param  v_mag_read_addr_u8 : The value of address need to be read
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_read_addr(
+u8 *v_mag_read_addr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the written address*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_READ_ADDR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_read_addr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_READ_ADDR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set
+ *	magnetometer write address from the register 0x4D bit 0 to 7
+ *	@brief mag write address writes the address of auxiliary mag to write
+ *
+ *
+ *
+ *  @param v_mag_read_addr_u8:
+ *	The data of auxiliary mag address to write data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_read_addr(
+u8 v_mag_read_addr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the mag read address*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_READ_ADDR__REG, &v_mag_read_addr_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read
+ *	magnetometer write address from the register 0x4E bit 0 to 7
+ *	@brief mag write address writes the address of auxiliary mag to write
+ *
+ *
+ *
+ *  @param  v_mag_write_addr_u8:
+ *	The data of auxiliary mag address to write data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_addr(
+u8 *v_mag_write_addr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the address of last written */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_WRITE_ADDR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_write_addr_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_WRITE_ADDR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set
+ *	magnetometer write address from the register 0x4E bit 0 to 7
+ *	@brief mag write address writes the address of auxiliary mag to write
+ *
+ *
+ *
+ *  @param  v_mag_write_addr_u8:
+ *	The data of auxiliary mag address to write data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_addr(
+u8 v_mag_write_addr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the data of mag address to write data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_WRITE_ADDR__REG, &v_mag_write_addr_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read magnetometer write data
+ *	form the resister 0x4F bit 0 to 7
+ *	@brief This writes the data will be wrote to mag
+ *
+ *
+ *
+ *  @param  v_mag_write_data_u8: The value of mag data
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_data(
+u8 *v_mag_write_data_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_WRITE_DATA__REG, &v_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_mag_write_data_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_WRITE_DATA);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to set magnetometer write data
+ *	form the resister 0x4F bit 0 to 7
+ *	@brief This writes the data will be wrote to mag
+ *
+ *
+ *
+ *  @param  v_mag_write_data_u8: The value of mag data
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_data(
+u8 v_mag_write_data_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt =
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_WRITE_DATA__REG, &v_mag_write_data_u8,
+			BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief  This API is used to read
+ *	interrupt enable from the register 0x50 bit 0 to 7
+ *
+ *
+ *
+ *
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_ANY_MOTION_X_ENABLE
+ *       1         | BMI160_ANY_MOTION_Y_ENABLE
+ *       2         | BMI160_ANY_MOTION_Z_ENABLE
+ *       3         | BMI160_DOUBLE_TAP_ENABLE
+ *       4         | BMI160_SINGLE_TAP_ENABLE
+ *       5         | BMI160_ORIENT_ENABLE
+ *       6         | BMI160_FLAT_ENABLE
+ *
+ *	@param v_intr_enable_zero_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_0(
+u8 v_enable_u8, u8 *v_intr_enable_zero_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* select interrupt to read*/
+		switch (v_enable_u8) {
+		case BMI160_ANY_MOTION_X_ENABLE:
+			/* read the any motion interrupt x data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE);
+		break;
+		case BMI160_ANY_MOTION_Y_ENABLE:
+			/* read the any motion interrupt y data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE);
+		break;
+		case BMI160_ANY_MOTION_Z_ENABLE:
+			/* read the any motion interrupt z data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE);
+		break;
+		case BMI160_DOUBLE_TAP_ENABLE:
+			/* read the double tap interrupt data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE);
+		break;
+		case BMI160_SINGLE_TAP_ENABLE:
+			/* read the single tap interrupt data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE);
+		break;
+		case BMI160_ORIENT_ENABLE:
+			/* read the orient interrupt data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE);
+		break;
+		case BMI160_FLAT_ENABLE:
+			/* read the flat interrupt data */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_zero_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE);
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  This API is used to set
+ *	interrupt enable from the register 0x50 bit 0 to 7
+ *
+ *
+ *
+ *
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_ANY_MOTION_X_ENABLE
+ *       1         | BMI160_ANY_MOTION_Y_ENABLE
+ *       2         | BMI160_ANY_MOTION_Z_ENABLE
+ *       3         | BMI160_DOUBLE_TAP_ENABLE
+ *       4         | BMI160_SINGLE_TAP_ENABLE
+ *       5         | BMI160_ORIENT_ENABLE
+ *       6         | BMI160_FLAT_ENABLE
+ *
+ *	@param v_intr_enable_zero_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_0(
+u8 v_enable_u8, u8 v_intr_enable_zero_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_enable_u8) {
+	case BMI160_ANY_MOTION_X_ENABLE:
+		/* write any motion x*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_ANY_MOTION_Y_ENABLE:
+		/* write any motion y*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_ANY_MOTION_Z_ENABLE:
+		/* write any motion z*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_DOUBLE_TAP_ENABLE:
+		/* write double tap*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_SINGLE_TAP_ENABLE:
+		/* write single tap */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_ORIENT_ENABLE:
+		/* write orient interrupt*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_FLAT_ENABLE:
+		/* write flat interrupt*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE,
+			v_intr_enable_zero_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief  This API is used to read
+ *	interrupt enable byte1 from the register 0x51 bit 0 to 6
+ *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
+ *	data ready, fifo full and fifo water mark.
+ *
+ *
+ *
+ *  @param  v_enable_u8 :  The value of interrupt enable
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_HIGH_G_X_ENABLE
+ *       1         | BMI160_HIGH_G_Y_ENABLE
+ *       2         | BMI160_HIGH_G_Z_ENABLE
+ *       3         | BMI160_LOW_G_ENABLE
+ *       4         | BMI160_DATA_RDY_ENABLE
+ *       5         | BMI160_FIFO_FULL_ENABLE
+ *       6         | BMI160_FIFO_WM_ENABLE
+ *
+ *	@param v_intr_enable_1_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_1(
+u8 v_enable_u8, u8 *v_intr_enable_1_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_enable_u8) {
+		case BMI160_HIGH_G_X_ENABLE:
+			/* read high_g_x interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE);
+			break;
+		case BMI160_HIGH_G_Y_ENABLE:
+			/* read high_g_y interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE);
+			break;
+		case BMI160_HIGH_G_Z_ENABLE:
+			/* read high_g_z interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE);
+			break;
+		case BMI160_LOW_G_ENABLE:
+			/* read low_g interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE);
+			break;
+		case BMI160_DATA_RDY_ENABLE:
+			/* read data ready interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE);
+			break;
+		case BMI160_FIFO_FULL_ENABLE:
+			/* read fifo full interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE);
+			break;
+		case BMI160_FIFO_WM_ENABLE:
+			/* read fifo water mark interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_1_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  This API is used to set
+ *	interrupt enable byte1 from the register 0x51 bit 0 to 6
+ *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
+ *	data ready, fifo full and fifo water mark.
+ *
+ *
+ *
+ *  @param  v_enable_u8 :  The value of interrupt enable
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_HIGH_G_X_ENABLE
+ *       1         | BMI160_HIGH_G_Y_ENABLE
+ *       2         | BMI160_HIGH_G_Z_ENABLE
+ *       3         | BMI160_LOW_G_ENABLE
+ *       4         | BMI160_DATA_RDY_ENABLE
+ *       5         | BMI160_FIFO_FULL_ENABLE
+ *       6         | BMI160_FIFO_WM_ENABLE
+ *
+ *	@param v_intr_enable_1_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_1(
+u8 v_enable_u8, u8 v_intr_enable_1_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_enable_u8) {
+		case BMI160_HIGH_G_X_ENABLE:
+			/* write high_g_x interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_HIGH_G_Y_ENABLE:
+			/* write high_g_y interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_HIGH_G_Z_ENABLE:
+			/* write high_g_z interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_LOW_G_ENABLE:
+			/* write low_g interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_DATA_RDY_ENABLE:
+			/* write data ready interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_FIFO_FULL_ENABLE:
+			/* write fifo full interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_FIFO_WM_ENABLE:
+			/* write fifo water mark interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE,
+				v_intr_enable_1_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  This API is used to read
+ *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
+ *	@brief It reads no motion x,y and z
+ *
+ *
+ *
+ *	@param v_enable_u8: The value of interrupt enable
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_NOMOTION_X_ENABLE
+ *       1         | BMI160_NOMOTION_Y_ENABLE
+ *       2         | BMI160_NOMOTION_Z_ENABLE
+ *
+ *	@param v_intr_enable_2_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_2(
+u8 v_enable_u8, u8 *v_intr_enable_2_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_enable_u8) {
+		case BMI160_NOMOTION_X_ENABLE:
+			/* read no motion x */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_2_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE);
+			break;
+		case BMI160_NOMOTION_Y_ENABLE:
+			/* read no motion y */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_2_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE);
+			break;
+		case BMI160_NOMOTION_Z_ENABLE:
+			/* read no motion z */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_enable_2_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  This API is used to set
+ *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
+ *	@brief It reads no motion x,y and z
+ *
+ *
+ *
+ *	@param v_enable_u8: The value of interrupt enable
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_NOMOTION_X_ENABLE
+ *       1         | BMI160_NOMOTION_Y_ENABLE
+ *       2         | BMI160_NOMOTION_Z_ENABLE
+ *
+ *	@param v_intr_enable_2_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_2(
+u8 v_enable_u8, u8 v_intr_enable_2_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_enable_u8) {
+	case BMI160_NOMOTION_X_ENABLE:
+		/* write no motion x */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr,
+		BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE,
+			v_intr_enable_2_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_NOMOTION_Y_ENABLE:
+		/* write no motion y */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr,
+		BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE,
+			v_intr_enable_2_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_NOMOTION_Z_ENABLE:
+		/* write no motion z */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr,
+		BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE,
+			v_intr_enable_2_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read
+ *	interrupt enable step detector interrupt from
+ *	the register bit 0x52 bit 3
+ *
+ *
+ *
+ *
+ *	@param v_step_intr_u8 : The value of step detector interrupt enable
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_detector_enable(
+u8 *v_step_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the step detector interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_step_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to set
+ *	interrupt enable step detector interrupt from
+ *	the register bit 0x52 bit 3
+ *
+ *
+ *
+ *
+ *	@param v_step_intr_u8 : The value of step detector interrupt enable
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_detector_enable(
+u8 v_step_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr,
+		BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE,
+			v_step_intr_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr,
+			BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  Configure trigger condition of interrupt1
+ *	and interrupt2 pin from the register 0x53
+ *	@brief interrupt1 - bit 0
+ *	@brief interrupt2 - bit 4
+ *
+ *  @param v_channel_u8: The value of edge trigger selection
+ *   v_channel_u8  |   Edge trigger
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_EDGE_CTRL
+ *       1         | BMI160_INTR2_EDGE_CTRL
+ *
+ *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_EDGE
+ *  0x00     |  BMI160_LEVEL
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_edge_ctrl(
+u8 v_channel_u8, u8 *v_intr_edge_ctrl_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_EDGE_CTRL:
+			/* read the edge trigger interrupt1*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_EDGE_CTRL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_edge_ctrl_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR1_EDGE_CTRL);
+			break;
+		case BMI160_INTR2_EDGE_CTRL:
+			/* read the edge trigger interrupt2*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_EDGE_CTRL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_edge_ctrl_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR2_EDGE_CTRL);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  Configure trigger condition of interrupt1
+ *	and interrupt2 pin from the register 0x53
+ *	@brief interrupt1 - bit 0
+ *	@brief interrupt2 - bit 4
+ *
+ *  @param v_channel_u8: The value of edge trigger selection
+ *   v_channel_u8  |   Edge trigger
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_EDGE_CTRL
+ *       1         | BMI160_INTR2_EDGE_CTRL
+ *
+ *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_EDGE
+ *  0x00     |  BMI160_LEVEL
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_edge_ctrl(
+u8 v_channel_u8, u8 v_intr_edge_ctrl_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_EDGE_CTRL:
+			/* write the edge trigger interrupt1*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_EDGE_CTRL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR1_EDGE_CTRL,
+				v_intr_edge_ctrl_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR1_EDGE_CTRL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		case BMI160_INTR2_EDGE_CTRL:
+			/* write the edge trigger interrupt2*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_EDGE_CTRL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR2_EDGE_CTRL,
+				v_intr_edge_ctrl_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR2_EDGE_CTRL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  API used for get the Configure level condition of interrupt1
+ *	and interrupt2 pin form the register 0x53
+ *	@brief interrupt1 - bit 1
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of level condition selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_LEVEL
+ *       1         | BMI160_INTR2_LEVEL
+ *
+ *	@param v_intr_level_u8 : The value of level of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_LEVEL_HIGH
+ *  0x00     |  BMI160_LEVEL_LOW
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_level(
+u8 v_channel_u8, u8 *v_intr_level_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_LEVEL:
+			/* read the interrupt1 level*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_LEVEL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_level_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR1_LEVEL);
+			break;
+		case BMI160_INTR2_LEVEL:
+			/* read the interrupt2 level*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_LEVEL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_level_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR2_LEVEL);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  API used for set the Configure level condition of interrupt1
+ *	and interrupt2 pin form the register 0x53
+ *	@brief interrupt1 - bit 1
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of level condition selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_LEVEL
+ *       1         | BMI160_INTR2_LEVEL
+ *
+ *	@param v_intr_level_u8 : The value of level of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_LEVEL_HIGH
+ *  0x00     |  BMI160_LEVEL_LOW
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_level(
+u8 v_channel_u8, u8 v_intr_level_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_LEVEL:
+			/* write the interrupt1 level*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_LEVEL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR1_LEVEL, v_intr_level_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR1_LEVEL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		case BMI160_INTR2_LEVEL:
+			/* write the interrupt2 level*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_LEVEL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR2_LEVEL, v_intr_level_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR2_LEVEL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  API used to get configured output enable of interrupt1
+ *	and interrupt2 from the register 0x53
+ *	@brief interrupt1 - bit 2
+ *	@brief interrupt2 - bit 6
+ *
+ *
+ *  @param v_channel_u8: The value of output type enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_intr_output_type_u8 :
+ *	The value of output type of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_OPEN_DRAIN
+ *  0x00     |  BMI160_PUSH_PULL
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_output_type(
+u8 v_channel_u8, u8 *v_intr_output_type_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_OUTPUT_TYPE:
+			/* read the output type of interrupt1*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_OUTPUT_TYPE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_output_type_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR1_OUTPUT_TYPE);
+			break;
+		case BMI160_INTR2_OUTPUT_TYPE:
+			/* read the output type of interrupt2*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_OUTPUT_TYPE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_output_type_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR2_OUTPUT_TYPE);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief  API used to set output enable of interrupt1
+ *	and interrupt2 from the register 0x53
+ *	@brief interrupt1 - bit 2
+ *	@brief interrupt2 - bit 6
+ *
+ *
+ *  @param v_channel_u8: The value of output type enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_intr_output_type_u8 :
+ *	The value of output type of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_OPEN_DRAIN
+ *  0x00     |  BMI160_PUSH_PULL
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_output_type(
+u8 v_channel_u8, u8 v_intr_output_type_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_OUTPUT_TYPE:
+			/* write the output type of interrupt1*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_OUTPUT_TYPE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR1_OUTPUT_TYPE,
+				v_intr_output_type_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR1_OUTPUT_TYPE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		case BMI160_INTR2_OUTPUT_TYPE:
+			/* write the output type of interrupt2*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_OUTPUT_TYPE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR2_OUTPUT_TYPE,
+				v_intr_output_type_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR2_OUTPUT_TYPE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief API used to get the Output enable for interrupt1
+ *	and interrupt1 pin from the register 0x53
+ *	@brief interrupt1 - bit 3
+ *	@brief interrupt2 - bit 7
+ *
+ *  @param v_channel_u8: The value of output enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_output_enable_u8 :
+ *	The value of output enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_output_enable(
+u8 v_channel_u8, u8 *v_output_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_OUTPUT_ENABLE:
+			/* read the output enable of interrupt1*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_OUTPUT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_output_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR1_OUTPUT_ENABLE);
+			break;
+		case BMI160_INTR2_OUTPUT_ENABLE:
+			/* read the output enable of interrupt2*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_OUTPUT_EN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_output_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR2_OUTPUT_EN);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief API used to set the Output enable for interrupt1
+ *	and interrupt1 pin from the register 0x53
+ *	@brief interrupt1 - bit 3
+ *	@brief interrupt2 - bit 7
+ *
+ *  @param v_channel_u8: The value of output enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_output_enable_u8 :
+ *	The value of output enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_output_enable(
+u8 v_channel_u8, u8 v_output_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_OUTPUT_ENABLE:
+			/* write the output enable of interrupt1*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_OUTPUT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR1_OUTPUT_ENABLE,
+				v_output_enable_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR1_OUTPUT_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_INTR2_OUTPUT_ENABLE:
+			/* write the output enable of interrupt2*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_OUTPUT_EN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR2_OUTPUT_EN,
+				v_output_enable_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR2_OUTPUT_EN__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+*	@brief This API is used to get the latch duration
+*	from the register 0x54 bit 0 to 3
+*	@brief This latch selection is not applicable for data ready,
+*	orientation and flat interrupts.
+*
+*
+*
+*  @param v_latch_intr_u8 : The value of latch duration
+*	Latch Duration                      |     value
+* --------------------------------------|------------------
+*    BMI160_LATCH_DUR_NONE              |      0x00
+*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
+*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
+*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
+*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
+*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
+*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
+*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
+*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
+*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
+*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
+*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
+*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
+*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
+*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
+*    BMI160_LATCHED                     |      0x0F
+*
+*
+*
+*	@return results of bus communication function
+*	@retval 0 -> Success
+*	@retval -1 -> Error
+*
+*
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_latch_intr(
+u8 *v_latch_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the latch duration value */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_LATCH__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_latch_intr_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LATCH);
+		}
+	return com_rslt;
+}
+/*!
+*	@brief This API is used to set the latch duration
+*	from the register 0x54 bit 0 to 3
+*	@brief This latch selection is not applicable for data ready,
+*	orientation and flat interrupts.
+*
+*
+*
+*  @param v_latch_intr_u8 : The value of latch duration
+*	Latch Duration                      |     value
+* --------------------------------------|------------------
+*    BMI160_LATCH_DUR_NONE              |      0x00
+*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
+*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
+*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
+*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
+*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
+*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
+*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
+*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
+*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
+*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
+*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
+*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
+*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
+*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
+*    BMI160_LATCHED                     |      0x0F
+*
+*
+*
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+*
+*
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_latch_intr(u8 v_latch_intr_u8)
+{
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_latch_intr_u8 <= BMI160_MAX_LATCH_INTR) {
+			/* write the latch duration value */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_LATCH__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_LATCH, v_latch_intr_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr, BMI160_USER_INTR_LATCH__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief API used to get input enable for interrupt1
+ *	and interrupt2 pin from the register 0x54
+ *	@brief interrupt1 - bit 4
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of input enable selection
+ *   v_channel_u8  |   input selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_INPUT_ENABLE
+ *       1         | BMI160_INTR2_INPUT_ENABLE
+ *
+ *	@param v_input_en_u8 :
+ *	The value of input enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_input_enable(
+u8 v_channel_u8, u8 *v_input_en_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read input enable of interrup1 and interrupt2*/
+		case BMI160_INTR1_INPUT_ENABLE:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_INPUT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_input_en_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR1_INPUT_ENABLE);
+			break;
+		case BMI160_INTR2_INPUT_ENABLE:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_INPUT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_input_en_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR2_INPUT_ENABLE);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief API used to set input enable for interrupt1
+ *	and interrupt2 pin from the register 0x54
+ *	@brief interrupt1 - bit 4
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of input enable selection
+ *   v_channel_u8  |   input selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_INPUT_ENABLE
+ *       1         | BMI160_INTR2_INPUT_ENABLE
+ *
+ *	@param v_input_en_u8 :
+ *	The value of input enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_input_enable(
+u8 v_channel_u8, u8 v_input_en_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* write input enable of interrup1 and interrupt2*/
+	case BMI160_INTR1_INPUT_ENABLE:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR1_INPUT_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR1_INPUT_ENABLE, v_input_en_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR1_INPUT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	case BMI160_INTR2_INPUT_ENABLE:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR2_INPUT_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR2_INPUT_ENABLE, v_input_en_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR2_INPUT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief reads the Low g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 0 in the register 0x55
+ *	@brief interrupt2 bit 0 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of low_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_LOW_G
+ *       1         | BMI160_INTR2_MAP_LOW_G
+ *
+ *	@param v_intr_low_g_u8 : The value of low_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g(
+u8 v_channel_u8, u8 *v_intr_low_g_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the low_g interrupt */
+		case BMI160_INTR1_MAP_LOW_G:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_low_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_LOW_G);
+			break;
+		case BMI160_INTR2_MAP_LOW_G:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_low_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_LOW_G);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief set the Low g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 0 in the register 0x55
+ *	@brief interrupt2 bit 0 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of low_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_LOW_G
+ *       1         | BMI160_INTR2_MAP_LOW_G
+ *
+ *	@param v_intr_low_g_u8 : The value of low_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g(
+u8 v_channel_u8, u8 v_intr_low_g_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u8 v_step_cnt_stat_u8 = BMI160_INIT_VALUE;
+u8 v_step_det_stat_u8 = BMI160_INIT_VALUE;
+
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	/* check the step detector interrupt enable status*/
+	com_rslt = bmi160_get_step_detector_enable(&v_step_det_stat_u8);
+	/* disable the step detector interrupt */
+	if (v_step_det_stat_u8 != BMI160_INIT_VALUE)
+		com_rslt += bmi160_set_step_detector_enable(BMI160_INIT_VALUE);
+	/* check the step counter interrupt enable status*/
+	com_rslt += bmi160_get_step_counter_enable(&v_step_cnt_stat_u8);
+	/* disable the step counter interrupt */
+	if (v_step_cnt_stat_u8 != BMI160_INIT_VALUE)
+			com_rslt += bmi160_set_step_counter_enable(
+			BMI160_INIT_VALUE);
+	switch (v_channel_u8) {
+	/* write the low_g interrupt*/
+	case BMI160_INTR1_MAP_LOW_G:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_LOW_G, v_intr_low_g_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_INTR2_MAP_LOW_G:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_LOW_G, v_intr_low_g_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads the HIGH g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 1 in the register 0x55
+ *	@brief interrupt2 bit 1 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of high_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_HIGH_G
+ *       1         | BMI160_INTR2_MAP_HIGH_G
+ *
+ *	@param v_intr_high_g_u8 : The value of high_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g(
+u8 v_channel_u8, u8 *v_intr_high_g_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* read the high_g interrupt*/
+		switch (v_channel_u8) {
+		case BMI160_INTR1_MAP_HIGH_G:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_high_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_HIGH_G);
+		break;
+		case BMI160_INTR2_MAP_HIGH_G:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_high_g_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_HIGH_G);
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write the HIGH g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 1 in the register 0x55
+ *	@brief interrupt2 bit 1 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of high_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_HIGH_G
+ *       1         | BMI160_INTR2_MAP_HIGH_G
+ *
+ *	@param v_intr_high_g_u8 : The value of high_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g(
+u8 v_channel_u8, u8 v_intr_high_g_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* write the high_g interrupt*/
+	case BMI160_INTR1_MAP_HIGH_G:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_HIGH_G, v_intr_high_g_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	case BMI160_INTR2_MAP_HIGH_G:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_HIGH_G, v_intr_high_g_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads the Any motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 2 in the register 0x55
+ *	@brief interrupt2 bit 2 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of any motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ANY_MOTION
+ *       1         | BMI160_INTR2_MAP_ANY_MOTION
+ *
+ *	@param v_intr_any_motion_u8 : The value of any motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion(
+u8 v_channel_u8, u8 *v_intr_any_motion_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the any motion interrupt */
+		case BMI160_INTR1_MAP_ANY_MOTION:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_any_motion_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION);
+		break;
+		case BMI160_INTR2_MAP_ANY_MOTION:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_any_motion_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION);
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write the Any motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 2 in the register 0x55
+ *	@brief interrupt2 bit 2 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of any motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ANY_MOTION
+ *       1         | BMI160_INTR2_MAP_ANY_MOTION
+ *
+ *	@param v_intr_any_motion_u8 : The value of any motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion(
+u8 v_channel_u8, u8 v_intr_any_motion_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u8 sig_mot_stat = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	/* read the status of significant motion interrupt */
+	com_rslt = bmi160_get_intr_significant_motion_select(&sig_mot_stat);
+	/* disable the significant motion interrupt */
+	if (sig_mot_stat != BMI160_INIT_VALUE)
+		com_rslt += bmi160_set_intr_significant_motion_select(
+		BMI160_INIT_VALUE);
+	switch (v_channel_u8) {
+	/* write the any motion interrupt */
+	case BMI160_INTR1_MAP_ANY_MOTION:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION,
+			v_intr_any_motion_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	case BMI160_INTR2_MAP_ANY_MOTION:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION,
+			v_intr_any_motion_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads the No motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 3 in the register 0x55
+ *	@brief interrupt2 bit 3 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of no motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_NOMO
+ *       1         | BMI160_INTR2_MAP_NOMO
+ *
+ *	@param v_intr_nomotion_u8 : The value of no motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_nomotion(
+u8 v_channel_u8, u8 *v_intr_nomotion_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the no motion interrupt*/
+		case BMI160_INTR1_MAP_NOMO:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_nomotion_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_NOMOTION);
+			break;
+		case BMI160_INTR2_MAP_NOMO:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_nomotion_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_NOMOTION);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write the No motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 3 in the register 0x55
+ *	@brief interrupt2 bit 3 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of no motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_NOMO
+ *       1         | BMI160_INTR2_MAP_NOMO
+ *
+ *	@param v_intr_nomotion_u8 : The value of no motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_nomotion(
+u8 v_channel_u8, u8 v_intr_nomotion_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* write the no motion interrupt*/
+	case BMI160_INTR1_MAP_NOMO:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_NOMOTION,
+			v_intr_nomotion_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_INTR2_MAP_NOMO:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_NOMOTION,
+			v_intr_nomotion_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads the Double Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 4 in the register 0x55
+ *	@brief interrupt2 bit 4 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of double tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
+ *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
+ *
+ *	@param v_intr_double_tap_u8 : The value of double tap enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_double_tap(
+u8 v_channel_u8, u8 *v_intr_double_tap_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		case BMI160_INTR1_MAP_DOUBLE_TAP:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_double_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP);
+			break;
+		case BMI160_INTR2_MAP_DOUBLE_TAP:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_double_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write the Double Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 4 in the register 0x55
+ *	@brief interrupt2 bit 4 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of double tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
+ *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
+ *
+ *	@param v_intr_double_tap_u8 : The value of double tap enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_double_tap(
+u8 v_channel_u8, u8 v_intr_double_tap_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* set the double tap interrupt */
+	case BMI160_INTR1_MAP_DOUBLE_TAP:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP,
+			v_intr_double_tap_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_INTR2_MAP_DOUBLE_TAP:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP,
+			v_intr_double_tap_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads the Single Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 5 in the register 0x55
+ *	@brief interrupt2 bit 5 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of single tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_SINGLE_TAP
+ *       1         | BMI160_INTR2_MAP_SINGLE_TAP
+ *
+ *	@param v_intr_single_tap_u8 : The value of single tap  enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_single_tap(
+u8 v_channel_u8, u8 *v_intr_single_tap_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* reads the single tap interrupt*/
+		case BMI160_INTR1_MAP_SINGLE_TAP:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_single_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP);
+			break;
+		case BMI160_INTR2_MAP_SINGLE_TAP:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_single_tap_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write the Single Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 5 in the register 0x55
+ *	@brief interrupt2 bit 5 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of single tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_SINGLE_TAP
+ *       1         | BMI160_INTR2_MAP_SINGLE_TAP
+ *
+ *	@param v_intr_single_tap_u8 : The value of single tap  enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_single_tap(
+u8 v_channel_u8, u8 v_intr_single_tap_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* write the single tap interrupt */
+	case BMI160_INTR1_MAP_SINGLE_TAP:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP,
+			v_intr_single_tap_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_INTR2_MAP_SINGLE_TAP:
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP,
+			v_intr_single_tap_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads the Orient interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 6 in the register 0x55
+ *	@brief interrupt2 bit 6 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of orient interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ORIENT
+ *       1         | BMI160_INTR2_MAP_ORIENT
+ *
+ *	@param v_intr_orient_u8 : The value of orient enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient(
+u8 v_channel_u8, u8 *v_intr_orient_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the orientation interrupt*/
+		case BMI160_INTR1_MAP_ORIENT:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_orient_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_ORIENT);
+			break;
+		case BMI160_INTR2_MAP_ORIENT:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_orient_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_ORIENT);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write the Orient interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 6 in the register 0x55
+ *	@brief interrupt2 bit 6 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of orient interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ORIENT
+ *       1         | BMI160_INTR2_MAP_ORIENT
+ *
+ *	@param v_intr_orient_u8 : The value of orient enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient(
+u8 v_channel_u8, u8 v_intr_orient_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* write the orientation interrupt*/
+	case BMI160_INTR1_MAP_ORIENT:
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_ORIENT, v_intr_orient_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	case BMI160_INTR2_MAP_ORIENT:
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 =
+			BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_ORIENT, v_intr_orient_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+		break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief Reads the Flat interrupt
+ *	mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 7 in the register 0x55
+ *	@brief interrupt2 bit 7 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of flat interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FLAT
+ *       1         | BMI160_INTR2_MAP_FLAT
+ *
+ *	@param v_intr_flat_u8 : The value of flat enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat(
+u8 v_channel_u8, u8 *v_intr_flat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the flat interrupt*/
+		case BMI160_INTR1_MAP_FLAT:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_flat_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_0_INTR1_FLAT);
+			break;
+		case BMI160_INTR2_MAP_FLAT:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_flat_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_2_INTR2_FLAT);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief Write the Flat interrupt
+ *	mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 7 in the register 0x55
+ *	@brief interrupt2 bit 7 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of flat interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FLAT
+ *       1         | BMI160_INTR2_MAP_FLAT
+ *
+ *	@param v_intr_flat_u8 : The value of flat enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat(
+u8 v_channel_u8, u8 v_intr_flat_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* write the flat interrupt */
+		case BMI160_INTR1_MAP_FLAT:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_MAP_0_INTR1_FLAT,
+				v_intr_flat_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		case BMI160_INTR2_MAP_FLAT:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_MAP_2_INTR2_FLAT,
+				v_intr_flat_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Reads PMU trigger interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 0 and 4
+ *	@brief interrupt1 bit 0 in the register 0x56
+ *	@brief interrupt2 bit 4 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of pmu trigger selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_PMUTRIG
+ *       1         | BMI160_INTR2_MAP_PMUTRIG
+ *
+ *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_pmu_trig(
+u8 v_channel_u8, u8 *v_intr_pmu_trig_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the pmu trigger interrupt*/
+		case BMI160_INTR1_MAP_PMUTRIG:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_pmu_trig_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG);
+			break;
+		case BMI160_INTR2_MAP_PMUTRIG:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_pmu_trig_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write PMU trigger interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 0 and 4
+ *	@brief interrupt1 bit 0 in the register 0x56
+ *	@brief interrupt2 bit 4 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of pmu trigger selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_PMUTRIG
+ *       1         | BMI160_INTR2_MAP_PMUTRIG
+ *
+ *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
+ *	value    | trigger enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_pmu_trig(
+u8 v_channel_u8, u8 v_intr_pmu_trig_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/* write the pmu trigger interrupt */
+	case BMI160_INTR1_MAP_PMUTRIG:
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 =
+			BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG,
+			v_intr_pmu_trig_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	case BMI160_INTR2_MAP_PMUTRIG:
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 =
+			BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG,
+			v_intr_pmu_trig_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief Reads FIFO Full interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 5 and 1
+ *	@brief interrupt1 bit 5 in the register 0x56
+ *	@brief interrupt2 bit 1 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo full interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_FULL
+ *       1         | BMI160_INTR2_MAP_FIFO_FULL
+ *
+ *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_full(
+u8 v_channel_u8, u8 *v_intr_fifo_full_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the fifo full interrupt */
+		case BMI160_INTR1_MAP_FIFO_FULL:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_fifo_full_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL);
+		break;
+		case BMI160_INTR2_MAP_FIFO_FULL:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_fifo_full_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL);
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write FIFO Full interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 5 and 1
+ *	@brief interrupt1 bit 5 in the register 0x56
+ *	@brief interrupt2 bit 1 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo full interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_FULL
+ *       1         | BMI160_INTR2_MAP_FIFO_FULL
+ *
+ *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_full(
+u8 v_channel_u8, u8 v_intr_fifo_full_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* write the fifo full interrupt */
+		case BMI160_INTR1_MAP_FIFO_FULL:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL,
+				v_intr_fifo_full_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		case BMI160_INTR2_MAP_FIFO_FULL:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL,
+				v_intr_fifo_full_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Reads FIFO Watermark interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 6 and 2
+ *	@brief interrupt1 bit 6 in the register 0x56
+ *	@brief interrupt2 bit 2 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo Watermark interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_WM
+ *       1         | BMI160_INTR2_MAP_FIFO_WM
+ *
+ *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_wm(
+u8 v_channel_u8, u8 *v_intr_fifo_wm_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* read the fifo water mark interrupt */
+		case BMI160_INTR1_MAP_FIFO_WM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_fifo_wm_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM);
+			break;
+		case BMI160_INTR2_MAP_FIFO_WM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_fifo_wm_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write FIFO Watermark interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 6 and 2
+ *	@brief interrupt1 bit 6 in the register 0x56
+ *	@brief interrupt2 bit 2 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo Watermark interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_WM
+ *       1         | BMI160_INTR2_MAP_FIFO_WM
+ *
+ *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_wm(
+u8 v_channel_u8, u8 v_intr_fifo_wm_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/* write the fifo water mark interrupt */
+		case BMI160_INTR1_MAP_FIFO_WM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM,
+				v_intr_fifo_wm_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		case BMI160_INTR2_MAP_FIFO_WM:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM,
+				v_intr_fifo_wm_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+				dev_addr,
+				BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Reads Data Ready interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56
+ *	@brief interrupt1 bit 7 in the register 0x56
+ *	@brief interrupt2 bit 3 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of data ready interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DATA_RDY
+ *       1         | BMI160_INTR2_MAP_DATA_RDY
+ *
+ *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_data_rdy(
+u8 v_channel_u8, u8 *v_intr_data_rdy_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		switch (v_channel_u8) {
+		/*Read Data Ready interrupt*/
+		case BMI160_INTR1_MAP_DATA_RDY:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY);
+			break;
+		case BMI160_INTR2_MAP_DATA_RDY:
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_data_rdy_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY);
+			break;
+		default:
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+			break;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief Write Data Ready interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56
+ *	@brief interrupt1 bit 7 in the register 0x56
+ *	@brief interrupt2 bit 3 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of data ready interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DATA_RDY
+ *       1         | BMI160_INTR2_MAP_DATA_RDY
+ *
+ *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_data_rdy(
+u8 v_channel_u8, u8 v_intr_data_rdy_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	switch (v_channel_u8) {
+	/*Write Data Ready interrupt*/
+	case BMI160_INTR1_MAP_DATA_RDY:
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY,
+			v_intr_data_rdy_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	case BMI160_INTR2_MAP_DATA_RDY:
+		com_rslt =
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->
+		dev_addr, BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY,
+			v_intr_data_rdy_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC(p_bmi160->
+			dev_addr, BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	break;
+	default:
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API reads data source for the interrupt
+ *	engine for the single and double tap interrupts from the register
+ *	0x58 bit 3
+ *
+ *
+ *  @param v_tap_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_source(u8 *v_tap_source_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the tap source interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_source_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write data source for the interrupt
+ *	engine for the single and double tap interrupts from the register
+ *	0x58 bit 3
+ *
+ *
+ *  @param v_tap_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_source(
+u8 v_tap_source_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_tap_source_u8 <= BMI160_MAX_VALUE_SOURCE_INTR) {
+			/* write the tap source interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE,
+				v_tap_source_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API Reads Data source for the
+ *	interrupt engine for the low and high g interrupts
+ *	from the register 0x58 bit 7
+ *
+ *  @param v_low_high_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_high_source(
+u8 *v_low_high_source_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the high_low_g source interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_low_high_source_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write Data source for the
+ *	interrupt engine for the low and high g interrupts
+ *	from the register 0x58 bit 7
+ *
+ *  @param v_low_high_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_high_source(
+u8 v_low_high_source_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_low_high_source_u8 <= BMI160_MAX_VALUE_SOURCE_INTR) {
+		/* write the high_low_g source interrupt */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE,
+			v_low_high_source_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API reads Data source for the
+ *	interrupt engine for the nomotion and anymotion interrupts
+ *	from the register 0x59 bit 7
+ *
+ *  @param v_motion_source_u8 :
+ *	The value of the any/no motion interrupt source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_motion_source(
+u8 *v_motion_source_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the any/no motion interrupt  */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_motion_source_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write Data source for the
+ *	interrupt engine for the nomotion and anymotion interrupts
+ *	from the register 0x59 bit 7
+ *
+ *  @param v_motion_source_u8 :
+ *	The value of the any/no motion interrupt source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_motion_source(
+u8 v_motion_source_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_motion_source_u8 <= BMI160_MAX_VALUE_SOURCE_INTR) {
+			/* write the any/no motion interrupt  */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE,
+				v_motion_source_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read the low_g duration from register
+ *	0x5A bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_durn_u8 : The value of low_g duration
+ *
+ *	@note Low_g duration trigger trigger delay according to
+ *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
+ *	the default corresponds delay is 20ms
+ *	@note When low_g data source of interrupt is unfiltered
+ *	the sensor must not be in low power mode
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_durn(
+u8 *v_low_g_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the low_g interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_low_g_durn_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to write the low_g duration from register
+ *	0x5A bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_durn_u8 : The value of low_g duration
+ *
+ *	@note Low_g duration trigger trigger delay according to
+ *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
+ *	the default corresponds delay is 20ms
+ *	@note When low_g data source of interrupt is unfiltered
+ *	the sensor must not be in low power mode
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_durn(u8 v_low_g_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the low_g interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__REG,
+			&v_low_g_durn_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read Threshold
+ *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_thres_u8 : The value of low_g threshold
+ *
+ *	@note Low_g interrupt trigger threshold according to
+ *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
+ *	3.91 mg for v_low_g_thres_u8 = 0
+ *	The threshold range is form 3.91mg to 2.000mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_thres(
+u8 *v_low_g_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read low_g threshold */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_low_g_thres_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to write Threshold
+ *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_thres_u8 : The value of low_g threshold
+ *
+ *	@note Low_g interrupt trigger threshold according to
+ *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
+ *	3.91 mg for v_low_g_thres_u8 = 0
+ *	The threshold range is form 3.91mg to 2.000mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_thres(
+u8 v_low_g_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write low_g threshold */
+			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__REG,
+			&v_low_g_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API Reads Low-g interrupt hysteresis
+ *	from the register 0x5C bit 0 to 1
+ *
+ *  @param v_low_hyst_u8 :The value of low_g hysteresis
+ *
+ *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_hyst(
+u8 *v_low_hyst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read low_g hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_low_hyst_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write Low-g interrupt hysteresis
+ *	from the register 0x5C bit 0 to 1
+ *
+ *  @param v_low_hyst_u8 :The value of low_g hysteresis
+ *
+ *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_hyst(
+u8 v_low_hyst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write low_g hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST,
+				v_low_hyst_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads Low-g interrupt mode
+ *	from the register 0x5C bit 2
+ *
+ *  @param v_low_g_mode_u8 : The value of low_g mode
+ *	Value    |  Description
+ * ----------|-----------------
+ *	   0     | single-axis
+ *     1     | axis-summing
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_mode(u8 *v_low_g_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/*read Low-g interrupt mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_low_g_mode_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write Low-g interrupt mode
+ *	from the register 0x5C bit 2
+ *
+ *  @param v_low_g_mode_u8 : The value of low_g mode
+ *	Value    |  Description
+ * ----------|-----------------
+ *	   0     | single-axis
+ *     1     | axis-summing
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_mode(
+u8 v_low_g_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_low_g_mode_u8 <= BMI160_MAX_VALUE_LOW_G_MODE) {
+			/*write Low-g interrupt mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE,
+				v_low_g_mode_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads High-g interrupt hysteresis
+ *	from the register 0x5C bit 6 and 7
+ *
+ *  @param v_high_g_hyst_u8 : The value of high hysteresis
+ *
+ *	@note High_g hysteresis changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g hysteresis
+ *  ----------------|---------------------
+ *      2g          |  high_hy*125 mg
+ *      4g          |  high_hy*250 mg
+ *      8g          |  high_hy*500 mg
+ *      16g         |  high_hy*1000 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_hyst(
+u8 *v_high_g_hyst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read high_g hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_hyst_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write High-g interrupt hysteresis
+ *	from the register 0x5C bit 6 and 7
+ *
+ *  @param v_high_g_hyst_u8 : The value of high hysteresis
+ *
+ *	@note High_g hysteresis changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g hysteresis
+ *  ----------------|---------------------
+ *      2g          |  high_hy*125 mg
+ *      4g          |  high_hy*250 mg
+ *      8g          |  high_hy*500 mg
+ *      16g         |  high_hy*1000 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_hyst(
+u8 v_high_g_hyst_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* write high_g hysteresis*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST,
+			v_high_g_hyst_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API is used to read Delay
+ *	time definition for the high-g interrupt from the register
+ *	0x5D bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_high_g_durn_u8 :  The value of high duration
+ *
+ *	@note High_g interrupt delay triggered according to
+ *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_durn(
+u8 *v_high_g_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read high_g duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_durn_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to write Delay
+ *	time definition for the high-g interrupt from the register
+ *	0x5D bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_high_g_durn_u8 :  The value of high duration
+ *
+ *	@note High_g interrupt delay triggered according to
+ *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_durn(
+u8 v_high_g_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write high_g duration*/
+			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__REG,
+			&v_high_g_durn_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to read Threshold
+ *	definition for the high-g interrupt from the register 0x5E 0 to 7
+ *
+ *
+ *
+ *
+ *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
+ *	@note High_g threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  v_high_g_thres_u8*7.81 mg
+ *      4g          |  v_high_g_thres_u8*15.63 mg
+ *      8g          |  v_high_g_thres_u8*31.25 mg
+ *      16g         |  v_high_g_thres_u8*62.5 mg
+ *	@note when v_high_g_thres_u8 = 0
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  3.91 mg
+ *      4g          |  7.81 mg
+ *      8g          |  15.63 mg
+ *      16g         |  31.25 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_thres(
+u8 *v_high_g_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_high_g_thres_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES);
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to write Threshold
+ *	definition for the high-g interrupt from the register 0x5E 0 to 7
+ *
+ *
+ *
+ *
+ *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
+ *	@note High_g threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  v_high_g_thres_u8*7.81 mg
+ *      4g          |  v_high_g_thres_u8*15.63 mg
+ *      8g          |  v_high_g_thres_u8*31.25 mg
+ *      16g         |  v_high_g_thres_u8*62.5 mg
+ *	@note when v_high_g_thres_u8 = 0
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  3.91 mg
+ *      4g          |  7.81 mg
+ *      8g          |  15.63 mg
+ *      16g         |  31.25 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_thres(
+u8 v_high_g_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__REG,
+		&v_high_g_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads any motion duration
+ *	from the register 0x5F bit 0 and 1
+ *
+ *  @param v_any_motion_durn_u8 : The value of any motion duration
+ *
+ *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_durn(
+u8 *v_any_motion_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* read any motion duration*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_any_motion_durn_u8 = BMI160_GET_BITSLICE
+		(v_data_u8,
+		BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN);
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write any motion duration
+ *	from the register 0x5F bit 0 and 1
+ *
+ *  @param v_any_motion_durn_u8 : The value of any motion duration
+ *
+ *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_durn(
+u8 v_any_motion_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* write any motion duration*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN,
+			v_any_motion_durn_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read Slow/no-motion
+ *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
+ *
+ *  @param v_slow_no_motion_u8 :The value of slow no motion duration
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *	@note
+ *	@note v_slow_no_motion_u8(5:4)=0b00 ->
+ *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
+ *	@note v_slow_no_motion_u8(5:4)=1 ->
+ *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
+ *	@note v_slow_no_motion_u8(5)='1' ->
+ *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_durn(
+u8 *v_slow_no_motion_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* read slow no motion duration*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_slow_no_motion_u8 = BMI160_GET_BITSLICE
+		(v_data_u8,
+		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN);
+	}
+return com_rslt;
+}
+ /*!
+ *	@brief This API write Slow/no-motion
+ *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
+ *
+ *  @param v_slow_no_motion_u8 :The value of slow no motion duration
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *	@note
+ *	@note v_slow_no_motion_u8(5:4)=0b00 ->
+ *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
+ *	@note v_slow_no_motion_u8(5:4)=1 ->
+ *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
+ *	@note v_slow_no_motion_u8(5)='1' ->
+ *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_durn(
+u8 v_slow_no_motion_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	/* write slow no motion duration*/
+	com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+	(p_bmi160->dev_addr,
+	BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG,
+	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	if (com_rslt == SUCCESS) {
+		v_data_u8 = BMI160_SET_BITSLICE
+		(v_data_u8,
+		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN,
+		v_slow_no_motion_u8);
+		com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief This API is used to read threshold
+ *	definition for the any-motion interrupt
+ *	from the register 0x60 bit 0 to 7
+ *
+ *
+ *  @param  v_any_motion_thres_u8 : The value of any motion threshold
+ *
+ *	@note any motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_any_motion_thres_u8*3.91 mg
+ *      4g          |  v_any_motion_thres_u8*7.81 mg
+ *      8g          |  v_any_motion_thres_u8*15.63 mg
+ *      16g         |  v_any_motion_thres_u8*31.25 mg
+ *	@note when v_any_motion_thres_u8 = 0
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_thres(
+u8 *v_any_motion_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read any motion threshold*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_any_motion_thres_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to write threshold
+ *	definition for the any-motion interrupt
+ *	from the register 0x60 bit 0 to 7
+ *
+ *
+ *  @param  v_any_motion_thres_u8 : The value of any motion threshold
+ *
+ *	@note any motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_any_motion_thres_u8*3.91 mg
+ *      4g          |  v_any_motion_thres_u8*7.81 mg
+ *      8g          |  v_any_motion_thres_u8*15.63 mg
+ *      16g         |  v_any_motion_thres_u8*31.25 mg
+ *	@note when v_any_motion_thres_u8 = 0
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_thres(
+u8 v_any_motion_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* write any motion threshold*/
+		com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__REG,
+		&v_any_motion_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read threshold
+ *	for the slow/no-motion interrupt
+ *	from the register 0x61 bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
+ *	@note slow no motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
+ *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
+ *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
+ *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
+ *	@note when v_slow_no_motion_thres_u8 = 0
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_thres(
+u8 *v_slow_no_motion_thres_u8)
+{
+BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* read slow no motion threshold*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_slow_no_motion_thres_u8 =
+		BMI160_GET_BITSLICE(v_data_u8,
+		BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES);
+	}
+return com_rslt;
+}
+ /*!
+ *	@brief This API is used to write threshold
+ *	for the slow/no-motion interrupt
+ *	from the register 0x61 bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
+ *	@note slow no motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
+ *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
+ *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
+ *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
+ *	@note when v_slow_no_motion_thres_u8 = 0
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_thres(
+u8 v_slow_no_motion_thres_u8)
+{
+BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* write slow no motion threshold*/
+		com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__REG,
+		&v_slow_no_motion_thres_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read
+ *	the slow/no-motion selection from the register 0x62 bit 0
+ *
+ *
+ *
+ *
+ *  @param  v_intr_slow_no_motion_select_u8 :
+ *	The value of slow/no-motion select
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  SLOW_MOTION
+ *  0x01     |  NO_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_select(
+u8 *v_intr_slow_no_motion_select_u8)
+{
+BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* read slow no motion select*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_intr_slow_no_motion_select_u8 =
+		BMI160_GET_BITSLICE(v_data_u8,
+		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT);
+	}
+return com_rslt;
+}
+ /*!
+ *	@brief This API is used to write
+ *	the slow/no-motion selection from the register 0x62 bit 0
+ *
+ *
+ *
+ *
+ *  @param  v_intr_slow_no_motion_select_u8 :
+ *	The value of slow/no-motion select
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  SLOW_MOTION
+ *  0x01     |  NO_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_select(
+u8 v_intr_slow_no_motion_select_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+} else {
+if (v_intr_slow_no_motion_select_u8 <= BMI160_MAX_VALUE_NO_MOTION) {
+	/* write slow no motion select*/
+	com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+	(p_bmi160->dev_addr,
+	BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG,
+	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	if (com_rslt == SUCCESS) {
+		v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT,
+		v_intr_slow_no_motion_select_u8);
+		com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+} else {
+com_rslt = E_BMI160_OUT_OF_RANGE;
+}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API is used to select
+ *	the significant or any motion interrupt from the register 0x62 bit 1
+ *
+ *
+ *
+ *
+ *  @param  v_intr_significant_motion_select_u8 :
+ *	the value of significant or any motion interrupt selection
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  ANY_MOTION
+ *  0x01     |  SIGNIFICANT_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_select(
+u8 *v_intr_significant_motion_select_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the significant or any motion interrupt*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_intr_significant_motion_select_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to write, select
+ *	the significant or any motion interrupt from the register 0x62 bit 1
+ *
+ *
+ *
+ *
+ *  @param  v_intr_significant_motion_select_u8 :
+ *	the value of significant or any motion interrupt selection
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  ANY_MOTION
+ *  0x01     |  SIGNIFICANT_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_select(
+u8 v_intr_significant_motion_select_u8)
+{
+/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_intr_significant_motion_select_u8 <=
+	BMI160_MAX_VALUE_SIGNIFICANT_MOTION) {
+		/* write the significant or any motion interrupt*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT,
+			v_intr_significant_motion_select_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read
+ *	the significant skip time from the register 0x62 bit  2 and 3
+ *
+ *
+ *
+ *
+ *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  skip time 1.5 seconds
+ *  0x01     |  skip time 3 seconds
+ *  0x02     |  skip time 6 seconds
+ *  0x03     |  skip time 12 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_skip(
+u8 *v_int_sig_mot_skip_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read significant skip time*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_int_sig_mot_skip_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to write
+ *	the significant skip time from the register 0x62 bit  2 and 3
+ *
+ *
+ *
+ *
+ *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  skip time 1.5 seconds
+ *  0x01     |  skip time 3 seconds
+ *  0x02     |  skip time 6 seconds
+ *  0x03     |  skip time 12 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_skip(
+u8 v_int_sig_mot_skip_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_int_sig_mot_skip_u8 <= BMI160_MAX_UNDER_SIG_MOTION) {
+			/* write significant skip time*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP,
+				v_int_sig_mot_skip_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to read
+ *	the significant proof time from the register 0x62 bit  4 and 5
+ *
+ *
+ *
+ *
+ *  @param  v_significant_motion_proof_u8 :
+ *	the value of significant proof time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  proof time 0.25 seconds
+ *  0x01     |  proof time 0.5 seconds
+ *  0x02     |  proof time 1 seconds
+ *  0x03     |  proof time 2 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_proof(
+u8 *v_significant_motion_proof_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read significant proof time */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_significant_motion_proof_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API is used to write
+ *	the significant proof time from the register 0x62 bit  4 and 5
+ *
+ *
+ *
+ *
+ *  @param  v_significant_motion_proof_u8 :
+ *	the value of significant proof time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  proof time 0.25 seconds
+ *  0x01     |  proof time 0.5 seconds
+ *  0x02     |  proof time 1 seconds
+ *  0x03     |  proof time 2 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_proof(
+u8 v_significant_motion_proof_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_significant_motion_proof_u8
+		<= BMI160_MAX_UNDER_SIG_MOTION) {
+			/* write significant proof time */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF,
+				v_significant_motion_proof_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to get the tap duration
+ *	from the register 0x63 bit 0 to 2
+ *
+ *
+ *
+ *  @param v_tap_durn_u8 : The value of tap duration
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_DURN_50MS
+ *  0x01     | BMI160_TAP_DURN_100MS
+ *  0x03     | BMI160_TAP_DURN_150MS
+ *  0x04     | BMI160_TAP_DURN_200MS
+ *  0x05     | BMI160_TAP_DURN_250MS
+ *  0x06     | BMI160_TAP_DURN_375MS
+ *  0x07     | BMI160_TAP_DURN_700MS
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_durn(
+u8 *v_tap_durn_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_durn_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_DURN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API is used to write the tap duration
+ *	from the register 0x63 bit 0 to 2
+ *
+ *
+ *
+ *  @param v_tap_durn_u8 : The value of tap duration
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_DURN_50MS
+ *  0x01     | BMI160_TAP_DURN_100MS
+ *  0x03     | BMI160_TAP_DURN_150MS
+ *  0x04     | BMI160_TAP_DURN_200MS
+ *  0x05     | BMI160_TAP_DURN_250MS
+ *  0x06     | BMI160_TAP_DURN_375MS
+ *  0x07     | BMI160_TAP_DURN_700MS
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_durn(
+u8 v_tap_durn_u8)
+{
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_tap_durn_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_tap_durn_u8 <= BMI160_MAX_TAP_TURN) {
+			switch (v_tap_durn_u8) {
+			case BMI160_TAP_DURN_50MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_50MS;
+				break;
+			case BMI160_TAP_DURN_100MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_100MS;
+				break;
+			case BMI160_TAP_DURN_150MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_150MS;
+				break;
+			case BMI160_TAP_DURN_200MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_200MS;
+				break;
+			case BMI160_TAP_DURN_250MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_250MS;
+				break;
+			case BMI160_TAP_DURN_375MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_375MS;
+				break;
+			case BMI160_TAP_DURN_500MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_500MS;
+				break;
+			case BMI160_TAP_DURN_700MS:
+				v_data_tap_durn_u8 = BMI160_TAP_DURN_700MS;
+				break;
+			default:
+				break;
+			}
+			/* write tap duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_TAP_0_INTR_TAP_DURN,
+				v_data_tap_durn_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read the
+ *	tap shock duration from the register 0x63 bit 2
+ *
+ *  @param v_tap_shock_u8 :The value of tap shock
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_SHOCK_50MS
+ *  0x01     | BMI160_TAP_SHOCK_75MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_shock(
+u8 *v_tap_shock_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap shock duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_shock_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write the
+ *	tap shock duration from the register 0x63 bit 2
+ *
+ *  @param v_tap_shock_u8 :The value of tap shock
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_SHOCK_50MS
+ *  0x01     | BMI160_TAP_SHOCK_75MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_shock(u8 v_tap_shock_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_tap_shock_u8 <= BMI160_MAX_VALUE_TAP_SHOCK) {
+			/* write tap shock duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK,
+				v_tap_shock_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read
+ *	tap quiet duration from the register 0x63 bit 7
+ *
+ *
+ *  @param v_tap_quiet_u8 : The value of tap quiet
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_QUIET_30MS
+ *  0x01     | BMI160_TAP_QUIET_20MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_quiet(
+u8 *v_tap_quiet_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap quiet duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_quiet_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write
+ *	tap quiet duration from the register 0x63 bit 7
+ *
+ *
+ *  @param v_tap_quiet_u8 : The value of tap quiet
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_QUIET_30MS
+ *  0x01     | BMI160_TAP_QUIET_20MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_quiet(u8 v_tap_quiet_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_tap_quiet_u8 <= BMI160_MAX_VALUE_TAP_QUIET) {
+			/* write tap quiet duration*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET,
+				v_tap_quiet_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read Threshold of the
+ *	single/double tap interrupt from the register 0x64 bit 0 to 4
+ *
+ *
+ *	@param v_tap_thres_u8 : The value of single/double tap threshold
+ *
+ *	@note single/double tap threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | single/double tap threshold
+ *  ----------------|---------------------
+ *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
+ *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
+ *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
+ *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_thres(
+u8 *v_tap_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read tap threshold*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_tap_thres_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_TAP_1_INTR_TAP_THRES);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write Threshold of the
+ *	single/double tap interrupt from the register 0x64 bit 0 to 4
+ *
+ *
+ *	@param v_tap_thres_u8 : The value of single/double tap threshold
+ *
+ *	@note single/double tap threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | single/double tap threshold
+ *  ----------------|---------------------
+ *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
+ *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
+ *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
+ *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_thres(
+u8 v_tap_thres_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write tap threshold*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_TAP_1_INTR_TAP_THRES,
+				v_tap_thres_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read the threshold for orientation interrupt
+ *	from the register 0x65 bit 0 and 1
+ *
+ *  @param v_orient_mode_u8 : The value of threshold for orientation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | symmetrical
+ *  0x01     | high-asymmetrical
+ *  0x02     | low-asymmetrical
+ *  0x03     | symmetrical
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_mode(
+u8 *v_orient_mode_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orientation threshold*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_mode_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write the threshold for orientation interrupt
+ *	from the register 0x65 bit 0 and 1
+ *
+ *  @param v_orient_mode_u8 : The value of threshold for orientation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | symmetrical
+ *  0x01     | high-asymmetrical
+ *  0x02     | low-asymmetrical
+ *  0x03     | symmetrical
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_mode(
+u8 v_orient_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_orient_mode_u8 <= BMI160_MAX_ORIENT_MODE) {
+			/* write orientation threshold*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE,
+				v_orient_mode_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read the orient blocking mode
+ *	that is used for the generation of the orientation interrupt.
+ *	from the register 0x65 bit 2 and 3
+ *
+ *  @param v_orient_blocking_u8 : The value of orient blocking mode
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | No blocking
+ *  0x01     | Theta blocking or acceleration in any axis > 1.5g
+ *  0x02     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.2g or acceleration in any axis > 1.5g
+ *  0x03     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.4g or acceleration in any axis >
+ *   -       | 1.5g and value of orient is not stable
+ *   -       | for at least 100 ms
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_blocking(
+u8 *v_orient_blocking_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orient blocking mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_blocking_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write the orient blocking mode
+ *	that is used for the generation of the orientation interrupt.
+ *	from the register 0x65 bit 2 and 3
+ *
+ *  @param v_orient_blocking_u8 : The value of orient blocking mode
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | No blocking
+ *  0x01     | Theta blocking or acceleration in any axis > 1.5g
+ *  0x02     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.2g or acceleration in any axis > 1.5g
+ *  0x03     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.4g or acceleration in any axis >
+ *   -       | 1.5g and value of orient is not stable
+ *   -       | for at least 100 ms
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_blocking(
+u8 v_orient_blocking_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_orient_blocking_u8 <= BMI160_MAX_ORIENT_BLOCKING) {
+		/* write orient blocking mode*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING,
+			v_orient_blocking_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief This API read Orient interrupt
+ *	hysteresis, from the register 0x64 bit 4 to 7
+ *
+ *
+ *
+ *  @param v_orient_hyst_u8 : The value of orient hysteresis
+ *
+ *	@note 1 LSB corresponds to 62.5 mg,
+ *	irrespective of the selected accel range
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_hyst(
+u8 *v_orient_hyst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orient hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_hyst_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write Orient interrupt
+ *	hysteresis, from the register 0x64 bit 4 to 7
+ *
+ *
+ *
+ *  @param v_orient_hyst_u8 : The value of orient hysteresis
+ *
+ *	@note 1 LSB corresponds to 62.5 mg,
+ *	irrespective of the selected accel range
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_hyst(
+u8 v_orient_hyst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write orient hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST,
+				v_orient_hyst_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read Orient
+ *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
+ *
+ *  @param v_orient_theta_u8 : The value of Orient blocking angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_theta(
+u8 *v_orient_theta_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read Orient blocking angle*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_theta_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write Orient
+ *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
+ *
+ *  @param v_orient_theta_u8 : The value of Orient blocking angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_theta(
+u8 v_orient_theta_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_orient_theta_u8 <= BMI160_MAX_ORIENT_THETA) {
+		/* write Orient blocking angle*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA,
+			v_orient_theta_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief This API read orient change
+ *	of up/down bit from the register 0x66 bit 6
+ *
+ *  @param v_orient_ud_u8 : The value of orient change of up/down
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | Is ignored
+ *  0x01     | Generates orientation interrupt
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_ud_enable(
+u8 *v_orient_ud_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orient up/down enable*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_ud_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write orient change
+ *	of up/down bit from the register 0x66 bit 6
+ *
+ *  @param v_orient_ud_u8 : The value of orient change of up/down
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | Is ignored
+ *  0x01     | Generates orientation interrupt
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_ud_enable(
+u8 v_orient_ud_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_orient_ud_u8 <= BMI160_MAX_VALUE_ORIENT_UD) {
+		/* write orient up/down enable */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE,
+			v_orient_ud_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API read orientation axes changes
+ *	from the register 0x66 bit 7
+ *
+ *  @param v_orient_axes_u8 : The value of orient axes assignment
+ *	value    |       Behaviour    | Name
+ * ----------|--------------------|------
+ *  0x00     | x = x, y = y, z = z|orient_ax_noex
+ *  0x01     | x = y, y = z, z = x|orient_ax_ex
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_axes_enable(
+u8 *v_orient_axes_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read orientation axes changes  */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_orient_axes_u8 = BMI160_GET_BITSLICE
+			(v_data_u8,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write orientation axes changes
+ *	from the register 0x66 bit 7
+ *
+ *  @param v_orient_axes_u8 : The value of orient axes assignment
+ *	value    |       Behaviour    | Name
+ * ----------|--------------------|------
+ *  0x00     | x = x, y = y, z = z|orient_ax_noex
+ *  0x01     | x = y, y = z, z = x|orient_ax_ex
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_axes_enable(
+u8 v_orient_axes_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+	if (v_orient_axes_u8 <= BMI160_MAX_VALUE_ORIENT_AXES) {
+		/*write orientation axes changes  */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX,
+			v_orient_axes_u8);
+			com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+return com_rslt;
+}
+ /*!
+ *	@brief This API read Flat angle (0 to 44.8) for flat interrupt
+ *	from the register 0x67 bit 0 to 5
+ *
+ *  @param v_flat_theta_u8 : The value of flat angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_theta(
+u8 *v_flat_theta_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read Flat angle*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_flat_theta_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write Flat angle (0 to 44.8) for flat interrupt
+ *	from the register 0x67 bit 0 to 5
+ *
+ *  @param v_flat_theta_u8 : The value of flat angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_theta(
+u8 v_flat_theta_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_flat_theta_u8 <= BMI160_MAX_FLAT_THETA) {
+			/* write Flat angle */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA,
+				v_flat_theta_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read Flat interrupt hold time;
+ *	from the register 0x68 bit 4 and 5
+ *
+ *  @param v_flat_hold_u8 : The value of flat hold time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | 0ms
+ *  0x01     | 512ms
+ *  0x01     | 1024ms
+ *  0x01     | 2048ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hold(
+u8 *v_flat_hold_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read flat hold time*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_flat_hold_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write Flat interrupt hold time;
+ *	from the register 0x68 bit 4 and 5
+ *
+ *  @param v_flat_hold_u8 : The value of flat hold time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | 0ms
+ *  0x01     | 512ms
+ *  0x01     | 1024ms
+ *  0x01     | 2048ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hold(
+u8 v_flat_hold_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_flat_hold_u8 <= BMI160_MAX_FLAT_HOLD) {
+			/* write flat hold time*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD,
+				v_flat_hold_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read flat interrupt hysteresis
+ *	from the register 0x68 bit 0 to 3
+ *
+ *  @param v_flat_hyst_u8 : The value of flat hysteresis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hyst(
+u8 *v_flat_hyst_u8)
+{
+	/* variable used to return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the flat hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_flat_hyst_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write flat interrupt hysteresis
+ *	from the register 0x68 bit 0 to 3
+ *
+ *  @param v_flat_hyst_u8 : The value of flat hysteresis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hyst(
+u8 v_flat_hyst_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_flat_hyst_u8 <= BMI160_MAX_FLAT_HYST) {
+			/* read the flat hysteresis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST,
+				v_flat_hyst_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read accel offset compensation
+ *	target value for z-axis from the register 0x69 bit 0 and 1
+ *
+ *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_z(u8 *v_foc_accel_z_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel offset compensation for z axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_foc_accel_z_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FOC_ACCEL_Z);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write accel offset compensation
+ *	target value for z-axis from the register 0x69 bit 0 and 1
+ *
+ *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_z(
+u8 v_foc_accel_z_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write the accel offset compensation for z axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_ACCEL_Z,
+				v_foc_accel_z_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_Z__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel offset compensation
+ *	target value for y-axis
+ *	from the register 0x69 bit 2 and 3
+ *
+ *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_y(u8 *v_foc_accel_y_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the accel offset compensation for y axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_foc_accel_y_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FOC_ACCEL_Y);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel offset compensation
+ *	target value for y-axis
+ *	from the register 0x69 bit 2 and 3
+ *
+ *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x02     | -1g
+ *  0x03     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_y(u8 v_foc_accel_y_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_foc_accel_y_u8 <= BMI160_MAX_ACCEL_FOC) {
+			/* write the accel offset compensation for y axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_ACCEL_Y,
+				v_foc_accel_y_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_Y__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel offset compensation
+ *	target value for x-axis is
+ *	from the register 0x69 bit 4 and 5
+ *
+ *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x02     | -1g
+ *  0x03     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_x(u8 *v_foc_accel_x_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* read the accel offset compensation for x axis*/
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_USER_FOC_ACCEL_X__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_foc_accel_x_u8 = BMI160_GET_BITSLICE(v_data_u8,
+		BMI160_USER_FOC_ACCEL_X);
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel offset compensation
+ *	target value for x-axis is
+ *	from the register 0x69 bit 4 and 5
+ *
+ *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_x(u8 v_foc_accel_x_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_foc_accel_x_u8 <= BMI160_MAX_ACCEL_FOC) {
+			/* write the accel offset compensation for x axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_ACCEL_X,
+				v_foc_accel_x_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_X__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API writes accel fast offset compensation
+ *	from the register 0x69 bit 0 to 5
+ *	@brief This API writes each axis individually
+ *	FOC_X_AXIS - bit 4 and 5
+ *	FOC_Y_AXIS - bit 2 and 3
+ *	FOC_Z_AXIS - bit 0 and 1
+ *
+ *  @param  v_foc_accel_u8: The value of accel offset compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_axis_u8: The value of accel offset axis selection
+  *	value    | axis
+ * ----------|-------------------
+ *  0        | FOC_X_AXIS
+ *  1        | FOC_Y_AXIS
+ *  2        | FOC_Z_AXIS
+ *
+ *	@param v_accel_offset_s8: The accel offset value
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_foc_trigger(u8 v_axis_u8,
+u8 v_foc_accel_u8, s8 *v_accel_offset_s8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+s8 v_status_s8 = SUCCESS;
+u8 v_timeout_u8 = BMI160_INIT_VALUE;
+s8 v_foc_accel_offset_x_s8  = BMI160_INIT_VALUE;
+s8 v_foc_accel_offset_y_s8 =  BMI160_INIT_VALUE;
+s8 v_foc_accel_offset_z_s8 =  BMI160_INIT_VALUE;
+u8 focstatus = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+} else {
+	v_status_s8 = bmi160_set_accel_offset_enable(
+	ACCEL_OFFSET_ENABLE);
+	if (v_status_s8 == SUCCESS) {
+		switch (v_axis_u8) {
+		case FOC_X_AXIS:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_ACCEL_X,
+				v_foc_accel_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_X__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* trigger the
+			FOC need to write
+			0x03 in the register 0x7e*/
+			com_rslt +=
+			bmi160_set_command_register(
+			START_FOC_ACCEL_GYRO);
+
+			com_rslt +=
+			bmi160_get_foc_rdy(&focstatus);
+			if ((com_rslt != SUCCESS) ||
+			(focstatus != BMI160_FOC_STAT_HIGH)) {
+				while ((com_rslt != SUCCESS) ||
+				(focstatus != BMI160_FOC_STAT_HIGH
+				&& v_timeout_u8 <
+				BMI160_MAXIMUM_TIMEOUT)) {
+					p_bmi160->delay_msec(
+					BMI160_DELAY_SETTLING_TIME);
+					com_rslt = bmi160_get_foc_rdy(
+					&focstatus);
+					v_timeout_u8++;
+				}
+			}
+			if ((com_rslt == SUCCESS) &&
+				(focstatus == BMI160_FOC_STAT_HIGH)) {
+				com_rslt +=
+				bmi160_get_accel_offset_compensation_xaxis(
+				&v_foc_accel_offset_x_s8);
+				*v_accel_offset_s8 =
+				v_foc_accel_offset_x_s8;
+			}
+		break;
+		case FOC_Y_AXIS:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_ACCEL_Y,
+				v_foc_accel_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_Y__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* trigger the FOC
+			need to write 0x03
+			in the register 0x7e*/
+			com_rslt +=
+			bmi160_set_command_register(
+			START_FOC_ACCEL_GYRO);
+
+			com_rslt +=
+			bmi160_get_foc_rdy(&focstatus);
+			if ((com_rslt != SUCCESS) ||
+			(focstatus != BMI160_FOC_STAT_HIGH)) {
+				while ((com_rslt != SUCCESS) ||
+				(focstatus != BMI160_FOC_STAT_HIGH
+				&& v_timeout_u8 <
+				BMI160_MAXIMUM_TIMEOUT)) {
+					p_bmi160->delay_msec(
+					BMI160_DELAY_SETTLING_TIME);
+					com_rslt = bmi160_get_foc_rdy(
+					&focstatus);
+					v_timeout_u8++;
+				}
+			}
+			if ((com_rslt == SUCCESS) &&
+			(focstatus == BMI160_FOC_STAT_HIGH)) {
+				com_rslt +=
+				bmi160_get_accel_offset_compensation_yaxis(
+				&v_foc_accel_offset_y_s8);
+				*v_accel_offset_s8 =
+				v_foc_accel_offset_y_s8;
+			}
+		break;
+		case FOC_Z_AXIS:
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_ACCEL_Z,
+				v_foc_accel_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_Z__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* trigger the FOC need to write
+			0x03 in the register 0x7e*/
+			com_rslt +=
+			bmi160_set_command_register(
+			START_FOC_ACCEL_GYRO);
+
+			com_rslt +=
+			bmi160_get_foc_rdy(&focstatus);
+			if ((com_rslt != SUCCESS) ||
+			(focstatus != BMI160_FOC_STAT_HIGH)) {
+				while ((com_rslt != SUCCESS) ||
+				(focstatus != BMI160_FOC_STAT_HIGH
+				&& v_timeout_u8 <
+				BMI160_MAXIMUM_TIMEOUT)) {
+					p_bmi160->delay_msec(
+					BMI160_DELAY_SETTLING_TIME);
+					com_rslt = bmi160_get_foc_rdy(
+					&focstatus);
+					v_timeout_u8++;
+				}
+			}
+			if ((com_rslt == SUCCESS) &&
+			(focstatus == BMI160_FOC_STAT_HIGH)) {
+				com_rslt +=
+				bmi160_get_accel_offset_compensation_zaxis(
+				&v_foc_accel_offset_z_s8);
+				*v_accel_offset_s8 =
+				v_foc_accel_offset_z_s8;
+			}
+		break;
+		default:
+		break;
+		}
+	} else {
+	com_rslt =  ERROR;
+	}
+}
+return com_rslt;
+}
+/*!
+ *	@brief This API write fast accel offset compensation
+ *	it writes all axis together.To the register 0x69 bit 0 to 5
+ *	FOC_X_AXIS - bit 4 and 5
+ *	FOC_Y_AXIS - bit 2 and 3
+ *	FOC_Z_AXIS - bit 0 and 1
+ *
+ *  @param  v_foc_accel_x_u8: The value of accel offset x compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_foc_accel_y_u8: The value of accel offset y compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_foc_accel_z_u8: The value of accel offset z compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_accel_off_x_s8: The value of accel offset x axis
+ *  @param  v_accel_off_y_s8: The value of accel offset y axis
+ *  @param  v_accel_off_z_s8: The value of accel offset z axis
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_accel_foc_trigger_xyz(u8 v_foc_accel_x_u8,
+u8 v_foc_accel_y_u8, u8 v_foc_accel_z_u8, s8 *v_accel_off_x_s8,
+s8 *v_accel_off_y_s8, s8 *v_accel_off_z_s8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 focx = BMI160_INIT_VALUE;
+u8 focy = BMI160_INIT_VALUE;
+u8 focz = BMI160_INIT_VALUE;
+s8 v_foc_accel_offset_x_s8 = BMI160_INIT_VALUE;
+s8 v_foc_accel_offset_y_s8 = BMI160_INIT_VALUE;
+s8 v_foc_accel_offset_z_s8 = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+u8 v_timeout_u8 = BMI160_INIT_VALUE;
+u8 focstatus = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		v_status_s8 = bmi160_set_accel_offset_enable(
+		ACCEL_OFFSET_ENABLE);
+		if (v_status_s8 == SUCCESS) {
+			/* foc x axis*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_X__REG,
+			&focx, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				focx = BMI160_SET_BITSLICE(focx,
+				BMI160_USER_FOC_ACCEL_X,
+				v_foc_accel_x_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_X__REG,
+				&focx, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* foc y axis*/
+			com_rslt +=
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Y__REG,
+			&focy, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				focy = BMI160_SET_BITSLICE(focy,
+				BMI160_USER_FOC_ACCEL_Y,
+				v_foc_accel_y_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_Y__REG,
+				&focy, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* foc z axis*/
+			com_rslt +=
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_ACCEL_Z__REG,
+			&focz, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				focz = BMI160_SET_BITSLICE(focz,
+				BMI160_USER_FOC_ACCEL_Z,
+				v_foc_accel_z_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_FOC_ACCEL_Z__REG,
+				&focz, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* trigger the FOC need to
+			write 0x03 in the register 0x7e*/
+			com_rslt += bmi160_set_command_register(
+			START_FOC_ACCEL_GYRO);
+
+			com_rslt += bmi160_get_foc_rdy(
+			&focstatus);
+			if ((com_rslt != SUCCESS) ||
+			(focstatus != BMI160_FOC_STAT_HIGH)) {
+				while ((com_rslt != SUCCESS) ||
+				(focstatus != BMI160_FOC_STAT_HIGH
+				&& v_timeout_u8 <
+				BMI160_MAXIMUM_TIMEOUT)) {
+					p_bmi160->delay_msec(
+					BMI160_DELAY_SETTLING_TIME);
+					com_rslt = bmi160_get_foc_rdy(
+					&focstatus);
+					v_timeout_u8++;
+				}
+			}
+			if ((com_rslt == SUCCESS) &&
+			(focstatus == BMI160_GEN_READ_WRITE_DATA_LENGTH)) {
+				com_rslt +=
+				bmi160_get_accel_offset_compensation_xaxis(
+				&v_foc_accel_offset_x_s8);
+				*v_accel_off_x_s8 =
+				v_foc_accel_offset_x_s8;
+				com_rslt +=
+				bmi160_get_accel_offset_compensation_yaxis(
+				&v_foc_accel_offset_y_s8);
+				*v_accel_off_y_s8 =
+				v_foc_accel_offset_y_s8;
+				com_rslt +=
+				bmi160_get_accel_offset_compensation_zaxis(
+				&v_foc_accel_offset_z_s8);
+				*v_accel_off_z_s8 =
+				v_foc_accel_offset_z_s8;
+			}
+		} else {
+		com_rslt =  ERROR;
+		}
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API read gyro fast offset enable
+ *	from the register 0x69 bit 6
+ *
+ *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
+ *  value    |  Description
+ * ----------|-------------
+ *    0      | fast offset compensation disabled
+ *    1      |  fast offset compensation enabled
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_gyro_enable(
+u8 *v_foc_gyro_u8)
+{
+	/* used for return the status of bus communication */
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the gyro fast offset enable*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_FOC_GYRO_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_foc_gyro_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_FOC_GYRO_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro fast offset enable
+ *	from the register 0x69 bit 6
+ *
+ *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
+ *  value    |  Description
+ * ----------|-------------
+ *    0      | fast offset compensation disabled
+ *    1      |  fast offset compensation enabled
+ *
+ *	@param v_gyro_off_x_s16 : The value of gyro fast offset x axis data
+ *	@param v_gyro_off_y_s16 : The value of gyro fast offset y axis data
+ *	@param v_gyro_off_z_s16 : The value of gyro fast offset z axis data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_gyro_enable(
+u8 v_foc_gyro_u8, s16 *v_gyro_off_x_s16,
+s16 *v_gyro_off_y_s16, s16 *v_gyro_off_z_s16)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+u8 v_timeout_u8 = BMI160_INIT_VALUE;
+s16 offsetx = BMI160_INIT_VALUE;
+s16 offsety = BMI160_INIT_VALUE;
+s16 offsetz = BMI160_INIT_VALUE;
+u8 focstatus = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		v_status_s8 = bmi160_set_gyro_offset_enable(
+		GYRO_OFFSET_ENABLE);
+		if (v_status_s8 == SUCCESS) {
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_FOC_GYRO_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_FOC_GYRO_ENABLE,
+				v_foc_gyro_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_FOC_GYRO_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			/* trigger the FOC need to write 0x03
+			in the register 0x7e*/
+			com_rslt += bmi160_set_command_register
+			(START_FOC_ACCEL_GYRO);
+
+			com_rslt += bmi160_get_foc_rdy(&focstatus);
+			if ((com_rslt != SUCCESS) ||
+			(focstatus != BMI160_FOC_STAT_HIGH)) {
+				while ((com_rslt != SUCCESS) ||
+				(focstatus != BMI160_FOC_STAT_HIGH
+				&& v_timeout_u8 <
+				BMI160_MAXIMUM_TIMEOUT)) {
+					p_bmi160->delay_msec(
+					BMI160_DELAY_SETTLING_TIME);
+					com_rslt = bmi160_get_foc_rdy(
+					&focstatus);
+					v_timeout_u8++;
+				}
+			}
+			if ((com_rslt == SUCCESS) &&
+			(focstatus == BMI160_FOC_STAT_HIGH)) {
+				com_rslt +=
+				bmi160_get_gyro_offset_compensation_xaxis
+				(&offsetx);
+				*v_gyro_off_x_s16 = offsetx;
+
+				com_rslt +=
+				bmi160_get_gyro_offset_compensation_yaxis
+				(&offsety);
+				*v_gyro_off_y_s16 = offsety;
+
+				com_rslt +=
+				bmi160_get_gyro_offset_compensation_zaxis(
+				&offsetz);
+				*v_gyro_off_z_s16 = offsetz;
+			}
+		} else {
+		com_rslt = ERROR;
+		}
+	}
+return com_rslt;
+}
+ /*!
+ *	@brief This API read NVM program enable
+ *	from the register 0x6A bit 1
+ *
+ *  @param v_nvm_prog_u8 : The value of NVM program enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_prog_enable(
+u8 *v_nvm_prog_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read NVM program*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_nvm_prog_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_CONFIG_NVM_PROG_ENABLE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write NVM program enable
+ *	from the register 0x6A bit 1
+ *
+ *  @param v_nvm_prog_u8 : The value of NVM program enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_prog_enable(
+u8 v_nvm_prog_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_nvm_prog_u8 <= BMI160_MAX_VALUE_NVM_PROG) {
+			/* write the NVM program*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_CONFIG_NVM_PROG_ENABLE,
+				v_nvm_prog_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ * @brief This API read to configure SPI
+ * Interface Mode for primary and OIS interface
+ * from the register 0x6B bit 0
+ *
+ *  @param v_spi3_u8 : The value of SPI mode selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  SPI 4-wire mode
+ *   1     |  SPI 3-wire mode
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi3(
+u8 *v_spi3_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read SPI mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_SPI3__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_spi3_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_IF_CONFIG_SPI3);
+		}
+	return com_rslt;
+}
+/*!
+ * @brief This API write to configure SPI
+ * Interface Mode for primary and OIS interface
+ * from the register 0x6B bit 0
+ *
+ *  @param v_spi3_u8 : The value of SPI mode selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  SPI 4-wire mode
+ *   1     |  SPI 3-wire mode
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi3(
+u8 v_spi3_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_spi3_u8 <= BMI160_MAX_VALUE_SPI3) {
+			/* write SPI mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_SPI3__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_IF_CONFIG_SPI3,
+				v_spi3_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_IF_CONFIG_SPI3__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read I2C Watchdog timer
+ *	from the register 0x70 bit 1
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  I2C watchdog v_timeout_u8 after 1 ms
+ *   1     |  I2C watchdog v_timeout_u8 after 50 ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_select(
+u8 *v_i2c_wdt_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read I2C watch dog timer */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_i2c_wdt_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_IF_CONFIG_I2C_WDT_SELECT);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write I2C Watchdog timer
+ *	from the register 0x70 bit 1
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  I2C watchdog v_timeout_u8 after 1 ms
+ *   1     |  I2C watchdog v_timeout_u8 after 50 ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_wdt_select(
+u8 v_i2c_wdt_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_i2c_wdt_u8 <= BMI160_MAX_VALUE_I2C_WDT) {
+			/* write I2C watch dog timer */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_IF_CONFIG_I2C_WDT_SELECT,
+				v_i2c_wdt_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read I2C watchdog enable
+ *	from the register 0x70 bit 2
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_enable(
+u8 *v_i2c_wdt_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read i2c watch dog eneble */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_i2c_wdt_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write I2C watchdog enable
+ *	from the register 0x70 bit 2
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_wdt_enable(
+u8 v_i2c_wdt_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_i2c_wdt_u8 <= BMI160_MAX_VALUE_I2C_WDT) {
+			/* write i2c watch dog eneble */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE,
+				v_i2c_wdt_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ * @brief This API read I2C interface configuration(if) moe
+ * from the register 0x6B bit 4 and 5
+ *
+ *  @param  v_if_mode_u8 : The value of interface configuration mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  |  Primary interface:autoconfig / secondary interface:off
+ *   0x01  |  Primary interface:I2C / secondary interface:OIS
+ *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
+ *   0x03  |   Reserved
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_if_mode(
+u8 *v_if_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read if mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_IF_MODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_if_mode_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_IF_CONFIG_IF_MODE);
+		}
+	return com_rslt;
+}
+/*!
+ * @brief This API write I2C interface configuration(if) moe
+ * from the register 0x6B bit 4 and 5
+ *
+ *  @param  v_if_mode_u8 : The value of interface configuration mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  |  Primary interface:autoconfig / secondary interface:off
+ *   0x01  |  Primary interface:I2C / secondary interface:OIS
+ *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
+ *   0x03  |   Reserved
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_if_mode(
+u8 v_if_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_if_mode_u8 <= BMI160_MAX_IF_MODE) {
+			/* write if mode*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_IF_CONFIG_IF_MODE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_IF_CONFIG_IF_MODE,
+				v_if_mode_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_IF_CONFIG_IF_MODE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read gyro sleep trigger
+ *	from the register 0x6C bit 0 to 2
+ *
+ *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
+ *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
+ *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
+ *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
+ *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
+ *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
+ *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
+ *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_trigger(
+u8 *v_gyro_sleep_trigger_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro sleep trigger */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_SLEEP_TRIGGER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_sleep_trigger_u8 =
+			BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_GYRO_SLEEP_TRIGGER);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro sleep trigger
+ *	from the register 0x6C bit 0 to 2
+ *
+ *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
+ *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
+ *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
+ *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
+ *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
+ *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
+ *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
+ *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_trigger(
+u8 v_gyro_sleep_trigger_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_gyro_sleep_trigger_u8 <= BMI160_MAX_GYRO_SLEEP_TIGGER) {
+			/* write gyro sleep trigger */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_SLEEP_TRIGGER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_SLEEP_TRIGGER,
+				v_gyro_sleep_trigger_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_GYRO_SLEEP_TRIGGER__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read gyro wakeup trigger
+ *	from the register 0x6C bit 3 and 4
+ *
+ *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | anymotion: no / INT1 pin: no
+ *   0x01  | anymotion: no / INT1 pin: yes
+ *   0x02  | anymotion: yes / INT1 pin: no
+ *   0x03  | anymotion: yes / INT1 pin: yes
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_trigger(
+u8 *v_gyro_wakeup_trigger_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro wakeup trigger */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_WAKEUP_TRIGGER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_wakeup_trigger_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_GYRO_WAKEUP_TRIGGER);
+	  }
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro wakeup trigger
+ *	from the register 0x6C bit 3 and 4
+ *
+ *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | anymotion: no / INT1 pin: no
+ *   0x01  | anymotion: no / INT1 pin: yes
+ *   0x02  | anymotion: yes / INT1 pin: no
+ *   0x03  | anymotion: yes / INT1 pin: yes
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_trigger(
+u8 v_gyro_wakeup_trigger_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_gyro_wakeup_trigger_u8
+		<= BMI160_MAX_GYRO_WAKEUP_TRIGGER) {
+			/* write gyro wakeup trigger */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_WAKEUP_TRIGGER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_WAKEUP_TRIGGER,
+				v_gyro_wakeup_trigger_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_GYRO_WAKEUP_TRIGGER__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read Target state for gyro sleep mode
+ *	from the register 0x6C bit 5
+ *
+ *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | Sleep transition to fast wake up state
+ *   0x01  | Sleep transition to suspend state
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_state(
+u8 *v_gyro_sleep_state_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro sleep state*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_SLEEP_STATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_sleep_state_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_GYRO_SLEEP_STATE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write Target state for gyro sleep mode
+ *	from the register 0x6C bit 5
+ *
+ *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | Sleep transition to fast wake up state
+ *   0x01  | Sleep transition to suspend state
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_state(
+u8 v_gyro_sleep_state_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_gyro_sleep_state_u8 <= BMI160_MAX_VALUE_SLEEP_STATE) {
+			/* write gyro sleep state*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_SLEEP_STATE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_SLEEP_STATE,
+				v_gyro_sleep_state_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_GYRO_SLEEP_STATE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read gyro wakeup interrupt
+ *	from the register 0x6C bit 6
+ *
+ *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | DISABLE
+ *   0x01  | ENABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_intr(
+u8 *v_gyro_wakeup_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro wakeup interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_WAKEUP_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_wakeup_intr_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_GYRO_WAKEUP_INTR);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro wakeup interrupt
+ *	from the register 0x6C bit 6
+ *
+ *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | DISABLE
+ *   0x01  | ENABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_intr(
+u8 v_gyro_wakeup_intr_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_gyro_wakeup_intr_u8 <= BMI160_MAX_VALUE_WAKEUP_INTR) {
+			/* write gyro wakeup interrupt */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_WAKEUP_INTR__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_WAKEUP_INTR,
+				v_gyro_wakeup_intr_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_GYRO_WAKEUP_INTR__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ * @brief This API read accel select axis to be self-test
+ *
+ *  @param v_accel_selftest_axis_u8 :
+ *	The value of accel self test axis selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | disabled
+ *   0x01  | x-axis
+ *   0x02  | y-axis
+ *   0x03  | z-axis
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_axis(
+u8 *v_accel_selftest_axis_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read accel self test axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_SELFTEST_AXIS__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_selftest_axis_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_ACCEL_SELFTEST_AXIS);
+		}
+	return com_rslt;
+}
+/*!
+ * @brief This API write accel select axis to be self-test
+ *
+ *  @param v_accel_selftest_axis_u8 :
+ *	The value of accel self test axis selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | disabled
+ *   0x01  | x-axis
+ *   0x02  | y-axis
+ *   0x03  | z-axis
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_axis(
+u8 v_accel_selftest_axis_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_accel_selftest_axis_u8
+		<= BMI160_MAX_ACCEL_SELFTEST_AXIS) {
+			/* write accel self test axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_SELFTEST_AXIS__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_ACCEL_SELFTEST_AXIS,
+				v_accel_selftest_axis_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_ACCEL_SELFTEST_AXIS__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel self test axis sign
+ *	from the register 0x6D bit 2
+ *
+ *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | negative
+ *   0x01  | positive
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_sign(
+u8 *v_accel_selftest_sign_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read accel self test axis sign*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_SELFTEST_SIGN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_selftest_sign_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_ACCEL_SELFTEST_SIGN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel self test axis sign
+ *	from the register 0x6D bit 2
+ *
+ *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | negative
+ *   0x01  | positive
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_sign(
+u8 v_accel_selftest_sign_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_accel_selftest_sign_u8 <=
+		BMI160_MAX_VALUE_SELFTEST_SIGN) {
+			/* write accel self test axis sign*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_ACCEL_SELFTEST_SIGN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_ACCEL_SELFTEST_SIGN,
+				v_accel_selftest_sign_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_ACCEL_SELFTEST_SIGN__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+			com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel self test amplitude
+ *	from the register 0x6D bit 3
+ *        select amplitude of the selftest deflection:
+ *
+ *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | LOW
+ *   0x01  | HIGH
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_amp(
+u8 *v_accel_selftest_amp_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read  self test amplitude*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_SELFTEST_AMP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_selftest_amp_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_SELFTEST_AMP);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel self test amplitude
+ *	from the register 0x6D bit 3
+ *        select amplitude of the selftest deflection:
+ *
+ *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | LOW
+ *   0x01  | HIGH
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_amp(
+u8 v_accel_selftest_amp_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_accel_selftest_amp_u8 <=
+		BMI160_MAX_VALUE_SELFTEST_AMP) {
+			/* write  self test amplitude*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_SELFTEST_AMP__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_SELFTEST_AMP,
+				v_accel_selftest_amp_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_SELFTEST_AMP__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read gyro self test trigger
+ *
+ *	@param v_gyro_selftest_start_u8: The value of gyro self test start
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest_start(
+u8 *v_gyro_selftest_start_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro self test start */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_SELFTEST_START__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_selftest_start_u8 = BMI160_GET_BITSLICE(
+			v_data_u8,
+			BMI160_USER_GYRO_SELFTEST_START);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro self test trigger
+ *
+ *	@param v_gyro_selftest_start_u8: The value of gyro self test start
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_selftest_start(
+u8 v_gyro_selftest_start_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_gyro_selftest_start_u8 <=
+		BMI160_MAX_VALUE_SELFTEST_START) {
+			/* write gyro self test start */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_GYRO_SELFTEST_START__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_GYRO_SELFTEST_START,
+				v_gyro_selftest_start_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_GYRO_SELFTEST_START__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ * @brief This API read primary interface selection I2C or SPI
+ *	from the register 0x70 bit 0
+ *
+ *  @param v_spi_enable_u8: The value of Interface selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | I2C Enable
+ *   0x01  | I2C DISBALE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi_enable(u8 *v_spi_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read interface section*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_NV_CONFIG_SPI_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_spi_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_NV_CONFIG_SPI_ENABLE);
+		}
+	return com_rslt;
+}
+ /*!
+ * @brief This API write primary interface selection I2C or SPI
+ *	from the register 0x70 bit 0
+ *
+ *  @param v_spi_enable_u8: The value of Interface selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | I2C Enable
+ *   0x01  | I2C DISBALE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi_enable(u8 v_spi_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write interface section*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_NV_CONFIG_SPI_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_NV_CONFIG_SPI_ENABLE,
+				v_spi_enable_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_NV_CONFIG_SPI_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read the spare zero
+ *	form register 0x70 bit 3
+ *
+ *
+ *  @param v_spare0_trim_u8: The value of spare zero
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_spare0_trim(u8 *v_spare0_trim_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read spare zero*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_NV_CONFIG_SPARE0__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_spare0_trim_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_NV_CONFIG_SPARE0);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write the spare zero
+ *	form register 0x70 bit 3
+ *
+ *
+ *  @param v_spare0_trim_u8: The value of spare zero
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_spare0_trim(u8 v_spare0_trim_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write  spare zero*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_NV_CONFIG_SPARE0__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_NV_CONFIG_SPARE0,
+				v_spare0_trim_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_NV_CONFIG_SPARE0__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read the NVM counter
+ *	form register 0x70 bit 4 to 7
+ *
+ *
+ *  @param v_nvm_counter_u8: The value of NVM counter
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_counter(u8 *v_nvm_counter_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read NVM counter*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_NV_CONFIG_NVM_COUNTER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_nvm_counter_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_NV_CONFIG_NVM_COUNTER);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write the NVM counter
+ *	form register 0x70 bit 4 to 7
+ *
+ *
+ *  @param v_nvm_counter_u8: The value of NVM counter
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_counter(
+u8 v_nvm_counter_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write NVM counter*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_NV_CONFIG_NVM_COUNTER__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_NV_CONFIG_NVM_COUNTER,
+				v_nvm_counter_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_NV_CONFIG_NVM_COUNTER__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel manual offset compensation of x axis
+ *	from the register 0x71 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_x_s8:
+ *	The value of accel manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_xaxis(
+s8 *v_accel_off_x_s8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read accel manual offset compensation of x axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_off_x_s8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_OFFSET_0_ACCEL_OFF_X);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel manual offset compensation of x axis
+ *	from the register 0x71 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_x_s8:
+ *	The value of accel manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_xaxis(
+s8 v_accel_off_x_s8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* enable accel offset */
+		v_status_s8 = bmi160_set_accel_offset_enable(
+		ACCEL_OFFSET_ENABLE);
+		if (v_status_s8 == SUCCESS) {
+			/* write accel manual offset compensation of x axis*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(
+				v_data_u8,
+				BMI160_USER_OFFSET_0_ACCEL_OFF_X,
+				v_accel_off_x_s8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt =  ERROR;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel manual offset compensation of y axis
+ *	from the register 0x72 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_y_s8:
+ *	The value of accel manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_yaxis(
+s8 *v_accel_off_y_s8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read accel manual offset compensation of y axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_off_y_s8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_OFFSET_1_ACCEL_OFF_Y);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel manual offset compensation of y axis
+ *	from the register 0x72 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_y_s8:
+ *	The value of accel manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_yaxis(
+s8 v_accel_off_y_s8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* enable accel offset */
+		v_status_s8 = bmi160_set_accel_offset_enable(
+		ACCEL_OFFSET_ENABLE);
+		if (v_status_s8 == SUCCESS) {
+			/* write accel manual offset compensation of y axis*/
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(
+				v_data_u8,
+				BMI160_USER_OFFSET_1_ACCEL_OFF_Y,
+				v_accel_off_y_s8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = ERROR;
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read accel manual offset compensation of z axis
+ *	from the register 0x73 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_z_s8:
+ *	The value of accel manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_zaxis(
+s8 *v_accel_off_z_s8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read accel manual offset compensation of z axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_off_z_s8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_OFFSET_2_ACCEL_OFF_Z);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write accel manual offset compensation of z axis
+ *	from the register 0x73 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_z_s8:
+ *	The value of accel manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_zaxis(
+s8 v_accel_off_z_s8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 v_status_s8 = SUCCESS;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* enable accel offset */
+			v_status_s8 = bmi160_set_accel_offset_enable(
+			ACCEL_OFFSET_ENABLE);
+			if (v_status_s8 == SUCCESS) {
+				/* write accel manual offset
+				compensation of z axis*/
+				com_rslt =
+				p_bmi160->BMI160_BUS_READ_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG,
+				&v_data_u8,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+				if (com_rslt == SUCCESS) {
+					v_data_u8 =
+					BMI160_SET_BITSLICE(v_data_u8,
+					BMI160_USER_OFFSET_2_ACCEL_OFF_Z,
+					v_accel_off_z_s8);
+					com_rslt +=
+					p_bmi160->BMI160_BUS_WRITE_FUNC(
+					p_bmi160->dev_addr,
+					BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG,
+					&v_data_u8,
+					BMI160_GEN_READ_WRITE_DATA_LENGTH);
+				}
+			} else {
+			com_rslt = ERROR;
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read gyro manual offset compensation of x axis
+ *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
+ *
+ *
+ *
+ *  @param v_gyro_off_x_s16:
+ *	The value of gyro manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_xaxis(
+s16 *v_gyro_off_x_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data1_u8r = BMI160_INIT_VALUE;
+	u8 v_data2_u8r = BMI160_INIT_VALUE;
+	s16 v_data3_u8r, v_data4_u8r = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro offset x*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_3_GYRO_OFF_X__REG,
+			&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			v_data1_u8r = BMI160_GET_BITSLICE(v_data1_u8r,
+			BMI160_USER_OFFSET_3_GYRO_OFF_X);
+			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_X__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			v_data2_u8r = BMI160_GET_BITSLICE(v_data2_u8r,
+			BMI160_USER_OFFSET_6_GYRO_OFF_X);
+			v_data3_u8r = v_data2_u8r
+			<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS;
+			v_data4_u8r =  v_data1_u8r
+			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
+			v_data3_u8r = v_data3_u8r | v_data4_u8r;
+			*v_gyro_off_x_s16 = v_data3_u8r
+			>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro manual offset compensation of x axis
+ *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
+ *
+ *
+ *
+ *  @param v_gyro_off_x_s16:
+ *	The value of gyro manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_xaxis(
+s16 v_gyro_off_x_s16)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data1_u8r, v_data2_u8r = BMI160_INIT_VALUE;
+u16 v_data3_u8r = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* write gyro offset x*/
+		v_status_s8 = bmi160_set_gyro_offset_enable(
+		GYRO_OFFSET_ENABLE);
+		if (v_status_s8 == SUCCESS) {
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_3_GYRO_OFF_X__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data1_u8r =
+				((s8) (v_gyro_off_x_s16 &
+				BMI160_GYRO_MANUAL_OFFSET_0_7));
+				v_data2_u8r = BMI160_SET_BITSLICE(
+				v_data2_u8r,
+				BMI160_USER_OFFSET_3_GYRO_OFF_X,
+				v_data1_u8r);
+				/* write 0x74 bit 0 to 7*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_3_GYRO_OFF_X__REG,
+				&v_data2_u8r,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_X__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data3_u8r =
+				(u16) (v_gyro_off_x_s16 &
+				BMI160_GYRO_MANUAL_OFFSET_8_9);
+				v_data1_u8r = (u8)(v_data3_u8r
+				>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
+				v_data2_u8r = BMI160_SET_BITSLICE(
+				v_data2_u8r,
+				BMI160_USER_OFFSET_6_GYRO_OFF_X,
+				v_data1_u8r);
+				/* write 0x77 bit 0 and 1*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_6_GYRO_OFF_X__REG,
+				&v_data2_u8r,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		return ERROR;
+		}
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API read gyro manual offset compensation of y axis
+ *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
+ *
+ *
+ *
+ *  @param v_gyro_off_y_s16:
+ *	The value of gyro manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_yaxis(
+s16 *v_gyro_off_y_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data1_u8r = BMI160_INIT_VALUE;
+	u8 v_data2_u8r = BMI160_INIT_VALUE;
+	s16 v_data3_u8r, v_data4_u8r = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro offset y*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG,
+			&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			v_data1_u8r = BMI160_GET_BITSLICE(v_data1_u8r,
+			BMI160_USER_OFFSET_4_GYRO_OFF_Y);
+			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			v_data2_u8r = BMI160_GET_BITSLICE(v_data2_u8r,
+			BMI160_USER_OFFSET_6_GYRO_OFF_Y);
+			v_data3_u8r = v_data2_u8r
+			<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS;
+			v_data4_u8r =  v_data1_u8r
+			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
+			v_data3_u8r = v_data3_u8r | v_data4_u8r;
+			*v_gyro_off_y_s16 = v_data3_u8r
+			>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro manual offset compensation of y axis
+ *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
+ *
+ *
+ *
+ *  @param v_gyro_off_y_s16:
+ *	The value of gyro manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_yaxis(
+s16 v_gyro_off_y_s16)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data1_u8r, v_data2_u8r = BMI160_INIT_VALUE;
+u16 v_data3_u8r = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* enable gyro offset bit */
+		v_status_s8 = bmi160_set_gyro_offset_enable(
+		GYRO_OFFSET_ENABLE);
+		/* write gyro offset y*/
+		if (v_status_s8 == SUCCESS) {
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data1_u8r =
+				((s8) (v_gyro_off_y_s16 &
+				BMI160_GYRO_MANUAL_OFFSET_0_7));
+				v_data2_u8r = BMI160_SET_BITSLICE(
+				v_data2_u8r,
+				BMI160_USER_OFFSET_4_GYRO_OFF_Y,
+				v_data1_u8r);
+				/* write 0x75 bit 0 to 7*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG,
+				&v_data2_u8r,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data3_u8r =
+				(u16) (v_gyro_off_y_s16 &
+				BMI160_GYRO_MANUAL_OFFSET_8_9);
+				v_data1_u8r = (u8)(v_data3_u8r
+				>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
+				v_data2_u8r = BMI160_SET_BITSLICE(
+				v_data2_u8r,
+				BMI160_USER_OFFSET_6_GYRO_OFF_Y,
+				v_data1_u8r);
+				/* write 0x77 bit 2 and 3*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG,
+				&v_data2_u8r,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		return ERROR;
+		}
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API read gyro manual offset compensation of z axis
+ *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
+ *
+ *
+ *
+ *  @param v_gyro_off_z_s16:
+ *	The value of gyro manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_zaxis(
+s16 *v_gyro_off_z_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data1_u8r = BMI160_INIT_VALUE;
+	u8 v_data2_u8r = BMI160_INIT_VALUE;
+	s16 v_data3_u8r, v_data4_u8r = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro manual offset z axis*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG,
+			&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			v_data1_u8r = BMI160_GET_BITSLICE
+			(v_data1_u8r,
+			BMI160_USER_OFFSET_5_GYRO_OFF_Z);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			v_data2_u8r = BMI160_GET_BITSLICE(
+			v_data2_u8r,
+			BMI160_USER_OFFSET_6_GYRO_OFF_Z);
+			v_data3_u8r = v_data2_u8r
+			<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS;
+			v_data4_u8r =  v_data1_u8r
+			<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
+			v_data3_u8r = v_data3_u8r | v_data4_u8r;
+			*v_gyro_off_z_s16 = v_data3_u8r
+			>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS;
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write gyro manual offset compensation of z axis
+ *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
+ *
+ *
+ *
+ *  @param v_gyro_off_z_s16:
+ *	The value of gyro manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_zaxis(
+s16 v_gyro_off_z_s16)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data1_u8r, v_data2_u8r = BMI160_INIT_VALUE;
+u16 v_data3_u8r = BMI160_INIT_VALUE;
+u8 v_status_s8 = SUCCESS;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+	} else {
+		/* enable gyro offset*/
+		v_status_s8 = bmi160_set_gyro_offset_enable(
+		GYRO_OFFSET_ENABLE);
+		/* write gyro manual offset z axis*/
+		if (v_status_s8 == SUCCESS) {
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data1_u8r =
+				((u8) (v_gyro_off_z_s16 &
+				BMI160_GYRO_MANUAL_OFFSET_0_7));
+				v_data2_u8r = BMI160_SET_BITSLICE(
+				v_data2_u8r,
+				BMI160_USER_OFFSET_5_GYRO_OFF_Z,
+				v_data1_u8r);
+				/* write 0x76 bit 0 to 7*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG,
+				&v_data2_u8r,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+
+			com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG,
+			&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data3_u8r =
+				(u16) (v_gyro_off_z_s16 &
+				BMI160_GYRO_MANUAL_OFFSET_8_9);
+				v_data1_u8r = (u8)(v_data3_u8r
+				>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
+				v_data2_u8r = BMI160_SET_BITSLICE(
+				v_data2_u8r,
+				BMI160_USER_OFFSET_6_GYRO_OFF_Z,
+				v_data1_u8r);
+				/* write 0x77 bit 4 and 5*/
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG,
+				&v_data2_u8r,
+				BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		return ERROR;
+		}
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This API read the accel offset enable bit
+ *	from the register 0x77 bit 6
+ *
+ *
+ *
+ *  @param v_accel_off_enable_u8: The value of accel offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_enable(
+u8 *v_accel_off_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read accel offset enable */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_accel_off_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write the accel offset enable bit
+ *	from the register 0x77 bit 6
+ *
+ *
+ *
+ *  @param v_accel_off_enable_u8: The value of accel offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_enable(
+u8 v_accel_off_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+			} else {
+			/* write accel offset enable */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE,
+				v_accel_off_enable_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API read the accel offset enable bit
+ *	from the register 0x77 bit 7
+ *
+ *
+ *
+ *  @param v_gyro_off_enable_u8: The value of gyro offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_enable(
+u8 *v_gyro_off_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read gyro offset*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_gyro_off_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_OFFSET_6_GYRO_OFF_EN);
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API write the accel offset enable bit
+ *	from the register 0x77 bit 7
+ *
+ *
+ *
+ *  @param v_gyro_off_enable_u8: The value of gyro offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_enable(
+u8 v_gyro_off_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write gyro offset*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 = BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_USER_OFFSET_6_GYRO_OFF_EN,
+				v_gyro_off_enable_u8);
+				com_rslt += p_bmi160->BMI160_BUS_WRITE_FUNC(
+				p_bmi160->dev_addr,
+				BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This API reads step counter value
+ *	form the register 0x78 and 0x79
+ *
+ *
+ *
+ *
+ *  @param v_step_cnt_s16 : The value of step counter
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_step_count(s16 *v_step_cnt_s16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* array having the step counter LSB and MSB data
+	v_data_u8[0] - LSB
+	v_data_u8[1] - MSB*/
+	u8 a_data_u8r[BMI160_STEP_COUNT_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read step counter */
+			com_rslt =
+			p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+			BMI160_USER_STEP_COUNT_LSB__REG,
+			a_data_u8r, BMI160_STEP_COUNTER_LENGTH);
+
+			*v_step_cnt_s16 = (s16)
+			((((s32)((s8)a_data_u8r[BMI160_STEP_COUNT_MSB_BYTE]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (a_data_u8r[BMI160_STEP_COUNT_LSB_BYTE]));
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API Reads
+ *	step counter configuration
+ *	from the register 0x7A bit 0 to 7
+ *	and from the register 0x7B bit 0 to 2 and 4 to 7
+ *
+ *
+ *  @param v_step_config_u16 : The value of step configuration
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_config(
+u16 *v_step_config_u16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data1_u8r = BMI160_INIT_VALUE;
+	u8 v_data2_u8r = BMI160_INIT_VALUE;
+	u16 v_data3_u8r = BMI160_INIT_VALUE;
+	/* Read the 0 to 7 bit*/
+	com_rslt =
+	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+	BMI160_USER_STEP_CONFIG_ZERO__REG,
+	&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* Read the 8 to 10 bit*/
+	com_rslt +=
+	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+	BMI160_USER_STEP_CONFIG_ONE_CNF1__REG,
+	&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	v_data2_u8r = BMI160_GET_BITSLICE(v_data2_u8r,
+	BMI160_USER_STEP_CONFIG_ONE_CNF1);
+	v_data3_u8r = ((u16)((((u32)
+	((u8)v_data2_u8r))
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | (v_data1_u8r)));
+	/* Read the 11 to 14 bit*/
+	com_rslt +=
+	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+	BMI160_USER_STEP_CONFIG_ONE_CNF2__REG,
+	&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	v_data1_u8r = BMI160_GET_BITSLICE(v_data1_u8r,
+	BMI160_USER_STEP_CONFIG_ONE_CNF2);
+	*v_step_config_u16 = ((u16)((((u32)
+	((u8)v_data1_u8r))
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | (v_data3_u8r)));
+
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write
+ *	step counter configuration
+ *	from the register 0x7A bit 0 to 7
+ *	and from the register 0x7B bit 0 to 2 and 4 to 7
+ *
+ *
+ *  @param v_step_config_u16   :
+ *	the value of  Enable step configuration
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_config(
+u16 v_step_config_u16)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data1_u8r = BMI160_INIT_VALUE;
+	u8 v_data2_u8r = BMI160_INIT_VALUE;
+	u16 v_data3_u16 = BMI160_INIT_VALUE;
+
+	/* write the 0 to 7 bit*/
+	v_data1_u8r = (u8)(v_step_config_u16 &
+	BMI160_STEP_CONFIG_0_7);
+	p_bmi160->BMI160_BUS_WRITE_FUNC
+	(p_bmi160->dev_addr,
+	BMI160_USER_STEP_CONFIG_ZERO__REG,
+	&v_data1_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* write the 8 to 10 bit*/
+	com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+	(p_bmi160->dev_addr,
+	BMI160_USER_STEP_CONFIG_ONE_CNF1__REG,
+	&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	if (com_rslt == SUCCESS) {
+		v_data3_u16 = (u16) (v_step_config_u16 &
+		BMI160_STEP_CONFIG_8_10);
+		v_data1_u8r = (u8)(v_data3_u16
+		>> BMI160_SHIFT_BIT_POSITION_BY_08_BITS);
+		v_data2_u8r = BMI160_SET_BITSLICE(v_data2_u8r,
+		BMI160_USER_STEP_CONFIG_ONE_CNF1, v_data1_u8r);
+		p_bmi160->BMI160_BUS_WRITE_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_STEP_CONFIG_ONE_CNF1__REG,
+		&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+	/* write the 11 to 14 bit*/
+	com_rslt += p_bmi160->BMI160_BUS_READ_FUNC
+	(p_bmi160->dev_addr,
+	BMI160_USER_STEP_CONFIG_ONE_CNF2__REG,
+	&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	if (com_rslt == SUCCESS) {
+		v_data3_u16 = (u16) (v_step_config_u16 &
+		BMI160_STEP_CONFIG_11_14);
+		v_data1_u8r = (u8)(v_data3_u16
+		>> BMI160_SHIFT_BIT_POSITION_BY_12_BITS);
+		v_data2_u8r = BMI160_SET_BITSLICE(v_data2_u8r,
+		BMI160_USER_STEP_CONFIG_ONE_CNF2, v_data1_u8r);
+		p_bmi160->BMI160_BUS_WRITE_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_STEP_CONFIG_ONE_CNF2__REG,
+		&v_data2_u8r, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	}
+
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read enable step counter
+ *	from the register 0x7B bit 3
+ *
+ *
+ *  @param v_step_counter_u8 : The value of step counter enable
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_counter_enable(
+u8 *v_step_counter_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the step counter */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_step_counter_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write enable step counter
+ *	from the register 0x7B bit 3
+ *
+ *
+ *  @param v_step_counter_u8 : The value of step counter enable
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_counter_enable(u8 v_step_counter_u8)
+{
+/* variable used for return the status of communication result*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+/* check the p_bmi160 structure as NULL*/
+if (p_bmi160 == BMI160_NULL) {
+	return E_BMI160_NULL_PTR;
+} else {
+	if (v_step_counter_u8 <= BMI160_MAX_GYRO_STEP_COUNTER) {
+		/* write the step counter */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+		(p_bmi160->dev_addr,
+		BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		if (com_rslt == SUCCESS) {
+			v_data_u8 =
+			BMI160_SET_BITSLICE(v_data_u8,
+			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE,
+			v_step_counter_u8);
+			com_rslt +=
+			p_bmi160->BMI160_BUS_WRITE_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	} else {
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+	}
+}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API set Step counter modes
+ *
+ *
+ *  @param  v_step_mode_u8 : The value of step counter mode
+ *  value    |   mode
+ * ----------|-----------
+ *   0       | BMI160_STEP_NORMAL_MODE
+ *   1       | BMI160_STEP_SENSITIVE_MODE
+ *   2       | BMI160_STEP_ROBUST_MODE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_mode(u8 v_step_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+
+	switch (v_step_mode_u8) {
+	case BMI160_STEP_NORMAL_MODE:
+		com_rslt = bmi160_set_step_config(
+		STEP_CONFIG_NORMAL);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_STEP_SENSITIVE_MODE:
+		com_rslt = bmi160_set_step_config(
+		STEP_CONFIG_SENSITIVE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_STEP_ROBUST_MODE:
+		com_rslt = bmi160_set_step_config(
+		STEP_CONFIG_ROBUST);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to trigger the  signification motion
+ *	interrupt
+ *
+ *
+ *  @param  v_significant_u8 : The value of interrupt selection
+ *  value    |  interrupt
+ * ----------|-----------
+ *   0       |  BMI160_MAP_INTR1
+ *   1       |  BMI160_MAP_INTR2
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_map_significant_motion_intr(
+u8 v_significant_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_sig_motion_u8 = BMI160_INIT_VALUE;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 v_any_motion_intr1_stat_u8 = BMI160_ENABLE_ANY_MOTION_INTR1;
+	u8 v_any_motion_intr2_stat_u8 = BMI160_ENABLE_ANY_MOTION_INTR2;
+	u8 v_any_motion_axis_stat_u8 = BMI160_ENABLE_ANY_MOTION_AXIS;
+	/* enable the significant motion interrupt */
+	com_rslt = bmi160_get_intr_significant_motion_select(&v_sig_motion_u8);
+	if (v_sig_motion_u8 != BMI160_SIG_MOTION_STAT_HIGH)
+		com_rslt += bmi160_set_intr_significant_motion_select(
+		BMI160_SIG_MOTION_INTR_ENABLE);
+	switch (v_significant_u8) {
+	case BMI160_MAP_INTR1:
+		/* interrupt */
+		com_rslt += bmi160_read_reg(
+		BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_any_motion_intr1_stat_u8;
+		/* map the signification interrupt to any-motion interrupt1*/
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* axis*/
+		com_rslt = bmi160_read_reg(BMI160_USER_INTR_ENABLE_0_ADDR,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_any_motion_axis_stat_u8;
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_ENABLE_0_ADDR,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+
+	case BMI160_MAP_INTR2:
+		/* map the signification interrupt to any-motion interrupt2*/
+		com_rslt += bmi160_read_reg(
+		BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_any_motion_intr2_stat_u8;
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* axis*/
+		com_rslt = bmi160_read_reg(BMI160_USER_INTR_ENABLE_0_ADDR,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_any_motion_axis_stat_u8;
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_ENABLE_0_ADDR,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to trigger the step detector
+ *	interrupt
+ *
+ *
+ *  @param  v_step_detector_u8 : The value of interrupt selection
+ *  value    |  interrupt
+ * ----------|-----------
+ *   0       |  BMI160_MAP_INTR1
+ *   1       |  BMI160_MAP_INTR2
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_map_step_detector_intr(
+u8 v_step_detector_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_step_det_u8 = BMI160_INIT_VALUE;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 v_low_g_intr_u81_stat_u8 = BMI160_LOW_G_INTR_STAT;
+	u8 v_low_g_intr_u82_stat_u8 = BMI160_LOW_G_INTR_STAT;
+	u8 v_low_g_enable_u8 = BMI160_ENABLE_LOW_G;
+	/* read the v_status_s8 of step detector interrupt*/
+	com_rslt = bmi160_get_step_detector_enable(&v_step_det_u8);
+	if (v_step_det_u8 != BMI160_STEP_DET_STAT_HIGH)
+		com_rslt += bmi160_set_step_detector_enable(
+		BMI160_STEP_DETECT_INTR_ENABLE);
+	switch (v_step_detector_u8) {
+	case BMI160_MAP_INTR1:
+		com_rslt += bmi160_read_reg(
+		BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_low_g_intr_u81_stat_u8;
+		/* map the step detector interrupt
+		to Low-g interrupt 1*/
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* Enable the Low-g interrupt*/
+		com_rslt = bmi160_read_reg(
+		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_low_g_enable_u8;
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_MAP_INTR2:
+		/* map the step detector interrupt
+		to Low-g interrupt 1*/
+		com_rslt += bmi160_read_reg(
+		BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_low_g_intr_u82_stat_u8;
+
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* Enable the Low-g interrupt*/
+		com_rslt = bmi160_read_reg(
+		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_data_u8 |= v_low_g_enable_u8;
+		com_rslt += bmi160_write_reg(
+		BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API used to clear the step counter interrupt
+ *	interrupt
+ *
+ *
+ *  @param  : None
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_clear_step_counter(void)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* clear the step counter*/
+	com_rslt = bmi160_set_command_register(RESET_STEP_COUNTER);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+
+	return com_rslt;
+
+}
+ /*!
+ *	@brief This API writes value to the register 0x7E bit 0 to 7
+ *
+ *
+ *  @param  v_command_reg_u8 : The value to write command register
+ *  value   |  Description
+ * ---------|--------------------------------------------------------
+ *	0x00	|	Reserved
+ *  0x03	|	Starts fast offset calibration for the accel and gyro
+ *	0x10	|	Sets the PMU mode for the Accelerometer to suspend
+ *	0x11	|	Sets the PMU mode for the Accelerometer to normal
+ *	0x12	|	Sets the PMU mode for the Accelerometer Lowpower
+ *  0x14	|	Sets the PMU mode for the Gyroscope to suspend
+ *	0x15	|	Sets the PMU mode for the Gyroscope to normal
+ *	0x16	|	Reserved
+ *	0x17	|	Sets the PMU mode for the Gyroscope to fast start-up
+ *  0x18	|	Sets the PMU mode for the Magnetometer to suspend
+ *	0x19	|	Sets the PMU mode for the Magnetometer to normal
+ *	0x1A	|	Sets the PMU mode for the Magnetometer to Lowpower
+ *	0xB0	|	Clears all data in the FIFO
+ *  0xB1	|	Resets the interrupt engine
+ *	0xB2	|	step_cnt_clr Clears the step counter
+ *	0xB6	|	Triggers a reset
+ *	0x37	|	See extmode_en_last
+ *	0x9A	|	See extmode_en_last
+ *	0xC0	|	Enable the extended mode
+ *  0xC4	|	Erase NVM cell
+ *	0xC8	|	Load NVM cell
+ *	0xF0	|	Reset acceleration data path
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_command_register(u8 v_command_reg_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write command register */
+			com_rslt = p_bmi160->BMI160_BUS_WRITE_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_CMD_COMMANDS__REG,
+			&v_command_reg_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read target page from the register 0x7F bit 4 and 5
+ *
+ *  @param v_target_page_u8: The value of target page
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  User data/configure page
+ *   1      |  Chip level trim/test page
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_target_page(u8 *v_target_page_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* read the page*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+			p_bmi160->dev_addr,
+			BMI160_CMD_TARGET_PAGE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			*v_target_page_u8 = BMI160_GET_BITSLICE(v_data_u8,
+			BMI160_CMD_TARGET_PAGE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write target page from the register 0x7F bit 4 and 5
+ *
+ *  @param v_target_page_u8: The value of target page
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  User data/configure page
+ *   1      |  Chip level trim/test page
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_target_page(u8 v_target_page_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_target_page_u8 <= BMI160_MAX_TARGET_PAGE) {
+			/* write the page*/
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_CMD_TARGET_PAGE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_CMD_TARGET_PAGE,
+				v_target_page_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_CMD_TARGET_PAGE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read page enable from the register 0x7F bit 7
+ *
+ *
+ *
+ *  @param v_page_enable_u8: The value of page enable
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  DISABLE
+ *   1      |  ENABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_paging_enable(u8 *v_page_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* read the page enable */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_CMD_PAGING_EN__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_page_enable_u8 = BMI160_GET_BITSLICE(v_data_u8,
+		BMI160_CMD_PAGING_EN);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API write page enable from the register 0x7F bit 7
+ *
+ *
+ *
+ *  @param v_page_enable_u8: The value of page enable
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  DISABLE
+ *   1      |  ENABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_paging_enable(
+u8 v_page_enable_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		if (v_page_enable_u8 <= BMI160_MAX_VALUE_PAGE) {
+			/* write the page enable */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_CMD_PAGING_EN__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_CMD_PAGING_EN,
+				v_page_enable_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_CMD_PAGING_EN__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		} else {
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This API read
+ *	pull up configuration from the register 0X85 bit 4 an 5
+ *
+ *
+ *
+ *  @param v_control_pullup_u8: The value of pull up register
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_pullup_configuration(
+u8 *v_control_pullup_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt  = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* read pull up value */
+		com_rslt = p_bmi160->BMI160_BUS_READ_FUNC(
+		p_bmi160->dev_addr,
+		BMI160_COM_C_TRIM_FIVE__REG,
+		&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		*v_control_pullup_u8 = BMI160_GET_BITSLICE(v_data_u8,
+		BMI160_COM_C_TRIM_FIVE);
+		}
+	return com_rslt;
+
+}
+ /*!
+ *	@brief This API write
+ *	pull up configuration from the register 0X85 bit 4 an 5
+ *
+ *
+ *
+ *  @param v_control_pullup_u8: The value of pull up register
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_pullup_configuration(
+u8 v_control_pullup_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+			/* write  pull up value */
+			com_rslt = p_bmi160->BMI160_BUS_READ_FUNC
+			(p_bmi160->dev_addr,
+			BMI160_COM_C_TRIM_FIVE__REG,
+			&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			if (com_rslt == SUCCESS) {
+				v_data_u8 =
+				BMI160_SET_BITSLICE(v_data_u8,
+				BMI160_COM_C_TRIM_FIVE,
+				v_control_pullup_u8);
+				com_rslt +=
+				p_bmi160->BMI160_BUS_WRITE_FUNC
+				(p_bmi160->dev_addr,
+				BMI160_COM_C_TRIM_FIVE__REG,
+				&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+			}
+		}
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for reading the compensated data of
+ *	mag secondary interface xyz data
+ *	@param v_mag_x_s16: The value of mag x data
+ *	@param v_mag_y_s16: The value of mag y data
+ *	@param v_mag_z_s16: The value of mag z data
+ *	@param v_mag_r_s16: The value of mag r data
+ *	@param v_mag_second_if_u8: The value of mag selection
+ *
+ *  value   |   v_mag_second_if_u8
+ * ---------|----------------------
+ *    0     |    BMM150
+ *    1     |    AKM09911
+ *    2     |    AKM09912
+ *    3     |    YAS532
+ *    4     |    YAS537
+ *	@param mag_fifo_data: The value of compensated mag xyz data
+ *
+ *
+ *  @return
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_second_if_mag_compensate_xyz(
+struct bmi160_mag_fifo_data_t mag_fifo_data,
+u8 v_mag_second_if_u8)
+{
+s8 com_rslt = BMI160_INIT_VALUE;
+s16 v_mag_x_s16 = BMI160_INIT_VALUE;
+s16 v_mag_y_s16 = BMI160_INIT_VALUE;
+s16 v_mag_z_s16 = BMI160_INIT_VALUE;
+u16 v_mag_r_u16 = BMI160_INIT_VALUE;
+u8 i = BMI160_INIT_VALUE;
+u8 v_ouflow_u8 = BMI160_INIT_VALUE;
+u8 v_busy_u8 = BMI160_INIT_VALUE;
+u8 v_coil_stat_u8 = BMI160_INIT_VALUE;
+u16 v_temperature_u16 = BMI160_INIT_VALUE;
+s32 a_h_s32[BMI160_YAS_H_DATA_SIZE] = {
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+s32 a_s_s32[BMI160_YAS_S_DATA_SIZE] = {
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+u16 xy1y2[3] = {
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+u16 v_xy1y2_u16[3] = {
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+u8 v_busy_yas532_u8 = BMI160_INIT_VALUE;
+u16 v_temp_yas532_u16 = BMI160_INIT_VALUE;
+u8 v_overflow_yas532_u8 = BMI160_INIT_VALUE;
+
+switch (v_mag_second_if_u8) {
+case BMI160_SEC_IF_BMM150:
+	/* x data*/
+	v_mag_x_s16 = (s16)((mag_fifo_data.mag_x_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_x_lsb));
+	v_mag_x_s16 = (s16)
+	(v_mag_x_s16 >> BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
+	/* y data*/
+	v_mag_y_s16 = (s16)((mag_fifo_data.mag_y_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_y_lsb));
+	v_mag_y_s16 = (s16)
+	(v_mag_y_s16 >> BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
+	/* z data*/
+	v_mag_z_s16 = (s16)((mag_fifo_data.mag_z_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_z_lsb));
+	v_mag_z_s16 = (s16)
+	(v_mag_z_s16 >> BMI160_SHIFT_BIT_POSITION_BY_01_BIT);
+	/* r data*/
+	v_mag_r_u16 = (u16)((mag_fifo_data.mag_r_y2_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_r_y2_lsb));
+	v_mag_r_u16 = (u16)
+	(v_mag_r_u16 >> BMI160_SHIFT_BIT_POSITION_BY_02_BITS);
+	/* Compensated mag x data */
+	processed_data.x =
+	bmi160_bmm150_mag_compensate_X(v_mag_x_s16,
+	v_mag_r_u16);
+	/* Compensated mag y data */
+	processed_data.y =
+	bmi160_bmm150_mag_compensate_Y(v_mag_y_s16,
+	v_mag_r_u16);
+	/* Compensated mag z data */
+	processed_data.z =
+	bmi160_bmm150_mag_compensate_Z(v_mag_z_s16,
+	v_mag_r_u16);
+break;
+case BMI160_SEC_IF_AKM09911:
+	/* x data*/
+	v_mag_x_s16 = (s16)((mag_fifo_data.mag_x_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_x_lsb));
+	/* y data*/
+	v_mag_y_s16 = (s16)((mag_fifo_data.mag_y_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_y_lsb));
+	/* z data*/
+	v_mag_z_s16 = (s16)((mag_fifo_data.mag_z_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_z_lsb));
+	/* Compensated for X data */
+	processed_data.x =
+	bmi160_bst_akm09911_compensate_X(v_mag_x_s16);
+	/* Compensated for Y data */
+	processed_data.y =
+	bmi160_bst_akm09911_compensate_Y(v_mag_y_s16);
+	/* Compensated for Z data */
+	processed_data.z =
+	bmi160_bst_akm09911_compensate_Z(v_mag_z_s16);
+break;
+case BMI160_SEC_IF_AKM09912:
+	/* x data*/
+	v_mag_x_s16 = (s16)((mag_fifo_data.mag_x_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_x_lsb));
+	/* y data*/
+	v_mag_y_s16 = (s16)((mag_fifo_data.mag_y_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_y_lsb));
+	/* z data*/
+	v_mag_z_s16 = (s16)((mag_fifo_data.mag_z_msb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_z_lsb));
+	/* Compensated for X data */
+	processed_data.x =
+	bmi160_bst_akm09912_compensate_X(v_mag_x_s16);
+	/* Compensated for Y data */
+	processed_data.y =
+	bmi160_bst_akm09912_compensate_Y(v_mag_y_s16);
+	/* Compensated for Z data */
+	processed_data.z =
+	bmi160_bst_akm09912_compensate_Z(v_mag_z_s16);
+break;
+case BMI160_SEC_IF_YAS532:
+	/* read the xyy1 data*/
+	v_busy_yas532_u8 =
+	((mag_fifo_data.mag_x_lsb
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01);
+	v_temp_yas532_u16 =
+	(u16)((((s32)mag_fifo_data.mag_x_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
+	& 0x3F8) | ((mag_fifo_data.mag_x_msb
+	>> BMI160_SHIFT_BIT_POSITION_BY_05_BITS) & 0x07));
+
+	v_xy1y2_u16[0] =
+	(u16)((((s32)mag_fifo_data.mag_y_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0x1FC0)
+	| ((mag_fifo_data.mag_y_msb >>
+	BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
+	v_xy1y2_u16[1] =
+	(u16)((((s32)mag_fifo_data.mag_z_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
+	& 0x1FC0)
+	| ((mag_fifo_data.mag_z_msb
+	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
+	v_xy1y2_u16[2] =
+	(u16)((((s32)mag_fifo_data.mag_r_y2_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
+	& 0x1FC0)
+	| ((mag_fifo_data.mag_r_y2_msb
+	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
+	v_overflow_yas532_u8 = 0;
+	for (i = 0; i < 3; i++) {
+		if (v_xy1y2_u16[i] == YAS532_DATA_OVERFLOW)
+			v_overflow_yas532_u8 |= (1 << (i * 2));
+		if (v_xy1y2_u16[i] == YAS532_DATA_UNDERFLOW)
+			v_overflow_yas532_u8 |= (1 << (i * 2 + 1));
+	}
+	/* assign the data*/
+	com_rslt = bmi160_bst_yas532_fifo_xyz_data(
+	v_xy1y2_u16, 1, v_overflow_yas532_u8,
+	v_temp_yas532_u16, v_busy_yas532_u8);
+	processed_data.x =
+	fifo_xyz_data.yas532_vector_xyz[0];
+	processed_data.y =
+	fifo_xyz_data.yas532_vector_xyz[1];
+	processed_data.z =
+	fifo_xyz_data.yas532_vector_xyz[2];
+break;
+case BMI160_SEC_IF_YAS537:
+	/* read the busy flag*/
+	v_busy_u8 = mag_fifo_data.mag_y_lsb
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS;
+	/* read the coil status*/
+	v_coil_stat_u8 =
+	((mag_fifo_data.mag_y_lsb >>
+	BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0X01);
+	/* read temperature data*/
+	v_temperature_u16 = (u16)((mag_fifo_data.mag_x_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| mag_fifo_data.mag_x_msb);
+	/* read x data*/
+	xy1y2[0] = (u16)(((mag_fifo_data.mag_y_lsb &
+	0x3F)
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (mag_fifo_data.mag_y_msb));
+	/* read y1 data*/
+	xy1y2[1] = (u16)((mag_fifo_data.mag_z_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| mag_fifo_data.mag_z_msb);
+	/* read y2 data*/
+	xy1y2[2] = (u16)((mag_fifo_data.mag_r_y2_lsb
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| mag_fifo_data.mag_r_y2_msb);
+	for (i = 0; i < 3; i++)
+		yas537_data.last_raw[i] = xy1y2[i];
+		yas537_data.last_raw[i] = v_temperature_u16;
+		if (yas537_data.calib_yas537.ver == 1) {
+			for (i = 0; i < 3; i++)
+				a_s_s32[i] = xy1y2[i] - 8192;
+		/* read hx*/
+		a_h_s32[0] = ((yas537_data.calib_yas537.k * (
+		(128 * a_s_s32[0]) +
+		(yas537_data.calib_yas537.a2 * a_s_s32[1]) +
+		(yas537_data.calib_yas537.a3 * a_s_s32[2])))
+		/ (8192));
+		/* read hy1*/
+		a_h_s32[1] = ((yas537_data.calib_yas537.k * (
+		(yas537_data.calib_yas537.a4 * a_s_s32[0]) +
+		(yas537_data.calib_yas537.a5 * a_s_s32[1]) +
+		(yas537_data.calib_yas537.a6 * a_s_s32[2])))
+		/ (8192));
+		/* read hy2*/
+		a_h_s32[2] = ((yas537_data.calib_yas537.k * (
+		(yas537_data.calib_yas537.a7 * a_s_s32[0]) +
+		(yas537_data.calib_yas537.a8 * a_s_s32[1]) +
+		(yas537_data.calib_yas537.a9 * a_s_s32[2])))
+		/ (8192));
+
+	for (i = 0; i < 3; i++) {
+		if (a_h_s32[i] < -8192)
+			a_h_s32[i] = -8192;
+
+		if (8192 < a_h_s32[i])
+			a_h_s32[i] = 8192;
+
+		xy1y2[i] = a_h_s32[i] + 8192;
+
+	}
+	}
+	v_ouflow_u8 = 0;
+	for (i = 0; i < 3; i++) {
+		if (YAS537_DATA_OVERFLOW
+		<= xy1y2[i])
+			v_ouflow_u8 |=
+			(1 << (i * 2));
+		if (xy1y2[i] ==
+		YAS537_DATA_UNDERFLOW)
+			v_ouflow_u8
+			|= (1 << (i * 2 + 1));
+	}
+	com_rslt = bmi160_bst_yamaha_yas537_fifo_xyz_data(
+	xy1y2, v_ouflow_u8, v_coil_stat_u8, v_busy_u8);
+	processed_data.x =
+	fifo_vector_xyz.yas537_vector_xyz[0];
+	processed_data.y =
+	fifo_vector_xyz.yas537_vector_xyz[1];
+	processed_data.z =
+	fifo_vector_xyz.yas537_vector_xyz[2];
+break;
+default:
+	com_rslt = E_BMI160_OUT_OF_RANGE;
+break;
+}
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header mode
+ *
+ *
+ *	@note Configure the below functions for FIFO header mode
+ *	@note 1. bmi160_set_fifo_down_gyro()
+ *	@note 2. bmi160_set_gyro_fifo_filter_data()
+ *	@note 3. bmi160_set_fifo_down_accel()
+ *	@note 4. bmi160_set_accel_fifo_filter_dat()
+ *	@note 5. bmi160_set_fifo_mag_enable()
+ *	@note 6. bmi160_set_fifo_accel_enable()
+ *	@note 7. bmi160_set_fifo_gyro_enable()
+ *	@note 8. bmi160_set_fifo_header_enable()
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full()
+ *	@note 2. bmi160_set_intr_fifo_wm()
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable()
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable()
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data(u8 v_mag_if_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	struct bmi160_fifo_data_header_t header_data;
+	/* read the whole fifo data*/
+	com_rslt =
+	bmi160_read_fifo_header_data_user_defined_length(
+	FIFO_FRAME, v_mag_if_u8, &header_data);
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header mode for using user defined length
+ *
+ *
+ *	@note Configure the below functions for FIFO header mode
+ *	@note 1. bmi160_set_fifo_down_gyro()
+ *	@note 2. bmi160_set_gyro_fifo_filter_data()
+ *	@note 3. bmi160_set_fifo_down_accel()
+ *	@note 4. bmi160_set_accel_fifo_filter_dat()
+ *	@note 5. bmi160_set_fifo_mag_enable()
+ *	@note 6. bmi160_set_fifo_accel_enable()
+ *	@note 7. bmi160_set_fifo_gyro_enable()
+ *	@note 8. bmi160_set_fifo_header_enable()
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full()
+ *	@note 2. bmi160_set_intr_fifo_wm()
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable()
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable()
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data_user_defined_length(
+u16 v_fifo_user_length_u16, u8 v_mag_if_mag_u8,
+struct bmi160_fifo_data_header_t *fifo_header_data)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_accel_index_u8 = BMI160_INIT_VALUE;
+	u8 v_gyro_index_u8 = BMI160_INIT_VALUE;
+	u8 v_mag_index_u8 = BMI160_INIT_VALUE;
+	s8 v_last_return_stat_s8 = BMI160_INIT_VALUE;
+	u16 v_fifo_index_u16 = BMI160_INIT_VALUE;
+	u8 v_frame_head_u8 = BMI160_INIT_VALUE;
+	u8 v_frame_index_u8 = BMI160_INIT_VALUE;
+
+	u16 v_fifo_length_u16 = BMI160_INIT_VALUE;
+
+	fifo_header_data->accel_frame_count = BMI160_INIT_VALUE;
+	fifo_header_data->mag_frame_count = BMI160_INIT_VALUE;
+	fifo_header_data->gyro_frame_count = BMI160_INIT_VALUE;
+	/* read fifo v_data_u8*/
+	com_rslt = bmi160_fifo_data(&v_fifo_data_u8[BMI160_INIT_VALUE],
+	v_fifo_user_length_u16);
+	v_fifo_length_u16 = v_fifo_user_length_u16;
+	for (v_fifo_index_u16 = BMI160_INIT_VALUE;
+	v_fifo_index_u16 < v_fifo_length_u16;) {
+		fifo_header_data->fifo_header[v_frame_index_u8]
+		= v_fifo_data_u8[v_fifo_index_u16];
+		v_frame_head_u8 =
+		fifo_header_data->fifo_header[v_frame_index_u8]
+		 & BMI160_FIFO_TAG_INTR_MASK;
+		v_frame_index_u8++;
+		switch (v_frame_head_u8) {
+		/* Header frame of accel */
+		case FIFO_HEAD_A:
+		{	/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_INDEX_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_A_LENGTH)
+			> v_fifo_length_u16) {
+				v_last_return_stat_s8 = FIFO_A_OVER_LEN;
+			break;
+			}
+			/* Accel raw x v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].x =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_MSB_DATA])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_LSB_DATA]));
+			/* Accel raw y v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].y =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_MSB_DATA])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_LSB_DATA]));
+			/* Accel raw z v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].z =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_MSB_DATA])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_LSB_DATA]));
+			/* check for accel frame count*/
+			fifo_header_data->accel_frame_count =
+			fifo_header_data->accel_frame_count
+			+ BMI160_FRAME_COUNT;
+			/* index adde to 6 accel alone*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_A_LENGTH;
+			v_accel_index_u8++;
+
+		break;
+		}
+		/* Header frame of gyro */
+		case FIFO_HEAD_G:
+		{	/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16
+			+ BMI160_FIFO_INDEX_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_G_LENGTH) >
+			v_fifo_length_u16) {
+				v_last_return_stat_s8 = FIFO_G_OVER_LEN;
+			break;
+			}
+			/* Gyro raw x v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].x  =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_MSB_DATA])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_LSB_DATA]));
+			/* Gyro raw y v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].y =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_MSB_DATA])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_LSB_DATA]));
+			/* Gyro raw z v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].z  =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_MSB_DATA])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			| (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_LSB_DATA]));
+			/* check for gyro frame count*/
+			fifo_header_data->gyro_frame_count =
+			fifo_header_data->gyro_frame_count + BMI160_FRAME_COUNT;
+			/*fifo G v_data_u8 frame index + 6*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_G_LENGTH;
+			v_gyro_index_u8++;
+
+		break;
+		}
+		/* Header frame of mag */
+		case FIFO_HEAD_M:
+		{	/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16
+			+ BMI160_FIFO_INDEX_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_M_LENGTH) >
+			(v_fifo_length_u16)) {
+				v_last_return_stat_s8 = FIFO_M_OVER_LEN;
+			break;
+			}
+			/* Mag x data*/
+			mag_data.mag_x_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_LSB_DATA]);
+			mag_data.mag_x_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_MSB_DATA]);
+			/* Mag y data*/
+			mag_data.mag_y_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_LSB_DATA]);
+			mag_data.mag_y_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_MSB_DATA]);
+			mag_data.mag_z_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_LSB_DATA]);
+			mag_data.mag_z_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_MSB_DATA]);
+			/* Mag r data*/
+			mag_data.mag_r_y2_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_LSB_DATA]);
+			mag_data.mag_r_y2_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_MSB_DATA]);
+
+			com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
+			v_mag_if_mag_u8);
+			 /* compensated mag x */
+			fifo_header_data->mag_fifo[v_gyro_index_u8].x
+			= processed_data.x;
+			/* compensated mag y */
+			fifo_header_data->mag_fifo[v_gyro_index_u8].y
+			= processed_data.y;
+			/* compensated mag z */
+			fifo_header_data->mag_fifo[v_gyro_index_u8].z
+			= processed_data.z;
+
+			/* check for mag frame count*/
+			fifo_header_data->mag_frame_count =
+			fifo_header_data->mag_frame_count
+			+ BMI160_FRAME_COUNT;
+
+			v_mag_index_u8++;
+			/*fifo M v_data_u8 frame index + 8*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_M_LENGTH;
+		break;
+		}
+		/* Header frame of gyro and accel */
+		case FIFO_HEAD_G_A:
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_INDEX_LENGTH;
+			if ((v_fifo_index_u16 + BMI160_FIFO_AG_LENGTH)
+			> v_fifo_length_u16) {
+				v_last_return_stat_s8 = FIFO_G_A_OVER_LEN;
+			break;
+			}
+			/* Raw gyro x */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].x   =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_G_X_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_G_X_LSB]));
+			/* Raw gyro y */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].y  =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_G_Y_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_G_Y_LSB]));
+			/* Raw gyro z */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].z  =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_G_Z_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_G_Z_LSB]));
+			/* check for gyro frame count*/
+			fifo_header_data->gyro_frame_count =
+			fifo_header_data->gyro_frame_count + BMI160_FRAME_COUNT;
+			/* Raw accel x */
+			fifo_header_data->accel_fifo[v_accel_index_u8].x =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_A_X_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_A_X_LSB]));
+			/* Raw accel y */
+			fifo_header_data->accel_fifo[v_accel_index_u8].y =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_A_Y_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_A_Y_LSB]));
+			/* Raw accel z */
+			fifo_header_data->accel_fifo[v_accel_index_u8].z =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_GA_FIFO_A_Z_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16
+			+ BMI160_GA_FIFO_A_Z_LSB]));
+			/* check for accel frame count*/
+			fifo_header_data->accel_frame_count =
+			fifo_header_data->accel_frame_count
+			+ BMI160_FRAME_COUNT;
+			/* Index added to 12 for gyro and accel*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_AG_LENGTH;
+			v_gyro_index_u8++;
+			v_accel_index_u8++;
+		break;
+		/* Header frame of mag, gyro and accel */
+		case FIFO_HEAD_M_G_A:
+			{	/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16
+			+ BMI160_FIFO_INDEX_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_AMG_LENGTH)
+			> (v_fifo_length_u16)) {
+				v_last_return_stat_s8 = FIFO_M_G_A_OVER_LEN;
+				break;
+			}
+					/* Mag x data*/
+			mag_data.mag_x_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_LSB_DATA]);
+			mag_data.mag_x_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_MSB_DATA]);
+			/* Mag y data*/
+			mag_data.mag_y_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_LSB_DATA]);
+			mag_data.mag_y_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_MSB_DATA]);
+			mag_data.mag_z_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_LSB_DATA]);
+			mag_data.mag_z_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_MSB_DATA]);
+			/* Mag r data*/
+			mag_data.mag_r_y2_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_LSB_DATA]);
+			mag_data.mag_r_y2_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_MSB_DATA]);
+			/* Processing the compensation data*/
+			com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
+			v_mag_if_mag_u8);
+			 /* compensated mag x */
+			fifo_header_data->mag_fifo[v_mag_index_u8].x =
+			processed_data.x;
+			/* compensated mag y */
+			fifo_header_data->mag_fifo[v_mag_index_u8].y =
+			processed_data.y;
+			/* compensated mag z */
+			fifo_header_data->mag_fifo[v_mag_index_u8].z =
+			processed_data.z;
+			/* check for mag frame count*/
+			fifo_header_data->mag_frame_count =
+			fifo_header_data->mag_frame_count + BMI160_FRAME_COUNT;
+			/* Gyro raw x v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].x =
+				(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+				BMI160_MGA_FIFO_G_X_MSB])
+				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+				|(v_fifo_data_u8[v_fifo_index_u16 +
+				BMI160_MGA_FIFO_G_X_LSB]));
+			/* Gyro raw y v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].y =
+				(s16)(((v_fifo_data_u8[
+				v_fifo_index_u16 + BMI160_MGA_FIFO_G_Y_MSB])
+				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+				|(v_fifo_data_u8[v_fifo_index_u16 +
+				BMI160_MGA_FIFO_G_Y_LSB]));
+			/* Gyro raw z v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].z =
+				(s16)(((v_fifo_data_u8[
+				v_fifo_index_u16 + BMI160_MGA_FIFO_G_Z_MSB])
+				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+				|(v_fifo_data_u8[
+				v_fifo_index_u16 + BMI160_MGA_FIFO_G_Z_LSB]));
+			/* check for gyro frame count*/
+			fifo_header_data->gyro_frame_count =
+			fifo_header_data->gyro_frame_count + BMI160_FRAME_COUNT;
+			/* Accel raw x v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].x =
+				(s16)(((v_fifo_data_u8[
+				v_fifo_index_u16 + BMI160_MGA_FIFO_A_X_MSB])
+				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+				|(v_fifo_data_u8[v_fifo_index_u16 +
+				BMI160_MGA_FIFO_A_X_LSB]));
+			/* Accel raw y v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].y =
+				(s16)(((v_fifo_data_u8[
+				v_fifo_index_u16 + BMI160_MGA_FIFO_A_Y_MSB])
+				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+				|(v_fifo_data_u8[v_fifo_index_u16 +
+				BMI160_MGA_FIFO_A_Y_LSB]));
+			/* Accel raw z v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].z =
+				(s16)(((v_fifo_data_u8[
+				v_fifo_index_u16 + BMI160_MGA_FIFO_A_Z_MSB])
+				<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+				|(v_fifo_data_u8[v_fifo_index_u16 +
+				BMI160_MGA_FIFO_A_Z_LSB]));
+			/* check for accel frame count*/
+			fifo_header_data->accel_frame_count =
+			fifo_header_data->accel_frame_count
+			+ BMI160_FRAME_COUNT;
+			/* Index added to 20 for mag, gyro and accel*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_AMG_LENGTH;
+			v_accel_index_u8++;
+			v_mag_index_u8++;
+			v_gyro_index_u8++;
+		break;
+			}
+		/* Header frame of mag and accel */
+		case FIFO_HEAD_M_A:
+			{	/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16
+			+ BMI160_GEN_READ_WRITE_DATA_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_MA_OR_MG_LENGTH)
+			> (v_fifo_length_u16)) {
+				v_last_return_stat_s8 = FIFO_M_A_OVER_LEN;
+				break;
+			}
+			/* Mag x data*/
+			mag_data.mag_x_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_LSB_DATA]);
+			mag_data.mag_x_msb = (v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_MSB_DATA]);
+			/* Mag y data*/
+			mag_data.mag_y_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_LSB_DATA]);
+			mag_data.mag_y_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_MSB_DATA]);
+			mag_data.mag_z_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_LSB_DATA]);
+			mag_data.mag_z_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_MSB_DATA]);
+			/* Mag r data*/
+			mag_data.mag_r_y2_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_LSB_DATA]);
+			mag_data.mag_r_y2_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_MSB_DATA]);
+			com_rslt =
+			bmi160_second_if_mag_compensate_xyz(mag_data,
+			 v_mag_if_mag_u8);
+			 /* compensated mag x */
+			fifo_header_data->mag_fifo[v_mag_index_u8].x =
+			processed_data.x;
+			/* compensated mag y */
+			fifo_header_data->mag_fifo[v_mag_index_u8].y =
+			processed_data.y;
+			/* compensated mag z */
+			fifo_header_data->mag_fifo[v_mag_index_u8].z =
+			processed_data.z;
+			/* check for mag frame count*/
+			fifo_header_data->mag_frame_count =
+			fifo_header_data->mag_frame_count
+			+ BMI160_FRAME_COUNT;
+			/* Accel raw x v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].x =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MA_FIFO_A_X_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MA_FIFO_A_X_LSB]));
+			/* Accel raw y v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].y =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MA_FIFO_A_Y_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MA_FIFO_A_Y_LSB]));
+			/* Accel raw z v_data_u8 */
+			fifo_header_data->accel_fifo[v_accel_index_u8].z =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MA_FIFO_A_Z_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MA_FIFO_A_Z_LSB]));
+			/* check for accel frame count*/
+			fifo_header_data->accel_frame_count =
+			fifo_header_data->accel_frame_count
+			+ BMI160_FRAME_COUNT;
+			/*fifo AM v_data_u8 frame index + 14(8+6)*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_MA_OR_MG_LENGTH;
+			v_accel_index_u8++;
+			v_mag_index_u8++;
+		break;
+			}
+			/* Header frame of mag and gyro */
+		case FIFO_HEAD_M_G:
+			{
+			/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16
+			+ BMI160_GEN_READ_WRITE_DATA_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_MA_OR_MG_LENGTH)
+			> v_fifo_length_u16) {
+				v_last_return_stat_s8 = FIFO_M_G_OVER_LEN;
+				break;
+			}
+			/* Mag x data*/
+			mag_data.mag_x_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_LSB_DATA]);
+			mag_data.mag_x_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_X_MSB_DATA]);
+			/* Mag y data*/
+			mag_data.mag_y_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_LSB_DATA]);
+			mag_data.mag_y_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Y_MSB_DATA]);
+			mag_data.mag_z_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_LSB_DATA]);
+			mag_data.mag_z_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_Z_MSB_DATA]);
+			/* Mag r data*/
+			mag_data.mag_r_y2_lsb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_LSB_DATA]);
+			mag_data.mag_r_y2_msb =
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_R_MSB_DATA]);
+			com_rslt =
+			bmi160_second_if_mag_compensate_xyz(mag_data,
+			v_mag_if_mag_u8);
+			 /* compensated mag x */
+			fifo_header_data->mag_fifo[v_mag_index_u8].x =
+			processed_data.x;
+			/* compensated mag y */
+			fifo_header_data->mag_fifo[v_mag_index_u8].y =
+			processed_data.y;
+			/* compensated mag z */
+			fifo_header_data->mag_fifo[v_mag_index_u8].z =
+			processed_data.z;
+			/* check for mag frame count*/
+			fifo_header_data->mag_frame_count =
+			fifo_header_data->mag_frame_count + BMI160_FRAME_COUNT;
+			/* Gyro raw x v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].x =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MG_FIFO_G_X_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MG_FIFO_G_X_LSB]));
+			/* Gyro raw y v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].y =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MG_FIFO_G_Y_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MG_FIFO_G_Y_LSB]));
+			/* Gyro raw z v_data_u8 */
+			fifo_header_data->gyro_fifo[v_gyro_index_u8].z =
+			(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MG_FIFO_G_Z_MSB])
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+			|(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_MG_FIFO_G_Z_LSB]));
+			/* check for gyro frame count*/
+			fifo_header_data->gyro_frame_count =
+			fifo_header_data->gyro_frame_count
+			+ BMI160_FRAME_COUNT;
+			/*fifo GM v_data_u8 frame index + 14(8+6)*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_MA_OR_MG_LENGTH;
+			v_mag_index_u8++;
+			v_gyro_index_u8++;
+		break;
+			}
+		/* Header frame of sensor time */
+		case FIFO_HEAD_SENSOR_TIME:
+			{
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_GEN_READ_WRITE_DATA_LENGTH;
+
+			if ((v_fifo_index_u16
+			+ BMI160_FIFO_SENSOR_TIME_LENGTH) >
+			(v_fifo_length_u16)) {
+				v_last_return_stat_s8
+				= FIFO_SENSORTIME_RETURN;
+			break;
+			}
+			/* Sensor time */
+			fifo_header_data->fifo_time = (u32)
+			((v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_SENSOR_TIME_MSB]
+			<< BMI160_SHIFT_BIT_POSITION_BY_16_BITS) |
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_SENSOR_TIME_XLSB]
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_fifo_data_u8[v_fifo_index_u16 +
+			BMI160_FIFO_SENSOR_TIME_LSB]));
+
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_SENSOR_TIME_LENGTH;
+		break;
+			}
+		/* Header frame of skip frame */
+		case FIFO_HEAD_SKIP_FRAME:
+			{
+			/*fifo v_data_u8 frame index + 1*/
+				v_fifo_index_u16 = v_fifo_index_u16 +
+				BMI160_FIFO_INDEX_LENGTH;
+				if (v_fifo_index_u16
+				+ BMI160_FIFO_INDEX_LENGTH
+				> v_fifo_length_u16) {
+					v_last_return_stat_s8 =
+					FIFO_SKIP_OVER_LEN;
+				break;
+				}
+				fifo_header_data->skip_frame =
+				v_fifo_data_u8[v_fifo_index_u16];
+				v_fifo_index_u16 = v_fifo_index_u16 +
+				BMI160_FIFO_INDEX_LENGTH;
+		break;
+			}
+		case FIFO_HEAD_INPUT_CONFIG:
+			{
+			/*fifo v_data_u8 frame index + 1*/
+				v_fifo_index_u16 = v_fifo_index_u16 +
+				BMI160_FIFO_INDEX_LENGTH;
+				if (v_fifo_index_u16
+				+ BMI160_FIFO_INDEX_LENGTH
+				> v_fifo_length_u16) {
+					v_last_return_stat_s8 =
+					FIFO_INPUT_CONFIG_OVER_LEN;
+				break;
+				}
+				fifo_header_data->fifo_input_config_info
+				= v_fifo_data_u8[v_fifo_index_u16];
+				v_fifo_index_u16 = v_fifo_index_u16 +
+				BMI160_FIFO_INDEX_LENGTH;
+		break;
+			}
+		/* Header frame of over read fifo v_data_u8 */
+		case FIFO_HEAD_OVER_READ_LSB:
+			{
+		/*fifo v_data_u8 frame index + 1*/
+			v_fifo_index_u16 = v_fifo_index_u16 +
+			BMI160_FIFO_INDEX_LENGTH;
+
+			if ((v_fifo_index_u16 + BMI160_FIFO_INDEX_LENGTH)
+			> (v_fifo_length_u16)) {
+				v_last_return_stat_s8 = FIFO_OVER_READ_RETURN;
+			break;
+			}
+			if (v_fifo_data_u8[v_fifo_index_u16] ==
+			FIFO_HEAD_OVER_READ_MSB) {
+				/*fifo over read frame index + 1*/
+				v_fifo_index_u16 = v_fifo_index_u16 +
+				BMI160_FIFO_INDEX_LENGTH;
+			break;
+			} else {
+				v_last_return_stat_s8 = FIFO_OVER_READ_RETURN;
+			break;
+			}
+			}
+
+		default:
+			v_last_return_stat_s8 = BMI160_FIFO_INDEX_LENGTH;
+		break;
+		}
+	if (v_last_return_stat_s8)
+		break;
+	}
+return com_rslt;
+}
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header less mode
+ *
+ *
+ *
+ *	@note Configure the below functions for FIFO header less mode
+ *	@note 1. bmi160_set_fifo_down_gyro
+ *	@note 2. bmi160_set_gyro_fifo_filter_data
+ *	@note 3. bmi160_set_fifo_down_accel
+ *	@note 4. bmi160_set_accel_fifo_filter_dat
+ *	@note 5. bmi160_set_fifo_mag_enable
+ *	@note 6. bmi160_set_fifo_accel_enable
+ *	@note 7. bmi160_set_fifo_gyro_enable
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full
+ *	@note 2. bmi160_set_intr_fifo_wm
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_headerless_mode(
+u8 v_mag_if_u8) {
+
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	struct bmi160_fifo_data_header_less_t headerless_data;
+	/* read the whole FIFO data*/
+	com_rslt =
+	bmi160_read_fifo_headerless_mode_user_defined_length(
+	FIFO_FRAME, &headerless_data, v_mag_if_u8);
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header less mode for using user defined length
+ *
+ *
+ *	@param v_fifo_user_length_u16: The value of length of fifo read data
+ *
+ *	@note Configure the below functions for FIFO header less mode
+ *	@note 1. bmi160_set_fifo_down_gyro
+ *	@note 2. bmi160_set_gyro_fifo_filter_data
+ *	@note 3. bmi160_set_fifo_down_accel
+ *	@note 4. bmi160_set_accel_fifo_filter_dat
+ *	@note 5. bmi160_set_fifo_mag_enable
+ *	@note 6. bmi160_set_fifo_accel_enable
+ *	@note 7. bmi160_set_fifo_gyro_enable
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full
+ *	@note 2. bmi160_set_intr_fifo_wm
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE
+bmi160_read_fifo_headerless_mode_user_defined_length(
+u16 v_fifo_user_length_u16,
+struct bmi160_fifo_data_header_less_t *fifo_data,
+u8 v_mag_if_mag_u8)
+{
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u32 v_fifo_index_u16 = BMI160_INIT_VALUE;
+u32 v_fifo_length_u16 = BMI160_INIT_VALUE;
+u8 v_accel_index_u8 = BMI160_INIT_VALUE;
+u8 v_gyro_index_u8 = BMI160_INIT_VALUE;
+u8 v_mag_index_u8 = BMI160_INIT_VALUE;
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+fifo_data->accel_frame_count = BMI160_INIT_VALUE;
+fifo_data->mag_frame_count = BMI160_INIT_VALUE;
+fifo_data->gyro_frame_count = BMI160_INIT_VALUE;
+/* disable the header data */
+com_rslt = bmi160_set_fifo_header_enable(BMI160_INIT_VALUE);
+/* read mag, accel and gyro enable status*/
+com_rslt += bmi160_read_reg(BMI160_USER_FIFO_CONFIG_1_ADDR,
+&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+v_data_u8 = v_data_u8 & BMI160_FIFO_M_G_A_ENABLE;
+/* read the fifo data of 1024 bytes*/
+com_rslt += bmi160_fifo_data(&v_fifo_data_u8[BMI160_INIT_VALUE],
+v_fifo_user_length_u16);
+v_fifo_length_u16 = v_fifo_user_length_u16;
+/* loop for executing the different conditions */
+for (v_fifo_index_u16 = BMI160_INIT_VALUE;
+v_fifo_index_u16 < v_fifo_length_u16;) {
+	/* condition for mag, gyro and accel enable*/
+	if (v_data_u8 == BMI160_FIFO_M_G_A_ENABLE) {
+		/* Raw mag x*/
+		mag_data.mag_x_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_LSB_DATA]);
+		mag_data.mag_x_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_MSB_DATA]);
+		/* Mag y data*/
+		mag_data.mag_y_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_LSB_DATA]);
+		mag_data.mag_y_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_MSB_DATA]);
+		/* Mag z data*/
+		mag_data.mag_z_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_LSB_DATA]);
+		mag_data.mag_z_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_MSB_DATA]);
+		/* Mag r data*/
+		mag_data.mag_r_y2_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_LSB_DATA]);
+		mag_data.mag_r_y2_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_MSB_DATA]);
+		com_rslt =
+		bmi160_second_if_mag_compensate_xyz(mag_data,
+		v_mag_if_mag_u8);
+		/* compensated mag x */
+		fifo_data->mag_fifo[v_mag_index_u8].x =
+		processed_data.x;
+		/* compensated mag y */
+		fifo_data->mag_fifo[v_mag_index_u8].y =
+		processed_data.y;
+		/* compensated mag z */
+		fifo_data->mag_fifo[v_mag_index_u8].z =
+		processed_data.z;
+		/* check for mag frame count*/
+		fifo_data->mag_frame_count =
+		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
+		/* Gyro raw x v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_G_X_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_G_X_LSB]));
+		/* Gyro raw y v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_G_Y_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_G_Y_LSB]));
+		/* Gyro raw z v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_G_Z_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_G_Z_LSB]));
+		/* check for gyro frame count*/
+		fifo_data->gyro_frame_count =
+		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
+		/* Accel raw x v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].x =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_A_X_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_A_X_LSB]));
+		/* Accel raw y v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_A_Y_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_A_Y_LSB]));
+		/* Accel raw z v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].z =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_A_Z_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MGA_FIFO_A_Z_LSB]));
+		/* check for accel frame count*/
+		fifo_data->accel_frame_count =
+		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
+		v_accel_index_u8++;
+		v_mag_index_u8++;
+		v_gyro_index_u8++;
+	   v_fifo_index_u16 = v_fifo_index_u16 +
+	   BMI160_FIFO_AMG_LENGTH;
+	}
+	/* condition for mag and gyro enable*/
+	else if (v_data_u8 == BMI160_FIFO_M_G_ENABLE) {
+		/* Raw mag x*/
+		mag_data.mag_x_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_LSB_DATA]);
+		mag_data.mag_x_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_MSB_DATA]);
+		/* Mag y data*/
+		mag_data.mag_y_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_LSB_DATA]);
+		mag_data.mag_y_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_MSB_DATA]);
+		/* Mag z data*/
+		mag_data.mag_z_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_LSB_DATA]);
+		mag_data.mag_z_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_MSB_DATA]);
+		/* Mag r data*/
+		mag_data.mag_r_y2_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_LSB_DATA]);
+		mag_data.mag_r_y2_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_MSB_DATA]);
+		 com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
+		 v_mag_if_mag_u8);
+		 /* compensated mag x */
+		fifo_data->mag_fifo[v_mag_index_u8].x =
+		processed_data.x;
+		/* compensated mag y */
+		fifo_data->mag_fifo[v_mag_index_u8].y =
+		processed_data.y;
+		/* compensated mag z */
+		fifo_data->mag_fifo[v_mag_index_u8].z =
+		processed_data.z;
+		/* check for mag frame count*/
+		fifo_data->mag_frame_count =
+		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
+		/* Gyro raw x v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MG_FIFO_G_X_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MG_FIFO_G_X_LSB]));
+		/* Gyro raw y v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MG_FIFO_G_Y_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MG_FIFO_G_Y_LSB]));
+		/* Gyro raw z v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MG_FIFO_G_Z_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MG_FIFO_G_Z_LSB]));
+		/* check for gyro frame count*/
+		fifo_data->gyro_frame_count =
+		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
+		v_gyro_index_u8++;
+		v_mag_index_u8++;
+		v_fifo_index_u16 = v_fifo_index_u16 +
+		BMI160_FIFO_MA_OR_MG_LENGTH;
+	}
+	/* condition for mag and accel enable*/
+	else if (v_data_u8 == BMI160_FIFO_M_A_ENABLE) {
+		/* Raw mag x*/
+		mag_data.mag_x_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_LSB_DATA]);
+		mag_data.mag_x_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_MSB_DATA]);
+		/* Mag y data*/
+		mag_data.mag_y_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_LSB_DATA]);
+		mag_data.mag_y_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_MSB_DATA]);
+		/* Mag z data*/
+		mag_data.mag_z_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_LSB_DATA]);
+		mag_data.mag_z_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_MSB_DATA]);
+			/* Mag r data*/
+		mag_data.mag_r_y2_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_LSB_DATA]);
+		mag_data.mag_r_y2_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_MSB_DATA]);
+		 com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
+		 v_mag_if_mag_u8);
+		 /* compensated mag x */
+		fifo_data->mag_fifo[v_mag_index_u8].x =
+		processed_data.x;
+		/* compensated mag y */
+		fifo_data->mag_fifo[v_mag_index_u8].y =
+		processed_data.y;
+		/* compensated mag z */
+		fifo_data->mag_fifo[v_mag_index_u8].z =
+		processed_data.z;
+		/* check for mag frame count*/
+		fifo_data->mag_frame_count =
+		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
+		/* Accel raw x v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].x =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MA_FIFO_A_X_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MA_FIFO_A_X_LSB]));
+		/* Accel raw y v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MA_FIFO_A_Y_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MA_FIFO_A_Y_LSB]));
+		/* Accel raw z v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].z =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MA_FIFO_A_Z_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_MA_FIFO_A_Z_LSB]));
+		/* check for accel frame count*/
+		fifo_data->accel_frame_count =
+		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
+		v_accel_index_u8++;
+		v_mag_index_u8++;
+		v_fifo_index_u16 = v_fifo_index_u16 +
+		BMI160_FIFO_MA_OR_MG_LENGTH;
+	}
+	/* condition for gyro and accel enable*/
+	else if (v_data_u8 == BMI160_FIFO_G_A_ENABLE) {
+		/* Gyro raw x v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_G_X_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_G_X_LSB]));
+		/* Gyro raw y v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_G_Y_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_G_Y_LSB]));
+		/* Gyro raw z v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_G_Z_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_G_Z_LSB]));
+		/* check for gyro frame count*/
+		fifo_data->gyro_frame_count =
+		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
+		/* Accel raw x v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].x =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_A_X_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_A_X_LSB]));
+		/* Accel raw y v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_A_Y_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_A_Y_LSB]));
+		/* Accel raw z v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].z =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_A_Z_MSB])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_GA_FIFO_A_Z_LSB]));
+		/* check for accel frame count*/
+		fifo_data->accel_frame_count =
+		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
+		v_accel_index_u8++;
+		v_gyro_index_u8++;
+		v_fifo_index_u16 = v_fifo_index_u16 +
+		BMI160_FIFO_AG_LENGTH;
+	}
+	/* condition  for gyro enable*/
+	else if (v_data_u8 == BMI160_FIFO_GYRO_ENABLE) {
+		/* Gyro raw x v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].x  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_X_MSB_DATA])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_X_LSB_DATA]));
+		/* Gyro raw y v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_Y_MSB_DATA])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_Y_LSB_DATA]));
+		/* Gyro raw z v_data_u8 */
+		fifo_data->gyro_fifo[v_gyro_index_u8].z  =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_Z_MSB_DATA])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_Z_LSB_DATA]));
+		/* check for gyro frame count*/
+		fifo_data->gyro_frame_count =
+		fifo_data->gyro_frame_count + BMI160_FRAME_COUNT;
+		v_fifo_index_u16 = v_fifo_index_u16 + BMI160_FIFO_G_LENGTH;
+		v_gyro_index_u8++;
+	}
+	/* condition  for accel enable*/
+	else if (v_data_u8 == BMI160_FIFO_A_ENABLE) {
+		/* Accel raw x v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].x =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_X_MSB_DATA])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_X_LSB_DATA]));
+		/* Accel raw y v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].y =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_Y_MSB_DATA])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_Y_LSB_DATA]));
+		/* Accel raw z v_data_u8 */
+		fifo_data->accel_fifo[v_accel_index_u8].z =
+		(s16)(((v_fifo_data_u8[v_fifo_index_u16
+		+ BMI160_FIFO_Z_MSB_DATA])
+		<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+		|(v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_Z_LSB_DATA]));
+		/* check for accel frame count*/
+		fifo_data->accel_frame_count =
+		fifo_data->accel_frame_count + BMI160_FRAME_COUNT;
+		v_fifo_index_u16 = v_fifo_index_u16 + BMI160_FIFO_A_LENGTH;
+		v_accel_index_u8++;
+	}
+	/* condition  for mag enable*/
+	else if (v_data_u8 == BMI160_FIFO_M_ENABLE) {
+		/* Raw mag x*/
+		mag_data.mag_x_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_LSB_DATA]);
+		mag_data.mag_x_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_X_MSB_DATA]);
+		/* Mag y data*/
+		mag_data.mag_y_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_LSB_DATA]);
+		mag_data.mag_y_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Y_MSB_DATA]);
+		/* Mag z data*/
+		mag_data.mag_z_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_LSB_DATA]);
+		mag_data.mag_z_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_Z_MSB_DATA]);
+		/* Mag r data*/
+		mag_data.mag_r_y2_lsb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_LSB_DATA]);
+		mag_data.mag_r_y2_msb =
+		(v_fifo_data_u8[v_fifo_index_u16 +
+		BMI160_FIFO_R_MSB_DATA]);
+		com_rslt = bmi160_second_if_mag_compensate_xyz(mag_data,
+		v_mag_if_mag_u8);
+		 /* compensated mag x */
+		fifo_data->mag_fifo[v_mag_index_u8].x =
+		processed_data.x;
+		/* compensated mag y */
+		fifo_data->mag_fifo[v_mag_index_u8].y =
+		processed_data.y;
+		/* compensated mag z */
+		fifo_data->mag_fifo[v_mag_index_u8].z =
+		processed_data.z;
+		/* check for mag frame count*/
+		fifo_data->mag_frame_count =
+		fifo_data->mag_frame_count + BMI160_FRAME_COUNT;
+		v_fifo_index_u16 = v_fifo_index_u16
+		+ BMI160_FIFO_M_LENGTH;
+		v_mag_index_u8++;
+	}
+	/* condition  for fifo over read enable*/
+	if (v_fifo_data_u8[v_fifo_index_u16] == FIFO_CONFIG_CHECK1 &&
+	v_fifo_data_u8[v_fifo_index_u16 + BMI160_FIFO_INDEX_LENGTH] ==
+	FIFO_CONFIG_CHECK2) {
+		break;
+		}
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for read the compensated value of mag
+ *	Before start reading the mag compensated data's
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_compensate_xyz(
+struct bmi160_mag_xyz_s32_t *mag_comp_xyz)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	struct bmi160_mag_xyzr_t mag_xyzr;
+
+	com_rslt = bmi160_read_mag_xyzr(&mag_xyzr);
+	if (com_rslt)
+		return com_rslt;
+	/* Compensation for X axis */
+	mag_comp_xyz->x = bmi160_bmm150_mag_compensate_X(
+	mag_xyzr.x, mag_xyzr.r);
+
+	/* Compensation for Y axis */
+	mag_comp_xyz->y = bmi160_bmm150_mag_compensate_Y(
+	mag_xyzr.y, mag_xyzr.r);
+
+	/* Compensation for Z axis */
+	mag_comp_xyz->z = bmi160_bmm150_mag_compensate_Z(
+	mag_xyzr.z, mag_xyzr.r);
+
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to get the compensated BMM150-X data
+ *	the out put of X as s32
+ *	Before start reading the mag compensated X data
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *
+ *  @param  v_mag_data_x_s16 : The value of mag raw X data
+ *  @param  v_data_r_u16 : The value of mag R data
+ *
+ *	@return results of compensated X data value output as s32
+ *
+ */
+s32 bmi160_bmm150_mag_compensate_X(s16 v_mag_data_x_s16, u16 v_data_r_u16)
+{
+s32 inter_retval = BMI160_INIT_VALUE;
+/* no overflow */
+if (v_mag_data_x_s16 != BMI160_MAG_FLIP_OVERFLOW_ADCVAL) {
+	if ((v_data_r_u16 != 0)
+	|| (mag_trim.dig_xyz1 != 0)) {
+		inter_retval = ((s32)(((u16)
+		((((s32)mag_trim.dig_xyz1)
+		<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS)/
+		 (v_data_r_u16 != 0 ?
+		 v_data_r_u16 : mag_trim.dig_xyz1))) -
+		((u16)0x4000)));
+	} else {
+		inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
+		return inter_retval;
+	}
+	inter_retval = ((s32)((((s32)v_mag_data_x_s16) *
+			((((((((s32)mag_trim.dig_xy2) *
+			((((s32)inter_retval) *
+			((s32)inter_retval))
+			>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS)) +
+			 (((s32)inter_retval) *
+			  ((s32)(((s16)mag_trim.dig_xy1)
+			  << BMI160_SHIFT_BIT_POSITION_BY_07_BITS))))
+			  >> BMI160_SHIFT_BIT_POSITION_BY_09_BITS) +
+		   ((s32)0x100000)) *
+		  ((s32)(((s16)mag_trim.dig_x2) +
+		  ((s16)0xA0))))
+		  >> BMI160_SHIFT_BIT_POSITION_BY_12_BITS))
+		  >> BMI160_SHIFT_BIT_POSITION_BY_13_BITS)) +
+		(((s16)mag_trim.dig_x1)
+		<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
+	/* check the overflow output */
+	if (inter_retval == (s32)BMI160_MAG_OVERFLOW_OUTPUT)
+		inter_retval = BMI160_MAG_OVERFLOW_OUTPUT_S32;
+} else {
+	/* overflow */
+	inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
+}
+return inter_retval;
+}
+/*!
+ *	@brief This API used to get the compensated BMM150-Y data
+ *	the out put of Y as s32
+ *	Before start reading the mag compensated Y data
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *
+ *  @param  v_mag_data_y_s16 : The value of mag raw Y data
+ *  @param  v_data_r_u16 : The value of mag R data
+ *
+ *	@return results of compensated Y data value output as s32
+ */
+s32 bmi160_bmm150_mag_compensate_Y(s16 v_mag_data_y_s16, u16 v_data_r_u16)
+{
+s32 inter_retval = BMI160_INIT_VALUE;
+/* no overflow */
+if (v_mag_data_y_s16 != BMI160_MAG_FLIP_OVERFLOW_ADCVAL) {
+	if ((v_data_r_u16 != 0)
+	|| (mag_trim.dig_xyz1 != 0)) {
+		inter_retval = ((s32)(((u16)(((
+		(s32)mag_trim.dig_xyz1)
+		<< BMI160_SHIFT_BIT_POSITION_BY_14_BITS) /
+		(v_data_r_u16 != 0 ?
+		 v_data_r_u16 : mag_trim.dig_xyz1))) -
+		((u16)0x4000)));
+		} else {
+			inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
+			return inter_retval;
+		}
+	inter_retval = ((s32)((((s32)v_mag_data_y_s16) * ((((((((s32)
+		mag_trim.dig_xy2) * ((((s32) inter_retval) *
+		((s32)inter_retval)) >> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
+		+ (((s32)inter_retval) *
+		((s32)(((s16)mag_trim.dig_xy1)
+		<< BMI160_SHIFT_BIT_POSITION_BY_07_BITS))))
+		>> BMI160_SHIFT_BIT_POSITION_BY_09_BITS) +
+		((s32)0x100000))
+		* ((s32)(((s16)mag_trim.dig_y2)
+		+ ((s16)0xA0))))
+		>> BMI160_SHIFT_BIT_POSITION_BY_12_BITS))
+		>> BMI160_SHIFT_BIT_POSITION_BY_13_BITS)) +
+		(((s16)mag_trim.dig_y1)
+		<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS);
+	/* check the overflow output */
+	if (inter_retval == (s32)BMI160_MAG_OVERFLOW_OUTPUT)
+		inter_retval = BMI160_MAG_OVERFLOW_OUTPUT_S32;
+} else {
+	/* overflow */
+	inter_retval = BMI160_MAG_OVERFLOW_OUTPUT;
+}
+return inter_retval;
+}
+/*!
+ *	@brief This API used to get the compensated BMM150-Z data
+ *	the out put of Z as s32
+ *	Before start reading the mag compensated Z data
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *
+ *  @param  v_mag_data_z_s16 : The value of mag raw Z data
+ *  @param  v_data_r_u16 : The value of mag R data
+ *
+ *	@return results of compensated Z data value output as s32
+ */
+s32 bmi160_bmm150_mag_compensate_Z(s16 v_mag_data_z_s16, u16 v_data_r_u16)
+{
+	s32 retval = BMI160_INIT_VALUE;
+
+	if (v_mag_data_z_s16 != BMI160_MAG_HALL_OVERFLOW_ADCVAL) {
+		if ((v_data_r_u16 != 0)
+		   && (mag_trim.dig_z2 != 0)
+		   && (mag_trim.dig_z1 != 0)) {
+			retval = (((((s32)(v_mag_data_z_s16 - mag_trim.dig_z4))
+			<< BMI160_SHIFT_BIT_POSITION_BY_15_BITS) -
+			((((s32)mag_trim.dig_z3) *
+			((s32)(((s16)v_data_r_u16) -
+			((s16)mag_trim.dig_xyz1))))
+			>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS))/
+			(mag_trim.dig_z2 +
+			((s16)(((((s32)mag_trim.dig_z1) *
+			((((s16)v_data_r_u16)
+			<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT))) +
+			(1 << BMI160_SHIFT_BIT_POSITION_BY_15_BITS))
+			>> BMI160_SHIFT_BIT_POSITION_BY_16_BITS))));
+		}
+	} else {
+		retval = BMI160_MAG_OVERFLOW_OUTPUT;
+	}
+		return retval;
+}
+ /*!
+ *	@brief This function used for initialize the bmm150 sensor
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_interface_init(u8 *v_chip_id_u8)
+{
+	/* This variable used for provide the communication
+	results*/
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
+	u8 v_pull_value_u8 = BMI160_INIT_VALUE;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	/* accel operation mode to normal*/
+	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* write the mag power mode as NORMAL*/
+	com_rslt += bmi160_set_mag_interface_normal();
+	/* register 0x7E write the 0x37, 0x9A and 0x30*/
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/*switch the page1*/
+	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_target_page(&v_data_u8);
+	com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_paging_enable(&v_data_u8);
+	/* enable the pullup configuration from
+	the register 0x05 bit 4 and 5 as 10*/
+	bmi160_get_pullup_configuration(&v_pull_value_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
+	com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/*switch the page0*/
+	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_target_page(&v_data_u8);
+	/* Write the BMM150 i2c address*/
+	com_rslt += bmi160_set_i2c_device_addr(BMI160_AUX_BMM150_I2C_ADDRESS);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* enable the mag interface to manual mode*/
+	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_mag_manual_enable(&v_data_u8);
+	/*Enable the MAG interface */
+	com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_if_mode(&v_data_u8);
+	/* Mag normal mode*/
+	com_rslt += bmi160_bmm150_mag_wakeup();
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* Read the BMM150 device id is 0x32*/
+	com_rslt += bmi160_set_mag_read_addr(BMI160_BMM150_CHIP_ID);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	*v_chip_id_u8 = v_data_u8;
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* write the power mode register*/
+	com_rslt += bmi160_set_mag_write_data(BMI160_BMM_POWER_MODE_REG);
+	/*write 0x4C register to write set power mode to normal*/
+	com_rslt += bmi160_set_mag_write_addr(
+	BMI160_BMM150_POWE_MODE_REG);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* read the mag trim values*/
+	com_rslt += bmi160_read_bmm150_mag_trim();
+	/* To avoid the auto mode enable when manual mode operation running*/
+	V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_ENABLE;
+	/* write the XY and Z repetitions*/
+	com_rslt += bmi160_set_bmm150_mag_presetmode(
+	BMI160_MAG_PRESETMODE_REGULAR);
+	/* To avoid the auto mode enable when manual mode operation running*/
+	V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_DISABLE;
+	/* Set the power mode of mag as force mode*/
+	/* The data have to write for the register
+	It write the value in the register 0x4F */
+	com_rslt += bmi160_set_mag_write_data(BMI160_BMM150_FORCE_MODE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* write into power mode register*/
+	com_rslt += bmi160_set_mag_write_addr(
+	BMI160_BMM150_POWE_MODE_REG);
+	/* write the mag v_data_bw_u8 as 25Hz*/
+	com_rslt += bmi160_set_mag_output_data_rate(
+	BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	/* When mag interface is auto mode - The mag read address
+	starts the register 0x42*/
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_BMM150_DATA_REG);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* enable mag interface to auto mode*/
+	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_mag_manual_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for set the mag power control
+ *	bit enable
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_wakeup(void)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
+	u8 v_try_times_u8 = BMI160_BMM150_MAX_RETRY_WAKEUP;
+	u8 v_power_control_bit_u8 = BMI160_INIT_VALUE;
+	u8 i = BMI160_INIT_VALUE;
+
+	for (i = BMI160_INIT_VALUE; i < v_try_times_u8; i++) {
+		com_rslt = bmi160_set_mag_write_data(BMI160_BMM150_POWER_ON);
+		p_bmi160->delay_msec(BMI160_BMM150_WAKEUP_DELAY1);
+		/*write 0x4B register to enable power control bit*/
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_CONTROL_REG);
+		p_bmi160->delay_msec(BMI160_BMM150_WAKEUP_DELAY2);
+		com_rslt += bmi160_set_mag_read_addr(
+		BMI160_BMM150_POWE_CONTROL_REG);
+		/* 0x04 is secondary read mag x lsb register */
+		p_bmi160->delay_msec(BMI160_BMM150_WAKEUP_DELAY3);
+		com_rslt += bmi160_read_reg(BMI160_USER_DATA_0_ADDR,
+		&v_power_control_bit_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+		v_power_control_bit_u8 = BMI160_BMM150_SET_POWER_CONTROL
+		& v_power_control_bit_u8;
+		if (v_power_control_bit_u8 == BMI160_BMM150_POWER_ON)
+			break;
+	}
+	com_rslt = (i >= v_try_times_u8) ?
+	BMI160_BMM150_POWER_ON_FAIL : BMI160_BMM150_POWER_ON_SUCCESS;
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for set the magnetometer
+ *	power mode.
+ *	@note
+ *	Before set the mag power mode
+ *	make sure the following two point is addressed
+ *		Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *
+ *	@param v_mag_sec_if_pow_mode_u8 : The value of mag power mode
+ *  value    |  mode
+ * ----------|------------
+ *   0       | BMI160_MAG_FORCE_MODE
+ *   1       | BMI160_MAG_SUSPEND_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_and_secondary_if_power_mode(
+u8 v_mag_sec_if_pow_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = BMI160_INIT_VALUE;
+	/* set the accel power mode to NORMAL*/
+	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* set mag interface manual mode*/
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)	{
+		com_rslt += bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_ENABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	}
+	switch (v_mag_sec_if_pow_mode_u8) {
+	case BMI160_MAG_FORCE_MODE:
+		/* set the secondary mag power mode as NORMAL*/
+		com_rslt += bmi160_set_mag_interface_normal();
+		/* set the mag power mode as FORCE mode*/
+		com_rslt += bmi160_bmm150_mag_set_power_mode(FORCE_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_MAG_SUSPEND_MODE:
+		/* set the mag power mode as SUSPEND mode*/
+		com_rslt += bmi160_bmm150_mag_set_power_mode(SUSPEND_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* set the secondary mag power mode as SUSPEND*/
+		com_rslt += bmi160_set_command_register(MAG_MODE_SUSPEND);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE) {
+		/* set mag interface auto mode*/
+		com_rslt += bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_DISABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for set the magnetometer
+ *	power mode.
+ *	@note
+ *	Before set the mag power mode
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@param v_mag_pow_mode_u8 : The value of mag power mode
+ *  value    |  mode
+ * ----------|------------
+ *   0       | FORCE_MODE
+ *   1       | SUSPEND_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_set_power_mode(
+u8 v_mag_pow_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* set mag interface manual mode*/
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE) {
+		com_rslt = bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_ENABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		if (com_rslt != SUCCESS)
+			return com_rslt;
+
+	}
+	switch (v_mag_pow_mode_u8) {
+	case FORCE_MODE:
+		/* Set the power control bit enabled */
+		com_rslt = bmi160_bmm150_mag_wakeup();
+		/* write the mag power mode as FORCE mode*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_BMM150_FORCE_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_MODE_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		/* To avoid the auto mode enable when manual
+		mode operation running*/
+		V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_ENABLE;
+		/* set the preset mode */
+		com_rslt += bmi160_set_bmm150_mag_presetmode(
+		BMI160_MAG_PRESETMODE_REGULAR);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* To avoid the auto mode enable when manual
+		mode operation running*/
+		V_bmm150_maual_auto_condition_u8 = BMI160_MANUAL_DISABLE;
+		/* set the mag read address to data registers*/
+		com_rslt += bmi160_set_mag_read_addr(
+		BMI160_BMM150_DATA_REG);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case SUSPEND_MODE:
+		/* Set the power mode of mag as suspend mode*/
+		com_rslt = bmi160_set_mag_write_data(
+		BMI160_BMM150_POWER_OFF);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_CONTROL_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+	/* set mag interface auto mode*/
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE) {
+		com_rslt += bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_DISABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to set the pre-set modes of bmm150
+ *	The pre-set mode setting is depend on data rate and xy and z repetitions
+ *
+ *	@note
+ *	Before set the mag preset mode
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param  v_mode_u8: The value of pre-set mode selection value
+ *  value    |  pre_set mode
+ * ----------|------------
+ *   1       | BMI160_MAG_PRESETMODE_LOWPOWER
+ *   2       | BMI160_MAG_PRESETMODE_REGULAR
+ *   3       | BMI160_MAG_PRESETMODE_HIGHACCURACY
+ *   4       | BMI160_MAG_PRESETMODE_ENHANCED
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_presetmode(u8 v_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* set mag interface manual mode*/
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_ENABLE);
+	switch (v_mode_u8) {
+	case BMI160_MAG_PRESETMODE_LOWPOWER:
+		/* write the XY and Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt = bmi160_set_mag_write_data(
+		BMI160_MAG_LOWPOWER_REPXY);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_XY_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* write the Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_LOWPOWER_REPZ);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_Z_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* set the mag v_data_u8 rate as 10 to the register 0x4C*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_LOWPOWER_DR);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_MODE_REG);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_MAG_PRESETMODE_REGULAR:
+		/* write the XY and Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt = bmi160_set_mag_write_data(
+		BMI160_MAG_REGULAR_REPXY);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_XY_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* write the Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_REGULAR_REPZ);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_Z_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* set the mag v_data_u8 rate as 10 to the register 0x4C*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_REGULAR_DR);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_MODE_REG);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_MAG_PRESETMODE_HIGHACCURACY:
+		/* write the XY and Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt = bmi160_set_mag_write_data(
+		BMI160_MAG_HIGHACCURACY_REPXY);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_XY_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* write the Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_HIGHACCURACY_REPZ);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_Z_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* set the mag v_data_u8 rate as 20 to the register 0x4C*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_HIGHACCURACY_DR);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_MODE_REG);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_MAG_PRESETMODE_ENHANCED:
+		/* write the XY and Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt = bmi160_set_mag_write_data(
+		BMI160_MAG_ENHANCED_REPXY);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_XY_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* write the Z repetitions*/
+		/* The v_data_u8 have to write for the register
+		It write the value in the register 0x4F*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_ENHANCED_REPZ);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_Z_REP);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* set the mag v_data_u8 rate as 10 to the register 0x4C*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_MAG_ENHANCED_DR);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_MODE_REG);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+	if (V_bmm150_maual_auto_condition_u8 == BMI160_MANUAL_DISABLE) {
+			com_rslt += bmi160_set_mag_write_data(
+			BMI160_BMM150_FORCE_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_BMM150_POWE_MODE_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_read_addr(BMI160_BMM150_DATA_REG);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* set mag interface auto mode*/
+		if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_DISABLE);
+		}
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for read the trim values of magnetometer
+ *
+ *	@note
+ *	Before reading the mag trimming values
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_bmm150_mag_trim(void)
+{
+	/* This variable used for provide the communication
+	results*/
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the bmm150 trim data
+	*/
+	u8 v_data_u8[BMI160_MAG_TRIM_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE};
+	/* read dig_x1 value */
+	com_rslt = bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_X1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_X1],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_x1 = v_data_u8[BMI160_BMM150_DIG_X1];
+	/* read dig_y1 value */
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_Y1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_Y1],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_y1 = v_data_u8[BMI160_BMM150_DIG_Y1];
+
+	/* read dig_x2 value */
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_X2);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_X2],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_x2 = v_data_u8[BMI160_BMM150_DIG_X2];
+	/* read dig_y2 value */
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_Y2);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_Y3],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_y2 = v_data_u8[BMI160_BMM150_DIG_Y3];
+
+	/* read dig_xy1 value */
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_XY1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_XY1],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_xy1 = v_data_u8[BMI160_BMM150_DIG_XY1];
+	/* read dig_xy2 value */
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_XY2);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is v_mag_x_s16 ls register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_XY2],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_xy2 = v_data_u8[BMI160_BMM150_DIG_XY2];
+
+	/* read dig_z1 lsb value */
+	com_rslt += bmi160_set_mag_read_addr(
+	BMI160_MAG_DIG_Z1_LSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_Z1_LSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* read dig_z1 msb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z1_MSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is v_mag_x_s16 msb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_Z1_MSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_z1 =
+	(u16)((((u32)((u8)v_data_u8[BMI160_BMM150_DIG_Z1_MSB]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_BMM150_DIG_Z1_LSB]));
+
+	/* read dig_z2 lsb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z2_LSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_Z2_LSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* read dig_z2 msb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z2_MSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is v_mag_x_s16 msb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_Z2_MSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_z2 =
+	(s16)((((s32)((s8)v_data_u8[BMI160_BMM150_DIG_Z2_MSB]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_BMM150_DIG_Z2_LSB]));
+
+	/* read dig_z3 lsb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z3_LSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_DIG_Z3_LSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* read dig_z3 msb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z3_MSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is v_mag_x_s16 msb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_DIG_Z3_MSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_z3 =
+	(s16)((((s32)((s8)v_data_u8[BMI160_BMM150_DIG_DIG_Z3_MSB]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_BMM150_DIG_DIG_Z3_LSB]));
+	/* read dig_z4 lsb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z4_LSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_DIG_Z4_LSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* read dig_z4 msb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_Z4_MSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is v_mag_x_s16 msb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_DIG_Z4_MSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_z4 =
+	(s16)((((s32)((s8)v_data_u8[BMI160_BMM150_DIG_DIG_Z4_MSB]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_BMM150_DIG_DIG_Z4_LSB]));
+
+	/* read dig_xyz1 lsb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_XYZ1_LSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_LSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* read dig_xyz1 msb value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_MAG_DIG_XYZ1_MSB);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is v_mag_x_s16 msb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_MSB],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	mag_trim.dig_xyz1 =
+	(u16)((((u32)((u8)v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_MSB]))
+			<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) |
+			(v_data_u8[BMI160_BMM150_DIG_DIG_XYZ1_LSB]));
+
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for initialize
+ *	the AKM09911 and AKM09912 sensor
+ *
+ *
+ *	@param v_akm_i2c_address_u8: The value of device address
+ *	AKM sensor   |  Slave address
+ * --------------|---------------------
+ *  AKM09911     |  AKM09911_I2C_ADDR_1
+ *     -         |  and AKM09911_I2C_ADDR_2
+ *  AKM09912     |  AKM09912_I2C_ADDR_1
+ *     -         |  AKM09912_I2C_ADDR_2
+ *     -         |  AKM09912_I2C_ADDR_3
+ *     -         |  AKM09912_I2C_ADDR_4
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_mag_interface_init(
+u8 v_akm_i2c_address_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_pull_value_u8 = BMI160_INIT_VALUE;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 v_akm_chip_id_u8 = BMI160_INIT_VALUE;
+	/* accel operation mode to normal*/
+	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(MAG_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_AKM_INIT_DELAY);
+	bmi160_get_mag_power_mode_stat(&v_data_u8);
+	/* register 0x7E write the 0x37, 0x9A and 0x30*/
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/*switch the page1*/
+	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_target_page(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_paging_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* enable the pullup configuration from
+	the register 0x05 bit 4 and 5  to 10*/
+	bmi160_get_pullup_configuration(&v_pull_value_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
+	com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	/*switch the page0*/
+	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_target_page(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* Write the AKM09911 0r AKM09912 i2c address*/
+	com_rslt += bmi160_set_i2c_device_addr(v_akm_i2c_address_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* enable the mag interface to manual mode*/
+	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_mag_manual_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/*Enable the MAG interface */
+	com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_if_mode(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	/* Set the AKM Fuse ROM mode */
+	/* Set value for fuse ROM mode*/
+	com_rslt += bmi160_set_mag_write_data(AKM_FUSE_ROM_MODE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* AKM mode address is 0x31*/
+	com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* Read the Fuse ROM v_data_u8 from registers
+	0x60,0x61 and 0x62*/
+	/* ASAX v_data_u8 */
+	com_rslt += bmi160_read_bst_akm_sensitivity_data();
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* read the device id of the AKM sensor
+	if device id is 0x05 - AKM09911
+	if device id is 0x04 - AKM09912*/
+	com_rslt += bmi160_set_mag_read_addr(AKM_CHIP_ID_REG);
+	/* 0x04 is mag_x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_akm_chip_id_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* Set value power down mode mode*/
+	com_rslt += bmi160_set_mag_write_data(AKM_POWER_DOWN_MODE_DATA);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* AKM mode address is 0x31*/
+	com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* Set AKM Force mode*/
+	com_rslt += bmi160_set_mag_write_data(
+	AKM_SINGLE_MEASUREMENT_MODE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* AKM mode address is 0x31*/
+	com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* Set the AKM read xyz v_data_u8 address*/
+	com_rslt += bmi160_set_mag_read_addr(AKM_DATA_REGISTER);
+	/* write the mag v_data_bw_u8 as 25Hz*/
+	com_rslt += bmi160_set_mag_output_data_rate(
+	BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* Enable mag interface to auto mode*/
+	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_mag_manual_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for read the sensitivity data of
+ *	AKM09911 and AKM09912
+ *
+ *	@note Before reading the mag sensitivity values
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_bst_akm_sensitivity_data(void)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the sensitivity ax,ay and az data*/
+	u8 v_data_u8[BMI160_AKM_SENSITIVITY_DATA_SIZE] = {
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* read asax value */
+	com_rslt = bmi160_set_mag_read_addr(BMI160_BST_AKM_ASAX);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[AKM_ASAX],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	akm_asa_data.asax = v_data_u8[AKM_ASAX];
+	/* read asay value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_BST_AKM_ASAY);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[AKM_ASAY],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	akm_asa_data.asay = v_data_u8[AKM_ASAY];
+	/* read asaz value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_BST_AKM_ASAZ);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[AKM_ASAZ],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	akm_asa_data.asaz = v_data_u8[AKM_ASAZ];
+
+	return com_rslt;
+}
+/*!
+ *	@brief This API used to get the compensated X data
+ *	of AKM09911 the out put of X as s32
+ *	@note	Before start reading the mag compensated X data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_x_s16 : The value of X data
+ *
+ *	@return results of compensated X data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09911_compensate_X(s16 v_bst_akm_x_s16)
+{
+	/*Return value of AKM x compensated v_data_u8*/
+	s32 retval = BMI160_INIT_VALUE;
+	/* Convert raw v_data_u8 into compensated v_data_u8*/
+	retval = (v_bst_akm_x_s16 *
+	((akm_asa_data.asax/AKM09911_SENSITIVITY_DIV) +
+	BMI160_GEN_READ_WRITE_DATA_LENGTH));
+	return retval;
+}
+/*!
+ *	@brief This API used to get the compensated Y data
+ *	of AKM09911 the out put of Y as s32
+ *	@note	Before start reading the mag compensated Y data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_y_s16 : The value of Y data
+ *
+ *	@return results of compensated Y data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09911_compensate_Y(s16 v_bst_akm_y_s16)
+{
+	/*Return value of AKM y compensated v_data_u8*/
+	s32 retval = BMI160_INIT_VALUE;
+	/* Convert raw v_data_u8 into compensated v_data_u8*/
+	retval = (v_bst_akm_y_s16 *
+	((akm_asa_data.asay/AKM09911_SENSITIVITY_DIV) +
+	BMI160_GEN_READ_WRITE_DATA_LENGTH));
+	return retval;
+}
+/*!
+ *	@brief This API used to get the compensated Z data
+ *	of AKM09911 the out put of Z as s32
+ *	@note	Before start reading the mag compensated Z data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_z_s16 : The value of Z data
+ *
+ *	@return results of compensated Z data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09911_compensate_Z(s16 v_bst_akm_z_s16)
+{
+	/*Return value of AKM z compensated v_data_u8*/
+	s32 retval = BMI160_INIT_VALUE;
+	/* Convert raw v_data_u8 into compensated v_data_u8*/
+	retval = (v_bst_akm_z_s16 *
+	((akm_asa_data.asaz/AKM09911_SENSITIVITY_DIV) +
+	BMI160_GEN_READ_WRITE_DATA_LENGTH));
+	return retval;
+}
+/*!
+ *	@brief This API used to get the compensated X data
+ *	of AKM09912 the out put of X as s32
+ *	@note	Before start reading the mag compensated X data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_x_s16 : The value of X data
+ *
+ *	@return results of compensated X data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09912_compensate_X(s16 v_bst_akm_x_s16)
+{
+	/*Return value of AKM x compensated data*/
+	s32 retval = BMI160_INIT_VALUE;
+	/* Convert raw data into compensated data*/
+	retval = v_bst_akm_x_s16 *
+	(akm_asa_data.asax + AKM09912_SENSITIVITY)
+	/ AKM09912_SENSITIVITY_DIV;
+	return retval;
+}
+/*!
+ *	@brief This API used to get the compensated Y data
+ *	of AKM09912 the out put of Y as s32
+ *	@note	Before start reading the mag compensated Y data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_y_s16 : The value of Y data
+ *
+ *	@return results of compensated Y data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09912_compensate_Y(s16 v_bst_akm_y_s16)
+{
+	/*Return value of AKM y compensated data*/
+	s32 retval = BMI160_INIT_VALUE;
+	/* Convert raw data into compensated data*/
+	retval = v_bst_akm_y_s16 *
+	(akm_asa_data.asax + AKM09912_SENSITIVITY)
+	/ AKM09912_SENSITIVITY_DIV;
+	return retval;
+}
+/*!
+ *	@brief This API used to get the compensated Z data
+ *	of AKM09912 the out put of Z as s32
+ *	@note	Before start reading the mag compensated Z data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_z_s16 : The value of Z data
+ *
+ *	@return results of compensated Z data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09912_compensate_Z(s16 v_bst_akm_z_s16)
+{
+	/*Return value of AKM z compensated data*/
+	s32 retval = BMI160_INIT_VALUE;
+	/* Convert raw data into compensated data*/
+	retval = v_bst_akm_z_s16 *
+	(akm_asa_data.asax + AKM09912_SENSITIVITY)
+	/ AKM09912_SENSITIVITY_DIV;
+	return retval;
+}
+ /*!
+ *	@brief This function used for read the compensated value of
+ *	AKM09911
+ *	@note Before start reading the mag compensated data's
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09911_compensate_xyz(
+struct bmi160_bst_akm_xyz_t *bst_akm_xyz)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	struct bmi160_mag_t mag_xyz;
+
+	com_rslt = bmi160_read_mag_xyz(&mag_xyz, BST_AKM);
+	/* Compensation for X axis */
+	bst_akm_xyz->x = bmi160_bst_akm09911_compensate_X(mag_xyz.x);
+
+	/* Compensation for Y axis */
+	bst_akm_xyz->y = bmi160_bst_akm09911_compensate_Y(mag_xyz.y);
+
+	/* Compensation for Z axis */
+	bst_akm_xyz->z = bmi160_bst_akm09911_compensate_Z(mag_xyz.z);
+
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for read the compensated value of
+ *	AKM09912
+ *	@note Before start reading the mag compensated data's
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09912_compensate_xyz(
+struct bmi160_bst_akm_xyz_t *bst_akm_xyz)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	struct bmi160_mag_t mag_xyz;
+
+	com_rslt = bmi160_read_mag_xyz(&mag_xyz, BST_AKM);
+	/* Compensation for X axis */
+	bst_akm_xyz->x = bmi160_bst_akm09912_compensate_X(mag_xyz.x);
+
+	/* Compensation for Y axis */
+	bst_akm_xyz->y = bmi160_bst_akm09912_compensate_Y(mag_xyz.y);
+
+	/* Compensation for Z axis */
+	bst_akm_xyz->z = bmi160_bst_akm09912_compensate_Z(mag_xyz.z);
+
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for set the AKM09911 and AKM09912
+ *	power mode.
+ *	@note Before set the AKM power mode
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@param v_akm_pow_mode_u8 : The value of akm power mode
+ *  value   |    Description
+ * ---------|--------------------
+ *    0     |  AKM_POWER_DOWN_MODE
+ *    1     |  AKM_SINGLE_MEAS_MODE
+ *    2     |  FUSE_ROM_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_set_powermode(
+u8 v_akm_pow_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* set mag interface manual mode*/
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE) {
+		com_rslt = bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_ENABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	}
+	switch (v_akm_pow_mode_u8) {
+	case AKM_POWER_DOWN_MODE:
+		/* Set the power mode of AKM as power down mode*/
+		com_rslt += bmi160_set_mag_write_data(AKM_POWER_DOWN_MODE_DATA);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	break;
+	case AKM_SINGLE_MEAS_MODE:
+		/* Set the power mode of AKM as
+		single measurement mode*/
+		com_rslt += bmi160_set_mag_write_data
+		(AKM_SINGLE_MEASUREMENT_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_read_addr(AKM_DATA_REGISTER);
+	break;
+	case FUSE_ROM_MODE:
+		/* Set the power mode of AKM as
+		Fuse ROM mode*/
+		com_rslt += bmi160_set_mag_write_data(AKM_FUSE_ROM_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		/* Sensitivity v_data_u8 */
+		com_rslt += bmi160_read_bst_akm_sensitivity_data();
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		/* power down mode*/
+		com_rslt += bmi160_set_mag_write_data(AKM_POWER_DOWN_MODE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(AKM_POWER_MODE_REG);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+	/* set mag interface auto mode*/
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE) {
+		com_rslt += bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_DISABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	}
+	return com_rslt;
+}
+ /*!
+ *	@brief This function used for set the magnetometer
+ *	power mode of AKM09911 and AKM09912
+ *	@note Before set the mag power mode
+ *	make sure the following two point is addressed
+ *		Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *
+ *	@param v_mag_sec_if_pow_mode_u8 : The value of secondary if power mode
+ *  value   |    Description
+ * ---------|--------------------
+ *    0     |  BMI160_MAG_FORCE_MODE
+ *    1     |  BMI160_MAG_SUSPEND_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_bst_akm_and_secondary_if_powermode(
+u8 v_mag_sec_if_pow_mode_u8)
+{
+	/* variable used for return the status of communication result*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* accel operation mode to normal*/
+	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* set mag interface manual mode*/
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE) {
+		com_rslt = bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_ENABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	}
+	switch (v_mag_sec_if_pow_mode_u8) {
+	case BMI160_MAG_FORCE_MODE:
+		/* set the secondary mag power mode as NORMAL*/
+		com_rslt += bmi160_set_mag_interface_normal();
+		/* set the akm power mode as single measurement mode*/
+		com_rslt += bmi160_bst_akm_set_powermode(AKM_SINGLE_MEAS_MODE);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_read_addr(AKM_DATA_REGISTER);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	break;
+	case BMI160_MAG_SUSPEND_MODE:
+		/* set the akm power mode as power down mode*/
+		com_rslt += bmi160_bst_akm_set_powermode(AKM_POWER_DOWN_MODE);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		/* set the secondary mag power mode as SUSPEND*/
+		com_rslt += bmi160_set_command_register(MAG_MODE_SUSPEND);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	break;
+	default:
+		com_rslt = E_BMI160_OUT_OF_RANGE;
+	break;
+	}
+	/* set mag interface auto mode*/
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+		com_rslt += bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_DISABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for read the YAMAH-YAS532 init
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_mag_interface_init(
+void)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	u8 v_pull_value_u8 = BMI160_INIT_VALUE;
+	u8 v_data_u8 = BMI160_INIT_VALUE;
+	u8 i = BMI160_INIT_VALUE;
+	/* accel operation mode to normal*/
+	com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* write mag power mode as NORMAL*/
+	com_rslt += bmi160_set_mag_interface_normal();
+	/* register 0x7E write the 0x37, 0x9A and 0x30*/
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/*switch the page1*/
+	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_target_page(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_paging_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* enable the pullup configuration from
+	the register 0x05 bit 4 and 5 as 10*/
+	bmi160_get_pullup_configuration(&v_pull_value_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
+	com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/*switch the page0*/
+	com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_target_page(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* Write the YAS532 i2c address*/
+	com_rslt += bmi160_set_i2c_device_addr(BMI160_AUX_YAS532_I2C_ADDRESS);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* enable the mag interface to manual mode*/
+	com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_mag_manual_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/*Enable the MAG interface */
+	com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_if_mode(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	v_data_u8 = BMI160_MANUAL_DISABLE;
+	/* Read the YAS532 device id is 0x02*/
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS_DEVICE_ID_REG);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* Read the YAS532 calibration data*/
+	com_rslt += bmi160_bst_yamaha_yas532_calib_values();
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* Assign the data acquisition mode*/
+	yas532_data.measure_state = YAS532_MAG_STATE_INIT_COIL;
+	/* Set the default offset as invalid offset*/
+	set_vector(yas532_data.v_hard_offset_s8, INVALID_OFFSET);
+	/* set the transform to zero */
+
+	yas532_data.transform = BMI160_NULL;
+	/* Assign overflow as zero*/
+	yas532_data.overflow = 0;
+	#if 1 < YAS532_MAG_TEMPERATURE_LOG
+		yas532_data.temp_data.num =
+		yas532_data.temp_data.idx = 0;
+	#endif
+	/* Assign the coef value*/
+	for (i = 0; i < 3; i++) {
+		yas532_data.coef[i] = yas532_version_ac_coef[i];
+		yas532_data.last_raw[i] = 0;
+	}
+	yas532_data.last_raw[3] = 0;
+	/* Set the initial values of yas532*/
+	com_rslt += bmi160_bst_yas532_set_initial_values();
+	/* write the mag v_data_bw_u8 as 25Hz*/
+	com_rslt += bmi160_set_mag_output_data_rate(
+	BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* Enable mag interface to auto mode*/
+	com_rslt += bmi160_set_mag_manual_enable(
+	BMI160_MANUAL_DISABLE);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	bmi160_get_mag_manual_enable(&v_data_u8);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	return com_rslt;
+}
+/*!
+ *	@brief This function used to set the YAS532 initial values
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_initial_values(void)
+{
+/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* write testr1 as 0x00*/
+	com_rslt = bmi160_set_mag_write_data(
+	BMI160_YAS532_WRITE_TESTR1);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_TESTR1);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* write testr2 as 0x00*/
+	com_rslt += bmi160_set_mag_write_data(
+	BMI160_YAS532_WRITE_TESTR2);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_TESTR2);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* write Rcoil as 0x00*/
+	com_rslt += bmi160_set_mag_write_data(
+	BMI160_YAS532_WRITE_RCOIL);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_RCOIL);
+	p_bmi160->delay_msec(BMI160_YAS532_SET_INITIAL_VALUE_DELAY);
+	/* check the valid offset*/
+	if (is_valid_offset(yas532_data.v_hard_offset_s8)) {
+		com_rslt += bmi160_bst_yas532_set_offset(
+		yas532_data.v_hard_offset_s8);
+		yas532_data.measure_state = YAS532_MAG_STATE_NORMAL;
+	} else {
+		/* set the default offset as invalid offset*/
+		set_vector(yas532_data.v_hard_offset_s8, INVALID_OFFSET);
+		/*Set the default measure state for offset correction*/
+		yas532_data.measure_state = YAS532_MAG_STATE_MEASURE_OFFSET;
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for YAS532 offset correction
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_magnetic_measure_set_offset(
+void)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* used for offset value set to the offset register*/
+	s8 v_hard_offset_s8[BMI160_HARD_OFFSET_DATA_SIZE] = {
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* offset correction factors*/
+	static const u8 v_correct_u8[BMI160_YAS_CORRECT_DATA_SIZE] = {
+	16, 8, 4, 2, 1};
+	/* used for the temperature */
+	u16 v_temp_u16 = BMI160_INIT_VALUE;
+	/* used for the xy1y2 read*/
+	u16 v_xy1y2_u16[BMI160_YAS_XY1Y2_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* local flag for assign the values*/
+	s32 v_flag_s32[BMI160_YAS_FLAG_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	u8 i, j, v_busy_u8, v_overflow_u8 = BMI160_INIT_VALUE;
+
+	for (i = 0; i < 5; i++) {
+		/* set the offset values*/
+		com_rslt = bmi160_bst_yas532_set_offset(v_hard_offset_s8);
+		/* read the sensor data*/
+		com_rslt += bmi160_bst_yas532_normal_measurement_data(
+		BMI160_YAS532_ACQ_START, &v_busy_u8, &v_temp_u16,
+		v_xy1y2_u16, &v_overflow_u8);
+		/* check the sensor busy status*/
+		if (v_busy_u8)
+			return E_BMI160_BUSY;
+		/* calculate the magnetic correction with
+		offset and assign the values
+		to the offset register */
+		for (j = 0; j < 3; j++) {
+			if (YAS532_DATA_CENTER == v_xy1y2_u16[j])
+				v_flag_s32[j] = 0;
+			if (YAS532_DATA_CENTER < v_xy1y2_u16[j])
+				v_flag_s32[j] = 1;
+			if (v_xy1y2_u16[j] < YAS532_DATA_CENTER)
+				v_flag_s32[j] = -1;
+		}
+		for (j = 0; j < 3; j++) {
+			if (v_flag_s32[j])
+				v_hard_offset_s8[j] = (s8)(v_hard_offset_s8[j]
+				+ v_flag_s32[j] * v_correct_u8[i]);
+		}
+	}
+	/* set the offset */
+	com_rslt += bmi160_bst_yas532_set_offset(v_hard_offset_s8);
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS532 calibration data
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_calib_values(void)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the YAS532 calibration values */
+	u8 v_data_u8[BMI160_YAS532_CALIB_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* Read the DX value */
+	com_rslt = bmi160_set_mag_read_addr(BMI160_YAS532_CALIB_CX);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[0], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	yas532_data.calib_yas532.cx = (s32)((v_data_u8[0]
+	* 10) - 1280);
+	/* Read the DY1 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB_CY1);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[1], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	yas532_data.calib_yas532.cy1 =
+	(s32)((v_data_u8[1] * 10) - 1280);
+	/* Read the DY2 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB_CY2);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[2], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	yas532_data.calib_yas532.cy2 =
+	(s32)((v_data_u8[2] * 10) - 1280);
+	/* Read the D2 and D3 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB1);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[3], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	yas532_data.calib_yas532.a2 =
+	(s32)(((v_data_u8[3] >>
+	BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
+	& 0x03F) - 32);
+	/* Read the D3 and D4 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB2);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[4], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* calculate a3*/
+	yas532_data.calib_yas532.a3 = (s32)((((v_data_u8[3] <<
+	BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x0C) |
+	((v_data_u8[4]
+	>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
+	& 0x03)) - 8);
+	/* calculate a4*/
+	yas532_data.calib_yas532.a4 = (s32)((v_data_u8[4]
+	& 0x3F) - 32);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+    /* Read the D5 and D6 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB3);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[5], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* calculate a5*/
+	yas532_data.calib_yas532.a5 =
+	(s32)(((v_data_u8[5]
+	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
+	& 0x3F) + 38);
+	/* Read the D6 and D7 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB4);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[6], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* calculate a6*/
+	yas532_data.calib_yas532.a6 =
+	(s32)((((v_data_u8[5]
+	<< BMI160_SHIFT_BIT_POSITION_BY_04_BITS)
+	& 0x30) | ((v_data_u8[6] >>
+	 BMI160_SHIFT_BIT_POSITION_BY_04_BITS)
+	 & 0x0F)) - 32);
+	 /* Read the D7 and D8 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB5);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[7], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* calculate a7*/
+	yas532_data.calib_yas532.a7 = (s32)((((v_data_u8[6]
+	<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
+	& 0x78) |
+	((v_data_u8[7]
+	>> BMI160_SHIFT_BIT_POSITION_BY_05_BITS) &
+	0x07)) - 64);
+	/* Read the D8 and D9 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CLAIB6);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[8], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* calculate a8*/
+	yas532_data.calib_yas532.a8 = (s32)((((v_data_u8[7] <<
+	BMI160_GEN_READ_WRITE_DATA_LENGTH) & 0x3E) |
+	((v_data_u8[8] >>
+	BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01)) -
+	32);
+
+	/* Read the D8 and D9 value */
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB7);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[9], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* calculate a9*/
+	yas532_data.calib_yas532.a9 = (s32)(((v_data_u8[8] <<
+	BMI160_GEN_READ_WRITE_DATA_LENGTH) & 0xFE) |
+	 ((v_data_u8[9] >>
+	 BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
+	/* calculate k*/
+	yas532_data.calib_yas532.k = (s32)((v_data_u8[9] >>
+	BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x1F);
+	/* Read the  value from register 0x9A*/
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB8);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[10],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* Read the  value from register 0x9B*/
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIIB9);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[11],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* Read the  value from register 0x9C*/
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB10);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[12],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* Read the  value from register 0x9D*/
+	com_rslt += bmi160_set_mag_read_addr(BMI160_YAS532_CALIB11);
+	/* 0x04 is secondary read mag x lsb register */
+	com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+	&v_data_u8[13],
+	BMI160_GEN_READ_WRITE_DATA_LENGTH);
+	/* Calculate the fxy1y2 and rxy1y1*/
+	yas532_data.calib_yas532.fxy1y2[0] =
+	(u8)(((v_data_u8[10]
+	& 0x01)
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	| ((v_data_u8[11] >>
+	BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
+	yas532_data.calib_yas532.rxy1y2[0] =
+	((s8)(((v_data_u8[10]
+	>> BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x3F)
+	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS))
+	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS;
+	yas532_data.calib_yas532.fxy1y2[1] =
+	(u8)(((v_data_u8[11] & 0x01)
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	 | ((v_data_u8[12] >>
+	 BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
+	yas532_data.calib_yas532.rxy1y2[1] =
+	((s8)(((v_data_u8[11]
+	>> BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x3F)
+	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS))
+	>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS;
+	yas532_data.calib_yas532.fxy1y2[2] =
+	(u8)(((v_data_u8[12] & 0x01)
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	| ((v_data_u8[13]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01));
+	yas532_data.calib_yas532.rxy1y2[2] =
+	((s8)(((v_data_u8[12]
+	>> BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x3F)
+	 << BMI160_SHIFT_BIT_POSITION_BY_02_BITS))
+	 >> BMI160_SHIFT_BIT_POSITION_BY_02_BITS;
+
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for calculate the
+ *	YAS532 read the linear data
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_xy1y2_to_linear(
+u16 *v_xy1y2_u16, s32 *xy1y2_linear)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = SUCCESS;
+	static const u16 v_calib_data[] = {
+	3721, 3971, 4221, 4471};
+	u8 i = BMI160_INIT_VALUE;
+
+	for (i = 0; i < 3; i++)
+		xy1y2_linear[i] = v_xy1y2_u16[i] -
+		 v_calib_data[yas532_data.calib_yas532.fxy1y2[i]]
+			+ (yas532_data.v_hard_offset_s8[i] -
+			yas532_data.calib_yas532.rxy1y2[i])
+			* yas532_data.coef[i];
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for read the YAS532 sensor data
+ *	@param	v_acquisition_command_u8: used to set the data acquisition
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ *	@param	v_busy_u8 : used to get the busy flay for sensor data read
+ *	@param	v_temp_u16 : used to get the temperature data
+ *	@param	v_xy1y2_u16 : used to get the sensor xy1y2 data
+ *	@param	v_overflow_u8 : used to get the overflow data
+ *
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_normal_measurement_data(
+u8 v_acquisition_command_u8, u8 *v_busy_u8,
+u16 *v_temp_u16, u16 *v_xy1y2_u16, u8 *v_overflow_u8)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the YAS532 xyy1 data*/
+	u8 v_data_u8[BMI160_YAS_XY1Y2T_DATA_SIZE] = {
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	u8 i = BMI160_INIT_VALUE;
+	/* check the p_bmi160 structure as NULL*/
+	if (p_bmi160 == BMI160_NULL) {
+		return E_BMI160_NULL_PTR;
+		} else {
+		/* read the sensor data */
+		com_rslt = bmi160_bst_yas532_acquisition_command_register(
+		v_acquisition_command_u8);
+		com_rslt +=
+		p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+		BMI160_USER_DATA_MAG_X_LSB__REG,
+		v_data_u8, BMI160_MAG_YAS_DATA_LENGTH);
+		 v_data_u8[0] = 0x31;
+		 v_data_u8[1] = 0xF8;
+		 v_data_u8[2] = 0x49;
+		 v_data_u8[3] = 0x3B;
+		 v_data_u8[4] = 0x45;
+		 v_data_u8[5] = 0x8F;
+		 v_data_u8[6] = 0x31;
+		 v_data_u8[7] = 0x90;
+		/* read the xyy1 data*/
+		*v_busy_u8 =
+		((v_data_u8[0]
+		>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS) & 0x01);
+		*v_temp_u16 =
+		(u16)((((s32)v_data_u8[0]
+		<< BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
+		& 0x3F8) | ((v_data_u8[1]
+		>> BMI160_SHIFT_BIT_POSITION_BY_05_BITS) & 0x07));
+		v_xy1y2_u16[0] =
+		(u16)((((s32)v_data_u8[2]
+		<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0x1FC0)
+		| ((v_data_u8[3] >>
+		BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
+		v_xy1y2_u16[1] =
+		(u16)((((s32)v_data_u8[4]
+		<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
+		& 0x1FC0)
+		| ((v_data_u8[5]
+		>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
+		v_xy1y2_u16[2] =
+		(u16)((((s32)v_data_u8[6]
+		<< BMI160_SHIFT_BIT_POSITION_BY_06_BITS)
+		& 0x1FC0)
+		| ((v_data_u8[7]
+		>> BMI160_SHIFT_BIT_POSITION_BY_02_BITS) & 0x3F));
+		*v_overflow_u8 = 0;
+		for (i = 0; i < 3; i++) {
+			if (v_xy1y2_u16[i] == YAS532_DATA_OVERFLOW)
+				*v_overflow_u8 |= (1 << (i * 2));
+			if (v_xy1y2_u16[i] == YAS532_DATA_UNDERFLOW)
+				*v_overflow_u8 |= (1 << (i * 2 + 1));
+		}
+	}
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for YAS532 sensor data
+ *	@param	v_acquisition_command_u8	:	the value of CMDR
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ * @param xyz_data : the vector xyz output
+ * @param v_overflow_s8 : the value of overflow
+ * @param v_temp_correction_u8 : the value of temperate correction enable
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_measurement_xyz_data(
+struct yas532_vector *xyz_data, u8 *v_overflow_s8, u8 v_temp_correction_u8,
+u8 v_acquisition_command_u8)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the linear calculation output*/
+	s32 v_xy1y2_linear_s32[BMI160_YAS_XY1Y2_DATA_SIZE] = {
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* Array holding the temperature data */
+	s32 v_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	s32 tmp = BMI160_INIT_VALUE;
+	s32 sx, sy1, sy2, sy, sz = BMI160_INIT_VALUE;
+	u8 i, v_busy_u8 = BMI160_INIT_VALUE;
+	u16 v_temp_u16 = BMI160_INIT_VALUE;
+	/* Array holding the xyy1 sensor raw data*/
+	u16 v_xy1y2_u16[BMI160_YAS_XY1Y2_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	#if 1 < YAS532_MAG_TEMPERATURE_LOG
+	s32 sum = BMI160_INIT_VALUE;
+	#endif
+	*v_overflow_s8 = BMI160_INIT_VALUE;
+	switch (yas532_data.measure_state) {
+	case YAS532_MAG_STATE_INIT_COIL:
+		if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_ENABLE);
+		/* write Rcoil*/
+		com_rslt += bmi160_set_mag_write_data(
+		BMI160_YAS_DISABLE_RCOIL);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_RCOIL);
+		p_bmi160->delay_msec(BMI160_YAS532_MEASUREMENT_DELAY);
+		if (!yas532_data.overflow && is_valid_offset(
+		yas532_data.v_hard_offset_s8))
+			yas532_data.measure_state = 0;
+	break;
+	case YAS532_MAG_STATE_MEASURE_OFFSET:
+		com_rslt = bmi160_bst_yas532_magnetic_measure_set_offset();
+		yas532_data.measure_state = 0;
+	break;
+	default:
+	break;
+	}
+	/* Read sensor data*/
+	com_rslt += bmi160_bst_yas532_normal_measurement_data(
+	v_acquisition_command_u8, &v_busy_u8, &v_temp_u16,
+	v_xy1y2_u16, v_overflow_s8);
+	/* Calculate the linear data*/
+	com_rslt += bmi160_bst_yas532_xy1y2_to_linear(v_xy1y2_u16,
+	v_xy1y2_linear_s32);
+	/* Calculate temperature correction */
+	#if 1 < YAS532_MAG_TEMPERATURE_LOG
+		yas532_data.temp_data.log[yas532_data.temp_data.idx++] =
+		v_temp_u16;
+	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.idx)
+		yas532_data.temp_data.idx = 0;
+		yas532_data.temp_data.num++;
+	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.num)
+		yas532_data.temp_data.num = YAS532_MAG_TEMPERATURE_LOG;
+	for (i = 0; i < yas532_data.temp_data.num; i++)
+		sum += yas532_data.temp_data.log[i];
+		tmp = sum * 10 / yas532_data.temp_data.num
+		- YAS532_TEMP20DEGREE_TYPICAL * 10;
+	#else
+		tmp = (v_temp_u16 - YAS532_TEMP20DEGREE_TYPICAL)
+		* 10;
+	#endif
+	sx  = v_xy1y2_linear_s32[0];
+	sy1 = v_xy1y2_linear_s32[1];
+	sy2 = v_xy1y2_linear_s32[2];
+	/* Temperature correction */
+	if (v_temp_correction_u8) {
+		sx  -= (yas532_data.calib_yas532.cx  * tmp)
+		/ 1000;
+		sy1 -= (yas532_data.calib_yas532.cy1 * tmp)
+		/ 1000;
+		sy2 -= (yas532_data.calib_yas532.cy2 * tmp)
+		/ 1000;
+	}
+	sy = sy1 - sy2;
+	sz = -sy1 - sy2;
+	#if 1
+	xyz_data->yas532_vector_xyz[0] = yas532_data.calib_yas532.k *
+	((100 * sx + yas532_data.calib_yas532.a2 * sy +
+	yas532_data.calib_yas532.a3 * sz) / 10);
+	xyz_data->yas532_vector_xyz[1] = yas532_data.calib_yas532.k *
+	((yas532_data.calib_yas532.a4 * sx + yas532_data.calib_yas532.a5 * sy +
+	yas532_data.calib_yas532.a6 * sz) / 10);
+	xyz_data->yas532_vector_xyz[2] = yas532_data.calib_yas532.k *
+	((yas532_data.calib_yas532.a7 * sx + yas532_data.calib_yas532.a8 * sy +
+	yas532_data.calib_yas532.a9 * sz) / 10);
+	if (yas532_data.transform != BMI160_NULL) {
+		for (i = 0; i < 3; i++) {
+				v_xyz_tmp_s32[i] = yas532_data.transform[i
+				* 3] *
+				xyz_data->yas532_vector_xyz[0]
+				+ yas532_data.transform[i * 3 + 1] *
+				xyz_data->yas532_vector_xyz[1]
+				+ yas532_data.transform[i * 3 + 2] *
+				xyz_data->yas532_vector_xyz[2];
+		}
+		set_vector(xyz_data->yas532_vector_xyz, v_xyz_tmp_s32);
+	}
+	for (i = 0; i < 3; i++) {
+		xyz_data->yas532_vector_xyz[i] -=
+		xyz_data->yas532_vector_xyz[i] % 10;
+		if (*v_overflow_s8 & (1
+		<< (i * 2)))
+			xyz_data->yas532_vector_xyz[i] +=
+			1; /* set overflow */
+		if (*v_overflow_s8 & (1 <<
+		(i * 2 + 1)))
+			xyz_data->yas532_vector_xyz[i] += 2; /* set underflow */
+	}
+#else
+	xyz_data->yas532_vector_xyz[0] = sx;
+	xyz_data->yas532_vector_xyz[1] = sy;
+	xyz_data->yas532_vector_xyz[2] = sz;
+#endif
+if (v_busy_u8)
+		return com_rslt;
+	if (0 < *v_overflow_s8) {
+		if (!yas532_data.overflow)
+			yas532_data.overflow = 1;
+		yas532_data.measure_state = YAS532_MAG_STATE_INIT_COIL;
+	} else
+		yas532_data.overflow = 0;
+	for (i = 0; i < 3; i++)
+		yas532_data.last_raw[i] = v_xy1y2_u16[i];
+	  yas532_data.last_raw[i] = v_temp_u16;
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for YAS532 sensor data
+ *	@param	v_acquisition_command_u8	:	the value of CMDR
+ *
+ * @param v_xy1y2_u16 : the vector xyz output
+ * @param v_overflow_s8 : the value of overflow
+ * @param v_temp_correction_u8 : the value of temperate correction enable
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_fifo_xyz_data(
+u16 *v_xy1y2_u16, u8 v_temp_correction_u8,
+s8 v_overflow_s8, u16 v_temp_u16, u8 v_busy_u8)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the linear calculation output*/
+	s32 v_xy1y2_linear_s32[BMI160_YAS_XY1Y2_DATA_SIZE] = {
+	BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* Array holding the temperature data */
+	s32 v_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	s32 tmp = BMI160_INIT_VALUE;
+	s32 sx, sy1, sy2, sy, sz = BMI160_INIT_VALUE;
+	u8 i = BMI160_INIT_VALUE;
+	#if 1 < YAS532_MAG_TEMPERATURE_LOG
+	s32 sum = BMI160_INIT_VALUE;
+	#endif
+	v_overflow_s8 = BMI160_INIT_VALUE;
+	/* Calculate the linear data*/
+	com_rslt = bmi160_bst_yas532_xy1y2_to_linear(v_xy1y2_u16,
+	v_xy1y2_linear_s32);
+	/* Calculate temperature correction */
+	#if 1 < YAS532_MAG_TEMPERATURE_LOG
+		yas532_data.temp_data.log[yas532_data.temp_data.idx++] =
+		v_temp_u16;
+	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.idx)
+		yas532_data.temp_data.idx = 0;
+		yas532_data.temp_data.num++;
+	if (YAS532_MAG_TEMPERATURE_LOG <= yas532_data.temp_data.num)
+		yas532_data.temp_data.num = YAS532_MAG_TEMPERATURE_LOG;
+	for (i = 0; i < yas532_data.temp_data.num; i++)
+		sum += yas532_data.temp_data.log[i];
+		tmp = sum * 10 / yas532_data.temp_data.num
+		- YAS532_TEMP20DEGREE_TYPICAL * 10;
+	#else
+		tmp = (v_temp_u16 - YAS532_TEMP20DEGREE_TYPICAL)
+		* 10;
+	#endif
+	sx  = v_xy1y2_linear_s32[0];
+	sy1 = v_xy1y2_linear_s32[1];
+	sy2 = v_xy1y2_linear_s32[2];
+	/* Temperature correction */
+	if (v_temp_correction_u8) {
+		sx  -= (yas532_data.calib_yas532.cx  * tmp)
+		/ 1000;
+		sy1 -= (yas532_data.calib_yas532.cy1 * tmp)
+		/ 1000;
+		sy2 -= (yas532_data.calib_yas532.cy2 * tmp)
+		/ 1000;
+	}
+	sy = sy1 - sy2;
+	sz = -sy1 - sy2;
+	#if 1
+	fifo_xyz_data.yas532_vector_xyz[0] = yas532_data.calib_yas532.k *
+	((100 * sx + yas532_data.calib_yas532.a2 * sy +
+	yas532_data.calib_yas532.a3 * sz) / 10);
+	fifo_xyz_data.yas532_vector_xyz[1] = yas532_data.calib_yas532.k *
+	((yas532_data.calib_yas532.a4 * sx + yas532_data.calib_yas532.a5 * sy +
+	yas532_data.calib_yas532.a6 * sz) / 10);
+	fifo_xyz_data.yas532_vector_xyz[2] = yas532_data.calib_yas532.k *
+	((yas532_data.calib_yas532.a7 * sx + yas532_data.calib_yas532.a8 * sy +
+	yas532_data.calib_yas532.a9 * sz) / 10);
+	if (yas532_data.transform != BMI160_NULL) {
+		for (i = 0; i < 3; i++) {
+				v_xyz_tmp_s32[i] = yas532_data.transform[i
+				* 3] *
+				fifo_xyz_data.yas532_vector_xyz[0]
+				+ yas532_data.transform[i * 3 + 1] *
+				fifo_xyz_data.yas532_vector_xyz[1]
+				+ yas532_data.transform[i * 3 + 2] *
+				fifo_xyz_data.yas532_vector_xyz[2];
+		}
+		set_vector(fifo_xyz_data.yas532_vector_xyz, v_xyz_tmp_s32);
+	}
+	for (i = 0; i < 3; i++) {
+		fifo_xyz_data.yas532_vector_xyz[i] -=
+		fifo_xyz_data.yas532_vector_xyz[i] % 10;
+		if (v_overflow_s8 & (1
+		<< (i * 2)))
+			fifo_xyz_data.yas532_vector_xyz[i] +=
+			1; /* set overflow */
+		if (v_overflow_s8 & (1 <<
+		(i * 2 + 1)))
+			fifo_xyz_data.yas532_vector_xyz[i] += 2;
+	}
+#else
+	fifo_xyz_data.yas532_vector_xyz[0] = sx;
+	fifo_xyz_data.yas532_vector_xyz[1] = sy;
+	fifo_xyz_data.yas532_vector_xyz[2] = sz;
+#endif
+if (v_busy_u8)
+		return com_rslt;
+	if (0 < v_overflow_s8) {
+		if (!yas532_data.overflow)
+			yas532_data.overflow = 1;
+		yas532_data.measure_state = YAS532_MAG_STATE_INIT_COIL;
+	} else
+		yas532_data.overflow = 0;
+	for (i = 0; i < 3; i++)
+		yas532_data.last_raw[i] = v_xy1y2_u16[i];
+	  yas532_data.last_raw[i] = v_temp_u16;
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for YAS532 write data acquisition
+ *	@param
+ */
+/*!
+ *	@brief This function used for YAS532 write data acquisition
+ *	command register write
+ *	@param	v_command_reg_data_u8	:	the value of data acquisition
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_acquisition_command_register(
+u8 v_command_reg_data_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_ENABLE);
+
+		com_rslt = bmi160_set_mag_write_data(v_command_reg_data_u8);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* YAMAHA YAS532-0x82*/
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_YAS532_COMMAND_REGISTER);
+		p_bmi160->delay_msec(BMI160_YAS_ACQ_COMMAND_DELAY);
+		com_rslt += bmi160_set_mag_read_addr(
+		BMI160_YAS532_DATA_REGISTER);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+		com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
+
+	return com_rslt;
+
+}
+/*!
+ *	@brief This function used write offset of YAS532
+ *
+ *	@param	p_offset_s8	: The value of offset to write
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_offset(
+const s8 *p_offset_s8)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+		com_rslt = bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
+		p_bmi160->delay_msec(BMI160_YAS532_OFFSET_DELAY);
+
+	    /* Write offset X data*/
+		com_rslt = bmi160_set_mag_write_data(p_offset_s8[0]);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* YAS532 offset x write*/
+		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_OFFSET_X);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+		/* Write offset Y data*/
+		com_rslt = bmi160_set_mag_write_data(p_offset_s8[1]);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* YAS532 offset y write*/
+		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_OFFSET_Y);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+		/* Write offset Z data*/
+		com_rslt = bmi160_set_mag_write_data(p_offset_s8[2]);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* YAS532 offset z write*/
+		com_rslt += bmi160_set_mag_write_addr(BMI160_YAS532_OFFSET_Z);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		set_vector(yas532_data.v_hard_offset_s8, p_offset_s8);
+
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+		com_rslt = bmi160_set_mag_manual_enable(BMI160_MANUAL_DISABLE);
+	return com_rslt;
+}
+/*!
+ *	@brief This function used to init the YAMAH-YAS537
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_mag_interface_init(
+void)
+{
+/* This variable used for provide the communication
+results*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+u8 v_pull_value_u8 = BMI160_INIT_VALUE;
+u8 v_data_u8 = BMI160_INIT_VALUE;
+u8 i = BMI160_INIT_VALUE;
+/* accel operation mode to normal*/
+com_rslt = bmi160_set_command_register(ACCEL_MODE_NORMAL);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* write mag power mode as NORMAL*/
+com_rslt += bmi160_set_mag_interface_normal();
+/* register 0x7E write the 0x37, 0x9A and 0x30*/
+com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_ONE);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_TWO);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_command_register(BMI160_COMMAND_REG_THREE);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+/*switch the page1*/
+com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE1);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+bmi160_get_target_page(&v_data_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_paging_enable(BMI160_WRITE_ENABLE_PAGE1);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+bmi160_get_paging_enable(&v_data_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* enable the pullup configuration from
+the register 0x05 bit 4 and 5 as 10*/
+bmi160_get_pullup_configuration(&v_pull_value_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+v_pull_value_u8 = v_pull_value_u8 | BMI160_PULL_UP_DATA;
+com_rslt += bmi160_set_pullup_configuration(v_pull_value_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/*switch the page0*/
+com_rslt += bmi160_set_target_page(BMI160_WRITE_TARGET_PAGE0);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+bmi160_get_target_page(&v_data_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* Write the YAS532 i2c address*/
+com_rslt += bmi160_set_i2c_device_addr(BMI160_YAS537_I2C_ADDRESS);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* enable the mag interface to manual mode*/
+com_rslt += bmi160_set_mag_manual_enable(BMI160_MANUAL_ENABLE);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+bmi160_get_mag_manual_enable(&v_data_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/*Enable the MAG interface */
+com_rslt += bmi160_set_if_mode(BMI160_ENABLE_MAG_IF_MODE);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+bmi160_get_if_mode(&v_data_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+v_data_u8 = BMI160_MANUAL_DISABLE;
+/* Read the YAS537 device id 0x07*/
+com_rslt += bmi160_set_mag_read_addr(BMI160_YAS_DEVICE_ID_REG);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&v_data_u8, BMI160_GEN_READ_WRITE_DATA_LENGTH);
+yas537_data.dev_id = v_data_u8;
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* Read the YAS532 calibration data*/
+
+com_rslt +=
+bmi160_bst_yamaha_yas537_calib_values(
+BMI160_GEN_READ_WRITE_DATA_LENGTH);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+/* set the mode to NORMAL*/
+yas537_data.measure_state = YAS537_MAG_STATE_NORMAL;
+/* set the transform to zero */
+yas537_data.transform = BMI160_NULL;
+yas537_data.average = 32;
+for (i = 0; i < 3; i++) {
+	yas537_data.hard_offset[i] = -128;
+	yas537_data.last_after_rcoil[i] = 0;
+}
+for (i = 0; i < 4; i++)
+	yas537_data.last_raw[i] = 0;
+/* write the mag bandwidth as 25Hz*/
+com_rslt += bmi160_set_mag_output_data_rate(
+BMI160_MAG_OUTPUT_DATA_RATE_25HZ);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* Enable mag interface to auto mode*/
+com_rslt += bmi160_set_mag_manual_enable(
+BMI160_MANUAL_DISABLE);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+bmi160_get_mag_manual_enable(&v_data_u8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+return com_rslt;
+}
+/*!
+*	@brief This function used for read the
+*	YAMAHA YAS537 calibration data
+*
+*
+*	@param v_rcoil_u8 : The value of r coil
+*
+*
+*	@return results of bus communication function
+*	@retval 0 -> Success
+*	@retval -1 -> Error
+*
+*
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_calib_values(
+u8 v_rcoil_u8)
+{
+/* This variable used for provide the communication
+results*/
+BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+/* Array holding the YAS532 calibration values */
+u8 a_data_u8[BMI160_YAS537_CALIB_DATA_SIZE] = {
+BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+};
+static const u8 v_avrr_u8[] = {0x50, 0x60, 0x70};
+u8 v_cal_valid_u8 = BMI160_INIT_VALUE, i;
+/* write soft reset as 0x02*/
+com_rslt = bmi160_set_mag_write_data(
+YAS537_SRSTR_DATA);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_mag_write_addr(YAS537_REG_SRSTR);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+/* Read the DX value */
+com_rslt = bmi160_set_mag_read_addr(YAS537_REG_CALR_C0);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[0], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the DY1 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C1);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[1], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the DY2 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C2);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[2], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D2 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C3);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[3], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D3 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C4);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[4], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D4 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C5);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[5], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D5 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C6);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[6], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D6 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C7);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[7], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D7 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C8);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[8], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D8 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_C9);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[9], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the D9 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CA);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[10], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the RX value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CB);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[11], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the RY1 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CC);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[12], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the RY2 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CD);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[13], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the RY2 value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CE);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[14], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the CHF value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_CF);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[15], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* Read the VER value */
+com_rslt += bmi160_set_mag_read_addr(YAS537_REG_CALR_DO);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+/* 0x04 is secondary read mag x lsb register */
+com_rslt += bmi160_read_reg(BMI160_MAG_DATA_READ_REG,
+&a_data_u8[16], BMI160_GEN_READ_WRITE_DATA_LENGTH);
+/* get the calib ver*/
+yas537_data.calib_yas537.ver =
+(a_data_u8[16] >> BMI160_SHIFT_BIT_POSITION_BY_06_BITS);
+for (i = 0; i < 17; i++) {
+	if (((i < 16 && a_data_u8[i]) != 0))
+		v_cal_valid_u8 = 1;
+	if ((i < 16 &&
+	(a_data_u8[i] & 0x3F)) != 0)
+		v_cal_valid_u8 = 1;
+}
+if (!v_cal_valid_u8)
+	return ERROR;
+if (yas537_data.calib_yas537.ver == 0) {
+	for (i = 0; i < 17; i++) {
+		if (i < 12) {
+			/* write offset*/
+			com_rslt += bmi160_set_mag_write_data(
+			a_data_u8[i]);
+			p_bmi160->delay_msec(
+			BMI160_GEN_READ_WRITE_DELAY);
+			com_rslt += bmi160_set_mag_write_addr(
+			YAS537_REG_MTCR + i);
+			p_bmi160->delay_msec(
+			BMI160_GEN_READ_WRITE_DELAY);
+		} else if (i < 15) {
+			/* write offset correction*/
+			com_rslt += bmi160_set_mag_write_data(
+			a_data_u8[i]);
+			p_bmi160->delay_msec(
+			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+			com_rslt += bmi160_set_mag_write_addr((
+			(YAS537_REG_OXR + i) - 12));
+			p_bmi160->delay_msec(
+			BMI160_GEN_READ_WRITE_DELAY);
+			yas537_data.hard_offset[i - 12]
+			= a_data_u8[i];
+		} else {
+			/* write offset correction*/
+			com_rslt += bmi160_set_mag_write_data(
+			a_data_u8[i]);
+			p_bmi160->delay_msec(
+			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+			com_rslt += bmi160_set_mag_write_addr((
+			(YAS537_REG_OXR + i) - 11));
+			p_bmi160->delay_msec(
+			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		}
+
+}
+} else if (yas537_data.calib_yas537.ver == 1) {
+	for (i = 0; i < 3; i++) {
+		/* write offset*/
+		com_rslt += bmi160_set_mag_write_data(
+		a_data_u8[i]);
+		p_bmi160->delay_msec(
+		BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(
+		YAS537_REG_MTCR + i);
+		p_bmi160->delay_msec(
+		BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		if (com_rslt == SUCCESS) {
+			/* write offset*/
+			com_rslt += bmi160_set_mag_write_data(
+			a_data_u8[i + 12]);
+			p_bmi160->delay_msec(
+			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+			com_rslt += bmi160_set_mag_write_addr(
+			YAS537_REG_OXR + i);
+			p_bmi160->delay_msec(
+			BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+			yas537_data.hard_offset[i] =
+			a_data_u8[i + 12];
+		} else {
+			com_rslt = ERROR;
+		}
+	}
+	/* write offset*/
+	com_rslt += bmi160_set_mag_write_data(
+	((a_data_u8[i] & 0xE0) | 0x10));
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(
+	YAS537_REG_MTCR + i);
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* write offset*/
+	com_rslt += bmi160_set_mag_write_data(
+	((a_data_u8[15]
+	>> BMI160_SHIFT_BIT_POSITION_BY_03_BITS)
+	& 0x1E));
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_HCKR);
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* write offset*/
+	com_rslt += bmi160_set_mag_write_data(
+	((a_data_u8[15] << 1) & 0x1E));
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_LCKR);
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	/* write offset*/
+	com_rslt += bmi160_set_mag_write_data(
+	(a_data_u8[16] & 0x3F));
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_OCR);
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+
+	/* Assign the calibration values*/
+	/* a2 */
+	yas537_data.calib_yas537.a2 =
+	((((a_data_u8[3]
+	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
+	& 0x7C)
+	| (a_data_u8[4]
+	>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS)) - 64);
+	/* a3 */
+	yas537_data.calib_yas537.a3 =
+	((((a_data_u8[4] << BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	& 0x7E)
+	| (a_data_u8[5]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS)) - 64);
+	/* a4 */
+	yas537_data.calib_yas537.a4 =
+	((((a_data_u8[5]
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	& 0xFE)
+	| (a_data_u8[6]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
+	- 128);
+	/* a5 */
+	yas537_data.calib_yas537.a5 =
+	((((a_data_u8[6]
+	<< BMI160_SHIFT_BIT_POSITION_BY_02_BITS)
+	& 0x1FC)
+	| (a_data_u8[7]
+	>> BMI160_SHIFT_BIT_POSITION_BY_06_BITS))
+	- 112);
+	/* a6 */
+	yas537_data.calib_yas537.a6 =
+	((((a_data_u8[7]
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	& 0x7E)
+	| (a_data_u8[8]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS)) - 64);
+	/* a7 */
+	yas537_data.calib_yas537.a7 =
+	((((a_data_u8[8]
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT)
+	& 0xFE)
+	| (a_data_u8[9]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
+	- 128);
+	/* a8 */
+	yas537_data.calib_yas537.a8 = ((a_data_u8[9] &
+	0x7F) - 64);
+	/* a9 */
+	yas537_data.calib_yas537.a9 = ((((a_data_u8[10]
+	<< BMI160_SHIFT_BIT_POSITION_BY_01_BIT) & 0x1FE)
+	| (a_data_u8[11]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS))
+	- 112);
+	/* k */
+	yas537_data.calib_yas537.k = (
+	a_data_u8[11] & 0x7F);
+	} else {
+		return ERROR;
+	}
+/* write A/D converter*/
+com_rslt += bmi160_set_mag_write_data(
+YAS537_WRITE_A_D_CONVERTER);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_mag_write_addr(YAS537_REG_ADCCALR);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+/* write A/D converter second register*/
+com_rslt += bmi160_set_mag_write_data(
+YAS537_WRITE_A_D_CONVERTER2);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_mag_write_addr(YAS537_REG_ADCCALR_ONE);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+/* write temperature calibration register*/
+com_rslt += bmi160_set_mag_write_data(YAS537_WRITE_TEMP_CALIB);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_mag_write_addr(YAS537_REG_TRMR);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+/* write average filter register*/
+com_rslt += bmi160_set_mag_write_data(
+v_avrr_u8[yas537_data.average]);
+p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+com_rslt += bmi160_set_mag_write_addr(YAS537_REG_AVRR);
+p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+if (v_rcoil_u8) {
+	/* write average; filter register*/
+	com_rslt += bmi160_set_mag_write_data(
+	YAS537_WRITE_FILTER);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_CONFR);
+	p_bmi160->delay_msec(
+	BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+}
+
+return com_rslt;
+
+}
+/*!
+ *	@brief This function used for YAS537 write data acquisition
+ *	command register write
+ *	@param	v_command_reg_data_u8	:	the value of data acquisition
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas537_acquisition_command_register(
+u8 v_command_reg_data_u8)
+{
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_ENABLE);
+			p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+		com_rslt = bmi160_set_mag_write_data(v_command_reg_data_u8);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		/* YAMAHA YAS532-0x82*/
+		com_rslt += bmi160_set_mag_write_addr(
+		BMI160_REG_YAS537_CMDR);
+		/* set the mode to RECORD*/
+		yas537_data.measure_state = YAS537_MAG_STATE_RECORD_DATA;
+		p_bmi160->delay_msec(BMI160_YAS_ACQ_COMMAND_DELAY);
+		com_rslt += bmi160_set_mag_read_addr(
+		YAS537_REG_TEMPERATURE_0);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+		com_rslt += bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_DISABLE);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+
+	return com_rslt;
+
+}
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param xy1y2: The value of raw xy1y2 data
+ *	@param xyz: The value of  xyz data
+ *
+ *
+ *	@return None
+ *
+ *
+ */
+static void xy1y2_to_xyz(u16 *xy1y2, s32 *xyz)
+{
+	xyz[0] = ((xy1y2[0] - 8192)
+	* 300);
+	xyz[1] = (((xy1y2[1] - xy1y2[2])
+	* 1732) / 10);
+	xyz[2] = (((-xy1y2[2] - xy1y2[2])
+	+ 16384) * 300);
+}
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param v_coil_stat_u8: The value of R coil status
+ *	@param v_busy_u8: The value of busy status
+ *	@param v_temperature_u16: The value of temperature
+ *	@param xy1y2: The value of raw xy1y2 data
+ *	@param v_ouflow_u8: The value of overflow
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_read_xy1y2_data(
+u8 *v_coil_stat_u8, u8 *v_busy_u8,
+u16 *v_temperature_u16, u16 *xy1y2, u8 *v_ouflow_u8)
+{
+	/* This variable used for provide the communication
+	results*/
+	BMI160_RETURN_FUNCTION_TYPE com_rslt = E_BMI160_COMM_RES;
+	/* Array holding the YAS532 calibration values */
+	u8 a_data_u8[BMI160_YAS_XY1Y2T_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE,
+	};
+	u8 i = BMI160_INIT_VALUE;
+	s32 a_h_s32[BMI160_YAS_H_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	s32 a_s_s32[BMI160_YAS_S_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	/* set command register*/
+	com_rslt = bmi160_bst_yas537_acquisition_command_register(
+	YAS537_SET_COMMAND_REGISTER);
+	/* read the yas537 sensor data of xy1y2*/
+	com_rslt +=
+	p_bmi160->BMI160_BUS_READ_FUNC(p_bmi160->dev_addr,
+	BMI160_USER_DATA_MAG_X_LSB__REG,
+	a_data_u8, BMI160_MAG_YAS_DATA_LENGTH);
+	/* read the busy flag*/
+	*v_busy_u8 = a_data_u8[2]
+	>> BMI160_SHIFT_BIT_POSITION_BY_07_BITS;
+	/* read the coil status*/
+	*v_coil_stat_u8 =
+	((a_data_u8[2] >>
+	BMI160_SHIFT_BIT_POSITION_BY_06_BITS) & 0X01);
+	/* read temperature data*/
+	*v_temperature_u16 = (u16)((a_data_u8[0]
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS) | a_data_u8[1]);
+	/* read x data*/
+	xy1y2[0] = (u16)(((a_data_u8[2] &
+	0x3F)
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| (a_data_u8[3]));
+	/* read y1 data*/
+	xy1y2[1] = (u16)((a_data_u8[4]
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| a_data_u8[5]);
+	/* read y2 data*/
+	xy1y2[2] = (u16)((a_data_u8[6]
+	<< BMI160_SHIFT_BIT_POSITION_BY_08_BITS)
+	| a_data_u8[7]);
+	for (i = 0; i < 3; i++)
+		yas537_data.last_raw[i] = xy1y2[i];
+	yas537_data.last_raw[i] = *v_temperature_u16;
+	if (yas537_data.calib_yas537.ver == 1) {
+		for (i = 0; i < 3; i++)
+			a_s_s32[i] = xy1y2[i] - 8192;
+		/* read hx*/
+		a_h_s32[0] = ((yas537_data.calib_yas537.k * (
+		(128 * a_s_s32[0]) +
+		(yas537_data.calib_yas537.a2 * a_s_s32[1]) +
+		(yas537_data.calib_yas537.a3 * a_s_s32[2])))
+		/ (8192));
+		/* read hy1*/
+		a_h_s32[1] = ((yas537_data.calib_yas537.k * (
+		(yas537_data.calib_yas537.a4 * a_s_s32[0]) +
+		(yas537_data.calib_yas537.a5 * a_s_s32[1]) +
+		(yas537_data.calib_yas537.a6 * a_s_s32[2])))
+		/ (8192));
+		/* read hy2*/
+		a_h_s32[2] = ((yas537_data.calib_yas537.k * (
+		(yas537_data.calib_yas537.a7 * a_s_s32[0]) +
+		(yas537_data.calib_yas537.a8 * a_s_s32[1]) +
+		(yas537_data.calib_yas537.a9 * a_s_s32[2])))
+		/ (8192));
+
+		for (i = 0; i < 3; i++) {
+			if (a_h_s32[i] < -8192)
+				a_h_s32[i] = -8192;
+
+			if (8192 < a_h_s32[i])
+				a_h_s32[i] = 8192;
+
+			xy1y2[i] = a_h_s32[i] + 8192;
+
+		}
+	}
+	*v_ouflow_u8 = 0;
+	for (i = 0; i < 3; i++) {
+		if (YAS537_DATA_OVERFLOW <= xy1y2[i])
+			*v_ouflow_u8 |= (1 << (i * 2));
+		if (xy1y2[i] == YAS537_DATA_UNDERFLOW)
+			*v_ouflow_u8 |= (1 << (i * 2 + 1));
+	}
+
+	return com_rslt;
+
+}
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param v_ouflow_u8: The value of overflow
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+static BMI160_RETURN_FUNCTION_TYPE invalid_magnetic_field(
+u16 *v_cur_u16, u16 *v_last_u16)
+{
+	s16 invalid_thresh[] = {1500, 1500, 1500};
+	u8 i = BMI160_INIT_VALUE;
+
+	for (i = 0; i < 3; i++)
+		if (invalid_thresh[i] < ABS(v_cur_u16[i] - v_last_u16[i]))
+			return 1;
+	return 0;
+}
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param v_ouflow_u8: The value of overflow
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_measure_xyz_data(
+u8 *v_ouflow_u8, struct yas_vector *vector_xyz)
+{
+	s32 a_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	u8 i = BMI160_INIT_VALUE;
+	s8 com_rslt = BMI160_INIT_VALUE;
+	u8 v_busy_u8 = BMI160_INIT_VALUE;
+	u8 v_rcoil_u8 = BMI160_INIT_VALUE;
+	u16 v_temperature_u16 = BMI160_INIT_VALUE;
+	u16 a_xy1y2_u16[BMI160_YAS_XY1Y2_DATA_SIZE] = {
+	BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+	*v_ouflow_u8 = 0;
+	/* read the yas537 xy1y2 data*/
+	com_rslt = bmi160_bst_yamaha_yas537_read_xy1y2_data(
+	&v_rcoil_u8, &v_busy_u8,
+	&v_temperature_u16, a_xy1y2_u16, v_ouflow_u8);
+	/* linear calculation*/
+	xy1y2_to_xyz(a_xy1y2_u16, vector_xyz->yas537_vector_xyz);
+	if (yas537_data.transform != BMI160_NULL) {
+		for (i = 0; i < 3; i++) {
+			a_xyz_tmp_s32[i] = ((
+			yas537_data.transform[i + 3]
+			* vector_xyz->yas537_vector_xyz[0])
+			+ (yas537_data.transform[
+			i * 3 + 1]
+			* vector_xyz->yas537_vector_xyz[1])
+			+ (yas537_data.transform[
+			i * 3 + 2]
+			* vector_xyz->yas537_vector_xyz[2]));
+		}
+		yas537_set_vector(
+		vector_xyz->yas537_vector_xyz, a_xyz_tmp_s32);
+	}
+	for (i = 0; i < 3; i++) {
+		vector_xyz->yas537_vector_xyz[i] -=
+		vector_xyz->yas537_vector_xyz[i] % 10;
+		if (*v_ouflow_u8 & (1 <<
+		(i * 2)))
+			vector_xyz->yas537_vector_xyz[i] +=
+			1; /* set overflow */
+		if (*v_ouflow_u8 & (1 << (i * 2 + 1)))
+			/* set underflow */
+			vector_xyz->yas537_vector_xyz[i] += 2;
+	}
+	if (v_busy_u8)
+		return ERROR;
+	switch (yas537_data.measure_state) {
+	case YAS537_MAG_STATE_INIT_COIL:
+		if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_ENABLE);
+		com_rslt += bmi160_set_mag_write_data(YAS537_WRITE_CONFR);
+		p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+		com_rslt += bmi160_set_mag_write_addr(YAS537_REG_CONFR);
+		p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+		yas537_data.measure_state = YAS537_MAG_STATE_RECORD_DATA;
+		if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+			com_rslt = bmi160_set_mag_manual_enable(
+			BMI160_MANUAL_DISABLE);
+	break;
+	case YAS537_MAG_STATE_RECORD_DATA:
+		if (v_rcoil_u8)
+			break;
+		yas537_set_vector(yas537_data.last_after_rcoil, a_xy1y2_u16);
+		yas537_data.measure_state = YAS537_MAG_STATE_NORMAL;
+	break;
+	case YAS537_MAG_STATE_NORMAL:
+		if (BMI160_INIT_VALUE < v_ouflow_u8
+		|| invalid_magnetic_field(a_xy1y2_u16,
+		yas537_data.last_after_rcoil)) {
+			yas537_data.measure_state = YAS537_MAG_STATE_INIT_COIL;
+			for (i = 0; i < 3; i++) {
+				if (!*v_ouflow_u8)
+					vector_xyz->yas537_vector_xyz[i] += 3;
+			}
+		}
+	break;
+	}
+
+	return com_rslt;
+}
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data of fifo
+ *
+ *	@param a_xy1y2_u16: The value of xyy1 data
+ *	@param v_over_flow_u8: The value of overflow
+ *	@param v_rcoil_u8: The value of rcoil
+ *	@param v_busy_u8: The value of busy flag
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_fifo_xyz_data(
+u16 *a_xy1y2_u16, u8 v_over_flow_u8, u8 v_rcoil_u8, u8 v_busy_u8)
+{
+
+s32 a_xyz_tmp_s32[BMI160_YAS_TEMP_DATA_SIZE] = {
+BMI160_INIT_VALUE, BMI160_INIT_VALUE, BMI160_INIT_VALUE};
+u8 i = BMI160_INIT_VALUE;
+s8 com_rslt = BMI160_INIT_VALUE;
+/* linear calculation*/
+xy1y2_to_xyz(a_xy1y2_u16, fifo_vector_xyz.yas537_vector_xyz);
+if (yas537_data.transform != BMI160_NULL) {
+	for (i = 0; i < 3; i++) {
+		a_xyz_tmp_s32[i] = ((
+		yas537_data.transform[i + 3]
+		* fifo_vector_xyz.yas537_vector_xyz[0])
+		+ (yas537_data.transform[
+		i * 3 + 1]
+		* fifo_vector_xyz.yas537_vector_xyz[1])
+		+ (yas537_data.transform[
+		i * 3 + 2]
+		* fifo_vector_xyz.yas537_vector_xyz[2]));
+	}
+	yas537_set_vector(
+	fifo_vector_xyz.yas537_vector_xyz, a_xyz_tmp_s32);
+}
+for (i = 0; i < 3; i++) {
+	fifo_vector_xyz.yas537_vector_xyz[i] -=
+	fifo_vector_xyz.yas537_vector_xyz[i] % 10;
+	if (v_over_flow_u8 & (1 <<
+	(i * 2)))
+		fifo_vector_xyz.yas537_vector_xyz[i] +=
+		1; /* set overflow */
+	if (v_over_flow_u8 & (1 << (i * 2 + 1)))
+		/* set underflow */
+		fifo_vector_xyz.yas537_vector_xyz[i] += 2;
+}
+if (v_busy_u8)
+	return ERROR;
+switch (yas537_data.measure_state) {
+case YAS537_MAG_STATE_INIT_COIL:
+	if (p_bmi160->mag_manual_enable != BMI160_MANUAL_ENABLE)
+		com_rslt = bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_ENABLE);
+	com_rslt += bmi160_set_mag_write_data(YAS537_WRITE_CONFR);
+	p_bmi160->delay_msec(BMI160_GEN_READ_WRITE_DELAY);
+	com_rslt += bmi160_set_mag_write_addr(YAS537_REG_CONFR);
+	p_bmi160->delay_msec(BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY);
+	yas537_data.measure_state = YAS537_MAG_STATE_RECORD_DATA;
+	if (p_bmi160->mag_manual_enable == BMI160_MANUAL_ENABLE)
+		com_rslt = bmi160_set_mag_manual_enable(
+		BMI160_MANUAL_DISABLE);
+break;
+case YAS537_MAG_STATE_RECORD_DATA:
+	if (v_rcoil_u8)
+		break;
+	yas537_set_vector(yas537_data.last_after_rcoil, a_xy1y2_u16);
+	yas537_data.measure_state = YAS537_MAG_STATE_NORMAL;
+break;
+case YAS537_MAG_STATE_NORMAL:
+	if (BMI160_INIT_VALUE < v_over_flow_u8
+	|| invalid_magnetic_field(a_xy1y2_u16,
+	yas537_data.last_after_rcoil)) {
+		yas537_data.measure_state = YAS537_MAG_STATE_INIT_COIL;
+		for (i = 0; i < 3; i++) {
+			if (!v_over_flow_u8)
+				fifo_vector_xyz.yas537_vector_xyz[i]
+				+= 3;
+		}
+	}
+break;
+}
+
+return com_rslt;
+
+}
+/*!
+ *	@brief This function used for reading
+ *	bmi160_t structure
+ *
+ *  @return the reference and values of bmi160_t
+ *
+ *
+*/
+struct bmi160_t *bmi160_get_ptr(void)
+{
+	return  p_bmi160;
+}
diff --git a/ext/lib/upm/src/bmi160/bosch_bmi160.h b/ext/lib/upm/src/bmi160/bosch_bmi160.h
new file mode 100644
index 0000000..87ca224
--- /dev/null
+++ b/ext/lib/upm/src/bmi160/bosch_bmi160.h
@@ -0,0 +1,12048 @@
+/** \mainpage
+*
+****************************************************************************
+* Copyright (C) 2014 Bosch Sensortec GmbH
+*
+* File : bosch_bmi160.h
+*
+* Date : 2014/10/27
+*
+* Revision : 2.0.6 $
+*
+* Usage: Sensor Driver for BMI160 sensor
+*
+****************************************************************************
+*
+* \section License
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*   Redistributions of source code must retain the above copyright
+*   notice, this list of conditions and the following disclaimer.
+*
+*   Redistributions in binary form must reproduce the above copyright
+*   notice, this list of conditions and the following disclaimer in the
+*   documentation and/or other materials provided with the distribution.
+*
+*   Neither the name of the copyright holder nor the names of the
+*   contributors may be used to endorse or promote products derived from
+*   this software without specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+* CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+* DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER
+* OR CONTRIBUTORS BE LIABLE FOR ANY
+* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
+* OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
+* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+* ANY WAY OUT OF THE USE OF THIS
+* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+*
+* The information provided is believed to be accurate and reliable.
+* The copyright holder assumes no responsibility
+* for the consequences of use
+* of such information nor for any infringement of patents or
+* other rights of third parties which may result from its use.
+* No license is granted by implication or otherwise under any patent or
+* patent rights of the copyright holder.
+**************************************************************************/
+
+/*! \file bmi160.hpp
+    \brief BMI160 Sensor Driver Support Header File */
+/* user defined code to be added here ... */
+#ifndef __BMI160_H__
+#define __BMI160_H__
+
+/*!
+* @brief The following definition uses for define the data types
+*
+* @note While porting the API please consider the following
+* @note Please check the version of C standard
+* @note Are you using Linux platform
+*/
+
+/*!
+* @brief For the Linux platform support
+* Please use the types.h for your data types definitions
+*/
+#ifdef	__KERNEL__
+
+#include <linux/types.h>
+/* singed integer type*/
+typedef	int8_t s8;/**< used for signed 8bit */
+typedef	int16_t s16;/**< used for signed 16bit */
+typedef	int32_t s32;/**< used for signed 32bit */
+typedef	int64_t s64;/**< used for signed 64bit */
+
+typedef	u_int8_t u8;/**< used for unsigned 8bit */
+typedef	u_int16_t u16;/**< used for unsigned 16bit */
+typedef	u_int32_t u32;/**< used for unsigned 32bit */
+typedef	u_int64_t u64;/**< used for unsigned 64bit */
+
+
+
+#else /* ! __KERNEL__ */
+/**********************************************************
+* These definition uses for define the C
+* standard version data types
+***********************************************************/
+# if !defined(__STDC_VERSION__)
+
+/************************************************
+ * compiler is C11 C standard
+************************************************/
+#if (__STDC_VERSION__ == 201112L)
+
+/************************************************/
+#include <stdint.h>
+/************************************************/
+
+/*unsigned integer types*/
+typedef	uint8_t u8;/**< used for unsigned 8bit */
+typedef	uint16_t u16;/**< used for unsigned 16bit */
+typedef	uint32_t u32;/**< used for unsigned 32bit */
+typedef	uint64_t u64;/**< used for unsigned 64bit */
+
+/*signed integer types*/
+typedef	int8_t s8;/**< used for signed 8bit */
+typedef	int16_t s16;/**< used for signed 16bit */
+typedef	int32_t s32;/**< used for signed 32bit */
+typedef	int64_t s64;/**< used for signed 64bit */
+/************************************************
+ * compiler is C99 C standard
+************************************************/
+
+#elif (__STDC_VERSION__ == 199901L)
+
+/* stdint.h is a C99 supported c library.
+which is used to fixed the integer size*/
+/************************************************/
+#include <stdint.h>
+/************************************************/
+
+/*unsigned integer types*/
+typedef	uint8_t u8;/**< used for unsigned 8bit */
+typedef	uint16_t u16;/**< used for unsigned 16bit */
+typedef	uint32_t u32;/**< used for unsigned 32bit */
+typedef	uint64_t u64;/**< used for unsigned 64bit */
+
+/*signed integer types*/
+typedef int8_t s8;/**< used for signed 8bit */
+typedef	int16_t s16;/**< used for signed 16bit */
+typedef	int32_t s32;/**< used for signed 32bit */
+typedef	int64_t s64;/**< used for signed 64bit */
+/************************************************
+ * compiler is C89 or other C standard
+************************************************/
+
+#else /*  !defined(__STDC_VERSION__) */
+/*!
+* @brief By default it is defined as 32 bit machine configuration
+*	define your data types based on your
+*	machine/compiler/controller configuration
+*/
+#define  MACHINE_32_BIT
+
+/*! @brief
+ *	If your machine support 16 bit
+ *	define the MACHINE_16_BIT
+ */
+#ifdef MACHINE_16_BIT
+#include <limits.h>
+/*signed integer types*/
+typedef	signed char  s8;/**< used for signed 8bit */
+typedef	signed short int s16;/**< used for signed 16bit */
+typedef	signed long int s32;/**< used for signed 32bit */
+
+#if defined(LONG_MAX) && LONG_MAX == 0x7fffffffffffffffL
+typedef long int s64;/**< used for signed 64bit */
+typedef unsigned long int u64;/**< used for unsigned 64bit */
+#elif defined(LLONG_MAX) && (LLONG_MAX == 0x7fffffffffffffffLL)
+typedef long long int s64;/**< used for signed 64bit */
+typedef unsigned long long int u64;/**< used for unsigned 64bit */
+#else
+#warning Either the correct data type for signed 64 bit integer \
+could not be found, or 64 bit integers are not supported in your environment.
+#warning If 64 bit integers are supported on your platform, \
+please set s64 manually.
+#endif
+
+/*unsigned integer types*/
+typedef	unsigned char u8;/**< used for unsigned 8bit */
+typedef	unsigned short int u16;/**< used for unsigned 16bit */
+typedef	unsigned long int u32;/**< used for unsigned 32bit */
+
+/* If your machine support 32 bit
+define the MACHINE_32_BIT*/
+#elif defined MACHINE_32_BIT
+/*signed integer types*/
+typedef	signed char  s8;/**< used for signed 8bit */
+typedef	signed short int s16;/**< used for signed 16bit */
+typedef	signed int s32;/**< used for signed 32bit */
+typedef	signed long long int s64;/**< used for signed 64bit */
+
+/*unsigned integer types*/
+typedef	unsigned char u8;/**< used for unsigned 8bit */
+typedef	unsigned short int u16;/**< used for unsigned 16bit */
+typedef	unsigned int u32;/**< used for unsigned 32bit */
+typedef	unsigned long long int u64;/**< used for unsigned 64bit */
+
+/* If your machine support 64 bit
+define the MACHINE_64_BIT*/
+#elif defined MACHINE_64_BIT
+/*signed integer types*/
+typedef	signed char  s8;/**< used for signed 8bit */
+typedef	signed short int s16;/**< used for signed 16bit */
+typedef	signed int s32;/**< used for signed 32bit */
+typedef	signed long int s64;/**< used for signed 64bit */
+
+/*unsigned integer types*/
+typedef	unsigned char u8;/**< used for unsigned 8bit */
+typedef	unsigned short int u16;/**< used for unsigned 16bit */
+typedef	unsigned int u32;/**< used for unsigned 32bit */
+typedef	unsigned long int u64;/**< used for unsigned 64bit */
+
+#else
+#warning The data types defined above which not supported \
+define the data types manually
+#endif
+#endif
+
+/*** This else will execute for the compilers
+ *	which are not supported the C standards
+ *	Like C89/C99/C11***/
+#else
+/*!
+* @brief By default it is defined as 32 bit machine configuration
+*	define your data types based on your
+*	machine/compiler/controller configuration
+*/
+#define  MACHINE_32_BIT
+
+/* If your machine support 16 bit
+define the MACHINE_16_BIT*/
+#ifdef MACHINE_16_BIT
+#include <limits.h>
+/*signed integer types*/
+typedef	signed char  s8;/**< used for signed 8bit */
+typedef	signed short int s16;/**< used for signed 16bit */
+typedef	signed long int s32;/**< used for signed 32bit */
+
+#if defined(LONG_MAX) && LONG_MAX == 0x7fffffffffffffffL
+typedef long int s64;/**< used for signed 64bit */
+typedef unsigned long int u64;/**< used for unsigned 64bit */
+#elif defined(LLONG_MAX) && (LLONG_MAX == 0x7fffffffffffffffLL)
+typedef long long int s64;/**< used for signed 64bit */
+typedef unsigned long long int u64;/**< used for unsigned 64bit */
+#else
+#warning Either the correct data type for signed 64 bit integer \
+could not be found, or 64 bit integers are not supported in your environment.
+#warning If 64 bit integers are supported on your platform, \
+please set s64 manually.
+#endif
+
+/*unsigned integer types*/
+typedef	unsigned char u8;/**< used for unsigned 8bit */
+typedef	unsigned short int u16;/**< used for unsigned 16bit */
+typedef	unsigned long int u32;/**< used for unsigned 32bit */
+
+/*! @brief If your machine support 32 bit
+define the MACHINE_32_BIT*/
+#elif defined MACHINE_32_BIT
+/*signed integer types*/
+typedef	signed char  s8;/**< used for signed 8bit */
+typedef	signed short int s16;/**< used for signed 16bit */
+typedef	signed int s32;/**< used for signed 32bit */
+typedef	signed long long int s64;/**< used for signed 64bit */
+
+/*unsigned integer types*/
+typedef	unsigned char u8;/**< used for unsigned 8bit */
+typedef	unsigned short int u16;/**< used for unsigned 16bit */
+typedef	unsigned int u32;/**< used for unsigned 32bit */
+typedef	unsigned long long int u64;/**< used for unsigned 64bit */
+
+/* If your machine support 64 bit
+define the MACHINE_64_BIT*/
+#elif defined MACHINE_64_BIT
+/*signed integer types*/
+typedef	signed char  s8;/**< used for signed 8bit */
+typedef	signed short int s16;/**< used for signed 16bit */
+typedef	signed int s32;/**< used for signed 32bit */
+typedef	signed long int s64;/**< used for signed 64bit */
+
+/*unsigned integer types*/
+typedef	unsigned char u8;/**< used for unsigned 8bit */
+typedef	unsigned short int u16;/**< used for unsigned 16bit */
+typedef	unsigned int u32;/**< used for unsigned 32bit */
+typedef	unsigned long int u64;/**< used for unsigned 64bit */
+
+#else
+#warning The data types defined above which not supported \
+define the data types manually
+#endif
+#endif
+#endif
+/***************************************************************/
+/**\name	BUS READ AND WRITE FUNCTION POINTERS        */
+/***************************************************************/
+/*!
+	@brief Define the calling convention of YOUR bus communication routine.
+	@note This includes types of parameters. This example shows the
+	configuration for an SPI bus link.
+
+    If your communication function looks like this:
+
+    write_my_bus_xy(u8 device_addr, u8 register_addr,
+    u8 * data, u8 length);
+
+    The BMI160_WR_FUNC_PTR would equal:
+
+    BMI160_WR_FUNC_PTR s8 (* bus_write)(u8,
+    u8, u8 *, u8)
+
+    Parameters can be mixed as needed refer to the
+    @ref BMI160_BUS_WRITE_FUNC  macro.
+
+
+*/
+#define BMI160_WR_FUNC_PTR s8 (*bus_write)(u8, u8,\
+u8 *, u8)
+/**< link macro between API function calls and bus write function
+	@note The bus write function can change since this is a
+	system dependant issue.
+
+    If the bus_write parameter calling order is like: reg_addr,
+    reg_data, wr_len it would be as it is here.
+
+    If the parameters are differently ordered or your communication
+    function like I2C need to know the device address,
+    you can change this macro accordingly.
+
+
+    BMI160_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
+    bus_write(dev_addr, reg_addr, reg_data, wr_len)
+
+    This macro lets all API functions call YOUR communication routine in a
+    way that equals your definition in the
+    @ref BMI160_WR_FUNC_PTR definition.
+
+*/
+#define BMI160_BUS_WRITE_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
+				bus_write(dev_addr, reg_addr, reg_data, wr_len)
+
+/**< Define the calling convention of YOUR bus communication routine.
+	@note This includes types of parameters. This example shows the
+	configuration for an SPI bus link.
+
+    If your communication function looks like this:
+
+    read_my_bus_xy(u8 device_addr, u8 register_addr,
+    u8 * data, u8 length);
+
+    The BMI160_RD_FUNC_PTR would equal:
+
+    BMI160_RD_FUNC_PTR s8 (* bus_read)(u8,
+    u8, u8 *, u8)
+
+    Parameters can be mixed as needed refer to the
+    refer BMI160_BUS_READ_FUNC  macro.
+
+*/
+#define BMI160_SPI_RD_MASK (0x80)   /* for spi read transactions on SPI the
+			MSB has to be set */
+#define BMI160_RD_FUNC_PTR s8 (*bus_read)(u8,\
+			u8, u8 *, u8)
+
+#define BMI160_BRD_FUNC_PTR s8 \
+(*burst_read)(u8, u8, u8 *, u32)
+
+/**< link macro between API function calls and bus read function
+	@note The bus write function can change since this is a
+	system dependant issue.
+
+    If the bus_read parameter calling order is like: reg_addr,
+    reg_data, wr_len it would be as it is here.
+
+    If the parameters are differently ordered or your communication
+    function like I2C need to know the device address,
+    you can change this macro accordingly.
+
+
+    BMI160_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, wr_len)\
+    bus_read(dev_addr, reg_addr, reg_data, wr_len)
+
+    This macro lets all API functions call YOUR communication routine in a
+    way that equals your definition in the
+    refer BMI160_WR_FUNC_PTR definition.
+
+    @note: this macro also includes the "MSB='1'
+    for reading BMI160 addresses.
+
+*/
+#define BMI160_BUS_READ_FUNC(dev_addr, reg_addr, reg_data, r_len)\
+				bus_read(dev_addr, reg_addr, reg_data, r_len)
+
+#define BMI160_BURST_READ_FUNC(device_addr, \
+register_addr, register_data, rd_len)\
+burst_read(device_addr, register_addr, register_data, rd_len)
+
+
+#define BMI160_MDELAY_DATA_TYPE                 u32
+
+/***************************************************************/
+/**\name	BUS READ AND WRITE FUNCTION POINTERS        */
+/***************************************************************/
+#define BMI160_I2C_ADDR1                   (0x68)
+/**< I2C Address needs to be changed */
+#define BMI160_I2C_ADDR2                    (0x69)
+ /**< I2C Address needs to be changed */
+#define BMI160_AUX_BMM150_I2C_ADDRESS       (0x10)
+/**< I2C address of BMM150*/
+#define BMI160_AUX_YAS532_I2C_ADDRESS       (0x2E)
+/**< I2C address of YAS532*/
+#define	BMI160_AUX_AKM09911_I2C_ADDR_1		(0x0C)
+/**< I2C address of AKM09911*/
+#define	BMI160_AUX_AKM09911_I2C_ADDR_2		(0x0D)
+/**< I2C address of AKM09911*/
+#define	BMI160_AUX_AKM09912_I2C_ADDR_1		(0x0C)
+/**< I2C address of AKM09912*/
+#define	BMI160_AUX_AKM09912_I2C_ADDR_2		(0x0D)
+/**< I2C address of AKM09912*/
+#define	BMI160_AUX_AKM09912_I2C_ADDR_3		(0x0E)
+/**< I2C address of AKM09912*/
+#define	BMI160_AUX_AKM09912_I2C_ADDR_4		(0x0F)
+/**< I2C address of AKM09912*/
+/*******************************************/
+/**\name	CONSTANTS        */
+/******************************************/
+#define  BMI160_INIT_VALUE					(0)
+#define  BMI160_ASSIGN_DATA                 (1)
+#define  BMI160_GEN_READ_WRITE_DATA_LENGTH	(1)
+#define  BMI160_MAXIMUM_TIMEOUT             (10)
+
+/* output data rate condition check*/
+#define  BMI160_OUTPUT_DATA_RATE0	(0)
+#define  BMI160_OUTPUT_DATA_RATE1	(1)
+#define  BMI160_OUTPUT_DATA_RATE2	(2)
+#define  BMI160_OUTPUT_DATA_RATE3	(3)
+#define  BMI160_OUTPUT_DATA_RATE4	(4)
+#define  BMI160_OUTPUT_DATA_RATE5	(5)
+#define  BMI160_OUTPUT_DATA_RATE6	(14)
+#define  BMI160_OUTPUT_DATA_RATE7	(15)
+
+/* accel range check*/
+#define BMI160_ACCEL_RANGE0  (3)
+#define BMI160_ACCEL_RANGE1  (5)
+#define BMI160_ACCEL_RANGE3  (8)
+#define BMI160_ACCEL_RANGE4  (12)
+
+/* check the status of registers*/
+#define  BMI160_FOC_STAT_HIGH			(1)
+#define  BMI160_SIG_MOTION_STAT_HIGH	(1)
+#define  BMI160_STEP_DET_STAT_HIGH		(1)
+
+/*condition check for reading and writing data*/
+#define	BMI160_MAX_VALUE_SIGNIFICANT_MOTION      (1)
+#define	BMI160_MAX_VALUE_FIFO_FILTER    (1)
+#define	BMI160_MAX_VALUE_FIFO_TIME      (1)
+#define	BMI160_MAX_VALUE_FIFO_INTR      (1)
+#define	BMI160_MAX_VALUE_FIFO_HEADER    (1)
+#define	BMI160_MAX_VALUE_FIFO_MAG       (1)
+#define	BMI160_MAX_VALUE_FIFO_ACCEL     (1)
+#define	BMI160_MAX_VALUE_FIFO_GYRO      (1)
+#define	BMI160_MAX_VALUE_SOURCE_INTR    (1)
+#define	BMI160_MAX_VALUE_LOW_G_MODE     (1)
+#define	BMI160_MAX_VALUE_NO_MOTION      (1)
+#define	BMI160_MAX_VALUE_TAP_SHOCK      (1)
+#define	BMI160_MAX_VALUE_TAP_QUIET      (1)
+#define	BMI160_MAX_VALUE_ORIENT_UD      (1)
+#define	BMI160_MAX_VALUE_ORIENT_AXES    (1)
+#define	BMI160_MAX_VALUE_NVM_PROG       (1)
+#define	BMI160_MAX_VALUE_SPI3           (1)
+#define	BMI160_MAX_VALUE_PAGE           (1)
+#define	BMI160_MAX_VALUE_I2C_WDT        (1)
+#define	BMI160_MAX_VALUE_SLEEP_STATE    (1)
+#define	BMI160_MAX_VALUE_WAKEUP_INTR    (1)
+#define	BMI160_MAX_VALUE_SELFTEST_SIGN  (1)
+#define	BMI160_MAX_VALUE_SELFTEST_AMP   (1)
+#define	BMI160_MAX_VALUE_SELFTEST_START (1)
+
+#define BMI160_MAX_GYRO_WAKEUP_TRIGGER		(3)
+#define BMI160_MAX_ACCEL_SELFTEST_AXIS	    (3)
+#define BMI160_MAX_GYRO_STEP_COUNTER        (1)
+#define BMI160_MAX_GYRO_BW                  (3)
+#define BMI160_MAX_ACCEL_BW                 (7)
+#define BMI160_MAX_ORIENT_MODE              (3)
+#define BMI160_MAX_ORIENT_BLOCKING          (3)
+#define BMI160_MAX_FLAT_HOLD                (3)
+#define BMI160_MAX_ACCEL_FOC                (3)
+#define BMI160_MAX_IF_MODE                  (3)
+#define BMI160_MAX_TARGET_PAGE              (3)
+#define BMI160_MAX_GYRO_RANGE               (4)
+#define BMI160_MAX_GYRO_SLEEP_TIGGER        (7)
+#define BMI160_MAX_TAP_TURN                 (7)
+#define BMI160_MAX_UNDER_SAMPLING           (1)
+#define BMI160_MAX_UNDER_SIG_MOTION         (3)
+#define BMI160_MAX_ACCEL_OUTPUT_DATA_RATE   (12)
+#define BMI160_MAX_LATCH_INTR               (15)
+#define BMI160_MAX_FLAT_HYST                (15)
+#define BMI160_MAX_ORIENT_THETA             (63)
+#define BMI160_MAX_FLAT_THETA               (63)
+
+/* FIFO index definitions*/
+#define BMI160_FIFO_X_LSB_DATA			(0)
+#define BMI160_FIFO_X_MSB_DATA			(1)
+#define BMI160_FIFO_Y_LSB_DATA			(2)
+#define BMI160_FIFO_Y_MSB_DATA			(3)
+#define BMI160_FIFO_Z_LSB_DATA			(4)
+#define BMI160_FIFO_Z_MSB_DATA			(5)
+#define BMI160_FIFO_R_LSB_DATA			(6)
+#define BMI160_FIFO_R_MSB_DATA			(7)
+/* FIFO gyro definition*/
+#define BMI160_GA_FIFO_G_X_LSB		(0)
+#define BMI160_GA_FIFO_G_X_MSB		(1)
+#define BMI160_GA_FIFO_G_Y_LSB		(2)
+#define BMI160_GA_FIFO_G_Y_MSB		(3)
+#define BMI160_GA_FIFO_G_Z_LSB		(4)
+#define BMI160_GA_FIFO_G_Z_MSB		(5)
+#define BMI160_GA_FIFO_A_X_LSB		(6)
+#define BMI160_GA_FIFO_A_X_MSB		(7)
+#define BMI160_GA_FIFO_A_Y_LSB		(8)
+#define BMI160_GA_FIFO_A_Y_MSB		(9)
+#define BMI160_GA_FIFO_A_Z_LSB		(10)
+#define BMI160_GA_FIFO_A_Z_MSB		(11)
+/* FIFO mag/gyro/accel definition*/
+#define BMI160_MGA_FIFO_M_X_LSB		(0)
+#define BMI160_MGA_FIFO_M_X_MSB		(1)
+#define BMI160_MGA_FIFO_M_Y_LSB		(2)
+#define BMI160_MGA_FIFO_M_Y_MSB		(3)
+#define BMI160_MGA_FIFO_M_Z_LSB		(4)
+#define BMI160_MGA_FIFO_M_Z_MSB		(5)
+#define BMI160_MGA_FIFO_M_R_LSB		(6)
+#define BMI160_MGA_FIFO_M_R_MSB		(7)
+#define BMI160_MGA_FIFO_G_X_LSB		(8)
+#define BMI160_MGA_FIFO_G_X_MSB		(9)
+#define BMI160_MGA_FIFO_G_Y_LSB		(10)
+#define BMI160_MGA_FIFO_G_Y_MSB		(11)
+#define BMI160_MGA_FIFO_G_Z_LSB		(12)
+#define BMI160_MGA_FIFO_G_Z_MSB		(13)
+#define BMI160_MGA_FIFO_A_X_LSB		(14)
+#define BMI160_MGA_FIFO_A_X_MSB		(15)
+#define BMI160_MGA_FIFO_A_Y_LSB		(16)
+#define BMI160_MGA_FIFO_A_Y_MSB		(17)
+#define BMI160_MGA_FIFO_A_Z_LSB		(18)
+#define BMI160_MGA_FIFO_A_Z_MSB		(19)
+/* FIFO mag definition*/
+#define BMI160_MA_FIFO_M_X_LSB		(0)
+#define BMI160_MA_FIFO_M_X_MSB		(1)
+#define BMI160_MA_FIFO_M_Y_LSB		(2)
+#define BMI160_MA_FIFO_M_Y_MSB		(3)
+#define BMI160_MA_FIFO_M_Z_LSB		(4)
+#define BMI160_MA_FIFO_M_Z_MSB		(5)
+#define BMI160_MA_FIFO_M_R_LSB		(6)
+#define BMI160_MA_FIFO_M_R_MSB		(7)
+#define BMI160_MA_FIFO_A_X_LSB		(8)
+#define BMI160_MA_FIFO_A_X_MSB		(9)
+#define BMI160_MA_FIFO_A_Y_LSB		(10)
+#define BMI160_MA_FIFO_A_Y_MSB		(11)
+#define BMI160_MA_FIFO_A_Z_LSB		(12)
+#define BMI160_MA_FIFO_A_Z_MSB		(13)
+/* FIFO mag/gyro definition*/
+#define BMI160_MG_FIFO_M_X_LSB		(0)
+#define BMI160_MG_FIFO_M_X_MSB		(1)
+#define BMI160_MG_FIFO_M_Y_LSB		(2)
+#define BMI160_MG_FIFO_M_Y_MSB		(3)
+#define BMI160_MG_FIFO_M_Z_LSB		(4)
+#define BMI160_MG_FIFO_M_Z_MSB		(5)
+#define BMI160_MG_FIFO_M_R_LSB		(6)
+#define BMI160_MG_FIFO_M_R_MSB		(7)
+#define BMI160_MG_FIFO_G_X_LSB		(8)
+#define BMI160_MG_FIFO_G_X_MSB		(9)
+#define BMI160_MG_FIFO_G_Y_LSB		(10)
+#define BMI160_MG_FIFO_G_Y_MSB		(11)
+#define BMI160_MG_FIFO_G_Z_LSB		(12)
+#define BMI160_MG_FIFO_G_Z_MSB		(13)
+/* FIFO length definitions*/
+#define BMI160_FIFO_SENSOR_TIME_LSB     (0)
+#define BMI160_FIFO_SENSOR_TIME_XLSB    (1)
+#define BMI160_FIFO_SENSOR_TIME_MSB     (2)
+#define BMI160_FIFO_SENSOR_TIME_LENGTH  (3)
+#define BMI160_FIFO_A_LENGTH            (6)
+#define BMI160_FIFO_G_LENGTH            (6)
+#define BMI160_FIFO_M_LENGTH            (8)
+#define BMI160_FIFO_AG_LENGTH           (12)
+#define BMI160_FIFO_AMG_LENGTH          (20)
+#define BMI160_FIFO_MA_OR_MG_LENGTH     (14)
+
+/* bus read and write length for mag, accel and gyro*/
+#define BMI160_MAG_X_DATA_LENGTH     (2)
+#define BMI160_MAG_Y_DATA_LENGTH     (2)
+#define BMI160_MAG_Z_DATA_LENGTH     (2)
+#define BMI160_MAG_R_DATA_LENGTH     (2)
+#define BMI160_MAG_XYZ_DATA_LENGTH	 (6)
+#define BMI160_MAG_XYZR_DATA_LENGTH	 (8)
+#define BMI160_MAG_YAS_DATA_LENGTH	 (8)
+#define BMI160_GYRO_DATA_LENGTH		 (2)
+#define BMI160_GYRO_XYZ_DATA_LENGTH	 (6)
+#define BMI160_ACCEL_DATA_LENGTH	 (2)
+#define BMI160_ACCEL_XYZ_DATA_LENGTH (6)
+#define BMI160_TEMP_DATA_LENGTH		 (2)
+#define BMI160_FIFO_DATA_LENGTH		 (2)
+#define BMI160_STEP_COUNTER_LENGTH	 (2)
+#define BMI160_SENSOR_TIME_LENGTH	 (3)
+
+/* Delay definitions*/
+#define BMI160_SEC_INTERFACE_GEN_READ_WRITE_DELAY    (5)
+#define BMI160_BMM150_WAKEUP_DELAY1                  (2)
+#define BMI160_BMM150_WAKEUP_DELAY2                  (3)
+#define BMI160_BMM150_WAKEUP_DELAY3                  (1)
+#define BMI160_YAS532_OFFSET_DELAY                   (2)
+#define BMI160_GEN_READ_WRITE_DELAY                  (1)
+#define BMI160_YAS532_MEASUREMENT_DELAY              (25)
+#define BMI160_YAS_ACQ_COMMAND_DELAY                 (50)
+#define BMI160_YAS532_SET_INITIAL_VALUE_DELAY        (200)
+#define BMI160_AKM_INIT_DELAY                        (60)
+/****************************************************/
+/**\name	ARRAY SIZE DEFINITIONS      */
+/***************************************************/
+#define	BMI160_ACCEL_X_DATA_SIZE   (2)
+#define	BMI160_ACCEL_Y_DATA_SIZE   (2)
+#define	BMI160_ACCEL_Z_DATA_SIZE   (2)
+#define	BMI160_ACCEL_XYZ_DATA_SIZE (6)
+
+#define	BMI160_GYRO_X_DATA_SIZE    (2)
+#define	BMI160_GYRO_Y_DATA_SIZE    (2)
+#define	BMI160_GYRO_Z_DATA_SIZE    (2)
+#define	BMI160_GYRO_XYZ_DATA_SIZE  (6)
+
+#define	BMI160_MAG_X_DATA_SIZE      (2)
+#define	BMI160_MAG_Y_DATA_SIZE      (2)
+#define	BMI160_MAG_Z_DATA_SIZE      (2)
+#define	BMI160_MAG_R_DATA_SIZE      (2)
+#define	BMI160_MAG_XYZ_DATA_SIZE    (6)
+#define	BMI160_MAG_XYZR_DATA_SIZE   (8)
+#define	BMI160_MAG_TRIM_DATA_SIZE   (16)
+
+
+#define	BMI160_TEMP_DATA_SIZE       (2)
+#define	BMI160_FIFO_DATA_SIZE       (2)
+#define	BMI160_STEP_COUNT_DATA_SIZE (2)
+
+#define	BMI160_SENSOR_TIME_DATA_SIZE      (3)
+#define	BMI160_AKM_SENSITIVITY_DATA_SIZE  (3)
+#define	BMI160_HARD_OFFSET_DATA_SIZE      (3)
+#define	BMI160_YAS_XY1Y2_DATA_SIZE        (3)
+#define	BMI160_YAS_FLAG_DATA_SIZE         (3)
+#define	BMI160_YAS_TEMP_DATA_SIZE         (3)
+#define	BMI160_YAS_H_DATA_SIZE            (3)
+#define	BMI160_YAS_S_DATA_SIZE            (3)
+#define BMI160_YAS_CORRECT_DATA_SIZE      (5)
+#define BMI160_YAS_XY1Y2T_DATA_SIZE       (8)
+#define BMI160_YAS537_CALIB_DATA_SIZE     (17)
+#define BMI160_YAS532_CALIB_DATA_SIZE     (14)
+
+/****************************************************/
+/**\name	ARRAY PARAMETER DEFINITIONS      */
+/***************************************************/
+#define BMI160_SENSOR_TIME_MSB_BYTE   (2)
+#define BMI160_SENSOR_TIME_XLSB_BYTE  (1)
+#define BMI160_SENSOR_TIME_LSB_BYTE   (0)
+
+#define BMI160_MAG_X_LSB_BYTE	          (0)
+#define BMI160_MAG_X_MSB_BYTE              (1)
+#define BMI160_MAG_Y_LSB_BYTE	           (0)
+#define BMI160_MAG_Y_MSB_BYTE              (1)
+#define BMI160_MAG_Z_LSB_BYTE	           (0)
+#define BMI160_MAG_Z_MSB_BYTE              (1)
+#define BMI160_MAG_R_LSB_BYTE	           (0)
+#define BMI160_MAG_R_MSB_BYTE              (1)
+#define BMI160_DATA_FRAME_MAG_X_LSB_BYTE   (0)
+#define BMI160_DATA_FRAME_MAG_X_MSB_BYTE   (1)
+#define BMI160_DATA_FRAME_MAG_Y_LSB_BYTE   (2)
+#define BMI160_DATA_FRAME_MAG_Y_MSB_BYTE   (3)
+#define BMI160_DATA_FRAME_MAG_Z_LSB_BYTE   (4)
+#define BMI160_DATA_FRAME_MAG_Z_MSB_BYTE   (5)
+#define BMI160_DATA_FRAME_MAG_R_LSB_BYTE   (6)
+#define BMI160_DATA_FRAME_MAG_R_MSB_BYTE   (7)
+
+#define BMI160_GYRO_X_LSB_BYTE              (0)
+#define BMI160_GYRO_X_MSB_BYTE              (1)
+#define BMI160_GYRO_Y_LSB_BYTE              (0)
+#define BMI160_GYRO_Y_MSB_BYTE              (1)
+#define BMI160_GYRO_Z_LSB_BYTE              (0)
+#define BMI160_GYRO_Z_MSB_BYTE              (1)
+#define BMI160_DATA_FRAME_GYRO_X_LSB_BYTE   (0)
+#define BMI160_DATA_FRAME_GYRO_X_MSB_BYTE   (1)
+#define BMI160_DATA_FRAME_GYRO_Y_LSB_BYTE   (2)
+#define BMI160_DATA_FRAME_GYRO_Y_MSB_BYTE   (3)
+#define BMI160_DATA_FRAME_GYRO_Z_LSB_BYTE   (4)
+#define BMI160_DATA_FRAME_GYRO_Z_MSB_BYTE   (5)
+
+#define BMI160_ACCEL_X_LSB_BYTE              (0)
+#define BMI160_ACCEL_X_MSB_BYTE              (1)
+#define BMI160_ACCEL_Y_LSB_BYTE              (0)
+#define BMI160_ACCEL_Y_MSB_BYTE              (1)
+#define BMI160_ACCEL_Z_LSB_BYTE              (0)
+#define BMI160_ACCEL_Z_MSB_BYTE              (1)
+#define BMI160_DATA_FRAME_ACCEL_X_LSB_BYTE   (0)
+#define BMI160_DATA_FRAME_ACCEL_X_MSB_BYTE   (1)
+#define BMI160_DATA_FRAME_ACCEL_Y_LSB_BYTE   (2)
+#define BMI160_DATA_FRAME_ACCEL_Y_MSB_BYTE   (3)
+#define BMI160_DATA_FRAME_ACCEL_Z_LSB_BYTE   (4)
+#define BMI160_DATA_FRAME_ACCEL_Z_MSB_BYTE   (5)
+
+#define	BMI160_TEMP_LSB_BYTE    (0)
+#define	BMI160_TEMP_MSB_BYTE    (1)
+
+#define	BMI160_FIFO_LENGTH_LSB_BYTE    (0)
+#define	BMI160_FIFO_LENGTH_MSB_BYTE    (1)
+
+#define	BMI160_STEP_COUNT_LSB_BYTE    (0)
+#define	BMI160_STEP_COUNT_MSB_BYTE    (1)
+/****************************************************/
+/**\name	ERROR CODES       */
+/***************************************************/
+
+#define E_BMI160_NULL_PTR			((s8)-127)
+#define E_BMI160_COMM_RES			((s8)-1)
+#define E_BMI160_OUT_OF_RANGE		((s8)-2)
+#define E_BMI160_BUSY				((s8)-3)
+#define	SUCCESS						((u8)0)
+#define	ERROR						((s8)-1)
+
+/* Constants */
+#define BMI160_NULL						(0)
+#define BMI160_DELAY_SETTLING_TIME		(5)
+/*This refers BMI160 return type as s8 */
+#define BMI160_RETURN_FUNCTION_TYPE		s8
+/****************************************************/
+/**\name	REGISTER DEFINITIONS       */
+/***************************************************/
+/*******************/
+/**\name CHIP ID */
+/*******************/
+#define BMI160_USER_CHIP_ID_ADDR				(0x00)
+/*******************/
+/**\name ERROR STATUS */
+/*******************/
+#define BMI160_USER_ERROR_ADDR					(0X02)
+/*******************/
+/**\name POWER MODE STATUS */
+/*******************/
+#define BMI160_USER_PMU_STAT_ADDR				(0X03)
+/*******************/
+/**\name MAG DATA REGISTERS */
+/*******************/
+#define BMI160_USER_DATA_0_ADDR					(0X04)
+#define BMI160_USER_DATA_1_ADDR					(0X05)
+#define BMI160_USER_DATA_2_ADDR					(0X06)
+#define BMI160_USER_DATA_3_ADDR					(0X07)
+#define BMI160_USER_DATA_4_ADDR					(0X08)
+#define BMI160_USER_DATA_5_ADDR					(0X09)
+#define BMI160_USER_DATA_6_ADDR					(0X0A)
+#define BMI160_USER_DATA_7_ADDR					(0X0B)
+/*******************/
+/**\name GYRO DATA REGISTERS */
+/*******************/
+#define BMI160_USER_DATA_8_ADDR					(0X0C)
+#define BMI160_USER_DATA_9_ADDR					(0X0D)
+#define BMI160_USER_DATA_10_ADDR				(0X0E)
+#define BMI160_USER_DATA_11_ADDR				(0X0F)
+#define BMI160_USER_DATA_12_ADDR				(0X10)
+#define BMI160_USER_DATA_13_ADDR				(0X11)
+#define BMI160_USER_DATA_14_ADDR				(0X12)
+#define BMI160_USER_DATA_15_ADDR				(0X13)
+/*******************/
+/**\name ACCEL DATA REGISTERS */
+/*******************/
+#define BMI160_USER_DATA_16_ADDR				(0X14)
+#define BMI160_USER_DATA_17_ADDR				(0X15)
+#define BMI160_USER_DATA_18_ADDR				(0X16)
+#define BMI160_USER_DATA_19_ADDR				(0X17)
+/*******************/
+/**\name SENSOR TIME REGISTERS */
+/*******************/
+#define BMI160_USER_SENSORTIME_0_ADDR			(0X18)
+#define BMI160_USER_SENSORTIME_1_ADDR			(0X19)
+#define BMI160_USER_SENSORTIME_2_ADDR			(0X1A)
+/*******************/
+/**\name STATUS REGISTER FOR SENSOR STATUS FLAG */
+/*******************/
+#define BMI160_USER_STAT_ADDR					(0X1B)
+/*******************/
+/**\name INTERRUPY STATUS REGISTERS */
+/*******************/
+#define BMI160_USER_INTR_STAT_0_ADDR			(0X1C)
+#define BMI160_USER_INTR_STAT_1_ADDR			(0X1D)
+#define BMI160_USER_INTR_STAT_2_ADDR			(0X1E)
+#define BMI160_USER_INTR_STAT_3_ADDR			(0X1F)
+/*******************/
+/**\name TEMPERATURE REGISTERS */
+/*******************/
+#define BMI160_USER_TEMPERATURE_0_ADDR			(0X20)
+#define BMI160_USER_TEMPERATURE_1_ADDR			(0X21)
+/*******************/
+/**\name FIFO REGISTERS */
+/*******************/
+#define BMI160_USER_FIFO_LENGTH_0_ADDR			(0X22)
+#define BMI160_USER_FIFO_LENGTH_1_ADDR			(0X23)
+#define BMI160_USER_FIFO_DATA_ADDR				(0X24)
+/***************************************************/
+/**\name ACCEL CONFIG REGISTERS  FOR ODR, BANDWIDTH AND UNDERSAMPLING*/
+/******************************************************/
+#define BMI160_USER_ACCEL_CONFIG_ADDR			(0X40)
+/*******************/
+/**\name ACCEL RANGE */
+/*******************/
+#define BMI160_USER_ACCEL_RANGE_ADDR            (0X41)
+/***************************************************/
+/**\name GYRO CONFIG REGISTERS  FOR ODR AND BANDWIDTH */
+/******************************************************/
+#define BMI160_USER_GYRO_CONFIG_ADDR            (0X42)
+/*******************/
+/**\name GYRO RANGE */
+/*******************/
+#define BMI160_USER_GYRO_RANGE_ADDR             (0X43)
+/***************************************************/
+/**\name MAG CONFIG REGISTERS  FOR ODR*/
+/******************************************************/
+#define BMI160_USER_MAG_CONFIG_ADDR				(0X44)
+/***************************************************/
+/**\name REGISTER FOR GYRO AND ACCEL DOWNSAMPLING RATES FOR FIFO*/
+/******************************************************/
+#define BMI160_USER_FIFO_DOWN_ADDR              (0X45)
+/***************************************************/
+/**\name FIFO CONFIG REGISTERS*/
+/******************************************************/
+#define BMI160_USER_FIFO_CONFIG_0_ADDR          (0X46)
+#define BMI160_USER_FIFO_CONFIG_1_ADDR          (0X47)
+/***************************************************/
+/**\name MAG INTERFACE REGISTERS*/
+/******************************************************/
+#define BMI160_USER_MAG_IF_0_ADDR				(0X4B)
+#define BMI160_USER_MAG_IF_1_ADDR				(0X4C)
+#define BMI160_USER_MAG_IF_2_ADDR				(0X4D)
+#define BMI160_USER_MAG_IF_3_ADDR				(0X4E)
+#define BMI160_USER_MAG_IF_4_ADDR				(0X4F)
+/***************************************************/
+/**\name INTERRUPT ENABLE REGISTERS*/
+/******************************************************/
+#define BMI160_USER_INTR_ENABLE_0_ADDR			(0X50)
+#define BMI160_USER_INTR_ENABLE_1_ADDR			(0X51)
+#define BMI160_USER_INTR_ENABLE_2_ADDR			(0X52)
+#define BMI160_USER_INTR_OUT_CTRL_ADDR			(0X53)
+/***************************************************/
+/**\name LATCH DURATION REGISTERS*/
+/******************************************************/
+#define BMI160_USER_INTR_LATCH_ADDR				(0X54)
+/***************************************************/
+/**\name MAP INTERRUPT 1 and 2 REGISTERS*/
+/******************************************************/
+#define BMI160_USER_INTR_MAP_0_ADDR				(0X55)
+#define BMI160_USER_INTR_MAP_1_ADDR				(0X56)
+#define BMI160_USER_INTR_MAP_2_ADDR				(0X57)
+/***************************************************/
+/**\name DATA SOURCE REGISTERS*/
+/******************************************************/
+#define BMI160_USER_INTR_DATA_0_ADDR			(0X58)
+#define BMI160_USER_INTR_DATA_1_ADDR			(0X59)
+/***************************************************/
+/**\name
+INTERRUPT THRESHOLD, HYSTERESIS, DURATION, MODE CONFIGURATION REGISTERS*/
+/******************************************************/
+#define BMI160_USER_INTR_LOWHIGH_0_ADDR			(0X5A)
+#define BMI160_USER_INTR_LOWHIGH_1_ADDR			(0X5B)
+#define BMI160_USER_INTR_LOWHIGH_2_ADDR			(0X5C)
+#define BMI160_USER_INTR_LOWHIGH_3_ADDR			(0X5D)
+#define BMI160_USER_INTR_LOWHIGH_4_ADDR			(0X5E)
+#define BMI160_USER_INTR_MOTION_0_ADDR			(0X5F)
+#define BMI160_USER_INTR_MOTION_1_ADDR			(0X60)
+#define BMI160_USER_INTR_MOTION_2_ADDR			(0X61)
+#define BMI160_USER_INTR_MOTION_3_ADDR			(0X62)
+#define BMI160_USER_INTR_TAP_0_ADDR				(0X63)
+#define BMI160_USER_INTR_TAP_1_ADDR				(0X64)
+#define BMI160_USER_INTR_ORIENT_0_ADDR			(0X65)
+#define BMI160_USER_INTR_ORIENT_1_ADDR			(0X66)
+#define BMI160_USER_INTR_FLAT_0_ADDR			(0X67)
+#define BMI160_USER_INTR_FLAT_1_ADDR			(0X68)
+/***************************************************/
+/**\name FAST OFFSET CONFIGURATION REGISTER*/
+/******************************************************/
+#define BMI160_USER_FOC_CONFIG_ADDR				(0X69)
+/***************************************************/
+/**\name MISCELLANEOUS CONFIGURATION REGISTER*/
+/******************************************************/
+#define BMI160_USER_CONFIG_ADDR					(0X6A)
+/***************************************************/
+/**\name SERIAL INTERFACE SETTINGS REGISTER*/
+/******************************************************/
+#define BMI160_USER_IF_CONFIG_ADDR				(0X6B)
+/***************************************************/
+/**\name GYRO POWER MODE TRIGGER REGISTER */
+/******************************************************/
+#define BMI160_USER_PMU_TRIGGER_ADDR			(0X6C)
+/***************************************************/
+/**\name SELF_TEST REGISTER*/
+/******************************************************/
+#define BMI160_USER_SELF_TEST_ADDR				(0X6D)
+/***************************************************/
+/**\name SPI,I2C SELECTION REGISTER*/
+/******************************************************/
+#define BMI160_USER_NV_CONFIG_ADDR				(0x70)
+/***************************************************/
+/**\name ACCEL AND GYRO OFFSET REGISTERS*/
+/******************************************************/
+#define BMI160_USER_OFFSET_0_ADDR				(0X71)
+#define BMI160_USER_OFFSET_1_ADDR				(0X72)
+#define BMI160_USER_OFFSET_2_ADDR				(0X73)
+#define BMI160_USER_OFFSET_3_ADDR				(0X74)
+#define BMI160_USER_OFFSET_4_ADDR				(0X75)
+#define BMI160_USER_OFFSET_5_ADDR				(0X76)
+#define BMI160_USER_OFFSET_6_ADDR				(0X77)
+/***************************************************/
+/**\name STEP COUNTER INTERRUPT REGISTERS*/
+/******************************************************/
+#define BMI160_USER_STEP_COUNT_0_ADDR			(0X78)
+#define BMI160_USER_STEP_COUNT_1_ADDR			(0X79)
+/***************************************************/
+/**\name STEP COUNTER CONFIGURATION REGISTERS*/
+/******************************************************/
+#define BMI160_USER_STEP_CONFIG_0_ADDR			(0X7A)
+#define BMI160_USER_STEP_CONFIG_1_ADDR			(0X7B)
+/***************************************************/
+/**\name COMMAND REGISTER*/
+/******************************************************/
+#define BMI160_CMD_COMMANDS_ADDR				(0X7E)
+/***************************************************/
+/**\name PAGE REGISTERS*/
+/******************************************************/
+#define BMI160_CMD_EXT_MODE_ADDR				(0X7F)
+#define BMI160_COM_C_TRIM_FIVE_ADDR				(0X05)
+
+/****************************************************/
+/**\name	SHIFT VALUE DEFINITION       */
+/***************************************************/
+#define BMI160_SHIFT_BIT_POSITION_BY_01_BIT      (1)
+#define BMI160_SHIFT_BIT_POSITION_BY_02_BITS     (2)
+#define BMI160_SHIFT_BIT_POSITION_BY_03_BITS     (3)
+#define BMI160_SHIFT_BIT_POSITION_BY_04_BITS     (4)
+#define BMI160_SHIFT_BIT_POSITION_BY_05_BITS     (5)
+#define BMI160_SHIFT_BIT_POSITION_BY_06_BITS     (6)
+#define BMI160_SHIFT_BIT_POSITION_BY_07_BITS     (7)
+#define BMI160_SHIFT_BIT_POSITION_BY_08_BITS     (8)
+#define BMI160_SHIFT_BIT_POSITION_BY_09_BITS     (9)
+#define BMI160_SHIFT_BIT_POSITION_BY_12_BITS     (12)
+#define BMI160_SHIFT_BIT_POSITION_BY_13_BITS     (13)
+#define BMI160_SHIFT_BIT_POSITION_BY_14_BITS     (14)
+#define BMI160_SHIFT_BIT_POSITION_BY_15_BITS     (15)
+#define BMI160_SHIFT_BIT_POSITION_BY_16_BITS     (16)
+
+/****************************************************/
+/**\name	 DEFINITIONS USED FOR YAMAHA-YAS532 */
+/***************************************************/
+#define YAS532_MAG_STATE_NORMAL				(0)
+#define YAS532_MAG_STATE_INIT_COIL			(1)
+#define YAS532_MAG_STATE_MEASURE_OFFSET		(2)
+#define YAS532_MAG_INITCOIL_TIMEOUT			(1000)
+#define YAS532_MAG_NOTRANS_POSITION			(3)
+#define YAS532_DEFAULT_SENSOR_DELAY			(50)
+#define YAS532_DATA_OVERFLOW				(8190)
+#define YAS532_DATA_UNDERFLOW				(0)
+#define YAS532_MAG_TEMPERATURE_LOG			(10)
+#define YAS532_TEMP20DEGREE_TYPICAL			(390)
+#define YAS532_VERSION_AC_COEF_X			(850)
+#define YAS532_VERSION_AC_COEF_Y1			(750)
+#define YAS532_VERSION_AC_COEF_Y2			(750)
+#define YAS532_DATA_CENTER					(4096)
+/****************************************************/
+/**\name	YAMAHA-YAS532 OFFSET DEFINITION */
+/***************************************************/
+static const s8 INVALID_OFFSET[] = {0x7f, 0x7f, 0x7f};
+#define set_vector(to, from) \
+	{int _l; for (_l = 0; _l < 3; _l++) (to)[_l] = (from)[_l]; }
+#define is_valid_offset(a) \
+	(((a)[0] <= 31) && ((a)[1] <= 31) && ((a)[2] <= 31) \
+		&& (-31 <= (a)[0]) && (-31 <= (a)[1]) && (-31 <= (a)[2]))
+
+/**************************************************/
+/**\name	YAS532 CALIB DATA DEFINITIONS  */
+/*************************************************/
+
+
+/* register address of YAS532*/
+#define BMI160_YAS532_TESTR1			(0x88)
+#define BMI160_YAS532_TESTR2			(0x89)
+#define BMI160_YAS532_RCOIL				(0x81)
+#define BMI160_YAS532_COMMAND_REGISTER	(0x82)
+#define BMI160_YAS532_DATA_REGISTER		(0xB0)
+/* calib data register definition*/
+#define BMI160_YAS532_CALIB_CX	        (0x90)
+#define BMI160_YAS532_CALIB_CY1	        (0x91)
+#define BMI160_YAS532_CALIB_CY2	        (0x92)
+#define BMI160_YAS532_CALIB1	        (0x93)
+#define BMI160_YAS532_CALIB2	        (0x94)
+#define BMI160_YAS532_CALIB3	        (0x95)
+#define BMI160_YAS532_CALIB4	        (0x96)
+#define BMI160_YAS532_CALIB5	        (0x97)
+#define BMI160_YAS532_CLAIB6	        (0x98)
+#define BMI160_YAS532_CALIB7	        (0x99)
+#define BMI160_YAS532_CALIB8	        (0x9A)
+#define BMI160_YAS532_CALIIB9	        (0x9B)
+#define BMI160_YAS532_CALIB10	        (0x9C)
+#define BMI160_YAS532_CALIB11	        (0x9D)
+/* offset definition */
+#define BMI160_YAS532_OFFSET_X	        (0x85)
+#define BMI160_YAS532_OFFSET_Y	        (0x86)
+#define BMI160_YAS532_OFFSET_Z	        (0x87)
+/* data to write register for yas532*/
+#define BMI160_YAS532_WRITE_TESTR1	    (0x00)
+#define BMI160_YAS532_WRITE_TESTR2	    (0x00)
+#define BMI160_YAS532_WRITE_RCOIL       (0x00)
+/**************************************************/
+/**\name	YAS537 DEFINITION  */
+/*************************************************/
+
+#define	YAS537_SRSTR_DATA		        (0x02)
+#define	YAS537_WRITE_A_D_CONVERTER		(0x03)
+#define	YAS537_WRITE_A_D_CONVERTER2		(0xF8)
+#define	YAS537_WRITE_FILTER             (0x08)
+#define	YAS537_WRITE_CONFR              (0x08)
+#define	YAS537_WRITE_TEMP_CALIB         (0xFF)
+#define	YAS537_SET_COMMAND_REGISTER     (0x01)
+
+/**************************************************/
+/**\name	YAS537 REGISTER DEFINITION  */
+/*************************************************/
+#define	YAS537_REG_SRSTR				(0x90)
+#define	YAS537_REG_CALR_C0				(0xC0)
+#define	YAS537_REG_CALR_C1				(0xC1)
+#define	YAS537_REG_CALR_C2				(0xC2)
+#define	YAS537_REG_CALR_C3				(0xC3)
+#define	YAS537_REG_CALR_C4				(0xC4)
+#define	YAS537_REG_CALR_C5				(0xC5)
+#define	YAS537_REG_CALR_C6				(0xC6)
+#define	YAS537_REG_CALR_C7				(0xC7)
+#define	YAS537_REG_CALR_C8				(0xC8)
+#define	YAS537_REG_CALR_C9				(0xC9)
+#define	YAS537_REG_CALR_CA				(0xCA)
+#define	YAS537_REG_CALR_CB				(0xCB)
+#define	YAS537_REG_CALR_CC				(0xCC)
+#define	YAS537_REG_CALR_CD				(0xCD)
+#define	YAS537_REG_CALR_CE				(0xCE)
+#define	YAS537_REG_CALR_CF				(0xCF)
+#define	YAS537_REG_CALR_DO				(0xD0)
+#define	YAS537_REG_MTCR					(0x93)
+#define	YAS537_REG_CONFR				(0x82)
+#define	BMI160_REG_YAS537_CMDR			(0x81)
+#define	YAS537_REG_OXR					(0x84)
+#define	YAS537_REG_AVRR					(0x87)
+#define	YAS537_REG_HCKR					(0x88)
+#define	YAS537_REG_LCKR					(0x89)
+#define	YAS537_REG_ADCCALR				(0x91)
+#define	YAS537_REG_ADCCALR_ONE			(0x92)
+#define	YAS537_REG_OCR					(0x9E)
+#define	YAS537_REG_TRMR			        (0x9F)
+#define	YAS537_REG_TEMPERATURE_0		(0xB0)
+#define	YAS537_REG_TEMPERATURE_1		(0xB1)
+#define	YAS537_REG_DATA_X_0				(0xB2)
+#define	YAS537_REG_DATA_X_1				(0xB3)
+#define	YAS537_REG_DATA_Y1_0			(0xB4)
+#define	YAS537_REG_DATA_Y1_1			(0xB5)
+#define	YAS537_REG_DATA_Y2_0			(0xB6)
+#define	YAS537_REG_DATA_Y2_1			(0xB7)
+#define YAS537_MAG_STATE_NORMAL			(0)
+#define YAS537_MAG_STATE_INIT_COIL		(1)
+#define YAS537_MAG_STATE_RECORD_DATA	(2)
+#define YAS537_DATA_UNDERFLOW			(0)
+#define YAS537_DATA_OVERFLOW			(16383)
+/****************************************************/
+/**\name	YAS537_set vector */
+/***************************************************/
+#define yas537_set_vector(to, from) \
+	{int _l; for (_l = 0; _l < 3; _l++) (to)[_l] = (from)[_l]; }
+
+#ifndef ABS
+#define ABS(a)		((a) > 0 ? (a) : -(a)) /*!< Absolute value */
+#endif
+/****************************************************/
+/**\name	AKM09911 AND AKM09912 DEFINITION */
+/***************************************************/
+#define AKM09912_SENSITIVITY_DIV	(256)
+#define AKM09912_SENSITIVITY		(128)
+#define AKM09911_SENSITIVITY_DIV	(128)
+#define AKM_ASAX	(0)
+#define AKM_ASAY	(1)
+#define AKM_ASAZ	(2)
+#define AKM_POWER_DOWN_MODE_DATA		(0x00)
+#define AKM_FUSE_ROM_MODE				(0x1F)
+#define AKM_POWER_MODE_REG				(0x31)
+#define	AKM_SINGLE_MEASUREMENT_MODE		(0x01)
+#define AKM_DATA_REGISTER				(0x11)
+/*! AKM09912 Register definition */
+#define AKM_CHIP_ID_REG			(0x01)
+/****************************************************/
+/**\name	BMM150 DEFINITION */
+/***************************************************/
+#define BMI160_BMM150_SET_POWER_CONTROL	(0x01)
+#define BMI160_BMM150_MAX_RETRY_WAKEUP	(5)
+#define BMI160_BMM150_POWER_ON			(0x01)
+#define BMI160_BMM150_POWER_OFF			(0x00)
+#define BMI160_BMM150_FORCE_MODE		(0x02)
+#define BMI160_BMM150_POWER_ON_SUCCESS	(0)
+#define BMI160_BMM150_POWER_ON_FAIL		((s8)-1)
+
+#define	BMI160_BMM150_DIG_X1			(0)
+#define	BMI160_BMM150_DIG_Y1			(1)
+#define	BMI160_BMM150_DIG_X2			(2)
+#define	BMI160_BMM150_DIG_Y3			(3)
+#define	BMI160_BMM150_DIG_XY1			(4)
+#define	BMI160_BMM150_DIG_XY2			(5)
+#define	BMI160_BMM150_DIG_Z1_LSB		(6)
+#define	BMI160_BMM150_DIG_Z1_MSB		(7)
+#define	BMI160_BMM150_DIG_Z2_LSB		(8)
+#define	BMI160_BMM150_DIG_Z2_MSB		(9)
+#define	BMI160_BMM150_DIG_DIG_Z3_LSB	(10)
+#define	BMI160_BMM150_DIG_DIG_Z3_MSB	(11)
+#define	BMI160_BMM150_DIG_DIG_Z4_LSB	(12)
+#define	BMI160_BMM150_DIG_DIG_Z4_MSB	(13)
+#define	BMI160_BMM150_DIG_DIG_XYZ1_LSB	(14)
+#define	BMI160_BMM150_DIG_DIG_XYZ1_MSB	(15)
+#define BMI160_FIFO_FRAME_CNT			(146)
+#define	BMI160_FRAME_COUNT				(1)
+
+/**************************************************************/
+/**\name	STRUCTURE DEFINITIONS                         */
+/**************************************************************/
+/*!
+*	@brief bmi160 structure
+*	This structure holds all relevant information about bmi160
+*/
+struct bmi160_t {
+u8 chip_id;/**< chip id of BMI160 */
+u8 dev_addr;/**< device address of BMI160 */
+s8 mag_manual_enable;/**< used for check the mag manual/auto mode status */
+BMI160_WR_FUNC_PTR;/**< bus write function pointer */
+BMI160_RD_FUNC_PTR;/**< bus read function pointer */
+BMI160_BRD_FUNC_PTR;/**< burst write function pointer */
+void (*delay_msec)(BMI160_MDELAY_DATA_TYPE);/**< delay function pointer */
+};
+/*!
+ * @brief Structure containing bmm150 and akm09911
+ *	magnetometer values for x,y and
+ *	z-axis in s16
+ */
+struct bmi160_mag_t {
+s32 x;/**< BMM150 and AKM09911 and AKM09912 X raw data*/
+s32 y;/**< BMM150 and AKM09911 and AKM09912 Y raw data*/
+s32 z;/**< BMM150 and AKM09911 and AKM09912 Z raw data*/
+};
+/*!
+ * @brief Structure containing bmm150 xyz data and temperature
+ */
+struct bmi160_mag_xyzr_t {
+s16 x;/**< BMM150 X raw data*/
+s16 y;/**< BMM150 Y raw data*/
+s16 z;/**<BMM150 Z raw data*/
+u16 r;/**<BMM150 R raw data*/
+};
+/*!
+ * @brief Structure containing gyro xyz data
+ */
+struct bmi160_gyro_t {
+s16 x;/**<gyro X  data*/
+s16 y;/**<gyro Y  data*/
+s16 z;/**<gyro Z  data*/
+};
+/*!
+ * @brief Structure containing accel xyz data
+ */
+struct bmi160_accel_t {
+s16 x;/**<accel X  data*/
+s16 y;/**<accel Y  data*/
+s16 z;/**<accel Z  data*/
+};
+/*!
+ * @brief Structure bmm150 mag compensated data with s32 output
+ */
+struct bmi160_mag_xyz_s32_t {
+s32 x;/**<BMM150 X compensated data*/
+s32 y;/**<BMM150 Y compensated data*/
+s32 z;/**<BMM150 Z compensated data*/
+};
+/*!
+ * @brief Structure bmm150 mag trim data
+ */
+struct trim_data_t {
+s8 dig_x1;/**<BMM150 trim x1 data*/
+s8 dig_y1;/**<BMM150 trim y1 data*/
+
+s8 dig_x2;/**<BMM150 trim x2 data*/
+s8 dig_y2;/**<BMM150 trim y2 data*/
+
+u16 dig_z1;/**<BMM150 trim z1 data*/
+s16 dig_z2;/**<BMM150 trim z2 data*/
+s16 dig_z3;/**<BMM150 trim z3 data*/
+s16 dig_z4;/**<BMM150 trim z4 data*/
+
+u8 dig_xy1;/**<BMM150 trim xy1 data*/
+s8 dig_xy2;/**<BMM150 trim xy2 data*/
+
+u16 dig_xyz1;/**<BMM150 trim xyz1 data*/
+};
+/*!
+ *	@brief Used to read the akm compensated values
+*/
+struct bmi160_bst_akm_xyz_t {
+s32 x;/**<AKM09911 and AKM09912 X compensated data*/
+s32 y;/**<AKM09911 and AKM09912 Y compensated data*/
+s32 z;/**<AKM09911 and AKM09912 Z compensated data*/
+};
+/*!
+*	@brief Structure for reading AKM compensating data
+*/
+struct bst_akm_sensitivity_data_t {
+u8 asax;/**<AKM09911 and AKM09912 X sensitivity data*/
+u8 asay;/**<AKM09911 and AKM09912 Y sensitivity data*/
+u8 asaz;/**<AKM09911 and AKM09912 Z sensitivity data*/
+};
+/*!
+* @brief YAMAHA-YAS532 struct
+* Calibration YAS532 data struct
+*/
+struct bst_yas532_calib_data_t {
+s32 cx;/**<YAS532 calib cx data */
+s32 cy1;/**<YAS532 calib cy1 data */
+s32 cy2;/**<YAS532 calib cy2 data */
+s32 a2;/**<YAS532 calib a2 data */
+s32 a3;/**<YAS532 calib a3 data */
+s32 a4;/**<YAS532 calib a4 data */
+s32 a5;/**<YAS532 calib a5 data */
+s32 a6;/**<YAS532 calib a6 data */
+s32 a7;/**<YAS532 calib a7 data */
+s32 a8;/**<YAS532 calib a8 data */
+s32 a9;/**<YAS532 calib a9 data */
+s32 k;/**<YAS532 calib k data */
+s8 rxy1y2[3];/**<YAS532 calib rxy1y2 data */
+u8 fxy1y2[3];/**<YAS532 calib fxy1y2 data */
+};
+/*!
+* @brief YAS532 Temperature structure
+*/
+#if 1 < YAS532_MAG_TEMPERATURE_LOG
+struct yas_temp_filter_t {
+u16 log[YAS532_MAG_TEMPERATURE_LOG];/**<YAS532 temp log array */
+u8 num;/**< used for increment the index */
+u8 idx;/**< used for increment the index */
+};
+#endif
+/*!
+* @brief YAS532 sensor initialization
+*/
+struct yas532_t {
+struct bst_yas532_calib_data_t calib_yas532;/**< calib data */
+s8 measure_state;/**< update measure state */
+s8 v_hard_offset_s8[3];/**< offset write array*/
+s32 coef[3];/**< co efficient data */
+s8 overflow;/**< over flow condition check */
+u8 dev_id;/**< device id information */
+const s8 *transform;/**< transform condition check  */
+#if 1 < YAS532_MAG_TEMPERATURE_LOG
+struct yas_temp_filter_t temp_data;/**< temp data */
+#endif
+u16 last_raw[4];/**< raw data */
+};
+/*!
+* @brief Used for reading the YAS532 XYZ data
+*/
+struct yas532_vector {
+s32 yas532_vector_xyz[3];/**< YAS532 compensated xyz data*/
+};
+/*!
+* @brief Used for reading the YAS532 XYZ data
+*/
+struct yas532_data {
+s32 x;
+s32 y;
+s32 z;
+};
+/**
+ * @struct yas_vector
+ * @brief Stores the sensor data
+ */
+struct yas_vector {
+	s32 yas537_vector_xyz[3]; /*!< vector data */
+};
+/*!
+* @brief YAMAHA-YAS532 struct
+* Calibration YAS532 data struct
+*/
+struct bst_yas537_calib_data_t {
+s8 a2;/**<YAS532 calib a2 data */
+s8 a3;/**<YAS532 calib a3 data */
+s8 a4;/**<YAS532 calib a4 data */
+s16 a5;/**<YAS532 calib a5 data */
+s8 a6;/**<YAS532 calib a6 data */
+s8 a7;/**<YAS532 calib a7 data */
+s8 a8;/**<YAS532 calib a8 data */
+s16 a9;/**<YAS532 calib a9 data */
+u8 k;/**<YAS532 calib k data */
+u8 ver;/**<YAS532 calib ver data*/
+};
+/*!
+* @brief YAS537 sensor initialization
+*/
+struct yas537_t {
+struct bst_yas537_calib_data_t calib_yas537;/**< calib data */
+s8 measure_state;/**< update measure state */
+s8 hard_offset[3];/**< offset write array*/
+u16 last_after_rcoil[3];/**< rcoil write array*/
+s32 coef[3];/**< co efficient data */
+s8 overflow;/**< over flow condition check */
+u8 dev_id;/**< device id information */
+u8 average;/**<average selection for offset configuration*/
+const s8 *transform;/**< transform condition check  */
+u16 last_raw[4];/**< raw data */
+struct yas_vector xyz; /*!< X, Y, Z measurement data of the sensor */
+};
+/*!
+* @brief FIFO used to store the FIFO header less data
+*/
+struct bmi160_fifo_data_header_less_t {
+
+struct bmi160_accel_t accel_fifo[BMI160_FIFO_FRAME_CNT];/**<
+Accel data of XYZ */
+struct bmi160_mag_t mag_fifo[BMI160_FIFO_FRAME_CNT];/**<
+Mag data of XYZ */
+struct bmi160_gyro_t gyro_fifo[BMI160_FIFO_FRAME_CNT];/**<
+Gyro data of XYZ */
+u8 accel_frame_count;/**< The total number of accel frame stored
+in the FIFO*/
+u8 gyro_frame_count;/**< The total number of gyro frame stored
+in the FIFO*/
+u8 mag_frame_count;/**< The total number of mag frame stored
+in the FIFO*/
+};
+/*!
+* @brief Struct used to store the FIFO header data
+*/
+struct bmi160_fifo_data_header_t {
+struct bmi160_accel_t accel_fifo[BMI160_FIFO_FRAME_CNT];/**<
+Accel data of XYZ */
+struct bmi160_mag_t mag_fifo[BMI160_FIFO_FRAME_CNT];/**<
+Mag data of XYZ */
+struct bmi160_gyro_t gyro_fifo[BMI160_FIFO_FRAME_CNT];/**<
+Gyro data of XYZ */
+u32 fifo_time;/**< Value of fifo time*/
+u8 skip_frame;/**< The value of skip frame information */
+u8 fifo_input_config_info; /**< FIFO input config info*/
+u8 accel_frame_count; /**< The total number of accel frame stored
+in the FIFO*/
+u8 gyro_frame_count; /**< The total number of gyro frame stored
+in the FIFO*/
+u8 mag_frame_count; /**< The total number of mag frame stored
+in the FIFO*/
+u8 fifo_header[BMI160_FIFO_FRAME_CNT]; /**< FIFO header info*/
+};
+/*!
+* @brief Struct used to store the FIFO mag data
+*/
+struct bmi160_mag_fifo_data_t {
+u8 mag_x_lsb;/**< The value of mag x LSB data*/
+u8 mag_x_msb;/**< The value of mag x MSB data*/
+u8 mag_y_lsb;/**< The value of mag y LSB data*/
+u8 mag_y_msb;/**< The value of mag y MSB data*/
+u8 mag_z_lsb;/**< The value of mag z LSB data*/
+u8 mag_z_msb;/**< The value of mag z MSB data*/
+u8 mag_r_y2_lsb;
+/**< The value of mag r for BMM150 Y2 for YAMAHA LSB data*/
+u8 mag_r_y2_msb;
+/**< The value of mag r for BMM150 Y2 for YAMAHA MSB data*/
+};
+
+/**************************************************************/
+/**\name	USER DATA REGISTERS DEFINITION START    */
+/**************************************************************/
+
+/**************************************************************/
+/**\name	CHIP ID LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Chip ID Description - Reg Addr --> (0x00), Bit --> 0...7 */
+#define BMI160_USER_CHIP_ID__POS             (0)
+#define BMI160_USER_CHIP_ID__MSK            (0xFF)
+#define BMI160_USER_CHIP_ID__LEN             (8)
+#define BMI160_USER_CHIP_ID__REG             (BMI160_USER_CHIP_ID_ADDR)
+/**************************************************************/
+/**\name	ERROR STATUS LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Error Description - Reg Addr --> (0x02), Bit --> 0 */
+#define BMI160_USER_ERR_STAT__POS               (0)
+#define BMI160_USER_ERR_STAT__LEN               (8)
+#define BMI160_USER_ERR_STAT__MSK               (0xFF)
+#define BMI160_USER_ERR_STAT__REG               (BMI160_USER_ERROR_ADDR)
+
+#define BMI160_USER_FATAL_ERR__POS               (0)
+#define BMI160_USER_FATAL_ERR__LEN               (1)
+#define BMI160_USER_FATAL_ERR__MSK               (0x01)
+#define BMI160_USER_FATAL_ERR__REG               (BMI160_USER_ERROR_ADDR)
+
+/* Error Description - Reg Addr --> (0x02), Bit --> 1...4 */
+#define BMI160_USER_ERR_CODE__POS               (1)
+#define BMI160_USER_ERR_CODE__LEN               (4)
+#define BMI160_USER_ERR_CODE__MSK               (0x1E)
+#define BMI160_USER_ERR_CODE__REG               (BMI160_USER_ERROR_ADDR)
+
+/* Error Description - Reg Addr --> (0x02), Bit --> 5 */
+#define BMI160_USER_I2C_FAIL_ERR__POS               (5)
+#define BMI160_USER_I2C_FAIL_ERR__LEN               (1)
+#define BMI160_USER_I2C_FAIL_ERR__MSK               (0x20)
+#define BMI160_USER_I2C_FAIL_ERR__REG               (BMI160_USER_ERROR_ADDR)
+
+/* Error Description - Reg Addr --> (0x02), Bit --> 6 */
+#define BMI160_USER_DROP_CMD_ERR__POS              (6)
+#define BMI160_USER_DROP_CMD_ERR__LEN              (1)
+#define BMI160_USER_DROP_CMD_ERR__MSK              (0x40)
+#define BMI160_USER_DROP_CMD_ERR__REG              (BMI160_USER_ERROR_ADDR)
+/**************************************************************/
+/**\name	MAG DATA READY LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Error Description - Reg Addr --> (0x02), Bit --> 7 */
+#define BMI160_USER_MAG_DADA_RDY_ERR__POS               (7)
+#define BMI160_USER_MAG_DADA_RDY_ERR__LEN               (1)
+#define BMI160_USER_MAG_DADA_RDY_ERR__MSK               (0x80)
+#define BMI160_USER_MAG_DADA_RDY_ERR__REG               (BMI160_USER_ERROR_ADDR)
+/**************************************************************/
+/**\name	MAG POWER MODE LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* PMU_Status Description of MAG - Reg Addr --> (0x03), Bit --> 1..0 */
+#define BMI160_USER_MAG_POWER_MODE_STAT__POS		(0)
+#define BMI160_USER_MAG_POWER_MODE_STAT__LEN		(2)
+#define BMI160_USER_MAG_POWER_MODE_STAT__MSK		(0x03)
+#define BMI160_USER_MAG_POWER_MODE_STAT__REG		\
+(BMI160_USER_PMU_STAT_ADDR)
+/**************************************************************/
+/**\name	GYRO POWER MODE LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* PMU_Status Description of GYRO - Reg Addr --> (0x03), Bit --> 3...2 */
+#define BMI160_USER_GYRO_POWER_MODE_STAT__POS               (2)
+#define BMI160_USER_GYRO_POWER_MODE_STAT__LEN               (2)
+#define BMI160_USER_GYRO_POWER_MODE_STAT__MSK               (0x0C)
+#define BMI160_USER_GYRO_POWER_MODE_STAT__REG		      \
+(BMI160_USER_PMU_STAT_ADDR)
+/**************************************************************/
+/**\name	ACCEL POWER MODE LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* PMU_Status Description of ACCEL - Reg Addr --> (0x03), Bit --> 5...4 */
+#define BMI160_USER_ACCEL_POWER_MODE_STAT__POS               (4)
+#define BMI160_USER_ACCEL_POWER_MODE_STAT__LEN               (2)
+#define BMI160_USER_ACCEL_POWER_MODE_STAT__MSK               (0x30)
+#define BMI160_USER_ACCEL_POWER_MODE_STAT__REG		    \
+(BMI160_USER_PMU_STAT_ADDR)
+/**************************************************************/
+/**\name	MAG DATA XYZ LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Mag_X(LSB) Description - Reg Addr --> (0x04), Bit --> 0...7 */
+#define BMI160_USER_DATA_0_MAG_X_LSB__POS           (0)
+#define BMI160_USER_DATA_0_MAG_X_LSB__LEN           (8)
+#define BMI160_USER_DATA_0_MAG_X_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_0_MAG_X_LSB__REG          (BMI160_USER_DATA_0_ADDR)
+
+/* Mag_X(LSB) Description - Reg Addr --> (0x04), Bit --> 3...7 */
+#define BMI160_USER_DATA_MAG_X_LSB__POS           (3)
+#define BMI160_USER_DATA_MAG_X_LSB__LEN           (5)
+#define BMI160_USER_DATA_MAG_X_LSB__MSK          (0xF8)
+#define BMI160_USER_DATA_MAG_X_LSB__REG          (BMI160_USER_DATA_0_ADDR)
+
+/* Mag_X(MSB) Description - Reg Addr --> (0x05), Bit --> 0...7 */
+#define BMI160_USER_DATA_1_MAG_X_MSB__POS           (0)
+#define BMI160_USER_DATA_1_MAG_X_MSB__LEN           (8)
+#define BMI160_USER_DATA_1_MAG_X_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_1_MAG_X_MSB__REG          (BMI160_USER_DATA_1_ADDR)
+
+/* Mag_Y(LSB) Description - Reg Addr --> (0x06), Bit --> 0...7 */
+#define BMI160_USER_DATA_2_MAG_Y_LSB__POS           (0)
+#define BMI160_USER_DATA_2_MAG_Y_LSB__LEN           (8)
+#define BMI160_USER_DATA_2_MAG_Y_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_2_MAG_Y_LSB__REG          (BMI160_USER_DATA_2_ADDR)
+
+/* Mag_Y(LSB) Description - Reg Addr --> (0x06), Bit --> 3...7 */
+#define BMI160_USER_DATA_MAG_Y_LSB__POS           (3)
+#define BMI160_USER_DATA_MAG_Y_LSB__LEN           (5)
+#define BMI160_USER_DATA_MAG_Y_LSB__MSK          (0xF8)
+#define BMI160_USER_DATA_MAG_Y_LSB__REG          (BMI160_USER_DATA_2_ADDR)
+
+/* Mag_Y(MSB) Description - Reg Addr --> (0x07), Bit --> 0...7 */
+#define BMI160_USER_DATA_3_MAG_Y_MSB__POS           (0)
+#define BMI160_USER_DATA_3_MAG_Y_MSB__LEN           (8)
+#define BMI160_USER_DATA_3_MAG_Y_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_3_MAG_Y_MSB__REG          (BMI160_USER_DATA_3_ADDR)
+
+/* Mag_Z(LSB) Description - Reg Addr --> (0x08), Bit --> 0...7 */
+#define BMI160_USER_DATA_4_MAG_Z_LSB__POS           (0)
+#define BMI160_USER_DATA_4_MAG_Z_LSB__LEN           (8)
+#define BMI160_USER_DATA_4_MAG_Z_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_4_MAG_Z_LSB__REG          (BMI160_USER_DATA_4_ADDR)
+
+/* Mag_X(LSB) Description - Reg Addr --> (0x08), Bit --> 3...7 */
+#define BMI160_USER_DATA_MAG_Z_LSB__POS           (1)
+#define BMI160_USER_DATA_MAG_Z_LSB__LEN           (7)
+#define BMI160_USER_DATA_MAG_Z_LSB__MSK          (0xFE)
+#define BMI160_USER_DATA_MAG_Z_LSB__REG          (BMI160_USER_DATA_4_ADDR)
+
+/* Mag_Z(MSB) Description - Reg Addr --> (0x09), Bit --> 0...7 */
+#define BMI160_USER_DATA_5_MAG_Z_MSB__POS           (0)
+#define BMI160_USER_DATA_5_MAG_Z_MSB__LEN           (8)
+#define BMI160_USER_DATA_5_MAG_Z_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_5_MAG_Z_MSB__REG          (BMI160_USER_DATA_5_ADDR)
+
+/* RHALL(LSB) Description - Reg Addr --> (0x0A), Bit --> 0...7 */
+#define BMI160_USER_DATA_6_RHALL_LSB__POS           (0)
+#define BMI160_USER_DATA_6_RHALL_LSB__LEN           (8)
+#define BMI160_USER_DATA_6_RHALL_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_6_RHALL_LSB__REG          (BMI160_USER_DATA_6_ADDR)
+
+/* Mag_R(LSB) Description - Reg Addr --> (0x0A), Bit --> 3...7 */
+#define BMI160_USER_DATA_MAG_R_LSB__POS           (2)
+#define BMI160_USER_DATA_MAG_R_LSB__LEN           (6)
+#define BMI160_USER_DATA_MAG_R_LSB__MSK          (0xFC)
+#define BMI160_USER_DATA_MAG_R_LSB__REG          (BMI160_USER_DATA_6_ADDR)
+
+/* RHALL(MSB) Description - Reg Addr --> (0x0B), Bit --> 0...7 */
+#define BMI160_USER_DATA_7_RHALL_MSB__POS           (0)
+#define BMI160_USER_DATA_7_RHALL_MSB__LEN           (8)
+#define BMI160_USER_DATA_7_RHALL_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_7_RHALL_MSB__REG          (BMI160_USER_DATA_7_ADDR)
+/**************************************************************/
+/**\name	GYRO DATA XYZ LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* GYR_X (LSB) Description - Reg Addr --> (0x0C), Bit --> 0...7 */
+#define BMI160_USER_DATA_8_GYRO_X_LSB__POS           (0)
+#define BMI160_USER_DATA_8_GYRO_X_LSB__LEN           (8)
+#define BMI160_USER_DATA_8_GYRO_X_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_8_GYRO_X_LSB__REG          (BMI160_USER_DATA_8_ADDR)
+
+/* GYR_X (MSB) Description - Reg Addr --> (0x0D), Bit --> 0...7 */
+#define BMI160_USER_DATA_9_GYRO_X_MSB__POS           (0)
+#define BMI160_USER_DATA_9_GYRO_X_MSB__LEN           (8)
+#define BMI160_USER_DATA_9_GYRO_X_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_9_GYRO_X_MSB__REG          (BMI160_USER_DATA_9_ADDR)
+
+/* GYR_Y (LSB) Description - Reg Addr --> 0x0E, Bit --> 0...7 */
+#define BMI160_USER_DATA_10_GYRO_Y_LSB__POS           (0)
+#define BMI160_USER_DATA_10_GYRO_Y_LSB__LEN           (8)
+#define BMI160_USER_DATA_10_GYRO_Y_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_10_GYRO_Y_LSB__REG          (BMI160_USER_DATA_10_ADDR)
+
+/* GYR_Y (MSB) Description - Reg Addr --> (0x0F), Bit --> 0...7 */
+#define BMI160_USER_DATA_11_GYRO_Y_MSB__POS           (0)
+#define BMI160_USER_DATA_11_GYRO_Y_MSB__LEN           (8)
+#define BMI160_USER_DATA_11_GYRO_Y_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_11_GYRO_Y_MSB__REG          (BMI160_USER_DATA_11_ADDR)
+
+/* GYR_Z (LSB) Description - Reg Addr --> (0x10), Bit --> 0...7 */
+#define BMI160_USER_DATA_12_GYRO_Z_LSB__POS           (0)
+#define BMI160_USER_DATA_12_GYRO_Z_LSB__LEN           (8)
+#define BMI160_USER_DATA_12_GYRO_Z_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_12_GYRO_Z_LSB__REG          (BMI160_USER_DATA_12_ADDR)
+
+/* GYR_Z (MSB) Description - Reg Addr --> (0x11), Bit --> 0...7 */
+#define BMI160_USER_DATA_13_GYRO_Z_MSB__POS           (0)
+#define BMI160_USER_DATA_13_GYRO_Z_MSB__LEN           (8)
+#define BMI160_USER_DATA_13_GYRO_Z_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_13_GYRO_Z_MSB__REG          (BMI160_USER_DATA_13_ADDR)
+/**************************************************************/
+/**\name	ACCEL DATA XYZ LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* ACC_X (LSB) Description - Reg Addr --> (0x12), Bit --> 0...7 */
+#define BMI160_USER_DATA_14_ACCEL_X_LSB__POS           (0)
+#define BMI160_USER_DATA_14_ACCEL_X_LSB__LEN           (8)
+#define BMI160_USER_DATA_14_ACCEL_X_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_14_ACCEL_X_LSB__REG          (BMI160_USER_DATA_14_ADDR)
+
+/* ACC_X (MSB) Description - Reg Addr --> 0x13, Bit --> 0...7 */
+#define BMI160_USER_DATA_15_ACCEL_X_MSB__POS           (0)
+#define BMI160_USER_DATA_15_ACCEL_X_MSB__LEN           (8)
+#define BMI160_USER_DATA_15_ACCEL_X_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_15_ACCEL_X_MSB__REG          (BMI160_USER_DATA_15_ADDR)
+
+/* ACC_Y (LSB) Description - Reg Addr --> (0x14), Bit --> 0...7 */
+#define BMI160_USER_DATA_16_ACCEL_Y_LSB__POS           (0)
+#define BMI160_USER_DATA_16_ACCEL_Y_LSB__LEN           (8)
+#define BMI160_USER_DATA_16_ACCEL_Y_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_16_ACCEL_Y_LSB__REG          (BMI160_USER_DATA_16_ADDR)
+
+/* ACC_Y (MSB) Description - Reg Addr --> (0x15), Bit --> 0...7 */
+#define BMI160_USER_DATA_17_ACCEL_Y_MSB__POS           (0)
+#define BMI160_USER_DATA_17_ACCEL_Y_MSB__LEN           (8)
+#define BMI160_USER_DATA_17_ACCEL_Y_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_17_ACCEL_Y_MSB__REG          (BMI160_USER_DATA_17_ADDR)
+
+/* ACC_Z (LSB) Description - Reg Addr --> 0x16, Bit --> 0...7 */
+#define BMI160_USER_DATA_18_ACCEL_Z_LSB__POS           (0)
+#define BMI160_USER_DATA_18_ACCEL_Z_LSB__LEN           (8)
+#define BMI160_USER_DATA_18_ACCEL_Z_LSB__MSK          (0xFF)
+#define BMI160_USER_DATA_18_ACCEL_Z_LSB__REG          (BMI160_USER_DATA_18_ADDR)
+
+/* ACC_Z (MSB) Description - Reg Addr --> (0x17), Bit --> 0...7 */
+#define BMI160_USER_DATA_19_ACCEL_Z_MSB__POS           (0)
+#define BMI160_USER_DATA_19_ACCEL_Z_MSB__LEN           (8)
+#define BMI160_USER_DATA_19_ACCEL_Z_MSB__MSK          (0xFF)
+#define BMI160_USER_DATA_19_ACCEL_Z_MSB__REG          (BMI160_USER_DATA_19_ADDR)
+/**************************************************************/
+/**\name	SENSOR TIME LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* SENSORTIME_0 (LSB) Description - Reg Addr --> (0x18), Bit --> 0...7 */
+#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__POS           (0)
+#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__LEN           (8)
+#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__MSK          (0xFF)
+#define BMI160_USER_SENSORTIME_0_SENSOR_TIME_LSB__REG          \
+		(BMI160_USER_SENSORTIME_0_ADDR)
+
+/* SENSORTIME_1 (MSB) Description - Reg Addr --> (0x19), Bit --> 0...7 */
+#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__POS           (0)
+#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__LEN           (8)
+#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__MSK          (0xFF)
+#define BMI160_USER_SENSORTIME_1_SENSOR_TIME_MSB__REG          \
+		(BMI160_USER_SENSORTIME_1_ADDR)
+
+/* SENSORTIME_2 (MSB) Description - Reg Addr --> (0x1A), Bit --> 0...7 */
+#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__POS           (0)
+#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__LEN           (8)
+#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__MSK          (0xFF)
+#define BMI160_USER_SENSORTIME_2_SENSOR_TIME_MSB__REG          \
+		(BMI160_USER_SENSORTIME_2_ADDR)
+/**************************************************************/
+/**\name	GYRO SELF TEST LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Status Description - Reg Addr --> 0x1B, Bit --> 1 */
+#define BMI160_USER_STAT_GYRO_SELFTEST_OK__POS          (1)
+#define BMI160_USER_STAT_GYRO_SELFTEST_OK__LEN          (1)
+#define BMI160_USER_STAT_GYRO_SELFTEST_OK__MSK          (0x02)
+#define BMI160_USER_STAT_GYRO_SELFTEST_OK__REG         \
+		(BMI160_USER_STAT_ADDR)
+/**************************************************************/
+/**\name	MAG MANUAL OPERATION LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Status Description - Reg Addr --> 0x1B, Bit --> 2 */
+#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__POS          (2)
+#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__LEN          (1)
+#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__MSK          (0x04)
+#define BMI160_USER_STAT_MAG_MANUAL_OPERATION__REG          \
+		(BMI160_USER_STAT_ADDR)
+/**************************************************************/
+/**\name	FOC STATUS LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Status Description - Reg Addr --> 0x1B, Bit --> 3 */
+#define BMI160_USER_STAT_FOC_RDY__POS          (3)
+#define BMI160_USER_STAT_FOC_RDY__LEN          (1)
+#define BMI160_USER_STAT_FOC_RDY__MSK          (0x08)
+#define BMI160_USER_STAT_FOC_RDY__REG          (BMI160_USER_STAT_ADDR)
+/**************************************************************/
+/**\name	NVM READY LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Status Description - Reg Addr --> 0x1B, Bit --> 4 */
+#define BMI160_USER_STAT_NVM_RDY__POS           (4)
+#define BMI160_USER_STAT_NVM_RDY__LEN           (1)
+#define BMI160_USER_STAT_NVM_RDY__MSK           (0x10)
+#define BMI160_USER_STAT_NVM_RDY__REG           (BMI160_USER_STAT_ADDR)
+/**************************************************************/
+/**\name	DATA READY LENGTH, POSITION AND MASK FOR ACCEL, MAG AND GYRO*/
+/**************************************************************/
+/* Status Description - Reg Addr --> 0x1B, Bit --> 5 */
+#define BMI160_USER_STAT_DATA_RDY_MAG__POS           (5)
+#define BMI160_USER_STAT_DATA_RDY_MAG__LEN           (1)
+#define BMI160_USER_STAT_DATA_RDY_MAG__MSK           (0x20)
+#define BMI160_USER_STAT_DATA_RDY_MAG__REG           (BMI160_USER_STAT_ADDR)
+
+/* Status Description - Reg Addr --> 0x1B, Bit --> 6 */
+#define BMI160_USER_STAT_DATA_RDY_GYRO__POS           (6)
+#define BMI160_USER_STAT_DATA_RDY_GYRO__LEN           (1)
+#define BMI160_USER_STAT_DATA_RDY_GYRO__MSK           (0x40)
+#define BMI160_USER_STAT_DATA_RDY_GYRO__REG           (BMI160_USER_STAT_ADDR)
+
+/* Status Description - Reg Addr --> 0x1B, Bit --> 7 */
+#define BMI160_USER_STAT_DATA_RDY_ACCEL__POS           (7)
+#define BMI160_USER_STAT_DATA_RDY_ACCEL__LEN           (1)
+#define BMI160_USER_STAT_DATA_RDY_ACCEL__MSK           (0x80)
+#define BMI160_USER_STAT_DATA_RDY_ACCEL__REG           (BMI160_USER_STAT_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT STATUS LENGTH, POSITION AND MASK    */
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 0 */
+#define BMI160_USER_INTR_STAT_0_STEP_INTR__POS           (0)
+#define BMI160_USER_INTR_STAT_0_STEP_INTR__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_STEP_INTR__MSK          (0x01)
+#define BMI160_USER_INTR_STAT_0_STEP_INTR__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	SIGNIFICANT INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 1 */
+#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__POS		(1)
+#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__LEN		(1)
+#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__MSK		(0x02)
+#define BMI160_USER_INTR_STAT_0_SIGNIFICANT_INTR__REG       \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	ANY_MOTION INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 2 */
+#define BMI160_USER_INTR_STAT_0_ANY_MOTION__POS           (2)
+#define BMI160_USER_INTR_STAT_0_ANY_MOTION__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_ANY_MOTION__MSK          (0x04)
+#define BMI160_USER_INTR_STAT_0_ANY_MOTION__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	PMU TRIGGER INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 3 */
+#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__POS           3
+#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__MSK          (0x08)
+#define BMI160_USER_INTR_STAT_0_PMU_TRIGGER__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	DOUBLE TAP INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 4 */
+#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__POS           4
+#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__MSK          (0x10)
+#define BMI160_USER_INTR_STAT_0_DOUBLE_TAP_INTR__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	SINGLE TAP INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 5 */
+#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__POS           5
+#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__MSK          (0x20)
+#define BMI160_USER_INTR_STAT_0_SINGLE_TAP_INTR__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	ORIENT INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 6 */
+#define BMI160_USER_INTR_STAT_0_ORIENT__POS           (6)
+#define BMI160_USER_INTR_STAT_0_ORIENT__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_ORIENT__MSK          (0x40)
+#define BMI160_USER_INTR_STAT_0_ORIENT__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	FLAT INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_0 Description - Reg Addr --> 0x1C, Bit --> 7 */
+#define BMI160_USER_INTR_STAT_0_FLAT__POS           (7)
+#define BMI160_USER_INTR_STAT_0_FLAT__LEN           (1)
+#define BMI160_USER_INTR_STAT_0_FLAT__MSK          (0x80)
+#define BMI160_USER_INTR_STAT_0_FLAT__REG          \
+		(BMI160_USER_INTR_STAT_0_ADDR)
+/**************************************************************/
+/**\name	HIGH_G INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 2 */
+#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__POS               (2)
+#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__LEN               (1)
+#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__MSK              (0x04)
+#define BMI160_USER_INTR_STAT_1_HIGH_G_INTR__REG              \
+		(BMI160_USER_INTR_STAT_1_ADDR)
+/**************************************************************/
+/**\name	LOW_G INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 3 */
+#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__POS               (3)
+#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__LEN               (1)
+#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__MSK              (0x08)
+#define BMI160_USER_INTR_STAT_1_LOW_G_INTR__REG              \
+		(BMI160_USER_INTR_STAT_1_ADDR)
+/**************************************************************/
+/**\name	DATA READY INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 4 */
+#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__POS               (4)
+#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__LEN               (1)
+#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__MSK               (0x10)
+#define BMI160_USER_INTR_STAT_1_DATA_RDY_INTR__REG               \
+		(BMI160_USER_INTR_STAT_1_ADDR)
+/**************************************************************/
+/**\name	FIFO FULL INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 5 */
+#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__POS               (5)
+#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__LEN               (1)
+#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__MSK               (0x20)
+#define BMI160_USER_INTR_STAT_1_FIFO_FULL_INTR__REG               \
+		(BMI160_USER_INTR_STAT_1_ADDR)
+/**************************************************************/
+/**\name FIFO WATERMARK INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 6 */
+#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__POS               (6)
+#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__LEN               (1)
+#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__MSK               (0x40)
+#define BMI160_USER_INTR_STAT_1_FIFO_WM_INTR__REG               \
+		(BMI160_USER_INTR_STAT_1_ADDR)
+/**************************************************************/
+/**\name	NO MOTION INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_1 Description - Reg Addr --> 0x1D, Bit --> 7 */
+#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__POS               (7)
+#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__LEN               (1)
+#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__MSK               (0x80)
+#define BMI160_USER_INTR_STAT_1_NOMOTION_INTR__REG               \
+		(BMI160_USER_INTR_STAT_1_ADDR)
+/**************************************************************/
+/**\name	ANY MOTION-XYZ AXIS INTERRUPT STATUS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 0 */
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__POS               (0)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__MSK               (0x01)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_X__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 1 */
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__POS               (1)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__MSK               (0x02)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Y__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 2 */
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__POS               (2)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__MSK               (0x04)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_FIRST_Z__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+/**************************************************************/
+/**\name	ANY MOTION SIGN LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 3 */
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__POS               (3)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__MSK               (0x08)
+#define BMI160_USER_INTR_STAT_2_ANY_MOTION_SIGN__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+/**************************************************************/
+/**\name	TAP_XYZ AND SIGN LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 4 */
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__POS               (4)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__MSK               (0x10)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_X__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 5 */
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__POS               (5)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__MSK               (0x20)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Y__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 6 */
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__POS               (6)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__MSK               (0x40)
+#define BMI160_USER_INTR_STAT_2_TAP_FIRST_Z__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 7 */
+#define BMI160_USER_INTR_STAT_2_TAP_SIGN__POS               (7)
+#define BMI160_USER_INTR_STAT_2_TAP_SIGN__LEN               (1)
+#define BMI160_USER_INTR_STAT_2_TAP_SIGN__MSK               (0x80)
+#define BMI160_USER_INTR_STAT_2_TAP_SIGN__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT SATAUS FOR WHOLE 0x1E LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_2 Description - Reg Addr --> 0x1E, Bit --> 0...7 */
+#define BMI160_USER_INTR_STAT_2__POS               (0)
+#define BMI160_USER_INTR_STAT_2__LEN               (8)
+#define BMI160_USER_INTR_STAT_2__MSK               (0xFF)
+#define BMI160_USER_INTR_STAT_2__REG               \
+		(BMI160_USER_INTR_STAT_2_ADDR)
+/**************************************************************/
+/**\name	HIGH_G-XYZ AND SIGN LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 0 */
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__POS               (0)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__LEN               (1)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__MSK               (0x01)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_X__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+
+/* Int_Status_3 Description - Reg Addr --> 0x1E, Bit --> 1 */
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__POS               (1)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__LEN               (1)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__MSK               (0x02)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Y__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 2 */
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__POS               (2)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__LEN               (1)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__MSK               (0x04)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_FIRST_Z__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 3 */
+#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__POS               (3)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__LEN               (1)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__MSK               (0x08)
+#define BMI160_USER_INTR_STAT_3_HIGH_G_SIGN__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+/**************************************************************/
+/**\name	ORIENT XY and Z AXIS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 4...5 */
+#define BMI160_USER_INTR_STAT_3_ORIENT_XY__POS               (4)
+#define BMI160_USER_INTR_STAT_3_ORIENT_XY__LEN               (2)
+#define BMI160_USER_INTR_STAT_3_ORIENT_XY__MSK               (0x30)
+#define BMI160_USER_INTR_STAT_3_ORIENT_XY__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 6 */
+#define BMI160_USER_INTR_STAT_3_ORIENT_Z__POS               (6)
+#define BMI160_USER_INTR_STAT_3_ORIENT_Z__LEN               (1)
+#define BMI160_USER_INTR_STAT_3_ORIENT_Z__MSK               (0x40)
+#define BMI160_USER_INTR_STAT_3_ORIENT_Z__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+/**************************************************************/
+/**\name	FLAT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 7 */
+#define BMI160_USER_INTR_STAT_3_FLAT__POS               (7)
+#define BMI160_USER_INTR_STAT_3_FLAT__LEN               (1)
+#define BMI160_USER_INTR_STAT_3_FLAT__MSK               (0x80)
+#define BMI160_USER_INTR_STAT_3_FLAT__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+/**************************************************************/
+/**\name	(0x1F) LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Status_3 Description - Reg Addr --> (0x1F), Bit --> 0...7 */
+#define BMI160_USER_INTR_STAT_3__POS               (0)
+#define BMI160_USER_INTR_STAT_3__LEN               (8)
+#define BMI160_USER_INTR_STAT_3__MSK               (0xFF)
+#define BMI160_USER_INTR_STAT_3__REG               \
+		(BMI160_USER_INTR_STAT_3_ADDR)
+/**************************************************************/
+/**\name	TEMPERATURE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Temperature Description - LSB Reg Addr --> (0x20), Bit --> 0...7 */
+#define BMI160_USER_TEMP_LSB_VALUE__POS               (0)
+#define BMI160_USER_TEMP_LSB_VALUE__LEN               (8)
+#define BMI160_USER_TEMP_LSB_VALUE__MSK               (0xFF)
+#define BMI160_USER_TEMP_LSB_VALUE__REG               \
+		(BMI160_USER_TEMPERATURE_0_ADDR)
+
+/* Temperature Description - LSB Reg Addr --> 0x21, Bit --> 0...7 */
+#define BMI160_USER_TEMP_MSB_VALUE__POS               (0)
+#define BMI160_USER_TEMP_MSB_VALUE__LEN               (8)
+#define BMI160_USER_TEMP_MSB_VALUE__MSK               (0xFF)
+#define BMI160_USER_TEMP_MSB_VALUE__REG               \
+		(BMI160_USER_TEMPERATURE_1_ADDR)
+/**************************************************************/
+/**\name	FIFO BYTE COUNTER LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Length0 Description - Reg Addr --> 0x22, Bit --> 0...7 */
+#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__POS           (0)
+#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__LEN           (8)
+#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__MSK          (0xFF)
+#define BMI160_USER_FIFO_BYTE_COUNTER_LSB__REG          \
+		(BMI160_USER_FIFO_LENGTH_0_ADDR)
+
+/*Fifo_Length1 Description - Reg Addr --> 0x23, Bit --> 0...2 */
+#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__POS           (0)
+#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__LEN           3
+#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__MSK          (0x07)
+#define BMI160_USER_FIFO_BYTE_COUNTER_MSB__REG          \
+		(BMI160_USER_FIFO_LENGTH_1_ADDR)
+
+/**************************************************************/
+/**\name	FIFO DATA LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Data Description - Reg Addr --> 0x24, Bit --> 0...7 */
+#define BMI160_USER_FIFO_DATA__POS           (0)
+#define BMI160_USER_FIFO_DATA__LEN           (8)
+#define BMI160_USER_FIFO_DATA__MSK          (0xFF)
+#define BMI160_USER_FIFO_DATA__REG          (BMI160_USER_FIFO_DATA_ADDR)
+
+/**************************************************************/
+/**\name	ACCEL CONFIGURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Acc_Conf Description - Reg Addr --> (0x40), Bit --> 0...3 */
+#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__POS               (0)
+#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__LEN               (4)
+#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__MSK               (0x0F)
+#define BMI160_USER_ACCEL_CONFIG_OUTPUT_DATA_RATE__REG		       \
+(BMI160_USER_ACCEL_CONFIG_ADDR)
+
+/* Acc_Conf Description - Reg Addr --> (0x40), Bit --> 4...6 */
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__POS               (4)
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__LEN               (3)
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__MSK               (0x70)
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_BW__REG	(BMI160_USER_ACCEL_CONFIG_ADDR)
+
+/* Acc_Conf Description - Reg Addr --> (0x40), Bit --> 7 */
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__POS           (7)
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__LEN           (1)
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__MSK           (0x80)
+#define BMI160_USER_ACCEL_CONFIG_ACCEL_UNDER_SAMPLING__REG	\
+(BMI160_USER_ACCEL_CONFIG_ADDR)
+
+/* Acc_Range Description - Reg Addr --> 0x41, Bit --> 0...3 */
+#define BMI160_USER_ACCEL_RANGE__POS               (0)
+#define BMI160_USER_ACCEL_RANGE__LEN               (4)
+#define BMI160_USER_ACCEL_RANGE__MSK               (0x0F)
+#define BMI160_USER_ACCEL_RANGE__REG              \
+(BMI160_USER_ACCEL_RANGE_ADDR)
+/**************************************************************/
+/**\name	GYRO CONFIGURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Gyro_Conf Description - Reg Addr --> (0x42), Bit --> 0...3 */
+#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__POS               (0)
+#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__LEN               (4)
+#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__MSK               (0x0F)
+#define BMI160_USER_GYRO_CONFIG_OUTPUT_DATA_RATE__REG               \
+(BMI160_USER_GYRO_CONFIG_ADDR)
+
+/* Gyro_Conf Description - Reg Addr --> (0x42), Bit --> 4...5 */
+#define BMI160_USER_GYRO_CONFIG_BW__POS               (4)
+#define BMI160_USER_GYRO_CONFIG_BW__LEN               (2)
+#define BMI160_USER_GYRO_CONFIG_BW__MSK               (0x30)
+#define BMI160_USER_GYRO_CONFIG_BW__REG               \
+(BMI160_USER_GYRO_CONFIG_ADDR)
+
+/* Gyr_Range Description - Reg Addr --> 0x43, Bit --> 0...2 */
+#define BMI160_USER_GYRO_RANGE__POS               (0)
+#define BMI160_USER_GYRO_RANGE__LEN               (3)
+#define BMI160_USER_GYRO_RANGE__MSK               (0x07)
+#define BMI160_USER_GYRO_RANGE__REG               (BMI160_USER_GYRO_RANGE_ADDR)
+/**************************************************************/
+/**\name	MAG CONFIGURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Mag_Conf Description - Reg Addr --> (0x44), Bit --> 0...3 */
+#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__POS               (0)
+#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__LEN               (4)
+#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__MSK               (0x0F)
+#define BMI160_USER_MAG_CONFIG_OUTPUT_DATA_RATE__REG               \
+(BMI160_USER_MAG_CONFIG_ADDR)
+/**************************************************************/
+/**\name	FIFO DOWNS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Downs Description - Reg Addr --> 0x45, Bit --> 0...2 */
+#define BMI160_USER_FIFO_DOWN_GYRO__POS               (0)
+#define BMI160_USER_FIFO_DOWN_GYRO__LEN               (3)
+#define BMI160_USER_FIFO_DOWN_GYRO__MSK               (0x07)
+#define BMI160_USER_FIFO_DOWN_GYRO__REG	(BMI160_USER_FIFO_DOWN_ADDR)
+/**************************************************************/
+/**\name	FIFO FILTER FOR ACCEL AND GYRO LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_filt Description - Reg Addr --> 0x45, Bit --> 3 */
+#define BMI160_USER_FIFO_FILTER_GYRO__POS               (3)
+#define BMI160_USER_FIFO_FILTER_GYRO__LEN               (1)
+#define BMI160_USER_FIFO_FILTER_GYRO__MSK               (0x08)
+#define BMI160_USER_FIFO_FILTER_GYRO__REG	  (BMI160_USER_FIFO_DOWN_ADDR)
+
+/* Fifo_Downs Description - Reg Addr --> 0x45, Bit --> 4...6 */
+#define BMI160_USER_FIFO_DOWN_ACCEL__POS               (4)
+#define BMI160_USER_FIFO_DOWN_ACCEL__LEN               (3)
+#define BMI160_USER_FIFO_DOWN_ACCEL__MSK               (0x70)
+#define BMI160_USER_FIFO_DOWN_ACCEL__REG	(BMI160_USER_FIFO_DOWN_ADDR)
+
+/* Fifo_FILT Description - Reg Addr --> 0x45, Bit --> 7 */
+#define BMI160_USER_FIFO_FILTER_ACCEL__POS               (7)
+#define BMI160_USER_FIFO_FILTER_ACCEL__LEN               (1)
+#define BMI160_USER_FIFO_FILTER_ACCEL__MSK               (0x80)
+#define BMI160_USER_FIFO_FILTER_ACCEL__REG	(BMI160_USER_FIFO_DOWN_ADDR)
+/**************************************************************/
+/**\name	FIFO WATER MARK LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_0 Description - Reg Addr --> 0x46, Bit --> 0...7 */
+#define BMI160_USER_FIFO_WM__POS               (0)
+#define BMI160_USER_FIFO_WM__LEN               (8)
+#define BMI160_USER_FIFO_WM__MSK               (0xFF)
+#define BMI160_USER_FIFO_WM__REG	(BMI160_USER_FIFO_CONFIG_0_ADDR)
+/**************************************************************/
+/**\name	FIFO TIME LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 1 */
+#define BMI160_USER_FIFO_TIME_ENABLE__POS               (1)
+#define BMI160_USER_FIFO_TIME_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_TIME_ENABLE__MSK               (0x02)
+#define BMI160_USER_FIFO_TIME_ENABLE__REG	(BMI160_USER_FIFO_CONFIG_1_ADDR)
+/**************************************************************/
+/**\name	FIFO TAG INTERRUPT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 2 */
+#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__POS               (2)
+#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__MSK               (0x04)
+#define BMI160_USER_FIFO_TAG_INTR2_ENABLE__REG	(BMI160_USER_FIFO_CONFIG_1_ADDR)
+
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 3 */
+#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__POS               (3)
+#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__MSK               (0x08)
+#define BMI160_USER_FIFO_TAG_INTR1_ENABLE__REG	(BMI160_USER_FIFO_CONFIG_1_ADDR)
+/**************************************************************/
+/**\name	FIFO HEADER LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 4 */
+#define BMI160_USER_FIFO_HEADER_ENABLE__POS               (4)
+#define BMI160_USER_FIFO_HEADER_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_HEADER_ENABLE__MSK               (0x10)
+#define BMI160_USER_FIFO_HEADER_ENABLE__REG		         \
+(BMI160_USER_FIFO_CONFIG_1_ADDR)
+/**************************************************************/
+/**\name	FIFO MAG ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 5 */
+#define BMI160_USER_FIFO_MAG_ENABLE__POS               (5)
+#define BMI160_USER_FIFO_MAG_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_MAG_ENABLE__MSK               (0x20)
+#define BMI160_USER_FIFO_MAG_ENABLE__REG		     \
+(BMI160_USER_FIFO_CONFIG_1_ADDR)
+/**************************************************************/
+/**\name	FIFO ACCEL ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 6 */
+#define BMI160_USER_FIFO_ACCEL_ENABLE__POS               (6)
+#define BMI160_USER_FIFO_ACCEL_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_ACCEL_ENABLE__MSK               (0x40)
+#define BMI160_USER_FIFO_ACCEL_ENABLE__REG		        \
+(BMI160_USER_FIFO_CONFIG_1_ADDR)
+/**************************************************************/
+/**\name	FIFO GYRO ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Fifo_Config_1 Description - Reg Addr --> 0x47, Bit --> 7 */
+#define BMI160_USER_FIFO_GYRO_ENABLE__POS               (7)
+#define BMI160_USER_FIFO_GYRO_ENABLE__LEN               (1)
+#define BMI160_USER_FIFO_GYRO_ENABLE__MSK               (0x80)
+#define BMI160_USER_FIFO_GYRO_ENABLE__REG		       \
+(BMI160_USER_FIFO_CONFIG_1_ADDR)
+
+/**************************************************************/
+/**\name	MAG I2C ADDRESS SELECTION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+
+/* Mag_IF_0 Description - Reg Addr --> 0x4b, Bit --> 1...7 */
+#define BMI160_USER_I2C_DEVICE_ADDR__POS               (1)
+#define BMI160_USER_I2C_DEVICE_ADDR__LEN               (7)
+#define BMI160_USER_I2C_DEVICE_ADDR__MSK               (0xFE)
+#define BMI160_USER_I2C_DEVICE_ADDR__REG	(BMI160_USER_MAG_IF_0_ADDR)
+/**************************************************************/
+/**\name MAG CONFIGURATION FOR SECONDARY
+	INTERFACE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Mag_IF_1 Description - Reg Addr --> 0x4c, Bit --> 0...1 */
+#define BMI160_USER_MAG_BURST__POS               (0)
+#define BMI160_USER_MAG_BURST__LEN               (2)
+#define BMI160_USER_MAG_BURST__MSK               (0x03)
+#define BMI160_USER_MAG_BURST__REG               (BMI160_USER_MAG_IF_1_ADDR)
+
+/* Mag_IF_1 Description - Reg Addr --> 0x4c, Bit --> 2...5 */
+#define BMI160_USER_MAG_OFFSET__POS               (2)
+#define BMI160_USER_MAG_OFFSET__LEN               (4)
+#define BMI160_USER_MAG_OFFSET__MSK               (0x3C)
+#define BMI160_USER_MAG_OFFSET__REG               (BMI160_USER_MAG_IF_1_ADDR)
+
+/* Mag_IF_1 Description - Reg Addr --> 0x4c, Bit --> 7 */
+#define BMI160_USER_MAG_MANUAL_ENABLE__POS               (7)
+#define BMI160_USER_MAG_MANUAL_ENABLE__LEN               (1)
+#define BMI160_USER_MAG_MANUAL_ENABLE__MSK               (0x80)
+#define BMI160_USER_MAG_MANUAL_ENABLE__REG               \
+(BMI160_USER_MAG_IF_1_ADDR)
+
+/* Mag_IF_2 Description - Reg Addr --> 0x4d, Bit -->0... 7 */
+#define BMI160_USER_READ_ADDR__POS               (0)
+#define BMI160_USER_READ_ADDR__LEN               (8)
+#define BMI160_USER_READ_ADDR__MSK               (0xFF)
+#define BMI160_USER_READ_ADDR__REG               (BMI160_USER_MAG_IF_2_ADDR)
+
+/* Mag_IF_3 Description - Reg Addr --> 0x4e, Bit -->0... 7 */
+#define BMI160_USER_WRITE_ADDR__POS               (0)
+#define BMI160_USER_WRITE_ADDR__LEN               (8)
+#define BMI160_USER_WRITE_ADDR__MSK               (0xFF)
+#define BMI160_USER_WRITE_ADDR__REG               (BMI160_USER_MAG_IF_3_ADDR)
+
+/* Mag_IF_4 Description - Reg Addr --> 0x4f, Bit -->0... 7 */
+#define BMI160_USER_WRITE_DATA__POS               (0)
+#define BMI160_USER_WRITE_DATA__LEN               (8)
+#define BMI160_USER_WRITE_DATA__MSK               (0xFF)
+#define BMI160_USER_WRITE_DATA__REG               (BMI160_USER_MAG_IF_4_ADDR)
+/**************************************************************/
+/**\name	ANY MOTION XYZ AXIS ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->0 */
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__POS               (0)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__MSK               (0x01)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_X_ENABLE__REG	              \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->1 */
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__POS               (1)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__MSK               (0x02)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Y_ENABLE__REG	          \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->2 */
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__POS               (2)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__MSK               (0x04)
+#define BMI160_USER_INTR_ENABLE_0_ANY_MOTION_Z_ENABLE__REG	            \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+/**************************************************************/
+/**\name	DOUBLE TAP ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->4 */
+#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__POS               (4)
+#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__MSK               (0x10)
+#define BMI160_USER_INTR_ENABLE_0_DOUBLE_TAP_ENABLE__REG	        \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+/**************************************************************/
+/**\name	SINGLE TAP ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->5 */
+#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__POS               (5)
+#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__MSK               (0x20)
+#define BMI160_USER_INTR_ENABLE_0_SINGLE_TAP_ENABLE__REG	       \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+/**************************************************************/
+/**\name	ORIENT ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->6 */
+#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__POS               (6)
+#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__MSK               (0x40)
+#define BMI160_USER_INTR_ENABLE_0_ORIENT_ENABLE__REG	           \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+/**************************************************************/
+/**\name	FLAT ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_0 Description - Reg Addr --> 0x50, Bit -->7 */
+#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__POS               (7)
+#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__MSK               (0x80)
+#define BMI160_USER_INTR_ENABLE_0_FLAT_ENABLE__REG	           \
+(BMI160_USER_INTR_ENABLE_0_ADDR)
+/**************************************************************/
+/**\name	HIGH_G XYZ ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->0 */
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__POS               (0)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__MSK               (0x01)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_X_ENABLE__REG	           \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->1 */
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__POS               (1)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__MSK               (0x02)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Y_ENABLE__REG	           \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->2 */
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__POS               (2)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__MSK               (0x04)
+#define BMI160_USER_INTR_ENABLE_1_HIGH_G_Z_ENABLE__REG	           \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+/**************************************************************/
+/**\name	LOW_G ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->3 */
+#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__POS               (3)
+#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__MSK               (0x08)
+#define BMI160_USER_INTR_ENABLE_1_LOW_G_ENABLE__REG	          \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+/**************************************************************/
+/**\name	DATA READY ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->4 */
+#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__POS               (4)
+#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__MSK               (0x10)
+#define BMI160_USER_INTR_ENABLE_1_DATA_RDY_ENABLE__REG	            \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+/**************************************************************/
+/**\name	FIFO FULL AND WATER MARK ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->5 */
+#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__POS               (5)
+#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__MSK               (0x20)
+#define BMI160_USER_INTR_ENABLE_1_FIFO_FULL_ENABLE__REG	              \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+
+/* Int_En_1 Description - Reg Addr --> (0x51), Bit -->6 */
+#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__POS               (6)
+#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__MSK               (0x40)
+#define BMI160_USER_INTR_ENABLE_1_FIFO_WM_ENABLE__REG	           \
+(BMI160_USER_INTR_ENABLE_1_ADDR)
+/**************************************************************/
+/**\name	NO MOTION XYZ ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->0 */
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__POS               (0)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__MSK               (0x01)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_X_ENABLE__REG	  \
+(BMI160_USER_INTR_ENABLE_2_ADDR)
+
+/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->1 */
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__POS               (1)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__MSK               (0x02)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Y_ENABLE__REG	  \
+(BMI160_USER_INTR_ENABLE_2_ADDR)
+
+/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->2 */
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__POS               (2)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__MSK               (0x04)
+#define BMI160_USER_INTR_ENABLE_2_NOMOTION_Z_ENABLE__REG	  \
+(BMI160_USER_INTR_ENABLE_2_ADDR)
+/**************************************************************/
+/**\name	STEP DETECTOR ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_En_2 Description - Reg Addr --> (0x52), Bit -->3 */
+#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__POS               (3)
+#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__LEN               (1)
+#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__MSK               (0x08)
+#define BMI160_USER_INTR_ENABLE_2_STEP_DETECTOR_ENABLE__REG	  \
+(BMI160_USER_INTR_ENABLE_2_ADDR)
+/**************************************************************/
+/**\name	EDGE CONTROL ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->0 */
+#define BMI160_USER_INTR1_EDGE_CTRL__POS               (0)
+#define BMI160_USER_INTR1_EDGE_CTRL__LEN               (1)
+#define BMI160_USER_INTR1_EDGE_CTRL__MSK               (0x01)
+#define BMI160_USER_INTR1_EDGE_CTRL__REG		\
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	LEVEL CONTROL ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->1 */
+#define BMI160_USER_INTR1_LEVEL__POS               (1)
+#define BMI160_USER_INTR1_LEVEL__LEN               (1)
+#define BMI160_USER_INTR1_LEVEL__MSK               (0x02)
+#define BMI160_USER_INTR1_LEVEL__REG               \
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	OUTPUT TYPE ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->2 */
+#define BMI160_USER_INTR1_OUTPUT_TYPE__POS               (2)
+#define BMI160_USER_INTR1_OUTPUT_TYPE__LEN               (1)
+#define BMI160_USER_INTR1_OUTPUT_TYPE__MSK               (0x04)
+#define BMI160_USER_INTR1_OUTPUT_TYPE__REG               \
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	OUTPUT TYPE ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->3 */
+#define BMI160_USER_INTR1_OUTPUT_ENABLE__POS               (3)
+#define BMI160_USER_INTR1_OUTPUT_ENABLE__LEN               (1)
+#define BMI160_USER_INTR1_OUTPUT_ENABLE__MSK               (0x08)
+#define BMI160_USER_INTR1_OUTPUT_ENABLE__REG		\
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	EDGE CONTROL ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->4 */
+#define BMI160_USER_INTR2_EDGE_CTRL__POS               (4)
+#define BMI160_USER_INTR2_EDGE_CTRL__LEN               (1)
+#define BMI160_USER_INTR2_EDGE_CTRL__MSK               (0x10)
+#define BMI160_USER_INTR2_EDGE_CTRL__REG		\
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	LEVEL CONTROL ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->5 */
+#define BMI160_USER_INTR2_LEVEL__POS               (5)
+#define BMI160_USER_INTR2_LEVEL__LEN               (1)
+#define BMI160_USER_INTR2_LEVEL__MSK               (0x20)
+#define BMI160_USER_INTR2_LEVEL__REG               \
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	OUTPUT TYPE ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->6 */
+#define BMI160_USER_INTR2_OUTPUT_TYPE__POS               (6)
+#define BMI160_USER_INTR2_OUTPUT_TYPE__LEN               (1)
+#define BMI160_USER_INTR2_OUTPUT_TYPE__MSK               (0x40)
+#define BMI160_USER_INTR2_OUTPUT_TYPE__REG               \
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+
+/* Int_Out_Ctrl Description - Reg Addr --> 0x53, Bit -->7 */
+#define BMI160_USER_INTR2_OUTPUT_EN__POS               (7)
+#define BMI160_USER_INTR2_OUTPUT_EN__LEN               (1)
+#define BMI160_USER_INTR2_OUTPUT_EN__MSK               (0x80)
+#define BMI160_USER_INTR2_OUTPUT_EN__REG		\
+(BMI160_USER_INTR_OUT_CTRL_ADDR)
+/**************************************************************/
+/**\name	LATCH INTERRUPT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Latch Description - Reg Addr --> 0x54, Bit -->0...3 */
+#define BMI160_USER_INTR_LATCH__POS               (0)
+#define BMI160_USER_INTR_LATCH__LEN               (4)
+#define BMI160_USER_INTR_LATCH__MSK               (0x0F)
+#define BMI160_USER_INTR_LATCH__REG               (BMI160_USER_INTR_LATCH_ADDR)
+/**************************************************************/
+/**\name	INPUT ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Latch Description - Reg Addr --> 0x54, Bit -->4 */
+#define BMI160_USER_INTR1_INPUT_ENABLE__POS               (4)
+#define BMI160_USER_INTR1_INPUT_ENABLE__LEN               (1)
+#define BMI160_USER_INTR1_INPUT_ENABLE__MSK               (0x10)
+#define BMI160_USER_INTR1_INPUT_ENABLE__REG               \
+(BMI160_USER_INTR_LATCH_ADDR)
+
+/* Int_Latch Description - Reg Addr --> 0x54, Bit -->5*/
+#define BMI160_USER_INTR2_INPUT_ENABLE__POS               (5)
+#define BMI160_USER_INTR2_INPUT_ENABLE__LEN               (1)
+#define BMI160_USER_INTR2_INPUT_ENABLE__MSK               (0x20)
+#define BMI160_USER_INTR2_INPUT_ENABLE__REG              \
+(BMI160_USER_INTR_LATCH_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF LOW_G LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->0 */
+#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__POS               (0)
+#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__MSK               (0x01)
+#define BMI160_USER_INTR_MAP_0_INTR1_LOW_G__REG	(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF HIGH_G LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->1 */
+#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__POS               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__MSK               (0x02)
+#define BMI160_USER_INTR_MAP_0_INTR1_HIGH_G__REG	\
+(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT MAPPIONG OF ANY MOTION_G LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->2 */
+#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__POS               (2)
+#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__MSK               (0x04)
+#define BMI160_USER_INTR_MAP_0_INTR1_ANY_MOTION__REG            \
+(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF NO MOTION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->3 */
+#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__POS               (3)
+#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__MSK               (0x08)
+#define BMI160_USER_INTR_MAP_0_INTR1_NOMOTION__REG (BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF DOUBLE TAP LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->4 */
+#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__POS               (4)
+#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__MSK               (0x10)
+#define BMI160_USER_INTR_MAP_0_INTR1_DOUBLE_TAP__REG	\
+(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF SINGLE TAP LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->5 */
+#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__POS               (5)
+#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__MSK               (0x20)
+#define BMI160_USER_INTR_MAP_0_INTR1_SINGLE_TAP__REG	      \
+(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF ORIENT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x55, Bit -->6 */
+#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__POS               (6)
+#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__MSK               (0x40)
+#define BMI160_USER_INTR_MAP_0_INTR1_ORIENT__REG	          \
+(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT MAPPIONG OF FLAT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_0 Description - Reg Addr --> 0x56, Bit -->7 */
+#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__POS               (7)
+#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__LEN               (1)
+#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__MSK               (0x80)
+#define BMI160_USER_INTR_MAP_0_INTR1_FLAT__REG	(BMI160_USER_INTR_MAP_0_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF PMU TRIGGER LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->0 */
+#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__POS               (0)
+#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__MSK               (0x01)
+#define BMI160_USER_INTR_MAP_1_INTR2_PMU_TRIG__REG (BMI160_USER_INTR_MAP_1_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF FIFO FULL AND
+	WATER MARK LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->1 */
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__POS               (1)
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__MSK               (0x02)
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_FULL__REG	         \
+(BMI160_USER_INTR_MAP_1_ADDR)
+
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->2 */
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__POS               (2)
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__MSK               (0x04)
+#define BMI160_USER_INTR_MAP_1_INTR2_FIFO_WM__REG	         \
+(BMI160_USER_INTR_MAP_1_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF DATA READY LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->3 */
+#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__POS               (3)
+#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__MSK               (0x08)
+#define BMI160_USER_INTR_MAP_1_INTR2_DATA_RDY__REG	      \
+(BMI160_USER_INTR_MAP_1_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF PMU TRIGGER LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->4 */
+#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__POS               (4)
+#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__MSK               (0x10)
+#define BMI160_USER_INTR_MAP_1_INTR1_PMU_TRIG__REG (BMI160_USER_INTR_MAP_1_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF FIFO FULL AND
+	WATER MARK LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->5 */
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__POS               (5)
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__MSK               (0x20)
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_FULL__REG	       \
+(BMI160_USER_INTR_MAP_1_ADDR)
+
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->6 */
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__POS               (6)
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__MSK               (0x40)
+#define BMI160_USER_INTR_MAP_1_INTR1_FIFO_WM__REG	\
+(BMI160_USER_INTR_MAP_1_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT1 MAPPIONG OF DATA READY LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_1 Description - Reg Addr --> 0x56, Bit -->7 */
+#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__POS               (7)
+#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__LEN               (1)
+#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__MSK               (0x80)
+#define BMI160_USER_INTR_MAP_1_INTR1_DATA_RDY__REG	\
+(BMI160_USER_INTR_MAP_1_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF LOW_G LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->0 */
+#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__POS               (0)
+#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__MSK               (0x01)
+#define BMI160_USER_INTR_MAP_2_INTR2_LOW_G__REG	(BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF HIGH_G LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->1 */
+#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__POS               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__MSK               (0x02)
+#define BMI160_USER_INTR_MAP_2_INTR2_HIGH_G__REG	\
+(BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF ANY MOTION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->2 */
+#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__POS      (2)
+#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__LEN      (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__MSK     (0x04)
+#define BMI160_USER_INTR_MAP_2_INTR2_ANY_MOTION__REG     \
+(BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF NO MOTION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->3 */
+#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__POS               (3)
+#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__MSK               (0x08)
+#define BMI160_USER_INTR_MAP_2_INTR2_NOMOTION__REG (BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF DOUBLE TAP LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->4 */
+#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__POS               (4)
+#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__MSK               (0x10)
+#define BMI160_USER_INTR_MAP_2_INTR2_DOUBLE_TAP__REG	\
+(BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF SINGLE TAP LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->5 */
+#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__POS               (5)
+#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__MSK               (0x20)
+#define BMI160_USER_INTR_MAP_2_INTR2_SINGLE_TAP__REG	\
+(BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF ORIENT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->6 */
+#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__POS               (6)
+#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__MSK               (0x40)
+#define BMI160_USER_INTR_MAP_2_INTR2_ORIENT__REG	\
+(BMI160_USER_INTR_MAP_2_ADDR)
+/**************************************************************/
+/**\name	INTERRUPT2 MAPPIONG OF FLAT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Map_2 Description - Reg Addr --> 0x57, Bit -->7 */
+#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__POS               (7)
+#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__LEN               (1)
+#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__MSK               (0x80)
+#define BMI160_USER_INTR_MAP_2_INTR2_FLAT__REG	(BMI160_USER_INTR_MAP_2_ADDR)
+
+/**************************************************************/
+/**\name	TAP SOURCE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Data_0 Description - Reg Addr --> 0x58, Bit --> 3 */
+#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__POS               (3)
+#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__LEN               (1)
+#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__MSK               (0x08)
+#define BMI160_USER_INTR_DATA_0_INTR_TAP_SOURCE__REG	           \
+(BMI160_USER_INTR_DATA_0_ADDR)
+
+/**************************************************************/
+/**\name	HIGH SOURCE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Data_0 Description - Reg Addr --> 0x58, Bit --> 7 */
+#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__POS           (7)
+#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__LEN           (1)
+#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__MSK           (0x80)
+#define BMI160_USER_INTR_DATA_0_INTR_LOW_HIGH_SOURCE__REG            \
+(BMI160_USER_INTR_DATA_0_ADDR)
+
+/**************************************************************/
+/**\name	MOTION SOURCE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Data_1 Description - Reg Addr --> 0x59, Bit --> 7 */
+#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__POS               (7)
+#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__LEN               (1)
+#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__MSK               (0x80)
+#define BMI160_USER_INTR_DATA_1_INTR_MOTION_SOURCE__REG               \
+		(BMI160_USER_INTR_DATA_1_ADDR)
+/**************************************************************/
+/**\name	LOW HIGH DURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_0 Description - Reg Addr --> 0x5a, Bit --> 0...7 */
+#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__POS               (0)
+#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__LEN               (8)
+#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__MSK               (0xFF)
+#define BMI160_USER_INTR_LOWHIGH_0_INTR_LOW_DURN__REG               \
+		(BMI160_USER_INTR_LOWHIGH_0_ADDR)
+/**************************************************************/
+/**\name	LOW THRESHOLD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_1 Description - Reg Addr --> 0x5b, Bit --> 0...7 */
+#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__POS               (0)
+#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__LEN               (8)
+#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__MSK               (0xFF)
+#define BMI160_USER_INTR_LOWHIGH_1_INTR_LOW_THRES__REG               \
+		(BMI160_USER_INTR_LOWHIGH_1_ADDR)
+/**************************************************************/
+/**\name	LOW HYSTERESIS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_2 Description - Reg Addr --> 0x5c, Bit --> 0...1 */
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__POS               (0)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__LEN               (2)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__MSK               (0x03)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_HYST__REG               \
+		(BMI160_USER_INTR_LOWHIGH_2_ADDR)
+/**************************************************************/
+/**\name	LOW MODE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_2 Description - Reg Addr --> 0x5c, Bit --> 2 */
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__POS               (2)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__LEN               (1)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__MSK               (0x04)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_LOW_G_MODE__REG               \
+		(BMI160_USER_INTR_LOWHIGH_2_ADDR)
+/**************************************************************/
+/**\name	HIGH_G HYSTERESIS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_2 Description - Reg Addr --> 0x5c, Bit --> 6...7 */
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__POS               (6)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__LEN               (2)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__MSK               (0xC0)
+#define BMI160_USER_INTR_LOWHIGH_2_INTR_HIGH_G_HYST__REG               \
+		(BMI160_USER_INTR_LOWHIGH_2_ADDR)
+/**************************************************************/
+/**\name	HIGH_G DURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_3 Description - Reg Addr --> 0x5d, Bit --> 0...7 */
+#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__POS               (0)
+#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__LEN               (8)
+#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__MSK               (0xFF)
+#define BMI160_USER_INTR_LOWHIGH_3_INTR_HIGH_G_DURN__REG               \
+		(BMI160_USER_INTR_LOWHIGH_3_ADDR)
+/**************************************************************/
+/**\name	HIGH_G THRESHOLD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_LowHigh_4 Description - Reg Addr --> 0x5e, Bit --> 0...7 */
+#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__POS               (0)
+#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__LEN               (8)
+#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__MSK               (0xFF)
+#define BMI160_USER_INTR_LOWHIGH_4_INTR_HIGH_THRES__REG               \
+		(BMI160_USER_INTR_LOWHIGH_4_ADDR)
+/**************************************************************/
+/**\name	ANY MOTION DURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Motion_0 Description - Reg Addr --> 0x5f, Bit --> 0...1 */
+#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__POS               (0)
+#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__LEN               (2)
+#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__MSK               (0x03)
+#define BMI160_USER_INTR_MOTION_0_INTR_ANY_MOTION_DURN__REG               \
+		(BMI160_USER_INTR_MOTION_0_ADDR)
+/**************************************************************/
+/**\name	SLOW/NO MOTION DURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+	/* Int_Motion_0 Description - Reg Addr --> 0x5f, Bit --> 2...7 */
+#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__POS      (2)
+#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__LEN      (6)
+#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__MSK      (0xFC)
+#define BMI160_USER_INTR_MOTION_0_INTR_SLOW_NO_MOTION_DURN__REG       \
+		(BMI160_USER_INTR_MOTION_0_ADDR)
+/**************************************************************/
+/**\name	ANY MOTION THRESHOLD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Motion_1 Description - Reg Addr --> (0x60), Bit --> 0...7 */
+#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__POS      (0)
+#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__LEN      (8)
+#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__MSK      (0xFF)
+#define BMI160_USER_INTR_MOTION_1_INTR_ANY_MOTION_THRES__REG               \
+		(BMI160_USER_INTR_MOTION_1_ADDR)
+/**************************************************************/
+/**\name	SLOW/NO MOTION THRESHOLD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Motion_2 Description - Reg Addr --> 0x61, Bit --> 0...7 */
+#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__POS       (0)
+#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__LEN       (8)
+#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__MSK       (0xFF)
+#define BMI160_USER_INTR_MOTION_2_INTR_SLOW_NO_MOTION_THRES__REG       \
+		(BMI160_USER_INTR_MOTION_2_ADDR)
+/**************************************************************/
+/**\name	SLOW/NO MOTION SELECT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 0 */
+#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__POS	(0)
+#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__LEN	(1)
+#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__MSK	(0x01)
+#define BMI160_USER_INTR_MOTION_3_INTR_SLOW_NO_MOTION_SELECT__REG   \
+(BMI160_USER_INTR_MOTION_3_ADDR)
+/**************************************************************/
+/**\name	SIGNIFICANT MOTION SELECT LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 1 */
+#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__POS		(1)
+#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__LEN		(1)
+#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__MSK		(0x02)
+#define BMI160_USER_INTR_SIGNIFICATION_MOTION_SELECT__REG		\
+		(BMI160_USER_INTR_MOTION_3_ADDR)
+
+/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 3..2 */
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__POS		(2)
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__LEN		(2)
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__MSK		(0x0C)
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_SKIP__REG		\
+		(BMI160_USER_INTR_MOTION_3_ADDR)
+
+/* Int_Motion_3 Description - Reg Addr --> (0x62), Bit --> 5..4 */
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__POS		(4)
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__LEN		(2)
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__MSK		(0x30)
+#define BMI160_USER_INTR_SIGNIFICANT_MOTION_PROOF__REG		\
+		(BMI160_USER_INTR_MOTION_3_ADDR)
+/**************************************************************/
+/**\name	TAP DURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* INT_TAP_0 Description - Reg Addr --> (0x63), Bit --> 0..2*/
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__POS               (0)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__LEN               (3)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__MSK               (0x07)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_DURN__REG	\
+(BMI160_USER_INTR_TAP_0_ADDR)
+/**************************************************************/
+/**\name	TAP SHOCK LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Tap_0 Description - Reg Addr --> (0x63), Bit --> 6 */
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__POS               (6)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__LEN               (1)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__MSK               (0x40)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_SHOCK__REG (BMI160_USER_INTR_TAP_0_ADDR)
+/**************************************************************/
+/**\name	TAP QUIET LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Tap_0 Description - Reg Addr --> (0x63), Bit --> 7 */
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__POS               (7)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__LEN               (1)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__MSK               (0x80)
+#define BMI160_USER_INTR_TAP_0_INTR_TAP_QUIET__REG (BMI160_USER_INTR_TAP_0_ADDR)
+/**************************************************************/
+/**\name	TAP THRESHOLD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Tap_1 Description - Reg Addr --> (0x64), Bit --> 0...4 */
+#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__POS               (0)
+#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__LEN               (5)
+#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__MSK               (0x1F)
+#define BMI160_USER_INTR_TAP_1_INTR_TAP_THRES__REG (BMI160_USER_INTR_TAP_1_ADDR)
+/**************************************************************/
+/**\name	ORIENT MODE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Orient_0 Description - Reg Addr --> (0x65), Bit --> 0...1 */
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__POS               (0)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__LEN               (2)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__MSK               (0x03)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_MODE__REG               \
+		(BMI160_USER_INTR_ORIENT_0_ADDR)
+/**************************************************************/
+/**\name	ORIENT BLOCKING LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Orient_0 Description - Reg Addr --> (0x65), Bit --> 2...3 */
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__POS               (2)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__LEN               (2)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__MSK               (0x0C)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_BLOCKING__REG               \
+		(BMI160_USER_INTR_ORIENT_0_ADDR)
+/**************************************************************/
+/**\name	ORIENT HYSTERESIS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Orient_0 Description - Reg Addr --> (0x65), Bit --> 4...7 */
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__POS               (4)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__LEN               (4)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__MSK               (0xF0)
+#define BMI160_USER_INTR_ORIENT_0_INTR_ORIENT_HYST__REG               \
+		(BMI160_USER_INTR_ORIENT_0_ADDR)
+/**************************************************************/
+/**\name	ORIENT THETA LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Orient_1 Description - Reg Addr --> 0x66, Bit --> 0...5 */
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__POS               (0)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__LEN               (6)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__MSK               (0x3F)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_THETA__REG               \
+		(BMI160_USER_INTR_ORIENT_1_ADDR)
+/**************************************************************/
+/**\name	ORIENT UD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Orient_1 Description - Reg Addr --> 0x66, Bit --> 6 */
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__POS         (6)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__LEN         (1)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__MSK         (0x40)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_UD_ENABLE__REG          \
+		(BMI160_USER_INTR_ORIENT_1_ADDR)
+/**************************************************************/
+/**\name	ORIENT AXIS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Orient_1 Description - Reg Addr --> 0x66, Bit --> 7 */
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__POS               (7)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__LEN               (1)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__MSK               (0x80)
+#define BMI160_USER_INTR_ORIENT_1_INTR_ORIENT_AXES_EX__REG               \
+		(BMI160_USER_INTR_ORIENT_1_ADDR)
+/**************************************************************/
+/**\name	FLAT THETA LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Flat_0 Description - Reg Addr --> 0x67, Bit --> 0...5 */
+#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__POS               (0)
+#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__LEN               (6)
+#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__MSK               (0x3F)
+#define BMI160_USER_INTR_FLAT_0_INTR_FLAT_THETA__REG  \
+		(BMI160_USER_INTR_FLAT_0_ADDR)
+/**************************************************************/
+/**\name	FLAT HYSTERESIS LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Flat_1 Description - Reg Addr --> (0x68), Bit --> 0...3 */
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__POS		(0)
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__LEN		(4)
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__MSK		(0x0F)
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HYST__REG	 \
+(BMI160_USER_INTR_FLAT_1_ADDR)
+/**************************************************************/
+/**\name	FLAT HOLD LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Int_Flat_1 Description - Reg Addr --> (0x68), Bit --> 4...5 */
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__POS                (4)
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__LEN                (2)
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__MSK                (0x30)
+#define BMI160_USER_INTR_FLAT_1_INTR_FLAT_HOLD__REG  \
+(BMI160_USER_INTR_FLAT_1_ADDR)
+/**************************************************************/
+/**\name	FOC ACCEL XYZ LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 0...1 */
+#define BMI160_USER_FOC_ACCEL_Z__POS               (0)
+#define BMI160_USER_FOC_ACCEL_Z__LEN               (2)
+#define BMI160_USER_FOC_ACCEL_Z__MSK               (0x03)
+#define BMI160_USER_FOC_ACCEL_Z__REG               (BMI160_USER_FOC_CONFIG_ADDR)
+
+/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 2...3 */
+#define BMI160_USER_FOC_ACCEL_Y__POS               (2)
+#define BMI160_USER_FOC_ACCEL_Y__LEN               (2)
+#define BMI160_USER_FOC_ACCEL_Y__MSK               (0x0C)
+#define BMI160_USER_FOC_ACCEL_Y__REG               (BMI160_USER_FOC_CONFIG_ADDR)
+
+/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 4...5 */
+#define BMI160_USER_FOC_ACCEL_X__POS               (4)
+#define BMI160_USER_FOC_ACCEL_X__LEN               (2)
+#define BMI160_USER_FOC_ACCEL_X__MSK               (0x30)
+#define BMI160_USER_FOC_ACCEL_X__REG               (BMI160_USER_FOC_CONFIG_ADDR)
+/**************************************************************/
+/**\name	FOC GYRO LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Foc_Conf Description - Reg Addr --> (0x69), Bit --> 6 */
+#define BMI160_USER_FOC_GYRO_ENABLE__POS               (6)
+#define BMI160_USER_FOC_GYRO_ENABLE__LEN               (1)
+#define BMI160_USER_FOC_GYRO_ENABLE__MSK               (0x40)
+#define BMI160_USER_FOC_GYRO_ENABLE__REG               \
+(BMI160_USER_FOC_CONFIG_ADDR)
+/**************************************************************/
+/**\name	NVM PROGRAM LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* CONF Description - Reg Addr --> (0x6A), Bit --> 1 */
+#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__POS               (1)
+#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__LEN               (1)
+#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__MSK               (0x02)
+#define BMI160_USER_CONFIG_NVM_PROG_ENABLE__REG               \
+(BMI160_USER_CONFIG_ADDR)
+
+/*IF_CONF Description - Reg Addr --> (0x6B), Bit --> 0 */
+
+#define BMI160_USER_IF_CONFIG_SPI3__POS               (0)
+#define BMI160_USER_IF_CONFIG_SPI3__LEN               (1)
+#define BMI160_USER_IF_CONFIG_SPI3__MSK               (0x01)
+#define BMI160_USER_IF_CONFIG_SPI3__REG               \
+(BMI160_USER_IF_CONFIG_ADDR)
+
+/*IF_CONF Description - Reg Addr --> (0x6B), Bit --> 5..4 */
+#define BMI160_USER_IF_CONFIG_IF_MODE__POS               (4)
+#define BMI160_USER_IF_CONFIG_IF_MODE__LEN               (2)
+#define BMI160_USER_IF_CONFIG_IF_MODE__MSK               (0x30)
+#define BMI160_USER_IF_CONFIG_IF_MODE__REG		\
+(BMI160_USER_IF_CONFIG_ADDR)
+/**************************************************************/
+/**\name	GYRO SLEEP CONFIGURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 0...2 */
+#define BMI160_USER_GYRO_SLEEP_TRIGGER__POS               (0)
+#define BMI160_USER_GYRO_SLEEP_TRIGGER__LEN               (3)
+#define BMI160_USER_GYRO_SLEEP_TRIGGER__MSK               (0x07)
+#define BMI160_USER_GYRO_SLEEP_TRIGGER__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
+
+/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 3...4 */
+#define BMI160_USER_GYRO_WAKEUP_TRIGGER__POS               (3)
+#define BMI160_USER_GYRO_WAKEUP_TRIGGER__LEN               (2)
+#define BMI160_USER_GYRO_WAKEUP_TRIGGER__MSK               (0x18)
+#define BMI160_USER_GYRO_WAKEUP_TRIGGER__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
+
+/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 5 */
+#define BMI160_USER_GYRO_SLEEP_STATE__POS               (5)
+#define BMI160_USER_GYRO_SLEEP_STATE__LEN               (1)
+#define BMI160_USER_GYRO_SLEEP_STATE__MSK               (0x20)
+#define BMI160_USER_GYRO_SLEEP_STATE__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
+
+/* Pmu_Trigger Description - Reg Addr --> 0x6c, Bit --> 6 */
+#define BMI160_USER_GYRO_WAKEUP_INTR__POS               (6)
+#define BMI160_USER_GYRO_WAKEUP_INTR__LEN               (1)
+#define BMI160_USER_GYRO_WAKEUP_INTR__MSK               (0x40)
+#define BMI160_USER_GYRO_WAKEUP_INTR__REG	(BMI160_USER_PMU_TRIGGER_ADDR)
+/**************************************************************/
+/**\name	ACCEL SELF TEST LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 0...1 */
+#define BMI160_USER_ACCEL_SELFTEST_AXIS__POS               (0)
+#define BMI160_USER_ACCEL_SELFTEST_AXIS__LEN               (2)
+#define BMI160_USER_ACCEL_SELFTEST_AXIS__MSK               (0x03)
+#define BMI160_USER_ACCEL_SELFTEST_AXIS__REG	(BMI160_USER_SELF_TEST_ADDR)
+
+/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 2 */
+#define BMI160_USER_ACCEL_SELFTEST_SIGN__POS               (2)
+#define BMI160_USER_ACCEL_SELFTEST_SIGN__LEN               (1)
+#define BMI160_USER_ACCEL_SELFTEST_SIGN__MSK               (0x04)
+#define BMI160_USER_ACCEL_SELFTEST_SIGN__REG	(BMI160_USER_SELF_TEST_ADDR)
+
+/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 3 */
+#define BMI160_USER_SELFTEST_AMP__POS               (3)
+#define BMI160_USER_SELFTEST_AMP__LEN               (1)
+#define BMI160_USER_SELFTEST_AMP__MSK               (0x08)
+#define BMI160_USER_SELFTEST_AMP__REG		(BMI160_USER_SELF_TEST_ADDR)
+/**************************************************************/
+/**\name	GYRO SELF TEST LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Self_Test Description - Reg Addr --> 0x6d, Bit --> 4 */
+#define BMI160_USER_GYRO_SELFTEST_START__POS               (4)
+#define BMI160_USER_GYRO_SELFTEST_START__LEN               (1)
+#define BMI160_USER_GYRO_SELFTEST_START__MSK               (0x10)
+#define BMI160_USER_GYRO_SELFTEST_START__REG		    \
+(BMI160_USER_SELF_TEST_ADDR)
+/**************************************************************/
+/**\name	NV_CONFIG LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* NV_CONF Description - Reg Addr --> (0x70), Bit --> 0 */
+#define BMI160_USER_NV_CONFIG_SPI_ENABLE__POS               (0)
+#define BMI160_USER_NV_CONFIG_SPI_ENABLE__LEN               (1)
+#define BMI160_USER_NV_CONFIG_SPI_ENABLE__MSK               (0x01)
+#define BMI160_USER_NV_CONFIG_SPI_ENABLE__REG	 (BMI160_USER_NV_CONFIG_ADDR)
+
+/*IF_CONF Description - Reg Addr --> (0x70), Bit --> 1 */
+#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__POS               (1)
+#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__LEN               (1)
+#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__MSK               (0x02)
+#define BMI160_USER_IF_CONFIG_I2C_WDT_SELECT__REG		\
+(BMI160_USER_NV_CONFIG_ADDR)
+
+/*IF_CONF Description - Reg Addr --> (0x70), Bit --> 2 */
+#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__POS               (2)
+#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__LEN               (1)
+#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__MSK               (0x04)
+#define BMI160_USER_IF_CONFIG_I2C_WDT_ENABLE__REG		\
+(BMI160_USER_NV_CONFIG_ADDR)
+
+/* NV_CONF Description - Reg Addr --> (0x70), Bit --> 3 */
+#define BMI160_USER_NV_CONFIG_SPARE0__POS               (3)
+#define BMI160_USER_NV_CONFIG_SPARE0__LEN               (1)
+#define BMI160_USER_NV_CONFIG_SPARE0__MSK               (0x08)
+#define BMI160_USER_NV_CONFIG_SPARE0__REG	(BMI160_USER_NV_CONFIG_ADDR)
+
+/* NV_CONF Description - Reg Addr --> (0x70), Bit --> 4...7 */
+#define BMI160_USER_NV_CONFIG_NVM_COUNTER__POS               (4)
+#define BMI160_USER_NV_CONFIG_NVM_COUNTER__LEN               (4)
+#define BMI160_USER_NV_CONFIG_NVM_COUNTER__MSK               (0xF0)
+#define BMI160_USER_NV_CONFIG_NVM_COUNTER__REG	(BMI160_USER_NV_CONFIG_ADDR)
+/**************************************************************/
+/**\name	ACCEL MANUAL OFFSET LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Offset_0 Description - Reg Addr --> (0x71), Bit --> 0...7 */
+#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__POS               (0)
+#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__LEN               (8)
+#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__MSK               (0xFF)
+#define BMI160_USER_OFFSET_0_ACCEL_OFF_X__REG	(BMI160_USER_OFFSET_0_ADDR)
+
+/* Offset_1 Description - Reg Addr --> 0x72, Bit --> 0...7 */
+#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__POS               (0)
+#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__LEN               (8)
+#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__MSK               (0xFF)
+#define BMI160_USER_OFFSET_1_ACCEL_OFF_Y__REG	(BMI160_USER_OFFSET_1_ADDR)
+
+/* Offset_2 Description - Reg Addr --> 0x73, Bit --> 0...7 */
+#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__POS               (0)
+#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__LEN               (8)
+#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__MSK               (0xFF)
+#define BMI160_USER_OFFSET_2_ACCEL_OFF_Z__REG	(BMI160_USER_OFFSET_2_ADDR)
+/**************************************************************/
+/**\name	GYRO MANUAL OFFSET LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Offset_3 Description - Reg Addr --> 0x74, Bit --> 0...7 */
+#define BMI160_USER_OFFSET_3_GYRO_OFF_X__POS               (0)
+#define BMI160_USER_OFFSET_3_GYRO_OFF_X__LEN               (8)
+#define BMI160_USER_OFFSET_3_GYRO_OFF_X__MSK               (0xFF)
+#define BMI160_USER_OFFSET_3_GYRO_OFF_X__REG	(BMI160_USER_OFFSET_3_ADDR)
+
+/* Offset_4 Description - Reg Addr --> 0x75, Bit --> 0...7 */
+#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__POS               (0)
+#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__LEN               (8)
+#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__MSK               (0xFF)
+#define BMI160_USER_OFFSET_4_GYRO_OFF_Y__REG	(BMI160_USER_OFFSET_4_ADDR)
+
+/* Offset_5 Description - Reg Addr --> 0x76, Bit --> 0...7 */
+#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__POS               (0)
+#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__LEN               (8)
+#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__MSK               (0xFF)
+#define BMI160_USER_OFFSET_5_GYRO_OFF_Z__REG	(BMI160_USER_OFFSET_5_ADDR)
+
+
+/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 0..1 */
+#define BMI160_USER_OFFSET_6_GYRO_OFF_X__POS               (0)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_X__LEN               (2)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_X__MSK               (0x03)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_X__REG	(BMI160_USER_OFFSET_6_ADDR)
+
+/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 2...3 */
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__POS               (2)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__LEN               (2)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__MSK               (0x0C)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Y__REG	(BMI160_USER_OFFSET_6_ADDR)
+
+/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 4...5 */
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__POS               (4)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__LEN               (2)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__MSK               (0x30)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_Z__REG	 (BMI160_USER_OFFSET_6_ADDR)
+/**************************************************************/
+/**\name	ACCEL OFFSET  ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Offset_6 Description - Reg Addr --> 0x77, Bit --> 6 */
+#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__POS               (6)
+#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__LEN               (1)
+#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__MSK               (0x40)
+#define BMI160_USER_OFFSET_6_ACCEL_OFF_ENABLE__REG	 \
+(BMI160_USER_OFFSET_6_ADDR)
+/**************************************************************/
+/**\name	GYRO OFFSET  ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Offset_6 Description - Reg Addr --> 0x77, Bit -->  7 */
+#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__POS               (7)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__LEN               (1)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__MSK               (0x80)
+#define BMI160_USER_OFFSET_6_GYRO_OFF_EN__REG	 (BMI160_USER_OFFSET_6_ADDR)
+/**************************************************************/
+/**\name	STEP COUNTER LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* STEP_CNT_0  Description - Reg Addr --> 0x78, Bit -->  0 to 7 */
+#define BMI160_USER_STEP_COUNT_LSB__POS               (0)
+#define BMI160_USER_STEP_COUNT_LSB__LEN               (7)
+#define BMI160_USER_STEP_COUNT_LSB__MSK               (0xFF)
+#define BMI160_USER_STEP_COUNT_LSB__REG	 (BMI160_USER_STEP_COUNT_0_ADDR)
+
+/* STEP_CNT_1  Description - Reg Addr --> 0x79, Bit -->  0 to 7 */
+#define BMI160_USER_STEP_COUNT_MSB__POS               (0)
+#define BMI160_USER_STEP_COUNT_MSB__LEN               (7)
+#define BMI160_USER_STEP_COUNT_MSB__MSK               (0xFF)
+#define BMI160_USER_STEP_COUNT_MSB__REG	 (BMI160_USER_STEP_COUNT_1_ADDR)
+/**************************************************************/
+/**\name	STEP COUNTER CONFIGURATION LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* STEP_CONFIG_0  Description - Reg Addr --> 0x7A, Bit -->  0 to 7 */
+#define BMI160_USER_STEP_CONFIG_ZERO__POS               (0)
+#define BMI160_USER_STEP_CONFIG_ZERO__LEN               (7)
+#define BMI160_USER_STEP_CONFIG_ZERO__MSK               (0xFF)
+#define BMI160_USER_STEP_CONFIG_ZERO__REG	 \
+(BMI160_USER_STEP_CONFIG_0_ADDR)
+
+
+/* STEP_CONFIG_1  Description - Reg Addr --> 0x7B, Bit -->  0 to 2 and
+4 to 7 */
+#define BMI160_USER_STEP_CONFIG_ONE_CNF1__POS               (0)
+#define BMI160_USER_STEP_CONFIG_ONE_CNF1__LEN               (3)
+#define BMI160_USER_STEP_CONFIG_ONE_CNF1__MSK               (0x07)
+#define BMI160_USER_STEP_CONFIG_ONE_CNF1__REG	 \
+(BMI160_USER_STEP_CONFIG_1_ADDR)
+
+#define BMI160_USER_STEP_CONFIG_ONE_CNF2__POS               (4)
+#define BMI160_USER_STEP_CONFIG_ONE_CNF2__LEN               (4)
+#define BMI160_USER_STEP_CONFIG_ONE_CNF2__MSK               (0xF0)
+#define BMI160_USER_STEP_CONFIG_ONE_CNF2__REG	 \
+(BMI160_USER_STEP_CONFIG_1_ADDR)
+/**************************************************************/
+/**\name	STEP COUNTER ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* STEP_CONFIG_1  Description - Reg Addr --> 0x7B, Bit -->  0 to 2 */
+#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__POS		(3)
+#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__LEN		(1)
+#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__MSK		(0x08)
+#define BMI160_USER_STEP_CONFIG_1_STEP_COUNT_ENABLE__REG	\
+(BMI160_USER_STEP_CONFIG_1_ADDR)
+
+/* USER REGISTERS DEFINITION END */
+/**************************************************************************/
+/* CMD REGISTERS DEFINITION START */
+/**************************************************************/
+/**\name	COMMAND REGISTER LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Command description address - Reg Addr --> 0x7E, Bit -->  0....7 */
+#define BMI160_CMD_COMMANDS__POS              (0)
+#define BMI160_CMD_COMMANDS__LEN              (8)
+#define BMI160_CMD_COMMANDS__MSK              (0xFF)
+#define BMI160_CMD_COMMANDS__REG	 (BMI160_CMD_COMMANDS_ADDR)
+/**************************************************************/
+/**\name	PAGE ENABLE LENGTH, POSITION AND MASK*/
+/**************************************************************/
+/* Target page address - Reg Addr --> 0x7F, Bit -->  4....5 */
+#define BMI160_CMD_TARGET_PAGE__POS           (4)
+#define BMI160_CMD_TARGET_PAGE__LEN           (2)
+#define BMI160_CMD_TARGET_PAGE__MSK           (0x30)
+#define BMI160_CMD_TARGET_PAGE__REG	 (BMI160_CMD_EXT_MODE_ADDR)
+
+/* Target page address - Reg Addr --> 0x7F, Bit -->  4....5 */
+#define BMI160_CMD_PAGING_EN__POS           (7)
+#define BMI160_CMD_PAGING_EN__LEN           (1)
+#define BMI160_CMD_PAGING_EN__MSK           (0x80)
+#define BMI160_CMD_PAGING_EN__REG		(BMI160_CMD_EXT_MODE_ADDR)
+
+/* Target page address - Reg Addr --> 0x7F, Bit -->  4....5 */
+#define BMI160_COM_C_TRIM_FIVE__POS           (0)
+#define BMI160_COM_C_TRIM_FIVE__LEN           (8)
+#define BMI160_COM_C_TRIM_FIVE__MSK           (0xFF)
+#define BMI160_COM_C_TRIM_FIVE__REG		(BMI160_COM_C_TRIM_FIVE_ADDR)
+
+/**************************************************************************/
+/* CMD REGISTERS DEFINITION END */
+
+/**************************************************/
+/**\name	FIFO FRAME COUNT DEFINITION           */
+/*************************************************/
+#define FIFO_FRAME				(1024)
+#define FIFO_CONFIG_CHECK1		(0x00)
+#define FIFO_CONFIG_CHECK2		(0x80)
+/**************************************************/
+/**\name	MAG SENSOR SELECT          */
+/*************************************************/
+#define BST_BMM		(0)
+#define BST_AKM		(1)
+#define BMI160_YAS537_I2C_ADDRESS	(0x2E)
+/**************************************************/
+/**\name	ACCEL RANGE          */
+/*************************************************/
+#define BMI160_ACCEL_RANGE_2G           (0X03)
+#define BMI160_ACCEL_RANGE_4G           (0X05)
+#define BMI160_ACCEL_RANGE_8G           (0X08)
+#define BMI160_ACCEL_RANGE_16G          (0X0C)
+/**************************************************/
+/**\name	ACCEL ODR          */
+/*************************************************/
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED       (0x00)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ         (0x01)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ         (0x02)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ         (0x03)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ         (0x04)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ         (0x05)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ           (0x06)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ           (0x07)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ          (0x08)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ          (0x09)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ          (0x0A)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ          (0x0B)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ         (0x0C)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED0      (0x0D)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED1      (0x0E)
+#define BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED2      (0x0F)
+/**************************************************/
+/**\name	ACCEL BANDWIDTH PARAMETER         */
+/*************************************************/
+#define BMI160_ACCEL_OSR4_AVG1			(0)
+#define BMI160_ACCEL_OSR2_AVG2			(1)
+#define BMI160_ACCEL_NORMAL_AVG4		(2)
+#define BMI160_ACCEL_CIC_AVG8			(3)
+#define BMI160_ACCEL_RES_AVG2			(4)
+#define BMI160_ACCEL_RES_AVG4			(5)
+#define BMI160_ACCEL_RES_AVG8			(6)
+#define BMI160_ACCEL_RES_AVG16			(7)
+#define BMI160_ACCEL_RES_AVG32			(8)
+#define BMI160_ACCEL_RES_AVG64			(9)
+#define BMI160_ACCEL_RES_AVG128			(10)
+
+#define BMI160_US_DISABLE				(0)
+#define BMI160_US_ENABLE				(1)
+/**************************************************/
+/**\name	GYRO ODR         */
+/*************************************************/
+#define BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED		(0x00)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_25HZ			(0x06)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_50HZ			(0x07)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_100HZ			(0x08)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_200HZ			(0x09)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_400HZ			(0x0A)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_800HZ			(0x0B)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ			(0x0C)
+#define BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ			(0x0D)
+/**************************************************/
+/**\name	GYRO BANDWIDTH PARAMETER         */
+/*************************************************/
+#define BMI160_GYRO_OSR4_MODE		(0x00)
+#define BMI160_GYRO_OSR2_MODE		(0x01)
+#define BMI160_GYRO_NORMAL_MODE		(0x02)
+#define BMI160_GYRO_CIC_MODE		(0x03)
+/**************************************************/
+/**\name	GYROSCOPE RANGE PARAMETER         */
+/*************************************************/
+#define BMI160_GYRO_RANGE_2000_DEG_SEC	(0x00)
+#define BMI160_GYRO_RANGE_1000_DEG_SEC	(0x01)
+#define BMI160_GYRO_RANGE_500_DEG_SEC	(0x02)
+#define BMI160_GYRO_RANGE_250_DEG_SEC	(0x03)
+#define BMI160_GYRO_RANGE_125_DEG_SEC	(0x04)
+/**************************************************/
+/**\name	MAG ODR         */
+/*************************************************/
+#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED       (0x00)
+#define BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ         (0x01)
+#define BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ         (0x02)
+#define BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ         (0x03)
+#define BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ         (0x04)
+#define BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ         (0x05)
+#define BMI160_MAG_OUTPUT_DATA_RATE_25HZ           (0x06)
+#define BMI160_MAG_OUTPUT_DATA_RATE_50HZ           (0x07)
+#define BMI160_MAG_OUTPUT_DATA_RATE_100HZ          (0x08)
+#define BMI160_MAG_OUTPUT_DATA_RATE_200HZ          (0x09)
+#define BMI160_MAG_OUTPUT_DATA_RATE_400HZ          (0x0A)
+#define BMI160_MAG_OUTPUT_DATA_RATE_800HZ          (0x0B)
+#define BMI160_MAG_OUTPUT_DATA_RATE_1600HZ         (0x0C)
+#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0      (0x0D)
+#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1      (0x0E)
+#define BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2      (0x0F)
+
+/**************************************************/
+/**\name	ENABLE/DISABLE SELECTIONS        */
+/*************************************************/
+
+/* Enable accel and gyro offset */
+#define ACCEL_OFFSET_ENABLE		(0x01)
+#define GYRO_OFFSET_ENABLE		(0x01)
+
+/* command register definition */
+#define START_FOC_ACCEL_GYRO	(0X03)
+
+ /* INT ENABLE 1 */
+#define BMI160_ANY_MOTION_X_ENABLE       (0)
+#define BMI160_ANY_MOTION_Y_ENABLE       (1)
+#define BMI160_ANY_MOTION_Z_ENABLE       (2)
+#define BMI160_DOUBLE_TAP_ENABLE         (4)
+#define BMI160_SINGLE_TAP_ENABLE         (5)
+#define BMI160_ORIENT_ENABLE             (6)
+#define BMI160_FLAT_ENABLE               (7)
+
+/* INT ENABLE 1 */
+#define BMI160_HIGH_G_X_ENABLE       (0)
+#define BMI160_HIGH_G_Y_ENABLE       (1)
+#define BMI160_HIGH_G_Z_ENABLE       (2)
+#define BMI160_LOW_G_ENABLE          (3)
+#define BMI160_DATA_RDY_ENABLE       (4)
+#define BMI160_FIFO_FULL_ENABLE      (5)
+#define BMI160_FIFO_WM_ENABLE        (6)
+
+/* INT ENABLE 2 */
+#define  BMI160_NOMOTION_X_ENABLE	(0)
+#define  BMI160_NOMOTION_Y_ENABLE	(1)
+#define  BMI160_NOMOTION_Z_ENABLE	(2)
+
+/* FOC axis selection for accel*/
+#define	FOC_X_AXIS		(0)
+#define	FOC_Y_AXIS		(1)
+#define	FOC_Z_AXIS		(2)
+
+/* IN OUT CONTROL */
+#define BMI160_INTR1_EDGE_CTRL			(0)
+#define BMI160_INTR2_EDGE_CTRL			(1)
+#define BMI160_INTR1_LEVEL				(0)
+#define BMI160_INTR2_LEVEL				(1)
+#define BMI160_INTR1_OUTPUT_TYPE		(0)
+#define BMI160_INTR2_OUTPUT_TYPE		(1)
+#define BMI160_INTR1_OUTPUT_ENABLE		(0)
+#define BMI160_INTR2_OUTPUT_ENABLE		(1)
+
+#define BMI160_INTR1_INPUT_ENABLE	(0)
+#define BMI160_INTR2_INPUT_ENABLE	(1)
+
+/*  INTERRUPT MAPS    */
+#define BMI160_INTR1_MAP_LOW_G			(0)
+#define BMI160_INTR2_MAP_LOW_G			(1)
+#define BMI160_INTR1_MAP_HIGH_G			(0)
+#define BMI160_INTR2_MAP_HIGH_G			(1)
+#define BMI160_INTR1_MAP_ANY_MOTION		(0)
+#define BMI160_INTR2_MAP_ANY_MOTION		(1)
+#define BMI160_INTR1_MAP_NOMO			(0)
+#define BMI160_INTR2_MAP_NOMO			(1)
+#define BMI160_INTR1_MAP_DOUBLE_TAP		(0)
+#define BMI160_INTR2_MAP_DOUBLE_TAP		(1)
+#define BMI160_INTR1_MAP_SINGLE_TAP		(0)
+#define BMI160_INTR2_MAP_SINGLE_TAP		(1)
+#define BMI160_INTR1_MAP_ORIENT			(0)
+#define BMI160_INTR2_MAP_ORIENT			(1)
+#define BMI160_INTR1_MAP_FLAT			(0)
+#define BMI160_INTR2_MAP_FLAT			(1)
+#define BMI160_INTR1_MAP_DATA_RDY		(0)
+#define BMI160_INTR2_MAP_DATA_RDY		(1)
+#define BMI160_INTR1_MAP_FIFO_WM		(0)
+#define BMI160_INTR2_MAP_FIFO_WM		(1)
+#define BMI160_INTR1_MAP_FIFO_FULL      (0)
+#define BMI160_INTR2_MAP_FIFO_FULL      (1)
+#define BMI160_INTR1_MAP_PMUTRIG        (0)
+#define BMI160_INTR2_MAP_PMUTRIG		(1)
+
+/* Interrupt mapping*/
+#define	BMI160_MAP_INTR1		(0)
+#define	BMI160_MAP_INTR2		(1)
+/**************************************************/
+/**\name	 TAP DURATION         */
+/*************************************************/
+#define BMI160_TAP_DURN_50MS     (0x00)
+#define BMI160_TAP_DURN_100MS    (0x01)
+#define BMI160_TAP_DURN_150MS    (0x02)
+#define BMI160_TAP_DURN_200MS    (0x03)
+#define BMI160_TAP_DURN_250MS    (0x04)
+#define BMI160_TAP_DURN_375MS    (0x05)
+#define BMI160_TAP_DURN_500MS    (0x06)
+#define BMI160_TAP_DURN_700MS    (0x07)
+/**************************************************/
+/**\name	TAP SHOCK         */
+/*************************************************/
+#define BMI160_TAP_SHOCK_50MS	(0x00)
+#define BMI160_TAP_SHOCK_75MS	(0x01)
+/**************************************************/
+/**\name	TAP QUIET        */
+/*************************************************/
+#define BMI160_TAP_QUIET_30MS	(0x00)
+#define BMI160_TAP_QUIET_20MS	(0x01)
+/**************************************************/
+/**\name	STEP DETECTION SELECTION MODES      */
+/*************************************************/
+#define	BMI160_STEP_NORMAL_MODE			(0)
+#define	BMI160_STEP_SENSITIVE_MODE		(1)
+#define	BMI160_STEP_ROBUST_MODE			(2)
+/**************************************************/
+/**\name	STEP CONFIGURATION SELECT MODE    */
+/*************************************************/
+#define	STEP_CONFIG_NORMAL		(0X315)
+#define	STEP_CONFIG_SENSITIVE	(0X2D)
+#define	STEP_CONFIG_ROBUST		(0X71D)
+/**************************************************/
+/**\name	BMM150 TRIM DATA DEFINITIONS      */
+/*************************************************/
+#define BMI160_MAG_DIG_X1                      (0x5D)
+#define BMI160_MAG_DIG_Y1                      (0x5E)
+#define BMI160_MAG_DIG_Z4_LSB                  (0x62)
+#define BMI160_MAG_DIG_Z4_MSB                  (0x63)
+#define BMI160_MAG_DIG_X2                      (0x64)
+#define BMI160_MAG_DIG_Y2                      (0x65)
+#define BMI160_MAG_DIG_Z2_LSB                  (0x68)
+#define BMI160_MAG_DIG_Z2_MSB                  (0x69)
+#define BMI160_MAG_DIG_Z1_LSB                  (0x6A)
+#define BMI160_MAG_DIG_Z1_MSB                  (0x6B)
+#define BMI160_MAG_DIG_XYZ1_LSB                (0x6C)
+#define BMI160_MAG_DIG_XYZ1_MSB                (0x6D)
+#define BMI160_MAG_DIG_Z3_LSB                  (0x6E)
+#define BMI160_MAG_DIG_Z3_MSB                  (0x6F)
+#define BMI160_MAG_DIG_XY2                     (0x70)
+#define BMI160_MAG_DIG_XY1                     (0x71)
+/**************************************************/
+/**\name	BMM150 PRE-SET MODE DEFINITIONS     */
+/*************************************************/
+#define BMI160_MAG_PRESETMODE_LOWPOWER                 (1)
+#define BMI160_MAG_PRESETMODE_REGULAR                  (2)
+#define BMI160_MAG_PRESETMODE_HIGHACCURACY             (3)
+#define BMI160_MAG_PRESETMODE_ENHANCED                 (4)
+/**************************************************/
+/**\name	BMM150 PRESET MODES - DATA RATES    */
+/*************************************************/
+#define BMI160_MAG_LOWPOWER_DR                       (0x02)
+#define BMI160_MAG_REGULAR_DR                        (0x02)
+#define BMI160_MAG_HIGHACCURACY_DR                   (0x2A)
+#define BMI160_MAG_ENHANCED_DR                       (0x02)
+/**************************************************/
+/**\name	BMM150 PRESET MODES - REPETITIONS-XY RATES */
+/*************************************************/
+#define BMI160_MAG_LOWPOWER_REPXY                    (1)
+#define BMI160_MAG_REGULAR_REPXY                     (4)
+#define BMI160_MAG_HIGHACCURACY_REPXY                (23)
+#define BMI160_MAG_ENHANCED_REPXY                    (7)
+/**************************************************/
+/**\name	BMM150 PRESET MODES - REPETITIONS-Z RATES */
+/*************************************************/
+#define BMI160_MAG_LOWPOWER_REPZ                     (2)
+#define BMI160_MAG_REGULAR_REPZ                      (14)
+#define BMI160_MAG_HIGHACCURACY_REPZ                 (82)
+#define BMI160_MAG_ENHANCED_REPZ                     (26)
+#define BMI160_MAG_NOAMRL_SWITCH_TIMES               (5)
+#define MAG_INTERFACE_PMU_ENABLE                     (1)
+#define MAG_INTERFACE_PMU_DISABLE                    (0)
+/**************************************************/
+/**\name	USED FOR MAG OVERFLOW CHECK FOR BMM150  */
+/*************************************************/
+#define BMI160_MAG_OVERFLOW_OUTPUT			((s16)-32768)
+#define BMI160_MAG_OVERFLOW_OUTPUT_S32		((s32)(-2147483647-1))
+#define BMI160_MAG_NEGATIVE_SATURATION_Z   ((s16)-32767)
+#define BMI160_MAG_POSITIVE_SATURATION_Z   ((u16)32767)
+#define BMI160_MAG_FLIP_OVERFLOW_ADCVAL		((s16)-4096)
+#define BMI160_MAG_HALL_OVERFLOW_ADCVAL		((s16)-16384)
+/**************************************************/
+/**\name	BMM150 REGISTER DEFINITION */
+/*************************************************/
+#define BMI160_BMM150_CHIP_ID           (0x40)
+#define BMI160_BMM150_POWE_CONTROL_REG	(0x4B)
+#define BMI160_BMM150_POWE_MODE_REG		(0x4C)
+#define BMI160_BMM150_DATA_REG			(0x42)
+#define BMI160_BMM150_XY_REP			(0x51)
+#define BMI160_BMM150_Z_REP				(0x52)
+/**************************************************/
+/**\name	AKM COMPENSATING DATA REGISTERS     */
+/*************************************************/
+#define BMI160_BST_AKM_ASAX		(0x60)
+#define BMI160_BST_AKM_ASAY		(0x61)
+#define BMI160_BST_AKM_ASAZ		(0x62)
+/**************************************************/
+/**\name	AKM POWER MODE SELECTION     */
+/*************************************************/
+#define AKM_POWER_DOWN_MODE			(0)
+#define AKM_SINGLE_MEAS_MODE		(1)
+#define FUSE_ROM_MODE				(2)
+/**************************************************/
+/**\name	SECONDARY_MAG POWER MODE SELECTION    */
+/*************************************************/
+#define BMI160_MAG_FORCE_MODE		(0)
+#define BMI160_MAG_SUSPEND_MODE		(1)
+/**************************************************/
+/**\name	MAG POWER MODE SELECTION    */
+/*************************************************/
+#define	FORCE_MODE		(0)
+#define	SUSPEND_MODE	(1)
+#define	NORMAL_MODE		(2)
+#define MAG_SUSPEND_MODE (1)
+/**************************************************/
+/**\name	FIFO CONFIGURATIONS    */
+/*************************************************/
+#define FIFO_HEADER_ENABLE			(0x01)
+#define FIFO_MAG_ENABLE				(0x01)
+#define FIFO_ACCEL_ENABLE			(0x01)
+#define FIFO_GYRO_ENABLE			(0x01)
+#define FIFO_TIME_ENABLE			(0x01)
+#define FIFO_STOPONFULL_ENABLE		(0x01)
+#define FIFO_WM_INTERRUPT_ENABLE	(0x01)
+#define	BMI160_FIFO_INDEX_LENGTH	(1)
+#define	BMI160_FIFO_TAG_INTR_MASK	(0xFC)
+
+/* FIFO definitions*/
+#define FIFO_HEAD_A        (0x84)
+#define FIFO_HEAD_G        (0x88)
+#define FIFO_HEAD_M        (0x90)
+
+#define FIFO_HEAD_G_A	(0x8C)
+#define FIFO_HEAD_M_A   (0x94)
+#define FIFO_HEAD_M_G   (0x98)
+
+#define FIFO_HEAD_M_G_A		(0x9C)
+
+#define FIFO_HEAD_SENSOR_TIME			(0x44)
+#define FIFO_HEAD_INPUT_CONFIG			(0x48)
+#define FIFO_HEAD_SKIP_FRAME			(0x40)
+#define FIFO_HEAD_OVER_READ_LSB			(0x80)
+#define FIFO_HEAD_OVER_READ_MSB			(0x00)
+
+
+/* FIFO 1024 byte, max fifo frame count not over 150 */
+
+#define	FIFO_INPUT_CONFIG_OVER_LEN  ((s8)-11)
+#define	FIFO_OVER_READ_RETURN		((s8)-10)
+#define	FIFO_SENSORTIME_RETURN		((s8)-9)
+#define	FIFO_SKIP_OVER_LEN			((s8)-8)
+#define	FIFO_M_G_A_OVER_LEN			((s8)-7)
+#define	FIFO_M_G_OVER_LEN			((s8)-6)
+#define	FIFO_M_A_OVER_LEN			((s8)-5)
+#define	FIFO_G_A_OVER_LEN			((s8)-4)
+#define	FIFO_M_OVER_LEN				((s8)-3)
+#define	FIFO_G_OVER_LEN				((s8)-2)
+#define	FIFO_A_OVER_LEN				((s8)-1)
+/**************************************************/
+/**\name	ACCEL POWER MODE    */
+/*************************************************/
+#define ACCEL_MODE_NORMAL	(0x11)
+#define	ACCEL_LOWPOWER		(0X12)
+#define	ACCEL_SUSPEND		(0X10)
+/**************************************************/
+/**\name	GYRO POWER MODE    */
+/*************************************************/
+#define GYRO_MODE_SUSPEND		(0x14)
+#define GYRO_MODE_NORMAL		(0x15)
+#define GYRO_MODE_FASTSTARTUP	(0x17)
+/**************************************************/
+/**\name	MAG POWER MODE    */
+/*************************************************/
+#define MAG_MODE_SUSPEND	(0x18)
+#define MAG_MODE_NORMAL		(0x19)
+#define MAG_MODE_LOWPOWER	(0x1A)
+/**************************************************/
+/**\name	ENABLE/DISABLE BIT VALUES    */
+/*************************************************/
+#define BMI160_ENABLE	(0x01)
+#define BMI160_DISABLE	(0x00)
+/**************************************************/
+/**\name	INTERRUPT EDGE TRIGGER ENABLE    */
+/*************************************************/
+#define BMI160_EDGE		(0x01)
+#define BMI160_LEVEL	(0x00)
+/**************************************************/
+/**\name	INTERRUPT LEVEL ENABLE    */
+/*************************************************/
+#define BMI160_LEVEL_LOW		(0x00)
+#define BMI160_LEVEL_HIGH		(0x01)
+/**************************************************/
+/**\name	INTERRUPT OUTPUT ENABLE    */
+/*************************************************/
+#define BMI160_OPEN_DRAIN	(0x01)
+#define BMI160_PUSH_PULL	(0x00)
+
+/* interrupt output enable*/
+#define BMI160_INPUT	(0x01)
+#define BMI160_OUTPUT	(0x00)
+
+/**************************************************/
+/**\name	INTERRUPT TAP SOURCE ENABLE    */
+/*************************************************/
+#define FILTER_DATA		(0x00)
+#define UNFILTER_DATA	(0x01)
+/**************************************************/
+/**\name	SLOW MOTION/ NO MOTION SELECT   */
+/*************************************************/
+#define SLOW_MOTION		(0x00)
+#define NO_MOTION		(0x01)
+/**************************************************/
+/**\name	SIGNIFICANT MOTION SELECTION   */
+/*************************************************/
+#define ANY_MOTION			(0x00)
+#define SIGNIFICANT_MOTION	(0x01)
+/**************************************************/
+/**\name	LATCH DURATION   */
+/*************************************************/
+#define BMI160_LATCH_DUR_NONE				(0x00)
+#define BMI160_LATCH_DUR_312_5_MICRO_SEC	(0x01)
+#define BMI160_LATCH_DUR_625_MICRO_SEC		(0x02)
+#define BMI160_LATCH_DUR_1_25_MILLI_SEC		(0x03)
+#define BMI160_LATCH_DUR_2_5_MILLI_SEC		(0x04)
+#define BMI160_LATCH_DUR_5_MILLI_SEC		(0x05)
+#define BMI160_LATCH_DUR_10_MILLI_SEC		(0x06)
+#define BMI160_LATCH_DUR_20_MILLI_SEC		(0x07)
+#define BMI160_LATCH_DUR_40_MILLI_SEC		(0x08)
+#define BMI160_LATCH_DUR_80_MILLI_SEC		(0x09)
+#define BMI160_LATCH_DUR_160_MILLI_SEC		(0x0A)
+#define BMI160_LATCH_DUR_320_MILLI_SEC		(0x0B)
+#define BMI160_LATCH_DUR_640_MILLI_SEC		(0x0C)
+#define BMI160_LATCH_DUR_1_28_SEC			(0x0D)
+#define BMI160_LATCH_DUR_2_56_SEC			(0x0E)
+#define BMI160_LATCHED						(0x0F)
+/**************************************************/
+/**\name	GYRO OFFSET MASK DEFINITION   */
+/*************************************************/
+#define BMI160_GYRO_MANUAL_OFFSET_0_7	(0x00FF)
+#define BMI160_GYRO_MANUAL_OFFSET_8_9	(0x0300)
+/**************************************************/
+/**\name	STEP CONFIGURATION MASK DEFINITION   */
+/*************************************************/
+#define BMI160_STEP_CONFIG_0_7		(0x00FF)
+#define BMI160_STEP_CONFIG_8_10		(0x0700)
+#define BMI160_STEP_CONFIG_11_14	(0xF000)
+/**************************************************/
+/**\name	DEFINITION USED FOR DIFFERENT WRITE   */
+/*************************************************/
+#define	BMI160_WRITE_TARGET_PAGE0	(0x00)
+#define	BMI160_WRITE_TARGET_PAGE1	(0x01)
+#define	BMI160_WRITE_ENABLE_PAGE1	(0x01)
+#define	BMI160_MANUAL_DISABLE	    (0x00)
+#define	BMI160_MANUAL_ENABLE	    (0x01)
+#define	BMI160_YAS_DISABLE_RCOIL	(0x00)
+#define	BMI160_ENABLE_MAG_IF_MODE	(0x02)
+#define	BMI160_ENABLE_ANY_MOTION_INTR1	(0x04)
+#define	BMI160_ENABLE_ANY_MOTION_INTR2	(0x04)
+#define	BMI160_MAG_DATA_READ_REG        (0x04)
+#define BMI160_BMM_POWER_MODE_REG		(0x06)
+#define	BMI160_ENABLE_ANY_MOTION_AXIS	(0x07)
+#define	BMI160_ENABLE_LOW_G             (0x08)
+#define	BMI160_YAS532_ACQ_START         (0x11)
+#define	BMI160_YAS_DEVICE_ID_REG        (0x80)
+#define	BMI160_FIFO_GYRO_ENABLE         (0x80)
+#define	BMI160_SIG_MOTION_INTR_ENABLE   (0x01)
+#define	BMI160_STEP_DETECT_INTR_ENABLE  (0x01)
+#define	BMI160_LOW_G_INTR_STAT          (0x01)
+#define BMI160_PULL_UP_DATA             (0x30)
+#define BMI160_FIFO_M_G_A_ENABLE        (0xE0)
+#define BMI160_FIFO_M_G_ENABLE          (0xA0)
+#define BMI160_FIFO_M_A_ENABLE          (0x60)
+#define BMI160_FIFO_G_A_ENABLE          (0xC0)
+#define BMI160_FIFO_A_ENABLE            (0x40)
+#define BMI160_FIFO_M_ENABLE            (0x20)
+
+#define BMI160_SEC_IF_BMM150	(0)
+#define BMI160_SEC_IF_AKM09911	(1)
+#define BMI160_SEC_IF_AKM09912	(2)
+#define BMI160_SEC_IF_YAS532	(3)
+#define BMI160_SEC_IF_YAS537	(4)
+/**************************************************/
+/**\name	MAG INIT DEFINITION  */
+/*************************************************/
+#define BMI160_COMMAND_REG_ONE		(0x37)
+#define BMI160_COMMAND_REG_TWO		(0x9A)
+#define BMI160_COMMAND_REG_THREE	(0xC0)
+#define	RESET_STEP_COUNTER			(0xB2)
+/**************************************************/
+/**\name	BIT SLICE GET AND SET FUNCTIONS  */
+/*************************************************/
+#define BMI160_GET_BITSLICE(regvar, bitname)\
+		((regvar & bitname##__MSK) >> bitname##__POS)
+
+
+#define BMI160_SET_BITSLICE(regvar, bitname, val)\
+		((regvar & ~bitname##__MSK) | \
+		((val<<bitname##__POS)&bitname##__MSK))
+
+/**************************************************/
+/**\name	 FUNCTION DECLARATIONS  */
+/*************************************************/
+/**************************************************/
+/**\name	 FUNCTION FOR BMI160 INITIALIZE  */
+/*************************************************/
+/*!
+ *	@brief
+ *	This function is used for initialize
+ *	bus read and bus write functions
+ *	assign the chip id and device address
+ *	chip id is read in the register 0x00 bit from 0 to 7
+ *
+ *	@param bmi160 : structure pointer
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *	@note
+ *	While changing the parameter of the bmi160_t
+ *	consider the following point:
+ *	Changing the reference value of the parameter
+ *	will changes the local copy or local reference
+ *	make sure your changes will not
+ *	affect the reference value of the parameter
+ *	(Better case don't change the reference value of the parameter)
+ *
+*/
+/* renamed from bmi160_init to avoid conflict with UPM code */
+BMI160_RETURN_FUNCTION_TYPE bmi160_init_bus(struct bmi160_t *bmi160);
+/**************************************************/
+/**\name	 FUNCTION FOR READ AND WRITE REGISTERS  */
+/*************************************************/
+/*!
+ * @brief
+ *	This API write the data to
+ *	the given register
+ *
+ *
+ *	@param v_addr_u8 -> Address of the register
+ *	@param v_data_u8 -> The data from the register
+ *	@param v_len_u8 -> no of bytes to read
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_write_reg(u8 v_addr_u8,
+u8 *v_data_u8, u8 v_len_u8);
+/*!
+ * @brief
+ *	This API reads the data from
+ *	the given register
+ *
+ *
+ *	@param v_addr_u8 -> Address of the register
+ *	@param v_data_u8 -> The data from the register
+ *	@param v_len_u8 -> no of bytes to read
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_reg(u8 v_addr_u8,
+u8 *v_data_u8, u8 v_len_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR ERROR CODES  */
+/*************************************************/
+/*!
+ *	@brief This API used to reads the fatal error
+ *	from the Register 0x02 bit 0
+ *	This flag will be reset only by power-on-reset and soft reset
+ *
+ *
+ *  @param v_fatal_err_u8 : The status of fatal error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fatal_err(u8
+*v_fatal_err_u8);
+/*!
+ *	@brief This API used to read the error code
+ *	from register 0x02 bit 1 to 4
+ *
+ *
+ *  @param v_err_code_u8 : The status of error codes
+ *	error_code  |    description
+ *  ------------|---------------
+ *	0x00        |no error
+ *	0x01        |ACC_CONF error (accel ODR and bandwidth not compatible)
+ *	0x02        |GYR_CONF error (Gyroscope ODR and bandwidth not compatible)
+ *	0x03        |Under sampling mode and interrupt uses pre filtered data
+ *	0x04        |reserved
+ *	0x05        |Selected trigger-readout offset in
+ *    -         |MAG_IF greater than selected ODR
+ *	0x06        |FIFO configuration error for header less mode
+ *	0x07        |Under sampling mode and pre filtered data as FIFO source
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_err_code(u8
+*v_error_code_u8);
+/*!
+ *	@brief This API Reads the i2c error code from the
+ *	Register 0x02 bit 5.
+ *	This error occurred in I2C master detected
+ *
+ *  @param v_i2c_err_code_u8 : The status of i2c fail error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_fail_err(u8
+*v_i2c_error_code_u8);
+ /*!
+ *	@brief This API Reads the dropped command error
+ *	from the register 0x02 bit 6
+ *
+ *
+ *  @param v_drop_cmd_err_u8 : The status of drop command error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_drop_cmd_err(u8
+*v_drop_cmd_err_u8);
+/*!
+ *	@brief This API reads the magnetometer data ready
+ *	interrupt not active.
+ *	It reads from the error register 0x0x2 bit 7
+ *
+ *
+ *
+ *
+ *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_dada_rdy_err(u8
+*v_mag_data_rdy_err_u8);
+/*!
+ *	@brief This API reads the error status
+ *	from the error register 0x02 bit 0 to 7
+ *
+ *  @param v_mag_data_rdy_err_u8 : The status of mag data ready interrupt
+ *  @param v_fatal_er_u8r : The status of fatal error
+ *  @param v_err_code_u8 : The status of error code
+ *  @param v_i2c_fail_err_u8 : The status of I2C fail error
+ *  @param v_drop_cmd_err_u8 : The status of drop command error
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_error_status(u8 *v_fatal_er_u8r,
+u8 *v_err_code_u8, u8 *v_i2c_fail_err_u8,
+u8 *v_drop_cmd_err_u8, u8 *v_mag_data_rdy_err_u8);
+/******************************************************************/
+/**\name	 FUNCTIONS FOR MAG,ACCEL AND GYRO POWER MODE STATUS  */
+/*****************************************************************/
+/*!
+ *	@brief This API reads the magnetometer power mode from
+ *	PMU status register 0x03 bit 0 and 1
+ *
+ *  @param v_mag_power_mode_stat_u8 : The value of mag power mode
+ *	mag_powermode    |   value
+ * ------------------|----------
+ *    SUSPEND        |   0x00
+ *    NORMAL         |   0x01
+ *   LOW POWER       |   0x02
+ *
+ *
+ * @note The power mode of mag set by the 0x7E command register
+ * @note using the function "bmi160_set_command_register()"
+ *  value    |   mode
+ *  ---------|----------------
+ *   0x18    | MAG_MODE_SUSPEND
+ *   0x19    | MAG_MODE_NORMAL
+ *   0x1A    | MAG_MODE_LOWPOWER
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_power_mode_stat(u8
+*v_mag_power_mode_stat_u8);
+/*!
+ *	@brief This API reads the gyroscope power mode from
+ *	PMU status register 0x03 bit 2 and 3
+ *
+ *  @param v_gyro_power_mode_stat_u8 :	The value of gyro power mode
+ *	gyro_powermode   |   value
+ * ------------------|----------
+ *    SUSPEND        |   0x00
+ *    NORMAL         |   0x01
+ *   FAST POWER UP   |   0x03
+ *
+ * @note The power mode of gyro set by the 0x7E command register
+ * @note using the function "bmi160_set_command_register()"
+ *  value    |   mode
+ *  ---------|----------------
+ *   0x14    | GYRO_MODE_SUSPEND
+ *   0x15    | GYRO_MODE_NORMAL
+ *   0x17    | GYRO_MODE_FASTSTARTUP
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_power_mode_stat(u8
+*v_gyro_power_mode_stat_u8);
+/*!
+ *	@brief This API reads the accelerometer power mode from
+ *	PMU status register 0x03 bit 4 and 5
+ *
+ *
+ *  @param v_accel_power_mode_stat_u8 :	The value of accel power mode
+ *	accel_powermode  |   value
+ * ------------------|----------
+ *    SUSPEND        |   0x00
+ *    NORMAL         |   0x01
+ *  LOW POWER        |   0x03
+ *
+ * @note The power mode of accel set by the 0x7E command register
+ * @note using the function "bmi160_set_command_register()"
+ *  value    |   mode
+ *  ---------|----------------
+ *   0x11    | ACCEL_MODE_NORMAL
+ *   0x12    | ACCEL_LOWPOWER
+ *   0x10    | ACCEL_SUSPEND
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_power_mode_stat(u8
+*v_accel_power_mode_stat_u8);
+/*!
+ *	@brief This API switch mag interface to normal mode
+ *	and confirm whether the mode switching done successfully or not
+*
+ *	@return results of bus communication function and current MAG_PMU result
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_interface_normal(void);
+/**************************************************/
+/**\name	 FUNCTION FOR Mag XYZ data read */
+/*************************************************/
+/*!
+ *	@brief This API reads magnetometer data X values
+ *	from the register 0x04 and 0x05
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param v_mag_x_s16 : The value of mag x
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_x(s16 *v_mag_x_s16,
+u8 v_sensor_select_u8);
+/*!
+ *	@brief This API reads magnetometer data Y values
+ *	from the register 0x06 and 0x07
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param v_mag_y_s16 : The value of mag y
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_y(s16 *v_mag_y_s16,
+u8 v_sensor_select_u8);
+/*!
+ *	@brief This API reads magnetometer data Z values
+ *	from the register 0x08 and 0x09
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param v_mag_z_s16 : The value of mag z
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_z(s16 *v_mag_z_s16,
+u8 v_sensor_select_u8);
+/*!
+ *	@brief This API reads magnetometer data RHALL values
+ *	from the register 0x0A and 0x0B
+ *
+ *
+ *  @param v_mag_r_s16 : The value of BMM150 r data
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_r(
+s16 *v_mag_r_s16);
+/*!
+ *	@brief This API reads magnetometer data X,Y,Z values
+ *	from the register 0x04 to 0x09
+ *
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param mag : The value of mag xyz data
+ *  @param v_sensor_select_u8 : Mag selection value
+ *  value    |   sensor
+ *  ---------|----------------
+ *   0       | BMM150
+ *   1       | AKM09911 or AKM09912
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyz(
+struct bmi160_mag_t *mag, u8 v_sensor_select_u8);
+ /*!*
+ *	@brief This API reads magnetometer data X,Y,Z,r
+ *	values from the register 0x04 to 0x0B
+ *
+ *	@brief The mag sensor data read form auxiliary mag
+ *
+ *  @param mag : The value of mag-BMM150 xyzr data
+ *
+ *	@note For mag data output rate configuration use the following function
+ *	@note bmi160_set_mag_output_data_rate()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_mag_xyzr(
+struct bmi160_mag_xyzr_t *mag);
+/**************************************************/
+/**\name	 FUNCTION FOR GYRO XYZ DATA READ  */
+/*************************************************/
+/*!
+ *	@brief This API reads gyro data X values
+ *	form the register 0x0C and 0x0D
+ *
+ *
+ *
+ *
+ *  @param v_gyro_x_s16 : The value of gyro x data
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_x(
+s16 *v_gyro_x_s16);
+/*!
+ *	@brief This API reads gyro data Y values
+ *	form the register 0x0E and 0x0F
+ *
+ *
+ *
+ *
+ *  @param v_gyro_y_s16 : The value of gyro y data
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error result of communication routines
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_y(
+s16 *v_gyro_y_s16);
+/*!
+ *	@brief This API reads gyro data Z values
+ *	form the register 0x10 and 0x11
+ *
+ *
+ *
+ *
+ *  @param v_gyro_z_s16 : The value of gyro z data
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_z(
+s16 *v_gyro_z_s16);
+/*!
+ *	@brief This API reads gyro data X,Y,Z values
+ *	from the register 0x0C to 0x11
+ *
+ *
+ *
+ *
+ *  @param gyro : The value of gyro xyz
+ *
+ *	@note Gyro Configuration use the following function
+ *	@note bmi160_set_gyro_output_data_rate()
+ *	@note bmi160_set_gyro_bw()
+ *	@note bmi160_set_gyro_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_gyro_xyz(
+struct bmi160_gyro_t *gyro);
+/**************************************************/
+/**\name	 FUNCTION FOR ACCEL XYZ DATA READ  */
+/*************************************************/
+/*!
+ *	@brief This API reads accelerometer data X values
+ *	form the register 0x12 and 0x13
+ *
+ *
+ *
+ *
+ *  @param v_accel_x_s16 : The value of accel x
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_x(
+s16 *v_accel_x_s16);
+/*!
+ *	@brief This API reads accelerometer data Y values
+ *	form the register 0x14 and 0x15
+ *
+ *
+ *
+ *
+ *  @param v_accel_y_s16 : The value of accel y
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_y(
+s16 *v_accel_y_s16);
+/*!
+ *	@brief This API reads accelerometer data Z values
+ *	form the register 0x16 and 0x17
+ *
+ *
+ *
+ *
+ *  @param v_accel_z_s16 : The value of accel z
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_z(
+s16 *v_accel_z_s16);
+/*!
+ *	@brief This API reads accelerometer data X,Y,Z values
+ *	from the register 0x12 to 0x17
+ *
+ *
+ *
+ *
+ *  @param accel :The value of accel xyz
+ *
+ *	@note For accel configuration use the following functions
+ *	@note bmi160_set_accel_output_data_rate()
+ *	@note bmi160_set_accel_bw()
+ *	@note bmi160_set_accel_under_sampling_parameter()
+ *	@note bmi160_set_accel_range()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_accel_xyz(
+struct bmi160_accel_t *accel);
+/**************************************************/
+/**\name	 FUNCTION FOR SENSOR TIME */
+/*************************************************/
+/*!
+ *	@brief This API reads sensor_time from the register
+ *	0x18 to 0x1A
+ *
+ *
+ *  @param v_sensor_time_u32 : The value of sensor time
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_sensor_time(
+u32 *v_sensor_time_u32);
+/**************************************************/
+/**\name	 FUNCTION FOR GYRO SLEF TEST  */
+/*************************************************/
+/*!
+ *	@brief This API reads the Gyroscope self test
+ *	status from the register 0x1B bit 1
+ *
+ *
+ *  @param v_gyro_selftest_u8 : The value of gyro self test status
+ *  value    |   status
+ *  ---------|----------------
+ *   0       | Gyroscope self test is running or failed
+ *   1       | Gyroscope self test completed successfully
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest(u8
+*v_gyro_selftest_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR MANUAL INTERFACE  */
+/*************************************************/
+/*!
+ *	@brief This API reads the status of
+ *	mag manual interface operation form the register 0x1B bit 2
+ *
+ *
+ *
+ *  @param v_mag_manual_stat_u8 : The value of mag manual operation status
+ *  value    |   status
+ *  ---------|----------------
+ *   0       | Indicates no manual magnetometer
+ *   -       | interface operation is ongoing
+ *   1       | Indicates manual magnetometer
+ *   -       | interface operation is ongoing
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_operation_stat(u8
+*v_mag_manual_stat_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR FAST OFFSET READY  */
+/*************************************************/
+/*!
+ *	@brief This API reads the fast offset compensation
+ *	status form the register 0x1B bit 3
+ *
+ *
+ *  @param v_foc_rdy_u8 : The status of fast compensation
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_rdy(u8
+*v_foc_rdy_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR NVM READY  */
+/*************************************************/
+/*!
+ * @brief This API Reads the nvm_rdy status from the
+ *	resister 0x1B bit 4
+ *
+ *
+ *  @param v_nvm_rdy_u8 : The value of NVM ready status
+ *  value    |   status
+ *  ---------|----------------
+ *   0       | NVM write operation in progress
+ *   1       | NVM is ready to accept a new write trigger
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_rdy(u8
+*v_nvm_rdy_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR DATA READY FOR MAG, GYRO, AND ACCEL */
+/*************************************************/
+/*!
+ *	@brief This API reads the status of mag data ready
+ *	from the register 0x1B bit 5
+ *	The status get reset when one mag data register is read out
+ *
+ *  @param v_data_rdy_u8 : The value of mag data ready status
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_data_rdy_mag(u8
+*v_data_rdy_u8);
+/*!
+ *	@brief This API reads the status of gyro data ready form the
+ *	register 0x1B bit 6
+ *	The status get reset when gyro data register read out
+ *
+ *
+ *	@param v_data_rdy_u8 :	The value of gyro data ready
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_data_rdy(u8
+*v_data_rdy_u8);
+/*!
+ *	@brief This API reads the status of accel data ready form the
+ *	register 0x1B bit 7
+ *	The status get reset when accel data register read out
+ *
+ *
+ *	@param v_data_rdy_u8 :	The value of accel data ready status
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_data_rdy(u8
+*drdy_acc);
+/**************************************************/
+/**\name	 FUNCTION FOR STEP INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the step detector interrupt status
+ *	from the register 0x1C bit 0
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_step_intr_u8 : The status of step detector interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_step_intr(u8
+*v_step_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR SIGNIFICANT INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the
+ *	significant motion interrupt status
+ *	from the register 0x1C bit 1
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *
+ *  @param v_significant_intr_u8 : The status of step
+ *	motion interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_significant_intr(u8
+*sigmot_intr);
+/**************************************************/
+/**\name	 FUNCTION FOR ANY MOTION INTERRUPT STATUS  */
+/*************************************************/
+ /*!
+ *	@brief This API reads the any motion interrupt status
+ *	from the register 0x1C bit 2
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *  @param v_any_motion_intr_u8 : The status of any-motion interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_any_motion_intr(u8
+*v_any_motion_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR PMU TRIGGER INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the power mode trigger interrupt status
+ *	from the register 0x1C bit 3
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *
+ *  @param v_pmu_trigger_intr_u8 : The status of power mode trigger interrupt
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_pmu_trigger_intr(u8
+*v_pmu_trigger_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR DOUBLE TAB STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the double tab status
+ *	from the register 0x1C bit 4
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_double_tap_intr_u8 :The status of double tab interrupt
+ *
+ *	@note Double tap interrupt can be configured by the following functions
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_double_tap()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat2_tap_first_x()
+ *	@note bmi160_get_stat2_tap_first_y()
+ *	@note bmi160_get_stat2_tap_first_z()
+ *	@note DURATION
+ *	@note bmi160_set_intr_tap_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_tap_thres()
+ *	@note TAP QUIET
+ *	@note bmi160_set_intr_tap_quiet()
+ *	@note TAP SHOCK
+ *	@note bmi160_set_intr_tap_shock()
+ *	@note TAP SOURCE
+ *	@note bmi160_set_intr_tap_source()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_double_tap_intr(u8
+*v_double_tap_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR SINGLE TAB STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the single tab status
+ *	from the register 0x1C bit 5
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the single tab interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt
+ *	signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_single_tap_intr_u8 :The status of single tap interrupt
+ *
+ *	@note Single tap interrupt can be configured by the following functions
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_single_tap()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat2_tap_first_x()
+ *	@note bmi160_get_stat2_tap_first_y()
+ *	@note bmi160_get_stat2_tap_first_z()
+ *	@note DURATION
+ *	@note bmi160_set_intr_tap_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_tap_thres()
+ *	@note TAP QUIET
+ *	@note bmi160_set_intr_tap_quiet()
+ *	@note TAP SHOCK
+ *	@note bmi160_set_intr_tap_shock()
+ *	@note TAP SOURCE
+ *	@note bmi160_set_intr_tap_source()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_single_tap_intr(u8
+*v_single_tap_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR ORIENT INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the orient status
+ *	from the register 0x1C bit 6
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the orient interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_orient_intr_u8 : The status of orient interrupt
+ *
+ *	@note For orient interrupt configuration use the following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat0_orient_intr()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat3_orient_xy()
+ *	@note bmi160_get_stat3_orient_z()
+ *	@note bmi160_set_intr_orient_axes_enable()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_orient()
+ *	@note INTERRUPT OUTPUT
+ *	@note bmi160_set_intr_orient_ud_enable()
+ *	@note THETA
+ *	@note bmi160_set_intr_orient_theta()
+ *	@note HYSTERESIS
+ *	@note bmi160_set_intr_orient_hyst()
+ *	@note BLOCKING
+ *	@note bmi160_set_intr_orient_blocking()
+ *	@note MODE
+ *	@note bmi160_set_intr_orient_mode()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_orient_intr(u8
+*v_orient_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR FLAT INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the flat interrupt status
+ *	from the register 0x1C bit 7
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the flat interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_flat_intr_u8 : The status of  flat interrupt
+ *
+ *	@note For flat configuration use the following functions
+ *	@note STATS
+ *	@note bmi160_get_stat0_flat_intr()
+ *	@note bmi160_get_stat3_flat()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_flat()
+ *	@note THETA
+ *	@note bmi160_set_intr_flat_theta()
+ *	@note HOLD TIME
+ *	@note bmi160_set_intr_flat_hold()
+ *	@note HYSTERESIS
+ *	@note bmi160_set_intr_flat_hyst()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat0_flat_intr(u8
+*v_flat_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR HIGH_G INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the high_g interrupt status
+ *	from the register 0x1D bit 2
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the high g  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be permanently
+ *	latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_high_g_intr_u8 : The status of high_g interrupt
+ *
+ *	@note High_g interrupt configured by following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat1_high_g_intr()
+ *	@note AXIS MAPPING
+ *	@note bmi160_get_stat3_high_g_first_x()
+ *	@note bmi160_get_stat3_high_g_first_y()
+ *	@note bmi160_get_stat3_high_g_first_z()
+ *	@note SIGN MAPPING
+ *	@note bmi160_get_stat3_high_g_first_sign()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_high_g()
+  *	@note HYSTERESIS
+ *	@note bmi160_set_intr_high_g_hyst()
+ *	@note DURATION
+ *	@note bmi160_set_intr_high_g_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_high_g_thres()
+ *	@note SOURCE
+ *	@note bmi160_set_intr_low_high_source()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_high_g_intr(u8
+*v_high_g_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR LOW_G INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads the low g interrupt status
+ *	from the register 0x1D bit 3
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the low g  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_low_g_intr_u8 : The status of low_g interrupt
+ *
+ *	@note Low_g interrupt configured by following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat1_low_g_intr()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_low_g()
+ *	@note SOURCE
+ *	@note bmi160_set_intr_low_high_source()
+ *	@note DURATION
+ *	@note bmi160_set_intr_low_g_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_low_g_thres()
+ *	@note HYSTERESIS
+ *	@note bmi160_set_intr_low_g_hyst()
+ *	@note MODE
+ *	@note bmi160_set_intr_low_g_mode()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_low_g_intr(u8
+*v_low_g_intr_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR DATA READY INTERRUPT STATUS  */
+/*************************************************/
+/*!
+ *	@brief This API reads data ready interrupt status
+ *	from the register 0x1D bit 4
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the  data ready  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_data_rdy_intr_u8 : The status of data ready interrupt
+ *
+ *	@note Data ready interrupt configured by following functions
+ *	@note STATUS
+ *	@note bmi160_get_stat1_data_rdy_intr()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_data_rdy()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_data_rdy_intr(u8
+*v_data_rdy_intr_u8);
+/**************************************************/
+/**\name	 FUNCTIONS FOR FIFO FULL AND WATER MARK INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads data ready FIFO full interrupt status
+ *	from the register 0x1D bit 5
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the FIFO full interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will
+ *	be permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_fifo_full_intr_u8 : The status of fifo full interrupt
+ *
+ *	@note FIFO full interrupt can be configured by following functions
+ *	@note bmi160_set_intr_fifo_full()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_full_intr(u8
+*v_fifo_full_intr_u8);
+/*!
+ *	@brief This API reads data
+ *	 ready FIFO watermark interrupt status
+ *	from the register 0x1D bit 6
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the FIFO watermark interrupt triggers. The
+ *	setting of INT_LATCH controls if the
+ *	interrupt signal and hence the
+ *	respective interrupt flag will be
+ *	permanently latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_fifo_wm_intr_u8 : The status of fifo water mark interrupt
+ *
+ *	@note FIFO full interrupt can be configured by following functions
+ *	@note bmi160_set_intr_fifo_wm()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_fifo_wm_intr(u8
+*v_fifo_wm_intr_u8);
+/**************************************************/
+/**\name	 FUNCTIONS FOR NO MOTION INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads data ready no motion interrupt status
+ *	from the register 0x1D bit 7
+ *	flag is associated with a specific interrupt function.
+ *	It is set when the no motion  interrupt triggers. The
+ *	setting of INT_LATCH controls if the interrupt signal and hence the
+ *	respective interrupt flag will be permanently
+ *	latched, temporarily latched
+ *	or not latched.
+ *
+ *
+ *
+ *
+ *  @param v_nomotion_intr_u8 : The status of no motion interrupt
+ *
+ *	@note No motion interrupt can be configured by following function
+ *	@note STATUS
+ *	@note bmi160_get_stat1_nomotion_intr()
+ *	@note INTERRUPT MAPPING
+ *	@note bmi160_set_intr_nomotion()
+ *	@note DURATION
+ *	@note bmi160_set_intr_slow_no_motion_durn()
+ *	@note THRESHOLD
+ *	@note bmi160_set_intr_slow_no_motion_thres()
+ *	@note SLOW/NO MOTION SELECT
+ *	@note bmi160_set_intr_slow_no_motion_select()
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat1_nomotion_intr(u8
+*nomo_intr);
+/**************************************************/
+/**\name	 FUNCTIONS FOR ANY MOTION FIRST XYZ AND SIGN INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads the status of any motion first x
+ *	from the register 0x1E bit 0
+ *
+ *
+ *  @param v_anymotion_first_x_u8 : The status of any motion first x interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by x axis
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_x(u8
+*v_anymotion_first_x_u8);
+/*!
+ *	@brief This API reads the status of any motion first y interrupt
+ *	from the register 0x1E bit 1
+ *
+ *
+ *
+ *@param v_any_motion_first_y_u8 : The status of any motion first y interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_y(u8
+*v_any_motion_first_y_u8);
+/*!
+ *	@brief This API reads the status of any motion first z interrupt
+ *	from the register 0x1E bit 2
+ *
+ *
+ *
+ *
+ *@param v_any_motion_first_z_u8 : The status of any motion first z interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_first_z(u8
+*v_any_motion_first_z_u8);
+/*!
+ *	@brief This API reads the any motion sign status from the
+ *	register 0x1E bit 3
+ *
+ *
+ *
+ *
+ *  @param v_anymotion_sign_u8 : The status of any motion sign
+ *  value     |  sign
+ * -----------|-------------
+ *   0        | positive
+ *   1        | negative
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_any_motion_sign(u8
+*v_anymotion_sign_u8);
+/**************************************************/
+/**\name	 FUNCTIONS FOR TAP FIRST XYZ AND SIGN INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads the any motion tap first x status from the
+ *	register 0x1E bit 4
+ *
+ *
+ *
+ *
+ *  @param v_tap_first_x_u8 :The status of any motion tap first x
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by x axis
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_x(u8
+*v_tap_first_x_u8);
+/*!
+ *	@brief This API reads the tap first y interrupt status from the
+ *	register 0x1E bit 5
+ *
+ *
+ *
+ *
+ *  @param v_tap_first_y_u8 :The status of tap first y interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_y(u8
+*v_tap_first_y_u8);
+/*!
+ *	@brief This API reads the tap first z interrupt status  from the
+ *	register 0x1E bit 6
+ *
+ *
+ *
+ *
+ *  @param v_tap_first_z_u8 :The status of tap first z interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_first_z(u8
+*v_tap_first_z_u8);
+/*!
+ *	@brief This API reads the tap sign status from the
+ *	register 0x1E bit 7
+ *
+ *
+ *
+ *
+ *  @param v_tap_sign_u8 : The status of tap sign
+ *  value     |  sign
+ * -----------|-------------
+ *   0        | positive
+ *   1        | negative
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat2_tap_sign(u8
+*tap_sign);
+/**************************************************/
+/**\name	 FUNCTIONS FOR HIGH_G FIRST XYZ AND SIGN INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads the high_g first x status from the
+ *	register 0x1F bit 0
+ *
+ *
+ *
+ *
+ *  @param v_high_g_first_x_u8 :The status of high_g first x
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_x(u8
+*v_high_g_first_x_u8);
+/*!
+ *	@brief This API reads the high_g first y status from the
+ *	register 0x1F bit 1
+ *
+ *
+ *
+ *
+ *  @param v_high_g_first_y_u8 : The status of high_g first y
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_y(u8
+*v_high_g_first_y_u8);
+/*!
+ *	@brief This API reads the high_g first z status from the
+ *	register 0x1F bit 3
+ *
+ *
+ *
+ *
+ *  @param v_high_g_first_z_u8 : The status of high_g first z
+ *  value     |  status
+ * -----------|-------------
+ *   0        | not triggered
+ *   1        | triggered by z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_first_z(u8
+*v_high_g_first_z_u8);
+/*!
+ *	@brief This API reads the high sign status from the
+ *	register 0x1F bit 3
+ *
+ *
+ *
+ *
+ *  @param v_high_g_sign_u8 :The status of high sign
+ *  value     |  sign
+ * -----------|-------------
+ *   0        | positive
+ *   1        | negative
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_high_g_sign(u8
+*v_high_g_sign_u8);
+/**************************************************/
+/**\name	 FUNCTIONS FOR ORIENT XY AND Z INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads the status of orient_xy plane
+ *	from the register 0x1F bit 4 and 5
+ *
+ *
+ *  @param v_orient_xy_u8 :The status of orient_xy plane
+ *  value     |  status
+ * -----------|-------------
+ *   0x00     | portrait upright
+ *   0x01     | portrait upside down
+ *   0x02     | landscape left
+ *   0x03     | landscape right
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_xy(u8
+*v_orient_xy_u8);
+/*!
+ *	@brief This API reads the status of orient z plane
+ *	from the register 0x1F bit 6
+ *
+ *
+ *  @param v_orient_z_u8 :The status of orient z
+ *  value     |  status
+ * -----------|-------------
+ *   0x00     | upward looking
+ *   0x01     | downward looking
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_orient_z(u8
+*v_orient_z_u8);
+/**************************************************/
+/**\name	 FUNCTIONS FOR FLAT INTERRUPT STATUS*/
+/*************************************************/
+/*!
+ *	@brief This API reads the flat status from the register
+ *	0x1F bit 7
+ *
+ *
+ *  @param v_flat_u8 : The status of flat interrupt
+ *  value     |  status
+ * -----------|-------------
+ *   0x00     | non flat
+ *   0x01     | flat position
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_stat3_flat(u8
+*flat);
+/**************************************************/
+/**\name	 FUNCTION FOR TEMPERATUE READ */
+/*************************************************/
+/*!
+ *	@brief This API reads the temperature of the sensor
+ *	from the register 0x21 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_temp_s16 : The value of temperature
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_temp(s16
+*v_temp_s16);
+/**************************************************/
+/**\name	 FUNCTION FOR FIFO LENGTH AND FIFO DATA READ */
+/*************************************************/
+/*!
+ *	@brief This API reads the  of the sensor
+ *	form the register 0x23 and 0x24 bit 0 to 7 and 0 to 2
+ *	@brief this byte counter is updated each time a complete frame
+ *	was read or writtern
+ *
+ *
+ *  @param v_fifo_length_u32 : The value of fifo byte counter
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_length(
+u32 *v_fifo_length_u32);
+/*!
+ *	@brief This API reads the fifo data of the sensor
+ *	from the register 0x24
+ *	@brief Data format depends on the setting of register FIFO_CONFIG
+ *
+ *
+ *
+ *  @param v_fifodata_u8 : Pointer holding the fifo data
+ *  @param v_fifo_length_u16 : The value of fifo length maximum
+ *	1024
+ *
+ *	@note For reading FIFO data use the following functions
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_fifo_data(
+u8 *v_fifodata_u8, u16 v_fifo_length_u16);
+/**************************************************/
+/**\name	 FUNCTION FOR ACCEL CONFIGURATIONS */
+/*************************************************/
+/*!
+ *	@brief This API is used to get the
+ *	accel output date rate form the register 0x40 bit 0 to 3
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of accel output date rate
+ *  value |  output data rate
+ * -------|--------------------------
+ *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
+ *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+ *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
+ *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
+ *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
+ *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
+ *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
+ *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
+ *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
+ *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
+ *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
+ *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
+ *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_output_data_rate(
+u8 *v_output_data_rate_u8);
+/*!
+ *	@brief This API is used to set the
+ *	accel output date rate form the register 0x40 bit 0 to 3
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of accel output date rate
+ *  value |  output data rate
+ * -------|--------------------------
+ *	 0    |	BMI160_ACCEL_OUTPUT_DATA_RATE_RESERVED
+ *	 1	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_0_78HZ
+ *	 2	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1_56HZ
+ *	 3    |	BMI160_ACCEL_OUTPUT_DATA_RATE_3_12HZ
+ *	 4    | BMI160_ACCEL_OUTPUT_DATA_RATE_6_25HZ
+ *	 5	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_12_5HZ
+ *	 6	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_25HZ
+ *	 7	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_50HZ
+ *	 8	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_100HZ
+ *	 9	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_200HZ
+ *	 10	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_400HZ
+ *	 11	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_800HZ
+ *	 12	  |	BMI160_ACCEL_OUTPUT_DATA_RATE_1600HZ
+ *
+ *  @param  v_accel_bw_u8 :The value of accel selected accel bandwidth
+ *  value |  output data rate
+ * -------|--------------------------
+ *    0   |  BMI160_ACCEL_OSR4_AVG1
+ *    1   |  BMI160_ACCEL_OSR2_AVG2
+ *    2   |  BMI160_ACCEL_NORMAL_AVG4
+ *    3   |  BMI160_ACCEL_CIC_AVG8
+ *    4   |  BMI160_ACCEL_RES_AVG2
+ *    5   |  BMI160_ACCEL_RES_AVG4
+ *    6   |  BMI160_ACCEL_RES_AVG8
+ *    7   |  BMI160_ACCEL_RES_AVG16
+ *    8   |  BMI160_ACCEL_RES_AVG32
+ *    9   |  BMI160_ACCEL_RES_AVG64
+ *    10  |  BMI160_ACCEL_RES_AVG128
+ *
+ *
+ *
+ *	@note Verify the accel bandwidth before seting the
+ *  output data rate
+ *  bandwidth  | output data rate |  under sampling
+ *-------------|------------------|----------------
+ *   OSR4      |  12.5 TO 1600    |   0
+ *   OSR2      |  12.5 TO 1600    |   0
+ *  NORMAL     |  12.5 TO 1600    |   0
+ *   CIC       |  12.5 TO 1600    |   0
+ *   AVG2      |  0.78 TO 400     |   1
+ *   AVG4      |  0.78 TO 200     |   1
+ *   AVG8      |  0.78 TO 100     |   1
+ *   AVG16     |  0.78 TO 50      |   1
+ *   AVG32     |  0.78 TO 25      |   1
+ *   AVG64     |  0.78 TO 12.5    |   1
+ *   AVG128    |  0.78 TO 6.25    |   1
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_output_data_rate(
+u8 v_output_data_rate_u8, u8 v_accel_bw_u8);
+/*!
+ *	@brief This API is used to get the
+ *	accel bandwidth from the register 0x40 bit 4 to 6
+ *	@brief bandwidth parameter determines filter configuration(acc_us=0)
+ *	and averaging for under sampling mode(acc_us=1)
+ *
+ *
+ *  @param  v_bw_u8 : The value of accel bandwidth
+ *
+ *	@note accel bandwidth depends on under sampling parameter
+ *	@note under sampling parameter cab be set by the function
+ *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
+ *
+ *	@note Filter configuration
+ *  accel_us  | Filter configuration
+ * -----------|---------------------
+ *    0x00    |  OSR4 mode
+ *    0x01    |  OSR2 mode
+ *    0x02    |  normal mode
+ *    0x03    |  CIC mode
+ *    0x04    |  Reserved
+ *    0x05    |  Reserved
+ *    0x06    |  Reserved
+ *    0x07    |  Reserved
+ *
+ *	@note accel under sampling mode
+ *  accel_us  | Under sampling mode
+ * -----------|---------------------
+ *    0x00    |  no averaging
+ *    0x01    |  average 2 samples
+ *    0x02    |  average 4 samples
+ *    0x03    |  average 8 samples
+ *    0x04    |  average 16 samples
+ *    0x05    |  average 32 samples
+ *    0x06    |  average 64 samples
+ *    0x07    |  average 128 samples
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_bw(u8 *v_bw_u8);
+/*!
+ *	@brief This API is used to set the
+ *	accel bandwidth from the register 0x40 bit 4 to 6
+ *	@brief bandwidth parameter determines filter configuration(acc_us=0)
+ *	and averaging for under sampling mode(acc_us=1)
+ *
+ *
+ *  @param  v_bw_u8 : The value of accel bandwidth
+ *
+ *	@note accel bandwidth depends on under sampling parameter
+ *	@note under sampling parameter cab be set by the function
+ *	"BMI160_SET_ACCEL_UNDER_SAMPLING_PARAMETER"
+ *
+ *	@note Filter configuration
+ *  accel_us  | Filter configuration
+ * -----------|---------------------
+ *    0x00    |  OSR4 mode
+ *    0x01    |  OSR2 mode
+ *    0x02    |  normal mode
+ *    0x03    |  CIC mode
+ *    0x04    |  Reserved
+ *    0x05    |  Reserved
+ *    0x06    |  Reserved
+ *    0x07    |  Reserved
+ *
+ *	@note accel under sampling mode
+ *  accel_us  | Under sampling mode
+ * -----------|---------------------
+ *    0x00    |  no averaging
+ *    0x01    |  average 2 samples
+ *    0x02    |  average 4 samples
+ *    0x03    |  average 8 samples
+ *    0x04    |  average 16 samples
+ *    0x05    |  average 32 samples
+ *    0x06    |  average 64 samples
+ *    0x07    |  average 128 samples
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_bw(u8 v_bw_u8);
+/*!
+ *	@brief This API is used to get the accel
+ *	under sampling parameter form the register 0x40 bit 7
+ *
+ *
+ *
+ *
+ *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
+ *	value    | under_sampling
+ * ----------|---------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_under_sampling_parameter(
+u8 *v_accel_under_sampling_u8);
+/*!
+ *	@brief This API is used to set the accel
+ *	under sampling parameter form the register 0x40 bit 7
+ *
+ *
+ *
+ *
+ *	@param  v_accel_under_sampling_u8 : The value of accel under sampling
+ *	value    | under_sampling
+ * ----------|---------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_under_sampling_parameter(
+u8 v_accel_under_sampling_u8);
+/*!
+ *	@brief This API is used to get the ranges
+ *	(g values) of the accel from the register 0x41 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param v_range_u8 : The value of accel g range
+ *	value    | g_range
+ * ----------|-----------
+ *   0x03    | BMI160_ACCEL_RANGE_2G
+ *   0x05    | BMI160_ACCEL_RANGE_4G
+ *   0x08    | BMI160_ACCEL_RANGE_8G
+ *   0x0C    | BMI160_ACCEL_RANGE_16G
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_range(
+u8 *v_range_u8);
+/*!
+ *	@brief This API is used to set the ranges
+ *	(g values) of the accel from the register 0x41 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param v_range_u8 : The value of accel g range
+ *	value    | g_range
+ * ----------|-----------
+ *   0x03    | BMI160_ACCEL_RANGE_2G
+ *   0x05    | BMI160_ACCEL_RANGE_4G
+ *   0x08    | BMI160_ACCEL_RANGE_8G
+ *   0x0C    | BMI160_ACCEL_RANGE_16G
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_range(
+u8 v_range_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR GYRO CONFIGURATIONS */
+/*************************************************/
+/*!
+ *	@brief This API is used to get the
+ *	gyroscope output data rate from the register 0x42 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of gyro output data rate
+ *  value     |      gyro output data rate
+ * -----------|-----------------------------
+ *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
+ *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
+ *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
+ *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
+ *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
+ *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
+ *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
+ *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
+ *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_output_data_rate(
+u8 *gyro_output_typer);
+/*!
+ *	@brief This API is used to set the
+ *	gyroscope output data rate from the register 0x42 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rate_u8 :The value of gyro output data rate
+ *  value     |      gyro output data rate
+ * -----------|-----------------------------
+ *   0x00     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x01     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x02     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x03     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x04     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x05     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x06     | BMI160_GYRO_OUTPUT_DATA_RATE_25HZ
+ *   0x07     | BMI160_GYRO_OUTPUT_DATA_RATE_50HZ
+ *   0x08     | BMI160_GYRO_OUTPUT_DATA_RATE_100HZ
+ *   0x09     | BMI160_GYRO_OUTPUT_DATA_RATE_200HZ
+ *   0x0A     | BMI160_GYRO_OUTPUT_DATA_RATE_400HZ
+ *   0x0B     | BMI160_GYRO_OUTPUT_DATA_RATE_800HZ
+ *   0x0C     | BMI160_GYRO_OUTPUT_DATA_RATE_1600HZ
+ *   0x0D     | BMI160_GYRO_OUTPUT_DATA_RATE_3200HZ
+ *   0x0E     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *   0x0F     | BMI160_GYRO_OUTPUT_DATA_RATE_RESERVED
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_output_data_rate(
+u8 gyro_output_typer);
+/*!
+ *	@brief This API is used to get the
+ *	data of gyro from the register 0x42 bit 4 to 5
+ *
+ *
+ *
+ *
+ *  @param  v_bw_u8 : The value of gyro bandwidth
+ *  value     | gyro bandwidth
+ *  ----------|----------------
+ *   0x00     | BMI160_GYRO_OSR4_MODE
+ *   0x01     | BMI160_GYRO_OSR2_MODE
+ *   0x02     | BMI160_GYRO_NORMAL_MODE
+ *   0x03     | BMI160_GYRO_CIC_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_bw(u8 *v_bw_u8);
+/*!
+ *	@brief This API is used to set the
+ *	data of gyro from the register 0x42 bit 4 to 5
+ *
+ *
+ *
+ *
+ *  @param  v_bw_u8 : The value of gyro bandwidth
+ *  value     | gyro bandwidth
+ *  ----------|----------------
+ *   0x00     | BMI160_GYRO_OSR4_MODE
+ *   0x01     | BMI160_GYRO_OSR2_MODE
+ *   0x02     | BMI160_GYRO_NORMAL_MODE
+ *   0x03     | BMI160_GYRO_CIC_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_bw(u8 v_bw_u8);
+/*!
+ *	@brief This API reads the range
+ *	of gyro from the register 0x43 bit 0 to 2
+ *
+ *  @param  v_range_u8 : The value of gyro range
+ *   value    |    range
+ *  ----------|-------------------------------
+ *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
+ *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
+ *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
+ *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
+ *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_range(
+u8 *v_range_u8);
+/*!
+ *	@brief This API set the range
+ *	of gyro from the register 0x43 bit 0 to 2
+ *
+ *  @param  v_range_u8 : The value of gyro range
+ *   value    |    range
+ *  ----------|-------------------------------
+ *    0x00    | BMI160_GYRO_RANGE_2000_DEG_SEC
+ *    0x01    | BMI160_GYRO_RANGE_1000_DEG_SEC
+ *    0x02    | BMI160_GYRO_RANGE_500_DEG_SEC
+ *    0x03    | BMI160_GYRO_RANGE_250_DEG_SEC
+ *    0x04    | BMI160_GYRO_RANGE_125_DEG_SEC
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_range(
+u8 v_range_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR MAG CONFIGURATIONS */
+/*************************************************/
+/*!
+ *	@brief This API is used to get the
+ *	output data rate of magnetometer from the register 0x44 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rat_u8e : The value of mag output data rate
+ *  value   |    mag output data rate
+ * ---------|---------------------------
+ *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
+ *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
+ *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
+ *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
+ *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
+ *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
+ *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
+ *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
+ *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
+ *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
+ *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
+ *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
+ *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
+ *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
+ *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
+ *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_output_data_rate(u8 *odr);
+/*!
+ *	@brief This API is used to set the
+ *	output data rate of magnetometer from the register 0x44 bit 0 to 3
+ *
+ *
+ *
+ *
+ *  @param  v_output_data_rat_u8e : The value of mag output data rate
+ *  value   |    mag output data rate
+ * ---------|---------------------------
+ *  0x00    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED
+ *  0x01    |BMI160_MAG_OUTPUT_DATA_RATE_0_78HZ
+ *  0x02    |BMI160_MAG_OUTPUT_DATA_RATE_1_56HZ
+ *  0x03    |BMI160_MAG_OUTPUT_DATA_RATE_3_12HZ
+ *  0x04    |BMI160_MAG_OUTPUT_DATA_RATE_6_25HZ
+ *  0x05    |BMI160_MAG_OUTPUT_DATA_RATE_12_5HZ
+ *  0x06    |BMI160_MAG_OUTPUT_DATA_RATE_25HZ
+ *  0x07    |BMI160_MAG_OUTPUT_DATA_RATE_50HZ
+ *  0x08    |BMI160_MAG_OUTPUT_DATA_RATE_100HZ
+ *  0x09    |BMI160_MAG_OUTPUT_DATA_RATE_200HZ
+ *  0x0A    |BMI160_MAG_OUTPUT_DATA_RATE_400HZ
+ *  0x0B    |BMI160_MAG_OUTPUT_DATA_RATE_800HZ
+ *  0x0C    |BMI160_MAG_OUTPUT_DATA_RATE_1600HZ
+ *  0x0D    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED0
+ *  0x0E    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED1
+ *  0x0F    |BMI160_MAG_OUTPUT_DATA_RATE_RESERVED2
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_output_data_rate(u8 odr);
+/**************************************************/
+/**\name	 FUNCTION FOR FIFO CONFIGURATIONS */
+/*************************************************/
+ /*!
+ *	@brief This API is used to read Down sampling
+ *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_gyro(
+u8 *v_fifo_down_gyro_u8);
+ /*!
+ *	@brief This API is used to set Down sampling
+ *	for gyro (2**downs_gyro) in the register 0x45 bit 0 to 2
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_gyro_u8 :The value of gyro fifo down
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_gyro(
+u8 v_fifo_down_gyro_u8);
+/*!
+ *	@brief This API is used to read gyro fifo filter data
+ *	from the register 0x45 bit 3
+ *
+ *
+ *
+ *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
+ *  value      |  gyro_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_fifo_filter_data(
+u8 *v_gyro_fifo_filter_data_u8);
+/*!
+ *	@brief This API is used to set gyro fifo filter data
+ *	from the register 0x45 bit 3
+ *
+ *
+ *
+ *  @param v_gyro_fifo_filter_data_u8 :The value of gyro filter data
+ *  value      |  gyro_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_fifo_filter_data(
+u8 v_gyro_fifo_filter_data_u8);
+/*!
+ *	@brief This API is used to read Down sampling
+ *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_u8 :The value of accel fifo down
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_down_accel(
+u8 *v_fifo_down_u8);
+ /*!
+ *	@brief This API is used to set Down sampling
+ *	for accel (2*downs_accel) from the register 0x45 bit 4 to 6
+ *
+ *
+ *
+ *
+ *  @param v_fifo_down_u8 :The value of accel fifo down
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_down_accel(
+u8 v_fifo_down_u8);
+/*!
+ *	@brief This API is used to read accel fifo filter data
+ *	from the register 0x45 bit 7
+ *
+ *
+ *
+ *  @param v_accel_fifo_filter_u8 :The value of accel filter data
+ *  value      |  accel_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_fifo_filter_data(
+u8 *v_accel_fifo_filter_u8);
+/*!
+ *	@brief This API is used to set accel fifo filter data
+ *	from the register 0x45 bit 7
+ *
+ *
+ *
+ *  @param v_accel_fifo_filter_u8 :The value of accel filter data
+ *  value      |  accel_fifo_filter_data
+ * ------------|-------------------------
+ *    0x00     |  Unfiltered data
+ *    0x01     |  Filtered data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_fifo_filter_data(
+u8 v_accel_fifo_filter_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR FIFO WATER MARK ENABLE */
+/*************************************************/
+/*!
+ *	@brief This API is used to Trigger an interrupt
+ *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_fifo_wm_u8 : The value of fifo water mark level
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_wm(
+u8 *v_fifo_wm_u8);
+/*!
+ *	@brief This API is used to Trigger an interrupt
+ *	when FIFO contains water mark level from the register 0x46 bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_fifo_wm_u8 : The value of fifo water mark level
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_wm(
+u8 v_fifo_wm_u8);
+/**************************************************/
+/**\name	 FUNCTION FOR FIFO CONFIGURATIONS */
+/*************************************************/
+/*!
+ *	@brief This API reads fifo sensor time
+ *	frame after the last valid data frame form the register  0x47 bit 1
+ *
+ *
+ *
+ *
+ *  @param v_fifo_time_enable_u8 : The value of sensor time
+ *  value      |  fifo sensor time
+ * ------------|-------------------------
+ *    0x00     |  do not return sensortime frame
+ *    0x01     |  return sensortime frame
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_time_enable(
+u8 *v_fifo_time_enable_u8);
+/*!
+ *	@brief This API set fifo sensor time
+ *	frame after the last valid data frame form the register  0x47 bit 1
+ *
+ *
+ *
+ *
+ *  @param v_fifo_time_enable_u8 : The value of sensor time
+ *  value      |  fifo sensor time
+ * ------------|-------------------------
+ *    0x00     |  do not return sensortime frame
+ *    0x01     |  return sensortime frame
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_time_enable(
+u8 v_fifo_time_enable_u8);
+/*!
+ *	@brief This API reads FIFO tag interrupt2 enable status
+ *	from the resister 0x47 bit 2
+ *
+ *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr2_enable(
+u8 *v_fifo_tag_intr2_u8);
+/*!
+ *	@brief This API set FIFO tag interrupt2 enable status
+ *	from the resister 0x47 bit 2
+ *
+ *  @param v_fifo_tag_intr2_u8 : The value of fifo tag interrupt
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr2_enable(
+u8 v_fifo_tag_intr2_u8);
+/*!
+ *	@brief This API get FIFO tag interrupt1 enable status
+ *	from the resister 0x47 bit 3
+ *
+ *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_tag_intr1_enable(
+u8 *v_fifo_tag_intr1_u8);
+/*!
+ *	@brief This API set FIFO tag interrupt1 enable status
+ *	from the resister 0x47 bit 3
+ *
+ *  @param v_fifo_tag_intr1_u8 :The value of fifo tag interrupt1
+ *	value    | fifo tag interrupt
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_tag_intr1_enable(
+u8 v_fifo_tag_intr1_u8);
+/*!
+ *	@brief This API reads FIFO frame
+ *	header enable from the register 0x47 bit 4
+ *
+ *  @param v_fifo_header_u8 :The value of fifo header
+ *	value    | fifo header
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_header_enable(
+u8 *v_fifo_header_u8);
+/*!
+ *	@brief This API set FIFO frame
+ *	header enable from the register 0x47 bit 4
+ *
+ *  @param v_fifo_header_u8 :The value of fifo header
+ *	value    | fifo header
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_header_enable(
+u8 v_fifo_header_u8);
+/*!
+ *	@brief This API is used to read stored
+ *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
+ *
+ *  @param v_fifo_mag_u8 : The value of fifo mag enble
+ *	value    | fifo mag
+ * ----------|-------------------
+ *  0x00     |  no magnetometer data is stored
+ *  0x01     |  magnetometer data is stored
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_mag_enable(
+u8 *v_fifo_mag_u8);
+/*!
+ *	@brief This API is used to set stored
+ *	magnetometer data in FIFO (all 3 axes) from the register 0x47 bit 5
+ *
+ *  @param v_fifo_mag_u8 : The value of fifo mag enble
+ *	value    | fifo mag
+ * ----------|-------------------
+ *  0x00     |  no magnetometer data is stored
+ *  0x01     |  magnetometer data is stored
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_mag_enable(
+u8 v_fifo_mag_u8);
+/*!
+ *	@brief This API is used to read stored
+ *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
+ *
+ *  @param v_fifo_accel_u8 : The value of fifo accel enble
+ *	value    | fifo accel
+ * ----------|-------------------
+ *  0x00     |  no accel data is stored
+ *  0x01     |  accel data is stored
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_accel_enable(
+u8 *v_fifo_accel_u8);
+/*!
+ *	@brief This API is used to set stored
+ *	accel data in FIFO (all 3 axes) from the register 0x47 bit 6
+ *
+ *  @param v_fifo_accel_u8 : The value of fifo accel enble
+ *	value    | fifo accel
+ * ----------|-------------------
+ *  0x00     |  no accel data is stored
+ *  0x01     |  accel data is stored
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_accel_enable(
+u8 v_fifo_accel_u8);
+/*!
+ *	@brief This API is used to read stored
+ *	 gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
+ *
+ *
+ *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
+ *	value    | fifo gyro
+ * ----------|-------------------
+ *  0x00     |  no gyro data is stored
+ *  0x01     |  gyro data is stored
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_fifo_gyro_enable(
+u8 *v_fifo_gyro_u8);
+/*!
+ *	@brief This API is used to set stored
+ *	gyro data in FIFO (all 3 axes) from the resister 0x47 bit 7
+ *
+ *
+ *  @param v_fifo_gyro_u8 : The value of fifo gyro enble
+ *	value    | fifo gyro
+ * ----------|-------------------
+ *  0x00     |  no gyro data is stored
+ *  0x01     |  gyro data is stored
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_fifo_gyro_enable(
+u8 v_fifo_gyro_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR MAG I2C ADDRESS SELECTION          */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read
+ *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
+ *
+ *
+ *
+ *
+ *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_device_addr(
+u8 *v_i2c_device_addr_u8);
+/*!
+ *	@brief This API is used to set
+ *	I2C device address of auxiliary mag from the register 0x4B bit 1 to 7
+ *
+ *
+ *
+ *
+ *  @param v_i2c_device_addr_u8 : The value of mag I2C device address
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_device_addr(
+u8 v_i2c_device_addr_u8);
+/*!
+ *	@brief This API is used to read
+ *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
+ *
+ *
+ *
+ *
+ *  @param v_mag_burst_u8 : The data of mag burst read lenth
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_burst(
+u8 *v_mag_burst_u8);
+/*!
+ *	@brief This API is used to set
+ *	Burst data length (1,2,6,8 byte) from the register 0x4C bit 0 to 1
+ *
+ *
+ *
+ *
+ *  @param v_mag_burst_u8 : The data of mag burst read lenth
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_burst(
+u8 v_mag_burst_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR MAG OFFSET         */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read
+ *	trigger-readout offset in units of 2.5 ms. If set to zero,
+ *	the offset is maximum, i.e. after readout a trigger
+ *	is issued immediately. from the register 0x4C bit 2 to 5
+ *
+ *
+ *
+ *
+ *  @param v_mag_offset_u8 : The value of mag offset
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_offset(
+u8 *v_mag_offset_u8);
+/*!
+ *	@brief This API is used to set
+ *	trigger-readout offset in units of 2.5 ms. If set to zero,
+ *	the offset is maximum, i.e. after readout a trigger
+ *	is issued immediately. from the register 0x4C bit 2 to 5
+ *
+ *
+ *
+ *
+ *  @param v_mag_offset_u8 : The value of mag offset
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_offset(
+u8 v_mag_offset_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR MAG MANUAL/AUTO MODE SELECTION          */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read
+ *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
+ *	This implies that the DATA registers are not updated with
+ *	magnetometer values. Accessing magnetometer requires
+ *	the magnetometer in normal mode in PMU_STATUS.
+ *	from the register 0x4C bit 7
+ *
+ *
+ *
+ *  @param v_mag_manual_u8 : The value of mag manual enable
+ *	value    | mag manual
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_manual_enable(
+u8 *v_mag_manual_u8);
+/*!
+ *	@brief This API is used to set
+ *	Enable register access on MAG_IF[2] or MAG_IF[3] writes.
+ *	This implies that the DATA registers are not updated with
+ *	magnetometer values. Accessing magnetometer requires
+ *	the magnetometer in normal mode in PMU_STATUS.
+ *	from the register 0x4C bit 7
+ *
+ *
+ *
+ *  @param v_mag_manual_u8 : The value of mag manual enable
+ *	value    | mag manual
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_manual_enable(
+u8 v_mag_manual_u8);
+/***************************************************************/
+/**\name	FUNCTIONS FOR MAG READ, WRITE AND WRITE DATA ADDRESS  */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read data
+ *	magnetometer address to read from the register 0x4D bit 0 to 7
+ *	@brief It used to provide mag read address of auxiliary mag
+ *
+ *
+ *
+ *
+ *  @param  v_mag_read_addr_u8 : The value of address need to be read
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_read_addr(
+u8 *v_mag_read_addr_u8);
+/*!
+ *	@brief This API is used to set
+ *	magnetometer write address from the register 0x4D bit 0 to 7
+ *	@brief mag write address writes the address of auxiliary mag to write
+ *
+ *
+ *
+ *  @param v_mag_read_addr_u8:
+ *	The data of auxiliary mag address to write data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_read_addr(
+u8 v_mag_read_addr_u8);
+/*!
+ *	@brief This API is used to read
+ *	magnetometer write address from the register 0x4E bit 0 to 7
+ *	@brief mag write address writes the address of auxiliary mag to write
+ *
+ *
+ *
+ *  @param  v_mag_write_addr_u8:
+ *	The data of auxiliary mag address to write data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_addr(
+u8 *v_mag_write_addr_u8);
+/*!
+ *	@brief This API is used to set
+ *	magnetometer write address from the register 0x4E bit 0 to 7
+ *	@brief mag write address writes the address of auxiliary mag to write
+ *
+ *
+ *
+ *  @param  v_mag_write_addr_u8:
+ *	The data of auxiliary mag address to write data
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_addr(
+u8 v_mag_write_addr_u8);
+/*!
+ *	@brief This API is used to read magnetometer write data
+ *	form the resister 0x4F bit 0 to 7
+ *	@brief This writes the data will be wrote to mag
+ *
+ *
+ *
+ *  @param  v_mag_write_data_u8: The value of mag data
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_mag_write_data(
+u8 *v_mag_write_data_u8);
+/*!
+ *	@brief This API is used to set magnetometer write data
+ *	form the resister 0x4F bit 0 to 7
+ *	@brief This writes the data will be wrote to mag
+ *
+ *
+ *
+ *  @param  v_mag_write_data_u8: The value of mag data
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_mag_write_data(
+u8 v_mag_write_data_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT ENABLE OF
+ANY-MOTION XYZ, DOUBLE AND SINGLE TAP, ORIENT AND FLAT         */
+/***************************************************************/
+/*!
+ *	@brief  This API is used to read
+ *	interrupt enable from the register 0x50 bit 0 to 7
+ *
+ *
+ *
+ *
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_ANY_MOTION_X_ENABLE
+ *       1         | BMI160_ANY_MOTION_Y_ENABLE
+ *       2         | BMI160_ANY_MOTION_Z_ENABLE
+ *       3         | BMI160_DOUBLE_TAP_ENABLE
+ *       4         | BMI160_SINGLE_TAP_ENABLE
+ *       5         | BMI160_ORIENT_ENABLE
+ *       6         | BMI160_FLAT_ENABLE
+ *
+ *	@param v_intr_enable_zero_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_0(
+u8 enable, u8 *v_intr_enable_zero_u8);
+/*!
+ *	@brief  This API is used to set
+ *	interrupt enable from the register 0x50 bit 0 to 7
+ *
+ *
+ *
+ *
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_ANY_MOTION_X_ENABLE
+ *       1         | BMI160_ANY_MOTION_Y_ENABLE
+ *       2         | BMI160_ANY_MOTION_Z_ENABLE
+ *       3         | BMI160_DOUBLE_TAP_ENABLE
+ *       4         | BMI160_SINGLE_TAP_ENABLE
+ *       5         | BMI160_ORIENT_ENABLE
+ *       6         | BMI160_FLAT_ENABLE
+ *
+ *	@param v_intr_enable_zero_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_0(
+u8 enable, u8 v_intr_enable_zero_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT ENABLE OF
+HIGH_G XYZ, LOW_G, DATA READY, FIFO FULL AND FIFO WATER MARK  */
+/***************************************************************/
+/*!
+ *	@brief  This API is used to read
+ *	interrupt enable byte1 from the register 0x51 bit 0 to 6
+ *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
+ *	data ready, fifo full and fifo water mark.
+ *
+ *
+ *
+ *  @param  v_enable_u8 :  The value of interrupt enable
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_HIGH_G_X_ENABLE
+ *       1         | BMI160_HIGH_G_Y_ENABLE
+ *       2         | BMI160_HIGH_G_Z_ENABLE
+ *       3         | BMI160_LOW_G_ENABLE
+ *       4         | BMI160_DATA_RDY_ENABLE
+ *       5         | BMI160_FIFO_FULL_ENABLE
+ *       6         | BMI160_FIFO_WM_ENABLE
+ *
+ *	@param v_intr_enable_1_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_1(
+u8 enable, u8 *v_intr_enable_1_u8);
+/*!
+ *	@brief  This API is used to set
+ *	interrupt enable byte1 from the register 0x51 bit 0 to 6
+ *	@brief It read the high_g_x,high_g_y,high_g_z,low_g_enable
+ *	data ready, fifo full and fifo water mark.
+ *
+ *
+ *
+ *  @param  v_enable_u8 :  The value of interrupt enable
+ *	@param v_enable_u8 : Value to decided to select interrupt
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_HIGH_G_X_ENABLE
+ *       1         | BMI160_HIGH_G_Y_ENABLE
+ *       2         | BMI160_HIGH_G_Z_ENABLE
+ *       3         | BMI160_LOW_G_ENABLE
+ *       4         | BMI160_DATA_RDY_ENABLE
+ *       5         | BMI160_FIFO_FULL_ENABLE
+ *       6         | BMI160_FIFO_WM_ENABLE
+ *
+ *	@param v_intr_enable_1_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_1(
+u8 enable, u8 v_intr_enable_1_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT ENABLE OF
+NO MOTION XYZ  */
+/***************************************************************/
+/*!
+ *	@brief  This API is used to read
+ *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
+ *	@brief It reads no motion x,y and z
+ *
+ *
+ *
+ *	@param v_enable_u8: The value of interrupt enable
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_NOMOTION_X_ENABLE
+ *       1         | BMI160_NOMOTION_Y_ENABLE
+ *       2         | BMI160_NOMOTION_Z_ENABLE
+ *
+ *	@param v_intr_enable_2_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_enable_2(
+u8 enable, u8 *v_intr_enable_2_u8);
+/*!
+ *	@brief  This API is used to set
+ *	interrupt enable byte2 from the register bit 0x52 bit 0 to 3
+ *	@brief It reads no motion x,y and z
+ *
+ *
+ *
+ *	@param v_enable_u8: The value of interrupt enable
+ *   v_enable_u8   |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_NOMOTION_X_ENABLE
+ *       1         | BMI160_NOMOTION_Y_ENABLE
+ *       2         | BMI160_NOMOTION_Z_ENABLE
+ *
+ *	@param v_intr_enable_2_u8 : The interrupt enable value
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_enable_2(
+u8 enable, u8 v_intr_enable_2_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT ENABLE OF
+  STEP DETECTOR */
+/***************************************************************/
+ /*!
+ *	@brief This API is used to read
+ *	interrupt enable step detector interrupt from
+ *	the register bit 0x52 bit 3
+ *
+ *
+ *
+ *
+ *	@param v_step_intr_u8 : The value of step detector interrupt enable
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_detector_enable(
+u8 *v_step_intr_u8);
+ /*!
+ *	@brief This API is used to set
+ *	interrupt enable step detector interrupt from
+ *	the register bit 0x52 bit 3
+ *
+ *
+ *
+ *
+ *	@param v_step_intr_u8 : The value of step detector interrupt enable
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_detector_enable(
+u8 v_step_intr_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT CONTROL */
+/***************************************************************/
+/*!
+ *	@brief  Configure trigger condition of interrupt1
+ *	and interrupt2 pin from the register 0x53
+ *	@brief interrupt1 - bit 0
+ *	@brief interrupt2 - bit 4
+ *
+ *  @param v_channel_u8: The value of edge trigger selection
+ *   v_channel_u8  |   Edge trigger
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_EDGE_CTRL
+ *       1         | BMI160_INTR2_EDGE_CTRL
+ *
+ *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_EDGE
+ *  0x00     |  BMI160_LEVEL
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_edge_ctrl(
+u8 v_channel_u8, u8 *v_intr_edge_ctrl_u8);
+/*!
+ *	@brief  Configure trigger condition of interrupt1
+ *	and interrupt2 pin from the register 0x53
+ *	@brief interrupt1 - bit 0
+ *	@brief interrupt2 - bit 4
+ *
+ *  @param v_channel_u8: The value of edge trigger selection
+ *   v_channel_u8  |   Edge trigger
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_EDGE_CTRL
+ *       1         | BMI160_INTR2_EDGE_CTRL
+ *
+ *	@param v_intr_edge_ctrl_u8 : The value of edge trigger enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_EDGE
+ *  0x00     |  BMI160_LEVEL
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_edge_ctrl(
+u8 v_channel_u8, u8 v_intr_edge_ctrl_u8);
+/*!
+ *	@brief  API used for get the Configure level condition of interrupt1
+ *	and interrupt2 pin form the register 0x53
+ *	@brief interrupt1 - bit 1
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of level condition selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_LEVEL
+ *       1         | BMI160_INTR2_LEVEL
+ *
+ *	@param v_intr_level_u8 : The value of level of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_LEVEL_HIGH
+ *  0x00     |  BMI160_LEVEL_LOW
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_level(
+u8 v_channel_u8, u8 *v_intr_level_u8);
+/*!
+ *	@brief  API used for set the Configure level condition of interrupt1
+ *	and interrupt2 pin form the register 0x53
+ *	@brief interrupt1 - bit 1
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of level condition selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_LEVEL
+ *       1         | BMI160_INTR2_LEVEL
+ *
+ *	@param v_intr_level_u8 : The value of level of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_LEVEL_HIGH
+ *  0x00     |  BMI160_LEVEL_LOW
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_level(
+u8 v_channel_u8, u8 v_intr_level_u8);
+/*!
+ *	@brief  API used to get configured output enable of interrupt1
+ *	and interrupt2 from the register 0x53
+ *	@brief interrupt1 - bit 2
+ *	@brief interrupt2 - bit 6
+ *
+ *
+ *  @param v_channel_u8: The value of output type enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_intr_output_type_u8 :
+ *	The value of output type of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_OPEN_DRAIN
+ *  0x00     |  BMI160_PUSH_PULL
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_output_type(
+u8 v_channel_u8, u8 *v_intr_output_type_u8);
+/*!
+ *	@brief  API used to set output enable of interrupt1
+ *	and interrupt2 from the register 0x53
+ *	@brief interrupt1 - bit 2
+ *	@brief interrupt2 - bit 6
+ *
+ *
+ *  @param v_channel_u8: The value of output type enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_intr_output_type_u8 :
+ *	The value of output type of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_OPEN_DRAIN
+ *  0x00     |  BMI160_PUSH_PULL
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_output_type(
+u8 v_channel_u8, u8 v_intr_output_type_u8);
+ /*!
+ *	@brief API used to get the Output enable for interrupt1
+ *	and interrupt1 pin from the register 0x53
+ *	@brief interrupt1 - bit 3
+ *	@brief interrupt2 - bit 7
+ *
+ *  @param v_channel_u8: The value of output enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_output_enable_u8 :
+ *	The value of output enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_output_enable(
+u8 v_channel_u8, u8 *v_output_enable_u8);
+ /*!
+ *	@brief API used to set the Output enable for interrupt1
+ *	and interrupt1 pin from the register 0x53
+ *	@brief interrupt1 - bit 3
+ *	@brief interrupt2 - bit 7
+ *
+ *  @param v_channel_u8: The value of output enable selection
+ *   v_channel_u8  |   level selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_OUTPUT_TYPE
+ *       1         | BMI160_INTR2_OUTPUT_TYPE
+ *
+ *	@param v_output_enable_u8 :
+ *	The value of output enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_output_enable(
+u8 v_channel_u8, u8 v_output_enable_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT LATCH INTERRUPT  */
+/***************************************************************/
+/*!
+*	@brief This API is used to get the latch duration
+*	from the register 0x54 bit 0 to 3
+*	@brief This latch selection is not applicable for data ready,
+*	orientation and flat interrupts.
+*
+*
+*
+*  @param v_latch_intr_u8 : The value of latch duration
+*	Latch Duration                      |     value
+* --------------------------------------|------------------
+*    BMI160_LATCH_DUR_NONE              |      0x00
+*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
+*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
+*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
+*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
+*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
+*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
+*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
+*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
+*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
+*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
+*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
+*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
+*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
+*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
+*    BMI160_LATCHED                     |      0x0F
+*
+*
+*
+*	@return results of bus communication function
+*	@retval 0 -> Success
+*	@retval -1 -> Error
+*
+*
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_latch_intr(
+u8 *v_latch_intr_u8);
+/*!
+*	@brief This API is used to set the latch duration
+*	from the register 0x54 bit 0 to 3
+*	@brief This latch selection is not applicable for data ready,
+*	orientation and flat interrupts.
+*
+*
+*
+*  @param v_latch_intr_u8 : The value of latch duration
+*	Latch Duration                      |     value
+* --------------------------------------|------------------
+*    BMI160_LATCH_DUR_NONE              |      0x00
+*    BMI160_LATCH_DUR_312_5_MICRO_SEC   |      0x01
+*    BMI160_LATCH_DUR_625_MICRO_SEC     |      0x02
+*    BMI160_LATCH_DUR_1_25_MILLI_SEC    |      0x03
+*    BMI160_LATCH_DUR_2_5_MILLI_SEC     |      0x04
+*    BMI160_LATCH_DUR_5_MILLI_SEC       |      0x05
+*    BMI160_LATCH_DUR_10_MILLI_SEC      |      0x06
+*    BMI160_LATCH_DUR_20_MILLI_SEC      |      0x07
+*    BMI160_LATCH_DUR_40_MILLI_SEC      |      0x08
+*    BMI160_LATCH_DUR_80_MILLI_SEC      |      0x09
+*    BMI160_LATCH_DUR_160_MILLI_SEC     |      0x0A
+*    BMI160_LATCH_DUR_320_MILLI_SEC     |      0x0B
+*    BMI160_LATCH_DUR_640_MILLI_SEC     |      0x0C
+*    BMI160_LATCH_DUR_1_28_SEC          |      0x0D
+*    BMI160_LATCH_DUR_2_56_SEC          |      0x0E
+*    BMI160_LATCHED                     |      0x0F
+*
+*
+*
+*	@return results of bus communication function
+*	@retval 0 -> Success
+*	@retval -1 -> Error
+*
+*
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_latch_intr(
+u8 v_latch_intr_u8);
+/*!
+ *	@brief API used to get input enable for interrupt1
+ *	and interrupt2 pin from the register 0x54
+ *	@brief interrupt1 - bit 4
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of input enable selection
+ *   v_channel_u8  |   input selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_INPUT_ENABLE
+ *       1         | BMI160_INTR2_INPUT_ENABLE
+ *
+ *	@param v_input_en_u8 :
+ *	The value of input enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_input_enable(
+u8 v_channel_u8, u8 *v_input_en_u8);
+/*!
+ *	@brief API used to set input enable for interrupt1
+ *	and interrupt2 pin from the register 0x54
+ *	@brief interrupt1 - bit 4
+ *	@brief interrupt2 - bit 5
+ *
+ *  @param v_channel_u8: The value of input enable selection
+ *   v_channel_u8  |   input selection
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_INPUT_ENABLE
+ *       1         | BMI160_INTR2_INPUT_ENABLE
+ *
+ *	@param v_input_en_u8 :
+ *	The value of input enable of interrupt enable
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x01     |  BMI160_INPUT
+ *  0x00     |  BMI160_OUTPUT
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_input_enable(
+u8 v_channel_u8, u8 v_input_en_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR INTERRUPT1 AND INTERRUPT2 MAPPING */
+/***************************************************************/
+ /*!
+ *	@brief reads the Low g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 0 in the register 0x55
+ *	@brief interrupt2 bit 0 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of low_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_LOW_G
+ *       1         | BMI160_INTR2_MAP_LOW_G
+ *
+ *	@param v_intr_low_g_u8 : The value of low_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g(
+u8 v_channel_u8, u8 *v_intr_low_g_u8);
+ /*!
+ *	@brief set the Low g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 0 in the register 0x55
+ *	@brief interrupt2 bit 0 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of low_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_LOW_G
+ *       1         | BMI160_INTR2_MAP_LOW_G
+ *
+ *	@param v_intr_low_g_u8 : The value of low_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g(
+u8 v_channel_u8, u8 v_intr_low_g_u8);
+/*!
+ *	@brief Reads the HIGH g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 1 in the register 0x55
+ *	@brief interrupt2 bit 1 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of high_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_HIGH_G
+ *       1         | BMI160_INTR2_MAP_HIGH_G
+ *
+ *	@param v_intr_high_g_u8 : The value of high_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g(
+u8 v_channel_u8, u8 *v_intr_high_g_u8);
+/*!
+ *	@brief Write the HIGH g interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 1 in the register 0x55
+ *	@brief interrupt2 bit 1 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of high_g selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_HIGH_G
+ *       1         | BMI160_INTR2_MAP_HIGH_G
+ *
+ *	@param v_intr_high_g_u8 : The value of high_g enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g(
+u8 v_channel_u8, u8 v_intr_high_g_u8);
+/*!
+ *	@brief Reads the Any motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 2 in the register 0x55
+ *	@brief interrupt2 bit 2 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of any motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ANY_MOTION
+ *       1         | BMI160_INTR2_MAP_ANY_MOTION
+ *
+ *	@param v_intr_any_motion_u8 : The value of any motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion(
+u8 v_channel_u8, u8 *v_intr_any_motion_u8);
+/*!
+ *	@brief Write the Any motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 2 in the register 0x55
+ *	@brief interrupt2 bit 2 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of any motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ANY_MOTION
+ *       1         | BMI160_INTR2_MAP_ANY_MOTION
+ *
+ *	@param v_intr_any_motion_u8 : The value of any motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion(
+u8 v_channel_u8, u8 v_intr_any_motion_u8);
+/*!
+ *	@brief Reads the No motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 3 in the register 0x55
+ *	@brief interrupt2 bit 3 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of no motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_NOMO
+ *       1         | BMI160_INTR2_MAP_NOMO
+ *
+ *	@param v_intr_nomotion_u8 : The value of no motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_nomotion(
+u8 v_channel_u8, u8 *v_intr_nomotion_u8);
+/*!
+ *	@brief Write the No motion interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 3 in the register 0x55
+ *	@brief interrupt2 bit 3 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of no motion selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_NOMO
+ *       1         | BMI160_INTR2_MAP_NOMO
+ *
+ *	@param v_intr_nomotion_u8 : The value of no motion enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_nomotion(
+u8 v_channel_u8, u8 v_intr_nomotion_u8);
+/*!
+ *	@brief Reads the Double Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 4 in the register 0x55
+ *	@brief interrupt2 bit 4 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of double tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
+ *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
+ *
+ *	@param v_intr_double_tap_u8 : The value of double tap enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_double_tap(
+u8 v_channel_u8, u8 *v_intr_double_tap_u8);
+/*!
+ *	@brief Write the Double Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 4 in the register 0x55
+ *	@brief interrupt2 bit 4 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of double tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DOUBLE_TAP
+ *       1         | BMI160_INTR2_MAP_DOUBLE_TAP
+ *
+ *	@param v_intr_double_tap_u8 : The value of double tap enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_double_tap(
+u8 v_channel_u8, u8 v_intr_double_tap_u8);
+/*!
+ *	@brief Reads the Single Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 5 in the register 0x55
+ *	@brief interrupt2 bit 5 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of single tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_SINGLE_TAP
+ *       1         | BMI160_INTR2_MAP_SINGLE_TAP
+ *
+ *	@param v_intr_single_tap_u8 : The value of single tap  enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_single_tap(
+u8 v_channel_u8, u8 *v_intr_single_tap_u8);
+/*!
+ *	@brief Write the Single Tap interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 5 in the register 0x55
+ *	@brief interrupt2 bit 5 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of single tap interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_SINGLE_TAP
+ *       1         | BMI160_INTR2_MAP_SINGLE_TAP
+ *
+ *	@param v_intr_single_tap_u8 : The value of single tap  enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_single_tap(
+u8 v_channel_u8, u8 v_intr_single_tap_u8);
+/*!
+ *	@brief Reads the Orient interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 6 in the register 0x55
+ *	@brief interrupt2 bit 6 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of orient interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ORIENT
+ *       1         | BMI160_INTR2_MAP_ORIENT
+ *
+ *	@param v_intr_orient_u8 : The value of orient enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient(
+u8 v_channel_u8, u8 *v_intr_orient_u8);
+/*!
+ *	@brief Write the Orient interrupt
+ *	interrupt mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 6 in the register 0x55
+ *	@brief interrupt2 bit 6 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of orient interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_ORIENT
+ *       1         | BMI160_INTR2_MAP_ORIENT
+ *
+ *	@param v_intr_orient_u8 : The value of orient enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient(
+u8 v_channel_u8, u8 v_intr_orient_u8);
+ /*!
+ *	@brief Reads the Flat interrupt
+ *	mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 7 in the register 0x55
+ *	@brief interrupt2 bit 7 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of flat interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FLAT
+ *       1         | BMI160_INTR2_MAP_FLAT
+ *
+ *	@param v_intr_flat_u8 : The value of flat enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat(
+u8 v_channel_u8, u8 *v_intr_flat_u8);
+ /*!
+ *	@brief Write the Flat interrupt
+ *	mapped to interrupt1
+ *	and interrupt2 from the register 0x55 and 0x57
+ *	@brief interrupt1 bit 7 in the register 0x55
+ *	@brief interrupt2 bit 7 in the register 0x57
+ *
+ *
+ *	@param v_channel_u8: The value of flat interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FLAT
+ *       1         | BMI160_INTR2_MAP_FLAT
+ *
+ *	@param v_intr_flat_u8 : The value of flat enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat(
+u8 v_channel_u8, u8 v_intr_flat_u8);
+/*!
+ *	@brief Reads PMU trigger interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 0 and 4
+ *	@brief interrupt1 bit 0 in the register 0x56
+ *	@brief interrupt2 bit 4 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of pmu trigger selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_PMUTRIG
+ *       1         | BMI160_INTR2_MAP_PMUTRIG
+ *
+ *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_pmu_trig(
+u8 v_channel_u8, u8 *v_intr_pmu_trig_u8);
+/*!
+ *	@brief Write PMU trigger interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 0 and 4
+ *	@brief interrupt1 bit 0 in the register 0x56
+ *	@brief interrupt2 bit 4 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of pmu trigger selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_PMUTRIG
+ *       1         | BMI160_INTR2_MAP_PMUTRIG
+ *
+ *	@param v_intr_pmu_trig_u8 : The value of pmu trigger enable
+ *	value    | trigger enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_pmu_trig(
+u8 v_channel_u8, u8 v_intr_pmu_trig_u8);
+/*!
+ *	@brief Reads FIFO Full interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 5 and 1
+ *	@brief interrupt1 bit 5 in the register 0x56
+ *	@brief interrupt2 bit 1 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo full interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_FULL
+ *       1         | BMI160_INTR2_MAP_FIFO_FULL
+ *
+ *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_full(
+u8 v_channel_u8, u8 *v_intr_fifo_full_u8);
+/*!
+ *	@brief Write FIFO Full interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 5 and 1
+ *	@brief interrupt1 bit 5 in the register 0x56
+ *	@brief interrupt2 bit 1 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo full interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_FULL
+ *       1         | BMI160_INTR2_MAP_FIFO_FULL
+ *
+ *	@param v_intr_fifo_full_u8 : The value of fifo full interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_full(
+u8 v_channel_u8, u8 v_intr_fifo_full_u8);
+/*!
+ *	@brief Reads FIFO Watermark interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 6 and 2
+ *	@brief interrupt1 bit 6 in the register 0x56
+ *	@brief interrupt2 bit 2 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo Watermark interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_WM
+ *       1         | BMI160_INTR2_MAP_FIFO_WM
+ *
+ *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_fifo_wm(
+u8 v_channel_u8, u8 *v_intr_fifo_wm_u8);
+/*!
+ *	@brief Write FIFO Watermark interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56 bit 6 and 2
+ *	@brief interrupt1 bit 6 in the register 0x56
+ *	@brief interrupt2 bit 2 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of fifo Watermark interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_FIFO_WM
+ *       1         | BMI160_INTR2_MAP_FIFO_WM
+ *
+ *	@param v_intr_fifo_wm_u8 : The value of fifo Watermark interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_fifo_wm(
+u8 v_channel_u8, u8 v_intr_fifo_wm_u8);
+/*!
+ *	@brief Reads Data Ready interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56
+ *	@brief interrupt1 bit 7 in the register 0x56
+ *	@brief interrupt2 bit 3 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of data ready interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DATA_RDY
+ *       1         | BMI160_INTR2_MAP_DATA_RDY
+ *
+ *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_data_rdy(
+u8 v_channel_u8, u8 *v_intr_data_rdy_u8);
+/*!
+ *	@brief Write Data Ready interrupt mapped to interrupt1
+ *	and interrupt2 form the register 0x56
+ *	@brief interrupt1 bit 7 in the register 0x56
+ *	@brief interrupt2 bit 3 in the register 0x56
+ *
+ *
+ *	@param v_channel_u8: The value of data ready interrupt selection
+ *   v_channel_u8  |   interrupt
+ *  ---------------|---------------
+ *       0         | BMI160_INTR1_MAP_DATA_RDY
+ *       1         | BMI160_INTR2_MAP_DATA_RDY
+ *
+ *	@param v_intr_data_rdy_u8 : The value of data ready interrupt enable
+ *	value    | interrupt enable
+ * ----------|-------------------
+ *  0x01     |  BMI160_ENABLE
+ *  0x00     |  BMI160_DISABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_data_rdy(
+u8 v_channel_u8, u8 v_intr_data_rdy_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR TAP SOURCE CONFIGURATION          */
+/***************************************************************/
+ /*!
+ *	@brief This API reads data source for the interrupt
+ *	engine for the single and double tap interrupts from the register
+ *	0x58 bit 3
+ *
+ *
+ *  @param v_tap_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_source(
+u8 *v_tap_source_u8);
+ /*!
+ *	@brief This API write data source for the interrupt
+ *	engine for the single and double tap interrupts from the register
+ *	0x58 bit 3
+ *
+ *
+ *  @param v_tap_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_source(
+u8 v_tap_source_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR LOW_G AND HIGH_G SOURCE CONFIGURATION */
+/***************************************************************/
+ /*!
+ *	@brief This API Reads Data source for the
+ *	interrupt engine for the low and high g interrupts
+ *	from the register 0x58 bit 7
+ *
+ *  @param v_low_high_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_high_source(
+u8 *v_low_high_source_u8);
+ /*!
+ *	@brief This API write Data source for the
+ *	interrupt engine for the low and high g interrupts
+ *	from the register 0x58 bit 7
+ *
+ *  @param v_low_high_source_u8 : The value of the tap source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_high_source(
+u8 v_low_high_source_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR MOTION SOURCE CONFIGURATION          */
+/***************************************************************/
+ /*!
+ *	@brief This API reads Data source for the
+ *	interrupt engine for the nomotion and anymotion interrupts
+ *	from the register 0x59 bit 7
+ *
+ *  @param v_motion_source_u8 :
+ *	The value of the any/no motion interrupt source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_motion_source(
+u8 *v_motion_source_u8);
+ /*!
+ *	@brief This API write Data source for the
+ *	interrupt engine for the nomotion and anymotion interrupts
+ *	from the register 0x59 bit 7
+ *
+ *  @param v_motion_source_u8 :
+ *	The value of the any/no motion interrupt source
+ *	value    | Description
+ * ----------|-------------------
+ *  0x01     |  UNFILTER_DATA
+ *  0x00     |  FILTER_DATA
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_motion_source(
+u8 v_motion_source_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR LOW_G DURATION CONFIGURATION          */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read the low_g duration from register
+ *	0x5A bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_durn_u8 : The value of low_g duration
+ *
+ *	@note Low_g duration trigger trigger delay according to
+ *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
+ *	the default corresponds delay is 20ms
+ *	@note When low_g data source of interrupt is unfiltered
+ *	the sensor must not be in low power mode
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_durn(
+u8 *v_low_durn_u8);
+ /*!
+ *	@brief This API is used to write the low_g duration from register
+ *	0x5A bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_durn_u8 : The value of low_g duration
+ *
+ *	@note Low_g duration trigger trigger delay according to
+ *	"(v_low_g_durn_u8 * 2.5)ms" in a range from 2.5ms to 640ms.
+ *	the default corresponds delay is 20ms
+ *	@note When low_g data source of interrupt is unfiltered
+ *	the sensor must not be in low power mode
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_durn(
+u8 v_low_durn_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR LOW_G THRESH CONFIGURATION          */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read Threshold
+ *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_thres_u8 : The value of low_g threshold
+ *
+ *	@note Low_g interrupt trigger threshold according to
+ *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
+ *	3.91 mg for v_low_g_thres_u8 = 0
+ *	The threshold range is form 3.91mg to 2.000mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_thres(
+u8 *v_low_g_thres_u8);
+/*!
+ *	@brief This API is used to write Threshold
+ *	definition for the low-g interrupt from the register 0x5B bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_low_g_thres_u8 : The value of low_g threshold
+ *
+ *	@note Low_g interrupt trigger threshold according to
+ *	(v_low_g_thres_u8 * 7.81)mg for v_low_g_thres_u8 > 0
+ *	3.91 mg for v_low_g_thres_u8 = 0
+ *	The threshold range is form 3.91mg to 2.000mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_thres(
+u8 v_low_g_thres_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR LOW_G HYSTERESIS CONFIGURATION     */
+/***************************************************************/
+ /*!
+ *	@brief This API Reads Low-g interrupt hysteresis
+ *	from the register 0x5C bit 0 to 1
+ *
+ *  @param v_low_hyst_u8 :The value of low_g hysteresis
+ *
+ *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_hyst(
+u8 *v_low_hyst_u8);
+ /*!
+ *	@brief This API write Low-g interrupt hysteresis
+ *	from the register 0x5C bit 0 to 1
+ *
+ *  @param v_low_hyst_u8 :The value of low_g hysteresis
+ *
+ *	@note Low_g hysteresis calculated by v_low_hyst_u8*125 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_hyst(
+u8 v_low_hyst_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR LOW_G MODE CONFIGURATION     */
+/***************************************************************/
+/*!
+ *	@brief This API reads Low-g interrupt mode
+ *	from the register 0x5C bit 2
+ *
+ *  @param v_low_g_mode_u8 : The value of low_g mode
+ *	Value    |  Description
+ * ----------|-----------------
+ *	   0     | single-axis
+ *     1     | axis-summing
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_low_g_mode(
+u8 *v_low_g_mode_u8);
+/*!
+ *	@brief This API write Low-g interrupt mode
+ *	from the register 0x5C bit 2
+ *
+ *  @param v_low_g_mode_u8 : The value of low_g mode
+ *	Value    |  Description
+ * ----------|-----------------
+ *	   0     | single-axis
+ *     1     | axis-summing
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_low_g_mode(
+u8 v_low_g_mode_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR HIGH_G HYST CONFIGURATION     */
+/***************************************************************/
+/*!
+ *	@brief This API reads High-g interrupt hysteresis
+ *	from the register 0x5C bit 6 and 7
+ *
+ *  @param v_high_g_hyst_u8 : The value of high hysteresis
+ *
+ *	@note High_g hysteresis changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g hysteresis
+ *  ----------------|---------------------
+ *      2g          |  high_hy*125 mg
+ *      4g          |  high_hy*250 mg
+ *      8g          |  high_hy*500 mg
+ *      16g         |  high_hy*1000 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_hyst(
+u8 *v_high_g_hyst_u8);
+/*!
+ *	@brief This API write High-g interrupt hysteresis
+ *	from the register 0x5C bit 6 and 7
+ *
+ *  @param v_high_g_hyst_u8 : The value of high hysteresis
+ *
+ *	@note High_g hysteresis changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g hysteresis
+ *  ----------------|---------------------
+ *      2g          |  high_hy*125 mg
+ *      4g          |  high_hy*250 mg
+ *      8g          |  high_hy*500 mg
+ *      16g         |  high_hy*1000 mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_hyst(
+u8 v_high_g_hyst_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR HIGH_G DURATION CONFIGURATION     */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read Delay
+ *	time definition for the high-g interrupt from the register
+ *	0x5D bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_high_g_durn_u8 :  The value of high duration
+ *
+ *	@note High_g interrupt delay triggered according to
+ *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_durn(
+u8 *v_high_g_durn_u8);
+/*!
+ *	@brief This API is used to write Delay
+ *	time definition for the high-g interrupt from the register
+ *	0x5D bit 0 to 7
+ *
+ *
+ *
+ *  @param  v_high_g_durn_u8 :  The value of high duration
+ *
+ *	@note High_g interrupt delay triggered according to
+ *	v_high_g_durn_u8 * 2.5ms in a range from 2.5ms to 640ms
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_durn(
+u8 v_high_g_durn_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR HIGH_G THRESHOLD CONFIGURATION     */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read Threshold
+ *	definition for the high-g interrupt from the register 0x5E 0 to 7
+ *
+ *
+ *
+ *
+ *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
+ *	@note High_g threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  v_high_g_thres_u8*7.81 mg
+ *      4g          |  v_high_g_thres_u8*15.63 mg
+ *      8g          |  v_high_g_thres_u8*31.25 mg
+ *      16g         |  v_high_g_thres_u8*62.5 mg
+ *	@note when v_high_g_thres_u8 = 0
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  3.91 mg
+ *      4g          |  7.81 mg
+ *      8g          |  15.63 mg
+ *      16g         |  31.25 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_high_g_thres(
+u8 *v_high_g_thres_u8);
+/*!
+ *	@brief This API is used to write Threshold
+ *	definition for the high-g interrupt from the register 0x5E 0 to 7
+ *
+ *
+ *
+ *
+ *  @param  v_high_g_thres_u8 : Pointer holding the value of Threshold
+ *	@note High_g threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  v_high_g_thres_u8*7.81 mg
+ *      4g          |  v_high_g_thres_u8*15.63 mg
+ *      8g          |  v_high_g_thres_u8*31.25 mg
+ *      16g         |  v_high_g_thres_u8*62.5 mg
+ *	@note when v_high_g_thres_u8 = 0
+ *   accel_range    | high_g threshold
+ *  ----------------|---------------------
+ *      2g          |  3.91 mg
+ *      4g          |  7.81 mg
+ *      8g          |  15.63 mg
+ *      16g         |  31.25 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_high_g_thres(
+u8 v_high_g_thres_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ANY MOTION DURATION CONFIGURATION     */
+/***************************************************************/
+/*!
+ *	@brief This API reads any motion duration
+ *	from the register 0x5F bit 0 and 1
+ *
+ *  @param v_any_motion_durn_u8 : The value of any motion duration
+ *
+ *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_durn(
+u8 *v_any_motion_durn_u8);
+/*!
+ *	@brief This API write any motion duration
+ *	from the register 0x5F bit 0 and 1
+ *
+ *  @param v_any_motion_durn_u8 : The value of any motion duration
+ *
+ *	@note Any motion duration can be calculated by "v_any_motion_durn_u8 + 1"
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_durn(
+u8 nomotion);
+/***************************************************************/
+/**\name	FUNCTION FOR SLOW NO MOTION DURATION CONFIGURATION  */
+/***************************************************************/
+ /*!
+ *	@brief This API read Slow/no-motion
+ *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
+ *
+ *  @param v_slow_no_motion_u8 :The value of slow no motion duration
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *	@note
+ *	@note v_slow_no_motion_u8(5:4)=0b00 ->
+ *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
+ *	@note v_slow_no_motion_u8(5:4)=1 ->
+ *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
+ *	@note v_slow_no_motion_u8(5)='1' ->
+ *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_durn(
+u8 *v_slow_no_motion_u8);
+ /*!
+ *	@brief This API write Slow/no-motion
+ *	interrupt trigger delay duration from the register 0x5F bit 2 to 7
+ *
+ *  @param v_slow_no_motion_u8 :The value of slow no motion duration
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *	@note
+ *	@note v_slow_no_motion_u8(5:4)=0b00 ->
+ *	[v_slow_no_motion_u8(3:0) + 1] * 1.28s (1.28s-20.48s)
+ *	@note v_slow_no_motion_u8(5:4)=1 ->
+ *	[v_slow_no_motion_u8(3:0)+5] * 5.12s (25.6s-102.4s)
+ *	@note v_slow_no_motion_u8(5)='1' ->
+ *	[(v_slow_no_motion_u8:0)+11] * 10.24s (112.64s-430.08s);
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_durn(
+u8 v_slow_no_motion_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ANY MOTION THRESHOLD CONFIGURATION  */
+/***************************************************************/
+/*!
+ *	@brief This API is used to read threshold
+ *	definition for the any-motion interrupt
+ *	from the register 0x60 bit 0 to 7
+ *
+ *
+ *  @param  v_any_motion_thres_u8 : The value of any motion threshold
+ *
+ *	@note any motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_any_motion_thres_u8*3.91 mg
+ *      4g          |  v_any_motion_thres_u8*7.81 mg
+ *      8g          |  v_any_motion_thres_u8*15.63 mg
+ *      16g         |  v_any_motion_thres_u8*31.25 mg
+ *	@note when v_any_motion_thres_u8 = 0
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_any_motion_thres(
+u8 *v_any_motion_thres_u8);
+/*!
+ *	@brief This API is used to write threshold
+ *	definition for the any-motion interrupt
+ *	from the register 0x60 bit 0 to 7
+ *
+ *
+ *  @param  v_any_motion_thres_u8 : The value of any motion threshold
+ *
+ *	@note any motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_any_motion_thres_u8*3.91 mg
+ *      4g          |  v_any_motion_thres_u8*7.81 mg
+ *      8g          |  v_any_motion_thres_u8*15.63 mg
+ *      16g         |  v_any_motion_thres_u8*31.25 mg
+ *	@note when v_any_motion_thres_u8 = 0
+ *   accel_range    | any motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_any_motion_thres(
+u8 v_any_motion_thres_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR SLO/NO MOTION THRESHOLD CONFIGURATION  */
+/***************************************************************/
+ /*!
+ *	@brief This API is used to read threshold
+ *	for the slow/no-motion interrupt
+ *	from the register 0x61 bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
+ *	@note slow no motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
+ *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
+ *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
+ *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
+ *	@note when v_slow_no_motion_thres_u8 = 0
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_thres(
+u8 *v_slow_no_motion_thres_u8);
+ /*!
+ *	@brief This API is used to write threshold
+ *	for the slow/no-motion interrupt
+ *	from the register 0x61 bit 0 to 7
+ *
+ *
+ *
+ *
+ *  @param v_slow_no_motion_thres_u8 : The value of slow no motion threshold
+ *	@note slow no motion threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  v_slow_no_motion_thres_u8*3.91 mg
+ *      4g          |  v_slow_no_motion_thres_u8*7.81 mg
+ *      8g          |  v_slow_no_motion_thres_u8*15.63 mg
+ *      16g         |  v_slow_no_motion_thres_u8*31.25 mg
+ *	@note when v_slow_no_motion_thres_u8 = 0
+ *   accel_range    | slow no motion threshold
+ *  ----------------|---------------------
+ *      2g          |  1.95 mg
+ *      4g          |  3.91 mg
+ *      8g          |  7.81 mg
+ *      16g         |  15.63 mg
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_thres(
+u8 v_slow_no_motion_thres_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR SLO/NO MOTION SELECT CONFIGURATION  */
+/***************************************************************/
+ /*!
+ *	@brief This API is used to read
+ *	the slow/no-motion selection from the register 0x62 bit 0
+ *
+ *
+ *
+ *
+ *  @param  v_intr_slow_no_motion_select_u8 :
+ *	The value of slow/no-motion select
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  SLOW_MOTION
+ *  0x01     |  NO_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_slow_no_motion_select(
+u8 *v_intr_slow_no_motion_select_u8);
+ /*!
+ *	@brief This API is used to write
+ *	the slow/no-motion selection from the register 0x62 bit 0
+ *
+ *
+ *
+ *
+ *  @param  v_intr_slow_no_motion_select_u8 :
+ *	The value of slow/no-motion select
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  SLOW_MOTION
+ *  0x01     |  NO_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_slow_no_motion_select(
+u8 v_intr_slow_no_motion_select_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR SIGNIFICANT MOTION SELECT CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API is used to select
+ *	the significant or any motion interrupt from the register 0x62 bit 1
+ *
+ *
+ *
+ *
+ *  @param  v_intr_significant_motion_select_u8 :
+ *	the value of significant or any motion interrupt selection
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  ANY_MOTION
+ *  0x01     |  SIGNIFICANT_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_select(
+u8 *int_sig_mot_sel);
+ /*!
+ *	@brief This API is used to write, select
+ *	the significant or any motion interrupt from the register 0x62 bit 1
+ *
+ *
+ *
+ *
+ *  @param  v_intr_significant_motion_select_u8 :
+ *	the value of significant or any motion interrupt selection
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  ANY_MOTION
+ *  0x01     |  SIGNIFICANT_MOTION
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_select(
+u8 int_sig_mot_sel);
+ /*!
+ *	@brief This API is used to read
+ *	the significant skip time from the register 0x62 bit  2 and 3
+ *
+ *
+ *
+ *
+ *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  skip time 1.5 seconds
+ *  0x01     |  skip time 3 seconds
+ *  0x02     |  skip time 6 seconds
+ *  0x03     |  skip time 12 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_skip(
+u8 *v_int_sig_mot_skip_u8);
+ /*!
+ *	@brief This API is used to write
+ *	the significant skip time from the register 0x62 bit  2 and 3
+ *
+ *
+ *
+ *
+ *  @param  v_int_sig_mot_skip_u8 : the value of significant skip time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  skip time 1.5 seconds
+ *  0x01     |  skip time 3 seconds
+ *  0x02     |  skip time 6 seconds
+ *  0x03     |  skip time 12 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_skip(
+u8 v_int_sig_mot_skip_u8);
+ /*!
+ *	@brief This API is used to read
+ *	the significant proof time from the register 0x62 bit  4 and 5
+ *
+ *
+ *
+ *
+ *  @param  v_significant_motion_proof_u8 :
+ *	the value of significant proof time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  proof time 0.25 seconds
+ *  0x01     |  proof time 0.5 seconds
+ *  0x02     |  proof time 1 seconds
+ *  0x03     |  proof time 2 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_significant_motion_proof(
+u8 *int_sig_mot_proof);
+ /*!
+ *	@brief This API is used to write
+ *	the significant proof time from the register 0x62 bit  4 and 5
+ *
+ *
+ *
+ *
+ *  @param  v_significant_motion_proof_u8 :
+ *	the value of significant proof time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     |  proof time 0.25 seconds
+ *  0x01     |  proof time 0.5 seconds
+ *  0x02     |  proof time 1 seconds
+ *  0x03     |  proof time 2 seconds
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_significant_motion_proof(
+u8 int_sig_mot_proof);
+/***************************************************************/
+/**\name	FUNCTION FOR TAP DURATION CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API is used to get the tap duration
+ *	from the register 0x63 bit 0 to 2
+ *
+ *
+ *
+ *  @param v_tap_durn_u8 : The value of tap duration
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_DURN_50MS
+ *  0x01     | BMI160_TAP_DURN_100MS
+ *  0x03     | BMI160_TAP_DURN_150MS
+ *  0x04     | BMI160_TAP_DURN_200MS
+ *  0x05     | BMI160_TAP_DURN_250MS
+ *  0x06     | BMI160_TAP_DURN_375MS
+ *  0x07     | BMI160_TAP_DURN_700MS
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_durn(
+u8 *v_tap_durn_u8);
+/*!
+ *	@brief This API is used to write the tap duration
+ *	from the register 0x63 bit 0 to 2
+ *
+ *
+ *
+ *  @param v_tap_durn_u8 : The value of tap duration
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_DURN_50MS
+ *  0x01     | BMI160_TAP_DURN_100MS
+ *  0x03     | BMI160_TAP_DURN_150MS
+ *  0x04     | BMI160_TAP_DURN_200MS
+ *  0x05     | BMI160_TAP_DURN_250MS
+ *  0x06     | BMI160_TAP_DURN_375MS
+ *  0x07     | BMI160_TAP_DURN_700MS
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_durn(
+u8 v_tap_durn_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR TAP SHOCK CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API read the
+ *	tap shock duration from the register 0x63 bit 2
+ *
+ *  @param v_tap_shock_u8 :The value of tap shock
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_SHOCK_50MS
+ *  0x01     | BMI160_TAP_SHOCK_75MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_shock(
+u8 *v_tap_shock_u8);
+ /*!
+ *	@brief This API write the
+ *	tap shock duration from the register 0x63 bit 2
+ *
+ *  @param v_tap_shock_u8 :The value of tap shock
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_SHOCK_50MS
+ *  0x01     | BMI160_TAP_SHOCK_75MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_shock(
+u8 v_tap_shock_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR TAP QUIET CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API read
+ *	tap quiet duration from the register 0x63 bit 7
+ *
+ *
+ *  @param v_tap_quiet_u8 : The value of tap quiet
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_QUIET_30MS
+ *  0x01     | BMI160_TAP_QUIET_20MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_quiet(
+u8 *v_tap_quiet_u8);
+/*!
+ *	@brief This API write
+ *	tap quiet duration from the register 0x63 bit 7
+ *
+ *
+ *  @param v_tap_quiet_u8 : The value of tap quiet
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | BMI160_TAP_QUIET_30MS
+ *  0x01     | BMI160_TAP_QUIET_20MS
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_quiet(
+u8 v_tap_quiet_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR TAP THRESHOLD CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API read Threshold of the
+ *	single/double tap interrupt from the register 0x64 bit 0 to 4
+ *
+ *
+ *	@param v_tap_thres_u8 : The value of single/double tap threshold
+ *
+ *	@note single/double tap threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | single/double tap threshold
+ *  ----------------|---------------------
+ *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
+ *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
+ *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
+ *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_tap_thres(
+u8 *v_tap_thres_u8);
+ /*!
+ *	@brief This API write Threshold of the
+ *	single/double tap interrupt from the register 0x64 bit 0 to 4
+ *
+ *
+ *	@param v_tap_thres_u8 : The value of single/double tap threshold
+ *
+ *	@note single/double tap threshold changes according to accel g range
+ *	accel g range can be set by the function ""
+ *   accel_range    | single/double tap threshold
+ *  ----------------|---------------------
+ *      2g          |  ((v_tap_thres_u8 + 1) * 62.5)mg
+ *      4g          |  ((v_tap_thres_u8 + 1) * 125)mg
+ *      8g          |  ((v_tap_thres_u8 + 1) * 250)mg
+ *      16g         |  ((v_tap_thres_u8 + 1) * 500)mg
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_tap_thres(
+u8 v_tap_thres_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ORIENT MODE CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API read the threshold for orientation interrupt
+ *	from the register 0x65 bit 0 and 1
+ *
+ *  @param v_orient_mode_u8 : The value of threshold for orientation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | symmetrical
+ *  0x01     | high-asymmetrical
+ *  0x02     | low-asymmetrical
+ *  0x03     | symmetrical
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_mode(
+u8 *v_orient_mode_u8);
+ /*!
+ *	@brief This API write the threshold for orientation interrupt
+ *	from the register 0x65 bit 0 and 1
+ *
+ *  @param v_orient_mode_u8 : The value of threshold for orientation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | symmetrical
+ *  0x01     | high-asymmetrical
+ *  0x02     | low-asymmetrical
+ *  0x03     | symmetrical
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_mode(
+u8 v_orient_mode_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ORIENT BLOCKING CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API read the orient blocking mode
+ *	that is used for the generation of the orientation interrupt.
+ *	from the register 0x65 bit 2 and 3
+ *
+ *  @param v_orient_blocking_u8 : The value of orient blocking mode
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | No blocking
+ *  0x01     | Theta blocking or acceleration in any axis > 1.5g
+ *  0x02     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.2g or acceleration in any axis > 1.5g
+ *  0x03     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.4g or acceleration in any axis >
+ *   -       | 1.5g and value of orient is not stable
+ *   -       | for at least 100 ms
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_blocking(
+u8 *v_orient_blocking_u8);
+/*!
+ *	@brief This API write the orient blocking mode
+ *	that is used for the generation of the orientation interrupt.
+ *	from the register 0x65 bit 2 and 3
+ *
+ *  @param v_orient_blocking_u8 : The value of orient blocking mode
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | No blocking
+ *  0x01     | Theta blocking or acceleration in any axis > 1.5g
+ *  0x02     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.2g or acceleration in any axis > 1.5g
+ *  0x03     | Theta blocking or acceleration slope in any axis >
+ *   -       | 0.4g or acceleration in any axis >
+ *   -       | 1.5g and value of orient is not stable
+ *   -       | for at least 100 ms
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_blocking(
+u8 v_orient_blocking_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ORIENT HYSTERESIS CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API read Orient interrupt
+ *	hysteresis, from the register 0x64 bit 4 to 7
+ *
+ *
+ *
+ *  @param v_orient_hyst_u8 : The value of orient hysteresis
+ *
+ *	@note 1 LSB corresponds to 62.5 mg,
+ *	irrespective of the selected accel range
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_hyst(
+u8 *v_orient_hyst_u8);
+/*!
+ *	@brief This API write Orient interrupt
+ *	hysteresis, from the register 0x64 bit 4 to 7
+ *
+ *
+ *
+ *  @param v_orient_hyst_u8 : The value of orient hysteresis
+ *
+ *	@note 1 LSB corresponds to 62.5 mg,
+ *	irrespective of the selected accel range
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_hyst(
+u8 v_orient_hyst_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ORIENT THETA CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API read Orient
+ *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
+ *
+ *  @param v_orient_theta_u8 : The value of Orient blocking angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_theta(
+u8 *v_orient_theta_u8);
+ /*!
+ *	@brief This API write Orient
+ *	blocking angle (0 to 44.8) from the register 0x66 bit 0 to 5
+ *
+ *  @param v_orient_theta_u8 : The value of Orient blocking angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_theta(
+u8 v_orient_theta_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ORIENT OUTPUT ENABLE CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API read orient change
+ *	of up/down bit from the register 0x66 bit 6
+ *
+ *  @param v_orient_ud_u8 : The value of orient change of up/down
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | Is ignored
+ *  0x01     | Generates orientation interrupt
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_ud_enable(
+u8 *v_orient_ud_u8);
+/*!
+ *	@brief This API write orient change
+ *	of up/down bit from the register 0x66 bit 6
+ *
+ *  @param v_orient_ud_u8 : The value of orient change of up/down
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | Is ignored
+ *  0x01     | Generates orientation interrupt
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_ud_enable(
+u8 v_orient_ud_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR ORIENT AXIS ENABLE CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API read orientation axes changes
+ *	from the register 0x66 bit 7
+ *
+ *  @param v_orient_axes_u8 : The value of orient axes assignment
+ *	value    |       Behaviour    | Name
+ * ----------|--------------------|------
+ *  0x00     | x = x, y = y, z = z|orient_ax_noex
+ *  0x01     | x = y, y = z, z = x|orient_ax_ex
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_orient_axes_enable(
+u8 *v_orient_axes_u8);
+ /*!
+ *	@brief This API write orientation axes changes
+ *	from the register 0x66 bit 7
+ *
+ *  @param v_orient_axes_u8 : The value of orient axes assignment
+ *	value    |       Behaviour    | Name
+ * ----------|--------------------|------
+ *  0x00     | x = x, y = y, z = z|orient_ax_noex
+ *  0x01     | x = y, y = z, z = x|orient_ax_ex
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_orient_axes_enable(
+u8 v_orient_axes_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR FLAT THETA CONFIGURATION*/
+/***************************************************************/
+ /*!
+ *	@brief This API read Flat angle (0 to 44.8) for flat interrupt
+ *	from the register 0x67 bit 0 to 5
+ *
+ *  @param v_flat_theta_u8 : The value of flat angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_theta(
+u8 *v_flat_theta_u8);
+ /*!
+ *	@brief This API write Flat angle (0 to 44.8) for flat interrupt
+ *	from the register 0x67 bit 0 to 5
+ *
+ *  @param v_flat_theta_u8 : The value of flat angle
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_theta(
+u8 v_flat_theta_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR FLAT HOLD CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API read Flat interrupt hold time;
+ *	from the register 0x68 bit 4 and 5
+ *
+ *  @param v_flat_hold_u8 : The value of flat hold time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | 0ms
+ *  0x01     | 512ms
+ *  0x01     | 1024ms
+ *  0x01     | 2048ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hold(
+u8 *v_flat_hold_u8);
+/*!
+ *	@brief This API write Flat interrupt hold time;
+ *	from the register 0x68 bit 4 and 5
+ *
+ *  @param v_flat_hold_u8 : The value of flat hold time
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | 0ms
+ *  0x01     | 512ms
+ *  0x01     | 1024ms
+ *  0x01     | 2048ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hold(
+u8 v_flat_hold_u8);
+/***************************************************************/
+/**\name	FUNCTION FOR FLAT HYSTERESIS CONFIGURATION*/
+/***************************************************************/
+/*!
+ *	@brief This API read flat interrupt hysteresis
+ *	from the register 0x68 bit 0 to 3
+ *
+ *  @param v_flat_hyst_u8 : The value of flat hysteresis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_intr_flat_hyst(
+u8 *v_flat_hyst_u8);
+/*!
+ *	@brief This API write flat interrupt hysteresis
+ *	from the register 0x68 bit 0 to 3
+ *
+ *  @param v_flat_hyst_u8 : The value of flat hysteresis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_intr_flat_hyst(
+u8 v_flat_hyst_u8);
+/***************************************************************/
+/**\name	FUNCTION FAST OFFSET COMPENSATION FOR ACCEL */
+/***************************************************************/
+ /*!
+ *	@brief This API read accel offset compensation
+ *	target value for z-axis from the register 0x69 bit 0 and 1
+ *
+ *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_z(
+u8 *v_foc_accel_z_u8);
+ /*!
+ *	@brief This API write accel offset compensation
+ *	target value for z-axis from the register 0x69 bit 0 and 1
+ *
+ *  @param v_foc_accel_z_u8 : the value of accel offset compensation z axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_z(
+u8 v_foc_accel_z_u8);
+/*!
+ *	@brief This API read accel offset compensation
+ *	target value for y-axis
+ *	from the register 0x69 bit 2 and 3
+ *
+ *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_y(
+u8 *v_foc_accel_y_u8);
+/*!
+ *	@brief This API write accel offset compensation
+ *	target value for y-axis
+ *	from the register 0x69 bit 2 and 3
+ *
+ *  @param v_foc_accel_y_u8 : the value of accel offset compensation y axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_y(
+u8 v_foc_accel_y_u8);
+/*!
+ *	@brief This API read accel offset compensation
+ *	target value for x-axis is
+ *	from the register 0x69 bit 4 and 5
+ *
+ *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_accel_x(
+u8 *v_foc_accel_x_u8);
+/*!
+ *	@brief This API write accel offset compensation
+ *	target value for x-axis is
+ *	from the register 0x69 bit 4 and 5
+ *
+ *  @param v_foc_accel_x_u8 : the value of accel offset compensation x axis
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_accel_x(
+u8 v_foc_accel_x_u8);
+/***************************************************************/
+/**\name	FUNCTION FAST OFFSET COMPENSATION FOR GYRO */
+/***************************************************************/
+/*!
+ *	@brief This API write gyro fast offset enable
+ *	from the register 0x69 bit 6
+ *
+ *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
+ *  value    |  Description
+ * ----------|-------------
+ *    0      | fast offset compensation disabled
+ *    1      |  fast offset compensation enabled
+ *
+ *	@param v_gyro_off_x_s16 : The value of gyro fast offset x axis data
+ *	@param v_gyro_off_y_s16 : The value of gyro fast offset y axis data
+ *	@param v_gyro_off_z_s16 : The value of gyro fast offset z axis data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_foc_gyro_enable(
+u8 v_foc_gyro_u8, s16 *v_gyro_off_x_s16,
+s16 *v_gyro_off_y_s16, s16 *v_gyro_off_z_s16);
+/***************************************************/
+/**\name	FUNCTION FOR NVM*/
+/***************************************************/
+ /*!
+ *	@brief This API read NVM program enable
+ *	from the register 0x6A bit 1
+ *
+ *  @param v_nvm_prog_u8 : The value of NVM program enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_prog_enable(
+u8 *v_nvm_prog_u8);
+ /*!
+ *	@brief This API write NVM program enable
+ *	from the register 0x6A bit 1
+ *
+ *  @param v_nvm_prog_u8 : The value of NVM program enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_prog_enable(
+u8 v_nvm_prog_u8);
+/***************************************************/
+/**\name	FUNCTION FOR SPI MODE*/
+/***************************************************/
+/*!
+ * @brief This API read to configure SPI
+ * Interface Mode for primary and OIS interface
+ * from the register 0x6B bit 0
+ *
+ *  @param v_spi3_u8 : The value of SPI mode selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  SPI 4-wire mode
+ *   1     |  SPI 3-wire mode
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi3(
+u8 *v_spi3_u8);
+/*!
+ * @brief This API write to configure SPI
+ * Interface Mode for primary and OIS interface
+ * from the register 0x6B bit 0
+ *
+ *  @param v_spi3_u8 : The value of SPI mode selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  SPI 4-wire mode
+ *   1     |  SPI 3-wire mode
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi3(
+u8 v_spi3_u8);
+/***************************************************/
+/**\name	FUNCTION FOR FOC GYRO */
+/***************************************************/
+/*!
+ *	@brief This API read gyro fast offset enable
+ *	from the register 0x69 bit 6
+ *
+ *  @param v_foc_gyro_u8 : The value of gyro fast offset enable
+ *  value    |  Description
+ * ----------|-------------
+ *    0      | fast offset compensation disabled
+ *    1      |  fast offset compensation enabled
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_foc_gyro_enable(
+u8 *v_foc_gyro_u8);
+/***************************************************/
+/**\name	FUNCTION FOR I2C WATCHDOG TIMBER */
+/***************************************************/
+/*!
+ *	@brief This API read I2C Watchdog timer
+ *	from the register 0x70 bit 1
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  I2C watchdog v_timeout_u8 after 1 ms
+ *   1     |  I2C watchdog v_timeout_u8 after 50 ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_select(
+u8 *v_i2c_wdt_u8);
+/*!
+ *	@brief This API write I2C Watchdog timer
+ *	from the register 0x70 bit 1
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watch dog timer
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  I2C watchdog v_timeout_u8 after 1 ms
+ *   1     |  I2C watchdog v_timeout_u8 after 50 ms
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE
+bmi160_set_i2c_wdt_select(u8 v_i2c_wdt_u8);
+/*!
+ *	@brief This API read I2C watchdog enable
+ *	from the register 0x70 bit 2
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_i2c_wdt_enable(
+u8 *v_i2c_wdt_u8);
+/*!
+ *	@brief This API write I2C watchdog enable
+ *	from the register 0x70 bit 2
+ *
+ *  @param v_i2c_wdt_u8 : The value of I2C watchdog enable
+ *  Value  |  Description
+ * --------|-------------
+ *   0     |  DISABLE
+ *   1     |  ENABLE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_i2c_wdt_enable(
+u8 v_i2c_wdt_u8);
+/***************************************************/
+/**\name	FUNCTION FOR IF MODE*/
+/***************************************************/
+/*!
+ * @brief This API read I2C interface configuration(if) moe
+ * from the register 0x6B bit 4 and 5
+ *
+ *  @param  v_if_mode_u8 : The value of interface configuration mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  |  Primary interface:autoconfig / secondary interface:off
+ *   0x01  |  Primary interface:I2C / secondary interface:OIS
+ *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
+ *   0x03  |   Reserved
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_if_mode(
+u8 *v_if_mode_u8);
+/*!
+ * @brief This API write I2C interface configuration(if) moe
+ * from the register 0x6B bit 4 and 5
+ *
+ *  @param  v_if_mode_u8 : The value of interface configuration mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  |  Primary interface:autoconfig / secondary interface:off
+ *   0x01  |  Primary interface:I2C / secondary interface:OIS
+ *   0x02  |  Primary interface:autoconfig/secondary interface:Magnetometer
+ *   0x03  |   Reserved
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_if_mode(
+u8 v_if_mode_u8);
+/***************************************************/
+/**\name	FUNCTION FOR GYRO SLEEP TRIGGER INTERRUPT CONFIGURATION*/
+/***************************************************/
+/*!
+ *	@brief This API read gyro sleep trigger
+ *	from the register 0x6C bit 0 to 2
+ *
+ *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
+ *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
+ *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
+ *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
+ *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
+ *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
+ *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
+ *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_trigger(
+u8 *v_gyro_sleep_trigger_u8);
+/*!
+ *	@brief This API write gyro sleep trigger
+ *	from the register 0x6C bit 0 to 2
+ *
+ *  @param v_gyro_sleep_trigger_u8 : The value of gyro sleep trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | nomotion: no / Not INT1 pin: no / INT2 pin: no
+ *   0x01  | nomotion: no / Not INT1 pin: no / INT2 pin: yes
+ *   0x02  | nomotion: no / Not INT1 pin: yes / INT2 pin: no
+ *   0x03  | nomotion: no / Not INT1 pin: yes / INT2 pin: yes
+ *   0x04  | nomotion: yes / Not INT1 pin: no / INT2 pin: no
+ *   0x05  | anymotion: yes / Not INT1 pin: no / INT2 pin: yes
+ *   0x06  | anymotion: yes / Not INT1 pin: yes / INT2 pin: no
+ *   0x07  | anymotion: yes / Not INT1 pin: yes / INT2 pin: yes
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_trigger(
+u8 v_gyro_sleep_trigger_u8);
+/*!
+ *	@brief This API read gyro wakeup trigger
+ *	from the register 0x6C bit 3 and 4
+ *
+ *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | anymotion: no / INT1 pin: no
+ *   0x01  | anymotion: no / INT1 pin: yes
+ *   0x02  | anymotion: yes / INT1 pin: no
+ *   0x03  | anymotion: yes / INT1 pin: yes
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_trigger(
+u8 *v_gyro_wakeup_trigger_u8);
+/*!
+ *	@brief This API write gyro wakeup trigger
+ *	from the register 0x6C bit 3 and 4
+ *
+ *  @param v_gyro_wakeup_trigger_u8 : The value of gyro wakeup trigger
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | anymotion: no / INT1 pin: no
+ *   0x01  | anymotion: no / INT1 pin: yes
+ *   0x02  | anymotion: yes / INT1 pin: no
+ *   0x03  | anymotion: yes / INT1 pin: yes
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_trigger(
+u8 v_gyro_wakeup_trigger_u8);
+/*!
+ *	@brief This API read Target state for gyro sleep mode
+ *	from the register 0x6C bit 5
+ *
+ *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | Sleep transition to fast wake up state
+ *   0x01  | Sleep transition to suspend state
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_sleep_state(
+u8 *v_gyro_sleep_state_u8);
+/*!
+ *	@brief This API write Target state for gyro sleep mode
+ *	from the register 0x6C bit 5
+ *
+ *  @param v_gyro_sleep_state_u8 : The value of gyro sleep mode
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | Sleep transition to fast wake up state
+ *   0x01  | Sleep transition to suspend state
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_sleep_state(
+u8 v_gyro_sleep_state_u8);
+/*!
+ *	@brief This API read gyro wakeup interrupt
+ *	from the register 0x6C bit 6
+ *
+ *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | DISABLE
+ *   0x01  | ENABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_wakeup_intr(
+u8 *v_gyro_wakeup_intr_u8);
+/*!
+ *	@brief This API write gyro wakeup interrupt
+ *	from the register 0x6C bit 6
+ *
+ *  @param v_gyro_wakeup_intr_u8 : The valeu of gyro wakeup interrupt
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | DISABLE
+ *   0x01  | ENABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_wakeup_intr(
+u8 v_gyro_wakeup_intr_u8);
+/***************************************************/
+/**\name	FUNCTION FOR ACCEL SELF TEST */
+/***************************************************/
+/*!
+ * @brief This API read accel select axis to be self-test
+ *
+ *  @param v_accel_selftest_axis_u8 :
+ *	The value of accel self test axis selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | disabled
+ *   0x01  | x-axis
+ *   0x02  | y-axis
+ *   0x03  | z-axis
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_axis(
+u8 *acc_selftest_axis);
+/*!
+ * @brief This API write accel select axis to be self-test
+ *
+ *  @param v_accel_selftest_axis_u8 :
+ *	The value of accel self test axis selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | disabled
+ *   0x01  | x-axis
+ *   0x02  | y-axis
+ *   0x03  | z-axis
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_axis(
+u8 acc_selftest_axis);
+/*!
+ *	@brief This API read accel self test axis sign
+ *	from the register 0x6D bit 2
+ *
+ *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | negative
+ *   0x01  | positive
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_sign(
+u8 *acc_selftest_sign);
+/*!
+ *	@brief This API write accel self test axis sign
+ *	from the register 0x6D bit 2
+ *
+ *  @param v_accel_selftest_sign_u8: The value of accel self test axis sign
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | negative
+ *   0x01  | positive
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_sign(
+u8 acc_selftest_sign);
+/*!
+ *	@brief This API read accel self test amplitude
+ *	from the register 0x6D bit 3
+ *        select amplitude of the selftest deflection:
+ *
+ *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | LOW
+ *   0x01  | HIGH
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_selftest_amp(
+u8 *acc_selftest_amp);
+/*!
+ *	@brief This API write accel self test amplitude
+ *	from the register 0x6D bit 3
+ *        select amplitude of the selftest deflection:
+ *
+ *  @param v_accel_selftest_amp_u8 : The value of accel self test amplitude
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | LOW
+ *   0x01  | HIGH
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_selftest_amp(
+u8 acc_selftest_amp);
+/***************************************************/
+/**\name	FUNCTION FOR GYRO SELF TEST */
+/***************************************************/
+/*!
+ *	@brief This API read gyro self test trigger
+ *
+ *	@param v_gyro_selftest_start_u8: The value of gyro self test start
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_selftest_start(
+u8 *v_gyro_selftest_start_u8);
+/*!
+ *	@brief This API write gyro self test trigger
+ *
+ *	@param v_gyro_selftest_start_u8: The value of gyro self test start
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_selftest_start(
+u8 v_gyro_selftest_start_u8);
+/***************************************************/
+/**\name	FUNCTION FOR SPI/I2C ENABLE */
+/***************************************************/
+ /*!
+ * @brief This API read primary interface selection I2C or SPI
+ *	from the register 0x70 bit 0
+ *
+ *  @param v_spi_enable_u8: The value of Interface selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | I2C Enable
+ *   0x01  | I2C DISBALE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_spi_enable(
+u8 *v_spi_enable_u8);
+ /*!
+ * @brief This API write primary interface selection I2C or SPI
+ *	from the register 0x70 bit 0
+ *
+ *  @param v_spi_enable_u8: The value of Interface selection
+ *  Value  |  Description
+ * --------|-------------
+ *   0x00  | I2C Enable
+ *   0x01  | I2C DISBALE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_spi_enable(
+u8 v_spi_enable_u8);
+ /*!
+ *	@brief This API read the spare zero
+ *	form register 0x70 bit 3
+ *
+ *
+ *  @param v_spare0_trim_u8: The value of spare zero
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_spare0_trim
+(u8 *v_spare0_trim_u8);
+ /*!
+ *	@brief This API write the spare zero
+ *	form register 0x70 bit 3
+ *
+ *
+ *  @param v_spare0_trim_u8: The value of spare zero
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_spare0_trim
+(u8 v_spare0_trim_u8);
+/***************************************************/
+/**\name	FUNCTION FOR NVM COUNTER */
+/***************************************************/
+ /*!
+ *	@brief This API read the NVM counter
+ *	form register 0x70 bit 4 to 7
+ *
+ *
+ *  @param v_nvm_counter_u8: The value of NVM counter
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_nvm_counter(
+u8 *v_nvm_counter_u8);
+ /*!
+ *	@brief This API write the NVM counter
+ *	form register 0x70 bit 4 to 7
+ *
+ *
+ *  @param v_nvm_counter_u8: The value of NVM counter
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_nvm_counter(
+u8 v_nvm_counter_u8);
+/***************************************************/
+/**\name	FUNCTION FOR ACCEL MANUAL OFFSET COMPENSATION */
+/***************************************************/
+/*!
+ *	@brief This API read accel manual offset compensation of x axis
+ *	from the register 0x71 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_x_s8:
+ *	The value of accel manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_xaxis(
+s8 *v_accel_off_x_s8);
+/*!
+ *	@brief This API write accel manual offset compensation of x axis
+ *	from the register 0x71 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_x_s8:
+ *	The value of accel manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_xaxis(
+s8 v_accel_off_x_s8);
+/*!
+ *	@brief This API read accel manual offset compensation of y axis
+ *	from the register 0x72 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_y_s8:
+ *	The value of accel manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_yaxis(
+s8 *v_accel_off_y_s8);
+/*!
+ *	@brief This API write accel manual offset compensation of y axis
+ *	from the register 0x72 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_y_s8:
+ *	The value of accel manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_yaxis(
+s8 v_accel_off_y_s8);
+/*!
+ *	@brief This API read accel manual offset compensation of z axis
+ *	from the register 0x73 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_z_s8:
+ *	The value of accel manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_compensation_zaxis(
+s8 *v_accel_off_z_s8);
+/*!
+ *	@brief This API write accel manual offset compensation of z axis
+ *	from the register 0x73 bit 0 to 7
+ *
+ *
+ *
+ *  @param v_accel_off_z_s8:
+ *	The value of accel manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_compensation_zaxis(
+s8 v_accel_off_z_s8);
+/***************************************************/
+/**\name	FUNCTION FOR GYRO MANUAL OFFSET COMPENSATION */
+/***************************************************/
+/*!
+ *	@brief This API read gyro manual offset compensation of x axis
+ *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
+ *
+ *
+ *
+ *  @param v_gyro_off_x_s16:
+ *	The value of gyro manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_xaxis(
+s16 *v_gyro_off_x_s16);
+/*!
+ *	@brief This API write gyro manual offset compensation of x axis
+ *	from the register 0x74 bit 0 to 7 and 0x77 bit 0 and 1
+ *
+ *
+ *
+ *  @param v_gyro_off_x_s16:
+ *	The value of gyro manual offset compensation of x axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_xaxis(
+s16 v_gyro_off_x_s16);
+/*!
+ *	@brief This API read gyro manual offset compensation of y axis
+ *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
+ *
+ *
+ *
+ *  @param v_gyro_off_y_s16:
+ *	The value of gyro manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_yaxis(
+s16 *v_gyro_off_y_s16);
+/*!
+ *	@brief This API write gyro manual offset compensation of y axis
+ *	from the register 0x75 bit 0 to 7 and 0x77 bit 2 and 3
+ *
+ *
+ *
+ *  @param v_gyro_off_y_s16:
+ *	The value of gyro manual offset compensation of y axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_yaxis(
+s16 v_gyro_off_y_s16);
+/*!
+ *	@brief This API read gyro manual offset compensation of z axis
+ *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
+ *
+ *
+ *
+ *  @param v_gyro_off_z_s16:
+ *	The value of gyro manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_compensation_zaxis(
+s16 *v_gyro_off_z_s16);
+/*!
+ *	@brief This API write gyro manual offset compensation of z axis
+ *	from the register 0x76 bit 0 to 7 and 0x77 bit 4 and 5
+ *
+ *
+ *
+ *  @param v_gyro_off_z_s16:
+ *	The value of gyro manual offset compensation of z axis
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_compensation_zaxis(
+s16 v_gyro_off_z_s16);
+/*!
+ *	@brief This API writes accel fast offset compensation
+ *	from the register 0x69 bit 0 to 5
+ *	@brief This API writes each axis individually
+ *	FOC_X_AXIS - bit 4 and 5
+ *	FOC_Y_AXIS - bit 2 and 3
+ *	FOC_Z_AXIS - bit 0 and 1
+ *
+ *  @param  v_foc_accel_u8: The value of accel offset compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_axis_u8: The value of accel offset axis selection
+  *	value    | axis
+ * ----------|-------------------
+ *  0        | FOC_X_AXIS
+ *  1        | FOC_Y_AXIS
+ *  2        | FOC_Z_AXIS
+ *
+ *	@param v_accel_offset_s8: The accel offset value
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_foc_trigger(u8 axis,
+u8 foc_acc, s8 *accel_offset);
+/*!
+ *	@brief This API write fast accel offset compensation
+ *	it writes all axis together.To the register 0x69 bit 0 to 5
+ *	FOC_X_AXIS - bit 4 and 5
+ *	FOC_Y_AXIS - bit 2 and 3
+ *	FOC_Z_AXIS - bit 0 and 1
+ *
+ *  @param  v_foc_accel_x_u8: The value of accel offset x compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_foc_accel_y_u8: The value of accel offset y compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_foc_accel_z_u8: The value of accel offset z compensation
+ *	value    | Behaviour
+ * ----------|-------------------
+ *  0x00     | disable
+ *  0x01     | +1g
+ *  0x01     | -1g
+ *  0x01     | 0g
+ *
+ *  @param  v_accel_off_x_s8: The value of accel offset x axis
+ *  @param  v_accel_off_y_s8: The value of accel offset y axis
+ *  @param  v_accel_off_z_s8: The value of accel offset z axis
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_accel_foc_trigger_xyz(u8 v_foc_accel_x_u8,
+u8 v_foc_accel_y_u8, u8 v_foc_accel_z_u8,
+s8 *acc_off_x, s8 *acc_off_y, s8 *acc_off_z);
+/***************************************************/
+/**\name	FUNCTION FOR ACEL AND GYRO OFFSET ENABLE */
+/***************************************************/
+/*!
+ *	@brief This API read the accel offset enable bit
+ *	from the register 0x77 bit 6
+ *
+ *
+ *
+ *  @param v_accel_off_enable_u8: The value of accel offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_accel_offset_enable(
+u8 *acc_off_en);
+/*!
+ *	@brief This API write the accel offset enable bit
+ *	from the register 0x77 bit 6
+ *
+ *
+ *
+ *  @param v_accel_off_enable_u8: The value of accel offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_accel_offset_enable(
+u8 acc_off_en);
+/*!
+ *	@brief This API read the accel offset enable bit
+ *	from the register 0x77 bit 7
+ *
+ *
+ *
+ *  @param v_gyro_off_enable_u8: The value of gyro offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_gyro_offset_enable(
+u8 *v_gyro_off_enable_u8);
+/*!
+ *	@brief This API write the accel offset enable bit
+ *	from the register 0x77 bit 7
+ *
+ *
+ *
+ *  @param v_gyro_off_enable_u8: The value of gyro offset enable
+ *  value    |  Description
+ * ----------|--------------
+ *   0x01    | ENABLE
+ *   0x00    | DISABLE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_gyro_offset_enable(
+u8 v_gyro_off_enable_u8);
+/***************************************************/
+/**\name	FUNCTION FOR STEP COUNTER INTERRUPT */
+/***************************************************/
+/*!
+ *	@brief This API reads step counter value
+ *	form the register 0x78 and 0x79
+ *
+ *
+ *
+ *
+ *  @param v_step_cnt_s16 : The value of step counter
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_step_count(s16 *v_step_cnt_s16);
+ /*!
+ *	@brief This API Reads
+ *	step counter configuration
+ *	from the register 0x7A bit 0 to 7
+ *	and from the register 0x7B bit 0 to 2 and 4 to 7
+ *
+ *
+ *  @param v_step_config_u16 : The value of step configuration
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_config(
+u16 *v_step_config_u16);
+ /*!
+ *	@brief This API write
+ *	step counter configuration
+ *	from the register 0x7A bit 0 to 7
+ *	and from the register 0x7B bit 0 to 2 and 4 to 7
+ *
+ *
+ *  @param v_step_config_u16   :
+ *	the value of  Enable step configuration
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_config(
+u16 v_step_config_u16);
+ /*!
+ *	@brief This API read enable step counter
+ *	from the register 0x7B bit 3
+ *
+ *
+ *  @param v_step_counter_u8 : The value of step counter enable
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_step_counter_enable(
+u8 *v_step_counter_u8);
+ /*!
+ *	@brief This API write enable step counter
+ *	from the register 0x7B bit 3
+ *
+ *
+ *  @param v_step_counter_u8 : The value of step counter enable
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_counter_enable(
+u8 v_step_counter_u8);
+ /*!
+ *	@brief This API set Step counter modes
+ *
+ *
+ *  @param  v_step_mode_u8 : The value of step counter mode
+ *  value    |   mode
+ * ----------|-----------
+ *   0       | BMI160_STEP_NORMAL_MODE
+ *   1       | BMI160_STEP_SENSITIVE_MODE
+ *   2       | BMI160_STEP_ROBUST_MODE
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_step_mode(u8 v_step_mode_u8);
+/*!
+ *	@brief This API used to trigger the  signification motion
+ *	interrupt
+ *
+ *
+ *  @param  v_significant_u8 : The value of interrupt selection
+ *  value    |  interrupt
+ * ----------|-----------
+ *   0       |  BMI160_MAP_INTR1
+ *   1       |  BMI160_MAP_INTR2
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_map_significant_motion_intr(
+u8 v_significant_u8);
+/*!
+ *	@brief This API used to trigger the step detector
+ *	interrupt
+ *
+ *
+ *  @param  v_step_detector_u8 : The value of interrupt selection
+ *  value    |  interrupt
+ * ----------|-----------
+ *   0       |  BMI160_MAP_INTR1
+ *   1       |  BMI160_MAP_INTR2
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_map_step_detector_intr(
+u8 v_step_detector_u8);
+ /*!
+ *	@brief This API used to clear the step counter interrupt
+ *	interrupt
+ *
+ *
+ *  @param  : None
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_clear_step_counter(void);
+/***************************************************/
+/**\name	FUNCTION FOR STEP COMMAND REGISTER WRITE */
+/***************************************************/
+ /*!
+ *	@brief This API writes value to the register 0x7E bit 0 to 7
+ *
+ *
+ *  @param  v_command_reg_u8 : The value to write command register
+ *  value   |  Description
+ * ---------|--------------------------------------------------------
+ *	0x00	|	Reserved
+ *  0x03	|	Starts fast offset calibration for the accel and gyro
+ *	0x10	|	Sets the PMU mode for the Accelerometer to suspend
+ *	0x11	|	Sets the PMU mode for the Accelerometer to normal
+ *	0x12	|	Sets the PMU mode for the Accelerometer Lowpower
+ *  0x14	|	Sets the PMU mode for the Gyroscope to suspend
+ *	0x15	|	Sets the PMU mode for the Gyroscope to normal
+ *	0x16	|	Reserved
+ *	0x17	|	Sets the PMU mode for the Gyroscope to fast start-up
+ *  0x18	|	Sets the PMU mode for the Magnetometer to suspend
+ *	0x19	|	Sets the PMU mode for the Magnetometer to normal
+ *	0x1A	|	Sets the PMU mode for the Magnetometer to Lowpower
+ *	0xB0	|	Clears all data in the FIFO
+ *  0xB1	|	Resets the interrupt engine
+ *	0xB2	|	step_cnt_clr Clears the step counter
+ *	0xB6	|	Triggers a reset
+ *	0x37	|	See extmode_en_last
+ *	0x9A	|	See extmode_en_last
+ *	0xC0	|	Enable the extended mode
+ *  0xC4	|	Erase NVM cell
+ *	0xC8	|	Load NVM cell
+ *	0xF0	|	Reset acceleration data path
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_command_register(
+u8 v_command_reg_u8);
+/***************************************************/
+/**\name	FUNCTION FOR PAGE ENABLE */
+/***************************************************/
+ /*!
+ *	@brief This API read target page from the register 0x7F bit 4 and 5
+ *
+ *  @param v_target_page_u8: The value of target page
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  User data/configure page
+ *   1      |  Chip level trim/test page
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_target_page(
+u8 *v_target_page_u8);
+ /*!
+ *	@brief This API write target page from the register 0x7F bit 4 and 5
+ *
+ *  @param v_target_page_u8: The value of target page
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  User data/configure page
+ *   1      |  Chip level trim/test page
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_target_page(
+u8 v_target_page_u8);
+ /*!
+ *	@brief This API read page enable from the register 0x7F bit 7
+ *
+ *
+ *
+ *  @param v_page_enable_u8: The value of page enable
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  DISABLE
+ *   1      |  ENABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_paging_enable(
+u8 *v_page_enable_u8);
+ /*!
+ *	@brief This API write page enable from the register 0x7F bit 7
+ *
+ *
+ *
+ *  @param v_page_enable_u8: The value of page enable
+ *  value   |  page
+ * ---------|-----------
+ *   0      |  DISABLE
+ *   1      |  ENABLE
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_paging_enable(
+u8 v_page_enable_u8);
+ /*!
+ *	@brief This API read
+ *	pull up configuration from the register 0X85 bit 4 an 5
+ *
+ *
+ *
+ *  @param v_control_pullup_u8: The value of pull up register
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_get_pullup_configuration(
+u8 *v_control_pullup_u8);
+ /*!
+ *	@brief This API write
+ *	pull up configuration from the register 0X85 bit 4 an 5
+ *
+ *
+ *
+ *  @param v_control_pullup_u8: The value of pull up register
+ *
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_pullup_configuration(
+u8 v_control_pullup_u8);
+/***************************************************/
+/**\name	FUNCTION FOR BMM150 */
+/***************************************************/
+ /*!
+ *	@brief This function used for initialize the bmm150 sensor
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_interface_init(u8 *v_chip_id_u8);
+ /*!
+ *	@brief This function used for set the mag power control
+ *	bit enable
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_wakeup(void);
+ /*!
+ *	@brief This function used for read the trim values of magnetometer
+ *
+ *	@note
+ *	Before reading the mag trimming values
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_bmm150_mag_trim(void);
+ /*!
+ *	@brief This function used for read the compensated value of mag
+ *	Before start reading the mag compensated data's
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_compensate_xyz(
+struct bmi160_mag_xyz_s32_t *mag_comp_xyz);
+/*!
+ *	@brief This API used to get the compensated BMM150-X data
+ *	the out put of X as s32
+ *	Before start reading the mag compensated X data
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *
+ *  @param  v_mag_data_x_s16 : The value of mag raw X data
+ *  @param  v_data_r_u16 : The value of mag R data
+ *
+ *	@return results of compensated X data value output as s32
+ *
+ */
+s32 bmi160_bmm150_mag_compensate_X(s16 v_mag_data_x_s16, u16 v_data_r_u16);
+/*!
+ *	@brief This API used to get the compensated BMM150-Y data
+ *	the out put of Y as s32
+ *	Before start reading the mag compensated Y data
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *
+ *  @param  v_mag_data_y_s16 : The value of mag raw Y data
+ *  @param  v_data_r_u16 : The value of mag R data
+ *
+ *	@return results of compensated Y data value output as s32
+ */
+s32 bmi160_bmm150_mag_compensate_Y(s16 v_mag_data_y_s16, u16 v_data_r_u16);
+/*!
+ *	@brief This API used to get the compensated BMM150-Z data
+ *	the out put of Z as s32
+ *	Before start reading the mag compensated Z data
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *
+ *  @param  v_mag_data_z_s16 : The value of mag raw Z data
+ *  @param  v_data_r_u16 : The value of mag R data
+ *
+ *	@return results of compensated Z data value output as s32
+ */
+s32 bmi160_bmm150_mag_compensate_Z(s16 v_mag_data_z_s16, u16 v_data_r_u16);
+/*!
+ *	@brief This API used to set the pre-set modes of bmm150
+ *	The pre-set mode setting is depend on data rate and xy and z repetitions
+ *
+ *	@note
+ *	Before set the mag preset mode
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param  v_mode_u8: The value of pre-set mode selection value
+ *  value    |  pre_set mode
+ * ----------|------------
+ *   1       | BMI160_MAG_PRESETMODE_LOWPOWER
+ *   2       | BMI160_MAG_PRESETMODE_REGULAR
+ *   3       | BMI160_MAG_PRESETMODE_HIGHACCURACY
+ *   4       | BMI160_MAG_PRESETMODE_ENHANCED
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_presetmode(u8 mode);
+/*!
+ *	@brief This function used for set the magnetometer
+ *	power mode.
+ *	@note
+ *	Before set the mag power mode
+ *	make sure the following two points are addressed
+ *	@note
+ *	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note
+ *	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@param v_mag_pow_mode_u8 : The value of mag power mode
+ *  value    |  mode
+ * ----------|------------
+ *   0       | FORCE_MODE
+ *   1       | SUSPEND_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bmm150_mag_set_power_mode(u8 mag_pow_mode);
+ /*!
+ *	@brief This function used for set the magnetometer
+ *	power mode.
+ *	@note
+ *	Before set the mag power mode
+ *	make sure the following two point is addressed
+ *		Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *
+ *	@param v_mag_sec_if_pow_mode_u8 : The value of mag power mode
+ *  value    |  mode
+ * ----------|------------
+ *   0       | BMI160_MAG_FORCE_MODE
+ *   1       | BMI160_MAG_SUSPEND_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_bmm150_mag_and_secondary_if_power_mode(
+u8 v_mag_sec_if_pow_mode_u8);
+/***************************************************/
+/**\name	FUNCTIONS FOR AKM09911 AND AKM09912*/
+/***************************************************/
+ /*!
+ *	@brief This function used for initialize
+ *	the AKM09911 and AKM09912 sensor
+ *
+ *
+ *	@param v_akm_i2c_address_u8: The value of device address
+ *	AKM sensor   |  Slave address
+ * --------------|---------------------
+ *  AKM09911     |  AKM09911_I2C_ADDR_1
+ *     -         |  and AKM09911_I2C_ADDR_2
+ *  AKM09912     |  AKM09912_I2C_ADDR_1
+ *     -         |  AKM09912_I2C_ADDR_2
+ *     -         |  AKM09912_I2C_ADDR_3
+ *     -         |  AKM09912_I2C_ADDR_4
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_mag_interface_init(
+u8 v_akm_i2c_address_u8);
+ /*!
+ *	@brief This function used for read the sensitivity data of
+ *	AKM09911 and AKM09912
+ *
+ *	@note Before reading the mag sensitivity values
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_bst_akm_sensitivity_data(void);
+/*!
+ *	@brief This API used to get the compensated X data
+ *	of AKM09911 the out put of X as s32
+ *	@note	Before start reading the mag compensated X data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_x_s16 : The value of X data
+ *
+ *	@return results of compensated X data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09911_compensate_X(s16 v_bst_akm_x_s16);
+/*!
+ *	@brief This API used to get the compensated Y data
+ *	of AKM09911 the out put of Y as s32
+ *	@note	Before start reading the mag compensated Y data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_y_s16 : The value of Y data
+ *
+ *	@return results of compensated Y data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09911_compensate_Y(s16 v_bst_akm_y_s16);
+/*!
+ *	@brief This API used to get the compensated Z data
+ *	of AKM09911 the out put of Z as s32
+ *	@note	Before start reading the mag compensated Z data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_z_s16 : The value of Z data
+ *
+ *	@return results of compensated Z data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09911_compensate_Z(s16 v_bst_akm_z_s16);
+/*!
+ *	@brief This API used to get the compensated X data
+ *	of AKM09912 the out put of X as s32
+ *	@note	Before start reading the mag compensated X data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_x_s16 : The value of X data
+ *
+ *	@return results of compensated X data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09912_compensate_X(s16 v_bst_akm_x_s16);
+/*!
+ *	@brief This API used to get the compensated Y data
+ *	of AKM09912 the out put of Y as s32
+ *	@note	Before start reading the mag compensated Y data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_y_s16 : The value of Y data
+ *
+ *	@return results of compensated Y data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09912_compensate_Y(s16 v_bst_akm_y_s16);
+/*!
+ *	@brief This API used to get the compensated Z data
+ *	of AKM09912 the out put of Z as s32
+ *	@note	Before start reading the mag compensated Z data
+ *			make sure the following two points are addressed
+ *	@note 1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note 2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *
+ *  @param v_bst_akm_z_s16 : The value of Z data
+ *
+ *	@return results of compensated Z data value output as s32
+ *
+ */
+s32 bmi160_bst_akm09912_compensate_Z(s16 v_bst_akm_z_s16);
+ /*!
+ *	@brief This function used for read the compensated value of
+ *	AKM09911
+ *	@note Before start reading the mag compensated data's
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09911_compensate_xyz(
+struct bmi160_bst_akm_xyz_t *bst_akm_xyz);
+ /*!
+ *	@brief This function used for read the compensated value of
+ *	AKM09912
+ *	@note Before start reading the mag compensated data's
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm09912_compensate_xyz(
+struct bmi160_bst_akm_xyz_t *bst_akm_xyz);
+/*!
+ *	@brief This function used for set the AKM09911 and AKM09912
+ *	power mode.
+ *	@note Before set the AKM power mode
+ *	make sure the following two points are addressed
+ *	@note	1.	Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *	@note	2.	And also confirm the secondary-interface power mode
+ *		is not in the SUSPEND mode.
+ *		by using the function bmi160_get_mag_pmu_status().
+ *		If the secondary-interface power mode is in SUSPEND mode
+ *		set the value of 0x19(NORMAL mode)by using the
+ *		bmi160_set_command_register(0x19) function.
+ *
+ *	@param v_akm_pow_mode_u8 : The value of akm power mode
+ *  value   |    Description
+ * ---------|--------------------
+ *    0     |  AKM_POWER_DOWN_MODE
+ *    1     |  AKM_SINGLE_MEAS_MODE
+ *    2     |  FUSE_ROM_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_akm_set_powermode(u8 v_akm_pow_mode_u8);
+ /*!
+ *	@brief This function used for set the magnetometer
+ *	power mode of AKM09911 and AKM09912
+ *	@note Before set the mag power mode
+ *	make sure the following two point is addressed
+ *		Make sure the mag interface is enabled or not,
+ *		by using the bmi160_get_if_mode() function.
+ *		If mag interface is not enabled set the value of 0x02
+ *		to the function bmi160_get_if_mode(0x02)
+ *
+ *	@param v_mag_sec_if_pow_mode_u8 : The value of secondary if power mode
+ *  value   |    Description
+ * ---------|--------------------
+ *    0     |  BMI160_MAG_FORCE_MODE
+ *    1     |  BMI160_MAG_SUSPEND_MODE
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_set_bst_akm_and_secondary_if_powermode(
+u8 v_mag_sec_if_pow_mode_u8);
+/***************************************************/
+/**\name	FUNCTIONS FOR YAMAH-YAS532 */
+/***************************************************/
+/*!
+ *	@brief This function used for read the YAMAH-YAS532 init
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_mag_interface_init(
+void);
+/*!
+ *	@brief This function used to set the YAS532 initial values
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_initial_values(void);
+/*!
+ *	@brief This function used for YAS532 offset correction
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_magnetic_measure_set_offset(
+void);
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS532 calibration data
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas532_calib_values(void);
+/*!
+ *	@brief This function used for calculate the
+ *	YAS532 read the linear data
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_xy1y2_to_linear(
+u16 *v_xy1y2_u16, s32 *xy1y2_linear);
+/*!
+ *	@brief This function used for read the YAS532 sensor data
+ *	@param	v_acquisition_command_u8: used to set the data acquisition
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ *	@param	v_busy_u8 : used to get the busy flay for sensor data read
+ *	@param	v_temp_u16 : used to get the temperature data
+ *	@param	v_xy1y2_u16 : used to get the sensor xy1y2 data
+ *	@param	v_overflow_u8 : used to get the overflow data
+ *
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_normal_measurement_data(
+u8 v_acquisition_command_u8, u8 *v_busy_u8,
+u16 *v_temp_u16, u16 *v_xy1y2_u16, u8 *v_overflow_u8);
+/*!
+ *	@brief This function used for YAS532 sensor data
+ *	@param	v_acquisition_command_u8	:	the value of CMDR
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ * @param xyz_data : the vector xyz output
+ * @param v_overflow_s8 : the value of overflow
+ * @param v_temp_correction_u8 : the value of temperate correction enable
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_measurement_xyz_data(
+struct yas532_vector *xyz_data, u8 *v_overflow_s8, u8 v_temp_correction_u8,
+u8 v_acquisition_command_u8);
+/*!
+ *	@brief This function used for YAS532 write data acquisition
+ *	command register write
+ *	@param	v_command_reg_data_u8	:	the value of data acquisition
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_acquisition_command_register(
+u8 v_command_reg_data_u8);
+/*!
+ *	@brief This function used write offset of YAS532
+ *
+ *	@param	p_offset_s8	: The value of offset to write
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_set_offset(
+const s8 *p_offset_s8);
+/*!
+ *	@brief This function used to init the YAMAH-YAS537
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_mag_interface_init(
+void);
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 calibration data
+ *
+ *
+ *	@param v_rcoil_u8 : The value of r coil
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_calib_values(
+u8 v_rcoil_u8);
+/*!
+ *	@brief This function used for YAS537 write data acquisition
+ *	command register write
+ *	@param	v_command_reg_data_u8	:	the value of data acquisition
+ *	acquisition_command  |   operation
+ *  ---------------------|-------------------------
+ *         0x17          | turn on the acquisition coil
+ *         -             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Deferred acquisition mode
+ *        0x07           | turn on the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as minus(-))
+ *         _             | Normal acquisition mode
+ *        0x11           | turn OFF the acquisition coil
+ *         _             | set direction of the coil
+ *         _             | (x and y as plus(+))
+ *         _             | Deferred acquisition mode
+ *       0x01            | turn OFF the acquisition coil
+ *        _              | set direction of the coil
+ *        _              | (x and y as plus(+))
+ *        _              | Normal acquisition mode
+ *
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas537_acquisition_command_register(
+u8 v_command_reg_data_u8);
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param xy1y2: The value of raw xy1y2 data
+ *	@param xyz: The value of  xyz data
+ *
+ *
+ *	@return None
+ *
+ *
+ */
+/*JET
+static void xy1y2_to_xyz(u16 *xy1y2, s32 *xyz);*/
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param v_coil_stat_u8: The value of R coil status
+ *	@param v_busy_u8: The value of busy status
+ *	@param v_temperature_u16: The value of temperature
+ *	@param xy1y2: The value of raw xy1y2 data
+ *	@param v_ouflow_u8: The value of overflow
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_read_xy1y2_data(
+u8 *v_coil_stat_u8, u8 *v_busy_u8,
+u16 *v_temperature_u16, u16 *xy1y2, u8 *v_ouflow_u8);
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param v_ouflow_u8: The value of overflow
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_measure_xyz_data(
+u8 *v_ouflow_u8, struct yas_vector *vector_xyz);
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data
+ *
+ *	@param v_ouflow_u8: The value of overflow
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+/* JET
+static BMI160_RETURN_FUNCTION_TYPE invalid_magnetic_field(
+  u16 *v_cur_u16, u16 *v_last_u16);*/
+/***************************************************/
+/**\name	FUNCTIONS FOR FIFO DATA READ */
+/***************************************************/
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header less mode
+ *
+ *
+ *
+ *	@note Configure the below functions for FIFO header less mode
+ *	@note 1. bmi160_set_fifo_down_gyro
+ *	@note 2. bmi160_set_gyro_fifo_filter_data
+ *	@note 3. bmi160_set_fifo_down_accel
+ *	@note 4. bmi160_set_accel_fifo_filter_dat
+ *	@note 5. bmi160_set_fifo_mag_enable
+ *	@note 6. bmi160_set_fifo_accel_enable
+ *	@note 7. bmi160_set_fifo_gyro_enable
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full
+ *	@note 2. bmi160_set_intr_fifo_wm
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_headerless_mode(
+u8 v_mag_if_u8);
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header less mode for using user defined length
+ *
+ *
+ *	@param v_fifo_user_length_u16: The value of length of fifo read data
+ *
+ *	@note Configure the below functions for FIFO header less mode
+ *	@note 1. bmi160_set_fifo_down_gyro
+ *	@note 2. bmi160_set_gyro_fifo_filter_data
+ *	@note 3. bmi160_set_fifo_down_accel
+ *	@note 4. bmi160_set_accel_fifo_filter_dat
+ *	@note 5. bmi160_set_fifo_mag_enable
+ *	@note 6. bmi160_set_fifo_accel_enable
+ *	@note 7. bmi160_set_fifo_gyro_enable
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full
+ *	@note 2. bmi160_set_intr_fifo_wm
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE
+bmi160_read_fifo_headerless_mode_user_defined_length(
+u16 v_fifo_user_length_u16,
+struct bmi160_fifo_data_header_less_t *fifo_data, u8 v_mag_if_mag_u8);
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header mode
+ *
+ *
+ *	@note Configure the below functions for FIFO header mode
+ *	@note 1. bmi160_set_fifo_down_gyro()
+ *	@note 2. bmi160_set_gyro_fifo_filter_data()
+ *	@note 3. bmi160_set_fifo_down_accel()
+ *	@note 4. bmi160_set_accel_fifo_filter_dat()
+ *	@note 5. bmi160_set_fifo_mag_enable()
+ *	@note 6. bmi160_set_fifo_accel_enable()
+ *	@note 7. bmi160_set_fifo_gyro_enable()
+ *	@note 8. bmi160_set_fifo_header_enable()
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full()
+ *	@note 2. bmi160_set_intr_fifo_wm()
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable()
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable()
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data(
+u8 v_mag_if_u8);
+/*!
+ *	@brief This function used for reading the
+ *	fifo data of  header mode for using user defined length
+ *
+ *
+ *	@note Configure the below functions for FIFO header mode
+ *	@note 1. bmi160_set_fifo_down_gyro()
+ *	@note 2. bmi160_set_gyro_fifo_filter_data()
+ *	@note 3. bmi160_set_fifo_down_accel()
+ *	@note 4. bmi160_set_accel_fifo_filter_dat()
+ *	@note 5. bmi160_set_fifo_mag_enable()
+ *	@note 6. bmi160_set_fifo_accel_enable()
+ *	@note 7. bmi160_set_fifo_gyro_enable()
+ *	@note 8. bmi160_set_fifo_header_enable()
+ *	@note For interrupt configuration
+ *	@note 1. bmi160_set_intr_fifo_full()
+ *	@note 2. bmi160_set_intr_fifo_wm()
+ *	@note 3. bmi160_set_fifo_tag_intr2_enable()
+ *	@note 4. bmi160_set_fifo_tag_intr1_enable()
+ *
+ *	@note The fifo reads the whole 1024 bytes
+ *	and processing the data
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_read_fifo_header_data_user_defined_length(
+u16 v_fifo_user_length_u16, u8 v_mag_if_mag_u8,
+struct bmi160_fifo_data_header_t *fifo_header_data);
+/*!
+ *	@brief This function used for reading
+ *	bmi160_t structure
+ *
+ *  @return the reference and values of bmi160_t
+ *
+ *
+*/
+struct bmi160_t *bmi160_get_ptr(void);
+/*!
+ *	@brief This function used for reading the compensated data of
+ *	mag secondary interface xyz data
+ *	@param v_mag_x_s16: The value of mag x data
+ *	@param v_mag_y_s16: The value of mag y data
+ *	@param v_mag_z_s16: The value of mag z data
+ *	@param v_mag_r_s16: The value of mag r data
+ *	@param v_mag_second_if_u8: The value of mag selection
+ *
+ *  value   |   v_mag_second_if_u8
+ * ---------|----------------------
+ *    0     |    BMM150
+ *    1     |    AKM09911
+ *    2     |    AKM09912
+ *    3     |    YAS532
+ *    4     |    YAS537
+ *	@param mag_fifo_data: The value of compensated mag xyz data
+ *
+ *
+ *  @return
+ *
+ *
+*/
+BMI160_RETURN_FUNCTION_TYPE bmi160_second_if_mag_compensate_xyz(
+struct bmi160_mag_fifo_data_t mag_fifo_data,
+u8 v_mag_second_if_u8);
+/*!
+ *	@brief This function used for read the
+ *	YAMAHA YAS537 xy1y2 data of fifo
+ *
+ *	@param a_xy1y2_u16: The value of xyy1 data
+ *	@param v_over_flow_u8: The value of overflow
+ *	@param v_rcoil_u8: The value of rcoil
+ *	@param v_busy_u8: The value of busy flag
+ *
+ *
+ *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yamaha_yas537_fifo_xyz_data(
+u16 *a_xy1y2_u16, u8 v_over_flow_u8, u8 v_rcoil_u8, u8 v_busy_u8);
+/*!
+ *	@brief This function used for YAS532 sensor data
+ *	@param	v_acquisition_command_u8	:	the value of CMDR
+ *
+ * @param v_xy1y2_u16 : the vector xyz output
+ * @param v_overflow_s8 : the value of overflow
+ * @param v_temp_correction_u8 : the value of temperate correction enable
+ *
+ *
+  *	@return results of bus communication function
+ *	@retval 0 -> Success
+ *	@retval -1 -> Error
+ *
+ *
+ */
+BMI160_RETURN_FUNCTION_TYPE bmi160_bst_yas532_fifo_xyz_data(
+u16 *v_xy1y2_u16, u8 v_temp_correction_u8,
+s8 v_overflow_s8, u16 v_temp_u16, u8 v_busy_u8);
+
+#endif
diff --git a/ext/lib/upm/src/button/Kbuild b/ext/lib/upm/src/button/Kbuild
new file mode 100644
index 0000000..fda0832
--- /dev/null
+++ b/ext/lib/upm/src/button/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_button) += button.o
diff --git a/ext/lib/upm/src/button/Kconfig b/ext/lib/upm/src/button/Kconfig
new file mode 100644
index 0000000..c076467
--- /dev/null
+++ b/ext/lib/upm/src/button/Kconfig
@@ -0,0 +1,9 @@
+config UPM_button
+    bool "button"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm button sensor module
+
diff --git a/ext/lib/upm/src/button/Makefile b/ext/lib/upm/src/button/Makefile
new file mode 100644
index 0000000..b295ed6
--- /dev/null
+++ b/ext/lib/upm/src/button/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_button
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/button
+endif
diff --git a/ext/lib/upm/src/button/button.c b/ext/lib/upm/src/button/button.c
new file mode 100644
index 0000000..9f109ef
--- /dev/null
+++ b/ext/lib/upm/src/button/button.c
@@ -0,0 +1,86 @@
+/*
+ * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
+ *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
+ *          Sarah Knepper <sarah.knepper@intel.com>
+ *          Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 - 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "button.h"
+
+button_context button_init(int pin){
+    // make sure that mraa is initialized
+    int mraa_rv;
+    if((mraa_rv = mraa_init()) != MRAA_SUCCESS){
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        return NULL;
+    }
+
+    button_context dev = (button_context) malloc(sizeof(struct _button_context));
+
+    if (dev == NULL){
+        printf("Unable to allocate space for the sensor structure\n");
+        return NULL;
+    }
+
+    dev->gpio_pin = pin;
+
+    dev->gpio = mraa_gpio_init(dev->gpio_pin);
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+    dev->isr_installed = false;
+
+    return dev;
+}
+
+void button_close(button_context dev){
+    mraa_gpio_close(dev->gpio);
+    free(dev);
+}
+
+upm_result_t button_get_value(button_context dev, bool* val){
+    int ret = mraa_gpio_read(dev->gpio);
+
+    if(ret > 0)
+        *val = true;
+    else
+        *val = false;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t button_install_isr(button_context dev, mraa_gpio_edge_t edge_level, void (*isr)(void *), void *arg){
+    button_uninstall_isr(dev);
+
+    mraa_gpio_isr(dev->gpio, edge_level, isr, arg);
+    dev->isr_installed = true;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t button_uninstall_isr(button_context dev){
+    if(dev->isr_installed)
+        mraa_gpio_isr_exit(dev->gpio);
+
+    dev->isr_installed = false;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/button/button.h b/ext/lib/upm/src/button/button.h
new file mode 100644
index 0000000..8a9145c
--- /dev/null
+++ b/ext/lib/upm/src/button/button.h
@@ -0,0 +1,98 @@
+/*
+ * Authors: Brendan Le Foll <brendan.le.foll@intel.com>
+ *          Mihai Tudor Panu <mihai.tudor.panu@intel.com>
+ *          Sarah Knepper <sarah.knepper@intel.com>
+ *          Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 - 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "upm.h"
+#include "mraa/gpio.h"
+
+/**
+ * @brief Button library
+ * @defgroup buttonlib libupm-button
+ * @ingroup seeed gpio button gsk
+ */
+
+/**
+ * @library buttonlib
+ * @sensor button
+ * @comname Button
+ * @altname Grove Button
+ * @type button
+ * @man seeed
+ * @con gpio
+ * @kit gsk
+ *
+ * @brief API for the Button
+ *
+ * Basic UPM module for the button sensor
+ *
+ * @image html button.jpg
+ * @snippet button.cxx Interesting
+ */
+
+typedef struct _button_context {
+    mraa_gpio_context    gpio;
+    uint8_t              gpio_pin;
+    bool                 isr_installed;
+} *button_context;
+
+/**
+* button init function
+*
+* @param gpio Pin to use
+*/
+button_context button_init(int pin);
+
+        /**
+         * button destructor
+         */
+void button_close(button_context dev);
+ /**
+         * Gets the value from the GPIO pin
+         *
+         * @return Value from the GPIO pin
+         */
+upm_result_t button_get_value(button_context dev, bool* val);
+/**
+         * Installs an interrupt service routine (ISR) to be called when
+         * the button is activated or deactivated.
+         *
+         * @param fptr Pointer to a function to be called on interrupt
+         * @param arg Pointer to an object to be supplied as an
+         * argument to the ISR.
+         */
+upm_result_t button_install_isr(button_context dev, mraa_gpio_edge_t edge_level, void (*isr)(void *), void *arg);
+/**
+         * Uninstalls the previously installed ISR
+         *
+         */
+upm_result_t button_uninstall_isr(button_context);
diff --git a/ext/lib/upm/src/buzzer/Kbuild b/ext/lib/upm/src/buzzer/Kbuild
new file mode 100644
index 0000000..0c37488
--- /dev/null
+++ b/ext/lib/upm/src/buzzer/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_buzzer) += buzzer.o
diff --git a/ext/lib/upm/src/buzzer/Kconfig b/ext/lib/upm/src/buzzer/Kconfig
new file mode 100644
index 0000000..774c6ba
--- /dev/null
+++ b/ext/lib/upm/src/buzzer/Kconfig
@@ -0,0 +1,8 @@
+config UPM_buzzer
+    bool "buzzer"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm pwm audio buzzer
diff --git a/ext/lib/upm/src/buzzer/Makefile b/ext/lib/upm/src/buzzer/Makefile
new file mode 100644
index 0000000..1f31e7b
--- /dev/null
+++ b/ext/lib/upm/src/buzzer/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_buzzer
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/buzzer
+endif
diff --git a/ext/lib/upm/src/buzzer/buzzer.c b/ext/lib/upm/src/buzzer/buzzer.c
new file mode 100644
index 0000000..2e58696
--- /dev/null
+++ b/ext/lib/upm/src/buzzer/buzzer.c
@@ -0,0 +1,142 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * based on original C++ driver by
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include <unistd.h>
+#include <upm_utilities.h>
+#include "buzzer.h"
+
+buzzer_context buzzer_init(int pin)
+{
+    buzzer_context dev =
+        (buzzer_context)malloc(sizeof(struct _buzzer_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->pwm = NULL;
+    dev->volume = 0.0;
+    dev->initialized = false;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        buzzer_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->pwm = mraa_pwm_init(pin)) )
+    {
+        printf("%s: mraa_pwm_init() failed\n",
+               __FUNCTION__);
+        buzzer_close(dev);
+        return NULL;
+    }
+
+    mraa_pwm_enable(dev->pwm, 1);
+
+    buzzer_set_volume(dev, 1.0);
+
+    dev->initialized = true;
+    return dev;
+}
+
+void buzzer_close(buzzer_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->initialized)
+        buzzer_stop_sound(dev);
+
+    if (dev->pwm)
+    {
+        mraa_pwm_enable(dev->pwm, 0);
+        mraa_pwm_close(dev->pwm);
+    }
+
+    free(dev);
+}
+
+void buzzer_set_volume(const buzzer_context dev, float vol)
+{
+    assert(dev != NULL);
+
+    dev->volume = vol;
+}
+
+float buzzer_get_volume(const buzzer_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->volume;
+}
+
+upm_result_t buzzer_play_sound(const buzzer_context dev, int note, int delay)
+{
+    assert(dev != NULL);
+
+    if (mraa_pwm_period_us(dev->pwm, note))
+    {
+        printf("%s: mraa_pwm_period_us() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if (mraa_pwm_write(dev->pwm, dev->volume * 0.5))
+    {
+        printf("%s: mraa_pwm_write() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if (delay >= 0)
+    {
+        upm_delay_us(delay);
+        return buzzer_stop_sound(dev);
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t buzzer_stop_sound(const buzzer_context dev)
+{
+    assert(dev != NULL);
+
+    mraa_result_t rv = MRAA_SUCCESS;
+
+    rv = mraa_pwm_period_us(dev->pwm, 1);
+    rv = mraa_pwm_write(dev->pwm, 0);
+
+    if (rv)
+    {
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/buzzer/buzzer.h b/ext/lib/upm/src/buzzer/buzzer.h
new file mode 100644
index 0000000..a478820
--- /dev/null
+++ b/ext/lib/upm/src/buzzer/buzzer.h
@@ -0,0 +1,115 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * based on original C++ driver by
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/pwm.h>
+#include <buzzer_tones.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file buzzer.h
+     * @library buzzer
+     * @brief C API for the buzzer driver
+     *
+     * @include buzzer.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _buzzer_context {
+        mraa_pwm_context pwm;
+
+        float volume;
+        bool initialized;
+    } *buzzer_context;
+
+    /**
+     * Initialize a buzzer context.
+     *
+     * @param pin Buzzer pin number (pwm capable)
+     * @return buzzer device context
+     */
+    buzzer_context buzzer_init(int pin);
+
+    /**
+     * Buzzer object destructor.
+     *
+     * @param dev Device context.
+     */
+    void buzzer_close(buzzer_context dev);
+
+    /**
+     * Plays a tone for a certain amount of time or indefinitely. When delay
+     * is not used, the sound can be stopped by calling stopSound().
+     *
+     * @param dev Device context.
+     * @param note Note to play (DO, RE, MI, etc.) or frequency
+     * @param delay Time in microseconds for which to play the sound;
+     * if the value is 0, the sound is played indefinitely
+     * @return UPM result
+     */
+    upm_result_t buzzer_play_sound(const buzzer_context dev, int note,
+                                   int delay);
+
+    /**
+     * Stops the sound currently playing. Should be called when playSound()
+     * does not have a delay value.
+     *
+     * @param dev Device context.
+     * @return UPM result
+     */
+    upm_result_t buzzer_stop_sound(const buzzer_context dev);
+
+    /**
+     * Sets the volume for the buzzer, but may affect the sound timbre.
+     * Works best with halved values; e.g., 1.0, 0.5, 0.25, etc.
+     *
+     * @param dev Device context.
+     * @param vol Value to set the volume to, from 0.0 to 1.0
+     */
+    void buzzer_set_volume(const buzzer_context dev, float vol);
+
+    /**
+     * Gets the buzzer volume.
+     *
+     * @param dev Device context.
+     * @return Value the volume was set to
+     */
+    float buzzer_get_volume(const buzzer_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/buzzer/buzzer_tones.h b/ext/lib/upm/src/buzzer/buzzer_tones.h
new file mode 100644
index 0000000..969c098
--- /dev/null
+++ b/ext/lib/upm/src/buzzer/buzzer_tones.h
@@ -0,0 +1,37 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * based on original C++ driver by
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+// Hz = 1000000 / N
+#define  BUZZER_DO     3800    // 262 Hz - C4
+#define  BUZZER_RE     3400    // 294 Hz - D
+#define  BUZZER_MI     3000    // 330 Hz - E
+#define  BUZZER_FA     2900    // 349 Hz - F
+#define  BUZZER_SOL    2550    // 392 Hz - G
+#define  BUZZER_LA     2270    // 440 Hz - A
+#define  BUZZER_SI     2000    // 494 Hz - B
diff --git a/ext/lib/upm/src/collision/Kbuild b/ext/lib/upm/src/collision/Kbuild
new file mode 100644
index 0000000..a7cf238
--- /dev/null
+++ b/ext/lib/upm/src/collision/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_collision) += collision.o
diff --git a/ext/lib/upm/src/collision/Kconfig b/ext/lib/upm/src/collision/Kconfig
new file mode 100644
index 0000000..2d01472
--- /dev/null
+++ b/ext/lib/upm/src/collision/Kconfig
@@ -0,0 +1,9 @@
+config UPM_collision
+    bool "collision"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm collisionsensor module
+
diff --git a/ext/lib/upm/src/collision/Makefile b/ext/lib/upm/src/collision/Makefile
new file mode 100644
index 0000000..a4d3a14
--- /dev/null
+++ b/ext/lib/upm/src/collision/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_collision
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/collision
+endif
diff --git a/ext/lib/upm/src/collision/collision.c b/ext/lib/upm/src/collision/collision.c
new file mode 100644
index 0000000..e517e9d
--- /dev/null
+++ b/ext/lib/upm/src/collision/collision.c
@@ -0,0 +1,59 @@
+/*
+ * Author: Zion Orent <sorent@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "collision.h"
+
+collision_context collision_init(int pin){
+    collision_context dev =
+      (collision_context)malloc(sizeof(struct _collision_context));
+
+    if (!dev)
+      return NULL;
+
+    dev->gpio_pin = pin;
+    dev->gpio = mraa_gpio_init(dev->gpio_pin);
+
+    if(mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN) != MRAA_SUCCESS)
+      {
+        free(dev);
+        return NULL;
+      }
+
+    return dev;
+}
+
+void collision_close(collision_context dev){
+    free(dev);
+}
+
+upm_result_t collision_is_colliding(collision_context dev, bool* collision_val){
+    int value = mraa_gpio_read(dev->gpio);
+
+    if(!value)
+        *collision_val = true;
+    else
+        *collision_val = false;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/collision/collision.h b/ext/lib/upm/src/collision/collision.h
new file mode 100644
index 0000000..3fefe2a
--- /dev/null
+++ b/ext/lib/upm/src/collision/collision.h
@@ -0,0 +1,91 @@
+/*
+ * Author: Zion Orent <sorent@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef COLLISION_H_
+#define COLLISION_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "upm.h"
+#include "mraa/gpio.h"
+
+/**
+ * @brief MVS0608 - GPIO Collision Sensor library
+ * @ingroup gpio accelerometer
+ */
+
+/**
+ * @library collision
+ * @sensor Collision
+ * @comname Collision Sensor
+ * @altname Grove Collision Sensor
+ * @type accelerometer
+ * @con gpio
+ *
+ * @brief API for the Collision Sensor
+ *
+ * MVS0608 can detect whether any
+ * collision movement or vibration happens.
+ * It outputs a low pulse signal when vibration is detected.
+ *
+ * @image html grovecollision.jpg
+ * @snippet collision.c Interesting
+ */
+
+/**
+ * device context
+ */
+typedef struct _collision_context {
+    mraa_gpio_context        gpio;
+    uint8_t                  gpio_pin;
+} *collision_context;
+
+/**
+ * Collision Initialization function
+ *
+ * @param pin number
+ * @return void* pointer to the sensor struct
+ */
+collision_context collision_init(int pin);
+
+/**
+ * Collision Initialization function
+ *
+ * @param void* pointer to the sensor struct
+ */
+void collision_close(collision_context dev);
+
+/**
+ * This function tells you whether the sensor has
+ * collided with something or not.
+ *
+ * @param void* pointer to the sensor struct
+ * @param bool* pointer to hold the collision value
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t collision_is_colliding(collision_context dev, bool* collision_val);
+
+#endif /* COLLISION_H_ */
diff --git a/ext/lib/upm/src/dfrorp/Kbuild b/ext/lib/upm/src/dfrorp/Kbuild
new file mode 100644
index 0000000..fa3c40b
--- /dev/null
+++ b/ext/lib/upm/src/dfrorp/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_dfrorp) += dfrorp.o
diff --git a/ext/lib/upm/src/dfrorp/Kconfig b/ext/lib/upm/src/dfrorp/Kconfig
new file mode 100644
index 0000000..c0620b4
--- /dev/null
+++ b/ext/lib/upm/src/dfrorp/Kconfig
@@ -0,0 +1,9 @@
+config UPM_dfrorp
+    bool "dfrorp"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm dfrobot analog ORP sensor
+
diff --git a/ext/lib/upm/src/dfrorp/Makefile b/ext/lib/upm/src/dfrorp/Makefile
new file mode 100644
index 0000000..6fbd986
--- /dev/null
+++ b/ext/lib/upm/src/dfrorp/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_dfrorp
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/dfrorp
+endif
diff --git a/ext/lib/upm/src/dfrorp/dfrorp.c b/ext/lib/upm/src/dfrorp/dfrorp.c
new file mode 100644
index 0000000..4cb6640
--- /dev/null
+++ b/ext/lib/upm/src/dfrorp/dfrorp.c
@@ -0,0 +1,165 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+
+#include "dfrorp.h"
+
+#include "upm_utilities.h"
+
+#define DFRORP_NUM_SAMPLES 10
+// Resistor R2 value in schematic, in KOhms
+#define DFRORP_R2 30.0
+// Resistor R3 value in schematic, in KOhms
+#define DFRORP_R3 75.0
+
+static float average(const dfrorp_context dev, int samples)
+{
+  int sum = 0;
+
+  if (samples < 1)
+    samples = 1;
+
+  int i;
+  for (i=0; i< samples; i++)
+    {
+      int j = mraa_aio_read(dev->aio);
+      if (j < 0)
+        {
+          printf("%s: mraa_aio_read() failed.\n", __FUNCTION__);
+          return -1.0;
+        }
+      sum += j;
+      upm_delay_ms(20);
+    }
+
+  return (float)(sum / samples);
+}
+
+dfrorp_context dfrorp_init(unsigned int apin, float a_ref)
+{
+  dfrorp_context dev =
+    (dfrorp_context)malloc(sizeof(struct _dfrorp_context));
+
+  if (!dev)
+    return NULL;
+
+  // zero out context
+  memset((void *)dev, 0, sizeof(struct _dfrorp_context));
+
+  dev->aio = NULL;
+
+  dev->a_ref = a_ref;
+
+  dev->offset = 0.0;
+  dev->scale = 1.0;
+
+  // initialize the MRAA context
+
+  if (!(dev->aio = mraa_aio_init(apin)))
+    {
+      printf("%s: mraa_aio_init() failed.\n", __FUNCTION__);
+      dfrorp_close(dev);
+      return NULL;
+    }
+
+  // set our analog resolution
+  dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio)) - 1;
+
+  return dev;
+}
+
+void dfrorp_close(dfrorp_context dev)
+{
+  assert(dev != NULL);
+
+  if (dev->aio)
+    mraa_aio_close(dev->aio);
+
+  free(dev);
+}
+
+void dfrorp_set_offset(const dfrorp_context dev, float offset)
+{
+  assert(dev != NULL);
+
+  dev->offset = offset;
+}
+
+void dfrorp_set_scale(const dfrorp_context dev, float scale)
+{
+  assert(dev != NULL);
+
+  dev->scale = scale;
+}
+
+upm_result_t dfrorp_update(const dfrorp_context dev)
+{
+  assert(dev != NULL);
+
+  float sample = average(dev, DFRORP_NUM_SAMPLES);
+  if (sample == -1.0)
+    return UPM_ERROR_OPERATION_FAILED;
+
+  dev->normalized = sample / dev->a_res;
+  dev->volts = dev->normalized * dev->a_ref;
+
+  float volts = dev->volts + dev->orp_cal_offset;
+
+  // From the DFRobot site
+  dev->orp = ( (DFRORP_R2 * dev->a_ref * 1000.0) -
+               (DFRORP_R3 * sample * dev->a_ref * 1000.0 / dev->a_res) ) /
+    DFRORP_R3 - dev->orp_cal_offset;
+
+  return UPM_SUCCESS;
+}
+
+float dfrorp_get_orp(const dfrorp_context dev)
+{
+  assert(dev != NULL);
+
+  return dev->orp * dev->scale + (dev->offset * dev->scale);
+}
+
+float dfrorp_get_volts(const dfrorp_context dev)
+{
+  assert(dev != NULL);
+
+  return dev->volts;
+}
+
+float dfrorp_get_normalized(const dfrorp_context dev)
+{
+  assert(dev != NULL);
+
+  return dev->normalized;
+}
+
+void dfrorp_set_calibration_offset(const dfrorp_context dev, float offset)
+{
+  assert(dev != NULL);
+
+  dev->orp_cal_offset = offset;
+}
diff --git a/ext/lib/upm/src/dfrorp/dfrorp.h b/ext/lib/upm/src/dfrorp/dfrorp.h
new file mode 100644
index 0000000..da15252
--- /dev/null
+++ b/ext/lib/upm/src/dfrorp/dfrorp.h
@@ -0,0 +1,181 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/aio.h"
+#include "mraa/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /**
+   * @brief UPM C API for the DFRobot ORP (Oxidation/Reduction
+   * Potential) Sensor
+   *
+   * The driver was tested with the DFRobot ORP Analog Sensor.
+   *
+   * To calibrate:
+   *
+   * Disconnect the sensor probe (but leave the sensor interface board
+   * connected).  Then run one of the examples while holding down the
+   * 'calibrate' button on the device.  Read the ORP value reported
+   * (it should be fairly small).
+   *
+   * This value is what you should supply to
+   * dfrorp_set_orp_cal_offset().  Then reconnect the probe to the
+   * interface board and you should be ready to go.
+   *
+   * DO NOT press the calibrate button on the interface board while
+   * the probe is attached or you can permanently damage the probe.
+   *
+   * @snippet dfrorp.c Interesting
+   */
+
+  /**
+   * Device context
+   */
+  typedef struct _dfrorp_context {
+    mraa_aio_context    aio;
+
+    // analog ADC resolution
+    float               a_res;
+
+    // analog reference voltage
+    float               a_ref;
+
+    // for external offset and scaling of the results
+    float               offset;
+    float               scale;
+
+    // For sensor interface board calibration
+    float               orp_cal_offset;
+
+    // our measurements
+
+    // ORP measurement (mV)
+    float               orp;
+
+    // volts
+    float               volts;
+
+    // normalized ADC
+    float               normalized;
+  } *dfrorp_context;
+
+  /**
+   * DFRORP Initializer
+   *
+   * @param apin Analog pin to use.
+   * @param a_ref The analog reference voltage in use
+   */
+  dfrorp_context dfrorp_init(unsigned int apin, float a_ref);
+
+  /**
+   * DFRORP sensor close function
+   */
+  void dfrorp_close(dfrorp_context dev);
+
+  /**
+   * Read the sensor status and update internal state.  dfrorp_update()
+   * must have been called before calling dfrorp_get_orp(),
+   * dfrorp_get_normalized(), or dfrorp_get_volts().
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  upm_result_t dfrorp_update(const dfrorp_context dev);
+
+  /**
+   * Set sensor offset.  This offset is applied to the ORP value
+   * before scaling.  Default is 0.0.
+   *
+   * @param dev sensor context pointer
+   * @param offset Offset to apply to the computed ORP value
+   */
+  void dfrorp_set_offset(const dfrorp_context dev, float offset);
+
+  /**
+   * Set sensor scale.  The ORP return value is scaled by this value
+   * before the offset is applied.  Default is 1.0.
+   *
+   * @param dev sensor context pointer
+   * @param scale The scale to apply to the computed ORP value
+   */
+  void dfrorp_set_scale(const dfrorp_context dev, float scale);
+
+  /**
+   * Get computed ORP (in millivolts) value from the
+   * sensor. dfrorp_update() must have been called prior to calling
+   * this function.
+   *
+   * @param dev sensor context pointer
+   * @return ORP value in millivolts
+   */
+  float dfrorp_get_orp(const dfrorp_context dev);
+
+  /**
+   * Set the calibration offset for the device.  This is
+   * determined by disconnecting the sensor probe (but leaving the
+   * sensor interface board connected).  Then run one of the examples
+   * while holding down the 'calibrate' button on the device.  Read
+   * the ORP value reported.
+   *
+   * This (low) ORP value is what you should supply to this function.
+   * Then reconnect the probe to the interface board and you should be
+   * ready to go.
+   *
+   * DO NOT press the calibrate button on the interface board while
+   * the probe is attached or you can permanently damage the probe.
+   *
+   * @param dev sensor context pointer
+   * @param offset The ORP offset obtained during calibration.
+   */
+  void dfrorp_set_calibration_offset(const dfrorp_context dev, float offset);
+
+  /**
+   * Get the raw measured volts from the sensor. dfrorp_update() must
+   * have been called prior to calling this function.
+   *
+   * @param dev sensor context pointer
+   * @return voltage read from the sensor
+   */
+  float dfrorp_get_volts(const dfrorp_context dev);
+
+  /**
+   * Get the raw normalized ADC values from the sensor.
+   * dfrorp_update() must have been called prior to calling this
+   * function.
+   *
+   * @param dev sensor context pointer
+   * @return normalized ADC value read from the sensor
+   */
+  float dfrorp_get_normalized(const dfrorp_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/dfrph/Kbuild b/ext/lib/upm/src/dfrph/Kbuild
new file mode 100644
index 0000000..643322a
--- /dev/null
+++ b/ext/lib/upm/src/dfrph/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_dfrph) += dfrph.o
diff --git a/ext/lib/upm/src/dfrph/Kconfig b/ext/lib/upm/src/dfrph/Kconfig
new file mode 100644
index 0000000..c0b392f
--- /dev/null
+++ b/ext/lib/upm/src/dfrph/Kconfig
@@ -0,0 +1,9 @@
+config UPM_dfrph
+    bool "dfrph"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm dfrobot pH sensor
+
diff --git a/ext/lib/upm/src/dfrph/Makefile b/ext/lib/upm/src/dfrph/Makefile
new file mode 100644
index 0000000..67cc0b6
--- /dev/null
+++ b/ext/lib/upm/src/dfrph/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_dfrph
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/dfrph
+endif
diff --git a/ext/lib/upm/src/dfrph/dfrph.c b/ext/lib/upm/src/dfrph/dfrph.c
new file mode 100644
index 0000000..1cde8ce
--- /dev/null
+++ b/ext/lib/upm/src/dfrph/dfrph.c
@@ -0,0 +1,109 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "dfrph.h"
+
+dfrph_context dfrph_init(int16_t pin)
+{
+    dfrph_context dev =
+      (dfrph_context) malloc(sizeof(struct _dfrph_context));
+
+    if(dev == NULL) return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    /* Set the ref, offset, and scale */
+    dev->m_aref = 5.0;
+    dev->m_offset = 0.0;
+    dev->m_scale = 1.0;
+
+    if(dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void dfrph_close(dfrph_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t dfrph_set_aref(const dfrph_context dev, float aref)
+{
+    dev->m_aref = aref;
+    return UPM_SUCCESS;
+}
+
+float dfrph_get_aref(const dfrph_context dev)
+{
+    return dev->m_aref;
+}
+
+upm_result_t dfrph_set_offset(const dfrph_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+upm_result_t dfrph_set_scale(const dfrph_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t dfrph_get_raw_volts(const dfrph_context dev, float *volts)
+{
+    *volts = mraa_aio_read_float(dev->aio);
+    if (*volts == -1.0) return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by aref */
+    *volts *= dev->m_aref;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t dfrph_get_ph(const dfrph_context dev, float *value)
+{
+    /* Read normalized */
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0.0) return UPM_ERROR_OPERATION_FAILED;
+
+    /* Apply scale */
+    *value *= dev->m_scale;
+
+    /* Vmax for sensor is 0.8 * Vref, so scale by 1/0.8 = 1.25 */
+    *value *= 1.25 * 14; /* Convert to pH */
+
+    /* Apply offset in pH */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/dfrph/dfrph.h b/ext/lib/upm/src/dfrph/dfrph.h
new file mode 100644
index 0000000..0f37466
--- /dev/null
+++ b/ext/lib/upm/src/dfrph/dfrph.h
@@ -0,0 +1,112 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * device context
+ */
+typedef struct _dfrph_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* ADC reference */
+    float m_aref;
+    /* Raw count offset */
+    float m_offset;
+    /* Raw count scale */
+    float m_scale;
+} *dfrph_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin is Analog pin
+ * @return sensor context as void pointer
+ */
+dfrph_context dfrph_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer deallocate memory
+ */
+void dfrph_close(dfrph_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t dfrph_set_aref(const dfrph_context dev, float aref);
+
+/**
+ *  Get sensor aref
+ *  @param dev sensor context pointer
+ *  @return Sensor ADC reference voltage
+ */
+float dfrph_get_aref(const dfrph_context dev);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     counts = counts + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t dfrph_set_offset(const dfrph_context dev, float offset);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t dfrph_set_scale(const dfrph_context dev, float scale);
+
+/**
+ * Get raw volts
+ * @param dev sensor context pointer
+ * @param volts Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t dfrph_get_raw_volts(const dfrph_context dev, float *volts);
+
+/**
+ * Read value from sensor
+ * @param dev sensor context pointer
+ * @param value pointer to returned pH value from sensor
+ * @return Function result code
+ */
+upm_result_t dfrph_get_ph(const dfrph_context dev, float *value);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/ecezo/Kbuild b/ext/lib/upm/src/ecezo/Kbuild
new file mode 100644
index 0000000..a241cf1
--- /dev/null
+++ b/ext/lib/upm/src/ecezo/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ecezo) += ecezo.o
diff --git a/ext/lib/upm/src/ecezo/Kconfig b/ext/lib/upm/src/ecezo/Kconfig
new file mode 100644
index 0000000..e6889fd
--- /dev/null
+++ b/ext/lib/upm/src/ecezo/Kconfig
@@ -0,0 +1,8 @@
+config UPM_ecezo
+    bool "ecezo"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm EC-EZO EC Sensor
diff --git a/ext/lib/upm/src/ecezo/Makefile b/ext/lib/upm/src/ecezo/Makefile
new file mode 100644
index 0000000..bc929150
--- /dev/null
+++ b/ext/lib/upm/src/ecezo/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ecezo
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ecezo
+endif
diff --git a/ext/lib/upm/src/ecezo/ecezo.c b/ext/lib/upm/src/ecezo/ecezo.c
new file mode 100644
index 0000000..1da72cd
--- /dev/null
+++ b/ext/lib/upm/src/ecezo/ecezo.c
@@ -0,0 +1,666 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <ctype.h>
+
+#include <upm_utilities.h>
+
+#include "ecezo.h"
+
+// "Typical" command completion delay in ms
+#define CMD_DELAY (350)
+
+// uncomment for dubugging
+//#define ECEZO_DEBUG (1)
+
+// I2C read helper
+static int readBytes(const ecezo_context dev, uint8_t *buffer, int len)
+{
+    assert(dev != NULL);
+    assert(dev->i2c != NULL);
+
+    bool done = false;
+    int rv;
+    int retries = 10;
+
+    while (!done && (retries-- > 0))
+    {
+        if ((rv = mraa_i2c_read(dev->i2c, buffer, len)) < 0)
+        {
+            printf("%s: mraa_i2c_read(code) failed.\n", __FUNCTION__);
+            return rv;
+        }
+
+#if defined(ECEZO_DEBUG)
+        printf("CODE: %02x\n", buffer[0]);
+#endif
+
+        if (buffer[0] == 0xff || buffer[0] == 0x02)
+        {
+            // no data available, or error
+            return -1;
+        }
+        else if (buffer[0] == 0x01)
+        {
+            // data is ready
+            done = true;
+
+            // now we need to move the data one byte down so the rest
+            // of this driver can work as-is.
+            memmove(buffer, (buffer + 1), len - 1);
+        }
+        else
+        {
+            // buffer[0] 0xfe - data is pending. wait and loop again.
+            upm_delay_ms(CMD_DELAY);
+        }
+    }
+
+    if (retries <= 0)
+    {
+        printf("%s: timed out waiting for correct response.\n", __FUNCTION__);
+        return -1;
+    }
+
+#if defined(ECEZO_DEBUG)
+    printf("%s: Got %d bytes\n", __FUNCTION__, rv);
+
+    for (int i=0; i<rv; i++)
+    {
+        printf("%02x (%c) ", buffer[i],
+               isprint(buffer[i]) ? buffer[i] : '@');
+    }
+    printf("\n");
+#endif // ECEZO_DEBUG
+
+    return rv;
+}
+
+static upm_result_t generic_init(const ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    // do some generic initialization
+    bool error = false;
+
+    // turn off response (*OK) codes (UART only)
+    if (dev->uart)
+    {
+        if (ecezo_send_command(dev, "Response,0", NULL, 0) < 0)
+            error = true;
+    }
+
+    // turn off continuous sampling
+    if (ecezo_set_continuous(dev, false))
+        error = true;
+
+    // make sure all parameters are enabled
+    if (ecezo_send_command(dev, "O,EC,1", NULL, 0) < 0)
+        error = true;
+    if (ecezo_send_command(dev, "O,TDS,1", NULL, 0) < 0)
+        error = true;
+    if (ecezo_send_command(dev, "O,S,1", NULL, 0) < 0)
+        error = true;
+    if (ecezo_send_command(dev, "O,SG,1", NULL, 0) < 0)
+        error = true;
+
+    if (error)
+        return UPM_ERROR_OPERATION_FAILED;
+    else
+        return UPM_SUCCESS;
+}
+
+static upm_result_t decode_report(const ecezo_context dev, char *data)
+{
+    assert(dev != NULL);
+
+    char *startptr = data;
+    char *endptr = NULL;
+    float val;
+
+    // the format of the data string should be: ec,tds,s,sg
+
+    // ec
+    val = strtof(startptr, &endptr);
+
+    if (startptr == endptr)
+    {
+        // error
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    dev->ec = val;
+    startptr = endptr + 1;
+
+    // tds
+    val = strtof(startptr, &endptr);
+
+    // error
+    if (startptr == endptr)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    dev->tds = val;
+    startptr = endptr + 1;
+
+    // salinity
+    val = strtof(startptr, &endptr);
+
+    // error
+    if (startptr == endptr)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    dev->salinity = val;
+    startptr = endptr + 1;
+
+    // sg
+    val = strtof(startptr, &endptr);
+
+    if (startptr == endptr)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    dev->sg = val;
+
+    return UPM_SUCCESS;
+}
+
+static bool ecezo_data_available(const ecezo_context dev, unsigned int millis)
+{
+    assert(dev != NULL);
+
+    // i2c, we don't support this
+    if (dev->i2c)
+    {
+        return false;
+    }
+
+    // uart
+    if (mraa_uart_data_available(dev->uart, millis))
+        return true;
+    else
+        return false;
+}
+
+// uart init
+ecezo_context ecezo_uart_init(unsigned int uart, unsigned int baudrate)
+{
+    ecezo_context dev =
+        (ecezo_context)malloc(sizeof(struct _ecezo_context));
+
+    if (!dev)
+        return NULL;
+
+    // zero out context
+    memset((void *)dev, 0, sizeof(struct _ecezo_context));
+
+    // initialize the MRAA contexts
+
+    // uart, default should be 8N1
+    if (!(dev->uart = mraa_uart_init(uart)))
+    {
+        printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
+        ecezo_close(dev);
+        return NULL;
+    }
+
+    if (mraa_uart_set_baudrate(dev->uart, baudrate))
+    {
+        printf("%s: mraa_uart_set_baudrate() failed.\n", __FUNCTION__);
+        ecezo_close(dev);
+        return NULL;
+    }
+
+    mraa_uart_set_flowcontrol(dev->uart, false, false);
+
+    if (generic_init(dev))
+    {
+        printf("%s: generic_init() failed.\n", __FUNCTION__);
+        ecezo_close(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+// i2c ublox init
+ecezo_context ecezo_i2c_init(unsigned int bus, uint8_t addr)
+{
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        return NULL;
+    }
+
+    ecezo_context dev =
+        (ecezo_context)malloc(sizeof(struct _ecezo_context));
+
+    if (!dev)
+        return NULL;
+
+    // zero out context
+    memset((void *)dev, 0, sizeof(struct _ecezo_context));
+
+    // initialize the MRAA contexts
+
+    if (!(dev->i2c = mraa_i2c_init(bus)))
+    {
+        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
+        ecezo_close(dev);
+        return NULL;
+    }
+
+    if (mraa_i2c_address(dev->i2c, addr))
+    {
+        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
+        ecezo_close(dev);
+        return NULL;
+    }
+
+    if (generic_init(dev))
+    {
+        printf("%s: generic_init() failed.\n", __FUNCTION__);
+        ecezo_close(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void ecezo_close(ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->uart)
+        mraa_uart_stop(dev->uart);
+    if (dev->i2c)
+        mraa_i2c_stop(dev->i2c);
+
+    free(dev);
+}
+
+upm_result_t ecezo_set_continuous(const ecezo_context dev, bool enable)
+{
+    int rv;
+
+    if (enable)
+        rv = ecezo_send_command(dev, "C,1", NULL, 0);
+    else
+        rv = ecezo_send_command(dev, "C,0", NULL, 0);
+
+    return ((rv < 0) ? UPM_ERROR_OPERATION_FAILED : UPM_SUCCESS);
+}
+
+upm_result_t ecezo_set_temperature(const ecezo_context dev, float temp)
+{
+    char buffer[ECEZO_MAX_BUFFER_LEN];
+
+    snprintf(buffer, ECEZO_MAX_BUFFER_LEN, "T,%f", temp);
+
+    int rv = ecezo_send_command(dev, buffer, NULL, 0);
+
+    return ((rv < 0) ? UPM_ERROR_OPERATION_FAILED : UPM_SUCCESS);
+}
+
+upm_result_t ecezo_set_led(const ecezo_context dev, bool enable)
+{
+    int rv;
+
+    if (enable)
+        rv = ecezo_send_command(dev, "L,1", NULL, 0);
+    else
+        rv = ecezo_send_command(dev, "L,0", NULL, 0);
+
+    return ((rv < 0) ? UPM_ERROR_OPERATION_FAILED : UPM_SUCCESS);
+}
+
+upm_result_t ecezo_set_k_value(const ecezo_context dev, float k)
+{
+    char buffer[ECEZO_MAX_BUFFER_LEN];
+
+    // the K value must be between 0.1 and 10.0
+    if (k < 0.1 || k > 10.0)
+    {
+        printf("%s: K value must be between 0.1 and 10.0\n", __FUNCTION__);
+        return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+    snprintf(buffer, ECEZO_MAX_BUFFER_LEN, "K,%f", k);
+
+    int rv = ecezo_send_command(dev, buffer, NULL, 0);
+
+    return ((rv < 0) ? UPM_ERROR_OPERATION_FAILED : UPM_SUCCESS);
+}
+
+upm_result_t ecezo_set_sleep(const ecezo_context dev, bool enable)
+{
+    int rv = 0;
+
+    if (enable)
+        rv =  ecezo_send_command(dev, "SLEEP", NULL, 0);
+    else
+    {
+        // "WAKE" isn't a real command, but should wake the device up.
+        // We ignore the return value, as it will likely be an error
+        // anyway.
+        ecezo_send_command(dev, "WAKE", NULL, 0);
+    }
+
+    return ((rv < 0) ? UPM_ERROR_OPERATION_FAILED : UPM_SUCCESS);
+}
+
+int ecezo_read(const ecezo_context dev, char *buffer, size_t len)
+{
+    assert(dev != NULL);
+
+    upm_delay_ms(CMD_DELAY); // delay CMD_DELAY ms to make sure cmd completed
+
+    // i2c
+    if (dev->i2c)
+    {
+        return readBytes(dev, (uint8_t *)buffer, len);
+    }
+    else
+    {
+        // UART
+        int bytesRead = 0;
+
+        while(bytesRead < len)
+        {
+            // we read one byte at a time, exiting when either len is
+            // reached, or a '\r' is found indicating the end of a
+            // sentence. Most commands (except 'R') require a minimum
+            // of 300ms to execute, so we wait up to CMD_DELAY ms after all
+            // data (if any) is read.
+            if (ecezo_data_available(dev, CMD_DELAY))
+            {
+                int br = mraa_uart_read(dev->uart, &buffer[bytesRead], 1);
+
+                if (br <= 0)
+                    return br;
+
+                if (buffer[bytesRead] == '\r')
+                {
+                    // if we found a CR, replace it with a 0 byte
+                    buffer[bytesRead++] = 0;
+                    return bytesRead;
+                }
+                bytesRead++;
+            }
+            else
+            {
+                // timed out - ok with responses disabled
+                return 0;
+            }
+        }
+    }
+
+    // anything else is an error
+    return -1;
+}
+
+upm_result_t ecezo_write(const ecezo_context dev, char *buffer, size_t len)
+{
+    assert(dev != NULL);
+
+    if (dev->uart)
+    {
+        if (mraa_uart_write(dev->uart, buffer, len) != len)
+        {
+            printf("%s: mraa_uart_write() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+
+    }
+    else
+    {
+        // I2C
+        if (mraa_i2c_write(dev->i2c, (uint8_t *)buffer, len))
+        {
+            printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+    }
+
+    return UPM_SUCCESS;
+}
+
+int ecezo_send_command(const ecezo_context dev, char *cmd, char *buffer,
+                       int len)
+{
+    assert(dev != NULL);
+
+    if (!cmd)
+        return -1;
+
+    // Our local buffer in case one isn't supplied
+    char localBuffer[ECEZO_MAX_BUFFER_LEN];
+
+    // our read buffer ptr
+    char *readBuffer = NULL;
+
+    if (!buffer || !len)
+    {
+        readBuffer = localBuffer;
+        len = ECEZO_MAX_BUFFER_LEN;
+    }
+    else
+    {
+        readBuffer = buffer;
+    }
+
+#if defined(ECEZO_DEBUG)
+    printf("Command: %s\n", cmd);
+#endif // ECEZO_DEBUG
+
+    // our write buffer
+    char writeBuffer[ECEZO_MAX_BUFFER_LEN];
+
+    strncpy(writeBuffer, cmd, ECEZO_MAX_BUFFER_LEN);
+    writeBuffer[ECEZO_MAX_BUFFER_LEN - 1] = 0;
+
+    int writelen = strlen(writeBuffer);
+
+    if (dev->uart)
+    {
+        if (strlen(writeBuffer) >= ECEZO_MAX_BUFFER_LEN - 2)
+        {
+            // too big.  Should never happen in real life.
+            printf("%s: cmd writeBuffer too big.\n", __FUNCTION__);
+            return -1;
+        }
+
+        strcat(writeBuffer, "\r");
+    }
+
+    // for the uart this will now include the added CR, for I2C, this
+    // will now include the already existing \0 terminator.
+    writelen++;
+
+    // Let the games begin...
+    int retries = 10;
+
+    while (retries-- > 0)
+    {
+        if (ecezo_write(dev, writeBuffer, writelen))
+        {
+            printf("%s: ecezo_write() failed\n", __FUNCTION__);
+            return -1;
+        }
+
+        // we wait up to CMD_DELAY ms for an error response, which should be
+        // more than enough time.  No response is also ok, since we
+        // disable the "*OK" response in the init.
+
+        memset((void *)readBuffer, 0, len);
+        int bytesRead = 0;
+        if ((bytesRead = ecezo_read(dev, readBuffer, len)) < 0)
+        {
+            return -1;
+        }
+
+        // for I2C, we are done at this point
+        if (dev->i2c)
+            break;
+
+        // for UART, we need some more checks
+        if (bytesRead && strstr(readBuffer, "*ER"))
+        {
+            // need to retry the command
+#if defined(ECEZO_DEBUG)
+            printf("%s: *ER DETECTED, retry\n", __FUNCTION__);
+#endif // ECEZO_DEBUG
+            continue;
+        }
+        else if (bytesRead && strchr(readBuffer, '*'))
+        {
+            // Some other diagnostic code, output it.
+#if defined(ECEZO_DEBUG)
+            printf("%s: * diagnostic code detected (%s), retry\n",
+                   __FUNCTION__, buffer);
+#endif // ECEZO_DEBUG
+            continue;
+        }
+        else
+        {
+            // we are done here
+#if defined(ECEZO_DEBUG)
+            printf("%s: bytesRead = %d\n", __FUNCTION__, bytesRead);
+#endif // ECEZO_DEBUG
+
+            break;
+        }
+    }
+
+    if (retries <= 0)
+    {
+        printf("%s: read timed out and/or and retries exhausted\n",
+               __FUNCTION__);
+        return 0;
+    }
+
+    return len;
+}
+
+upm_result_t ecezo_update(const ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    // first we send a 'R' command to get a reading (takes a minimum
+    // of 1 second), then we parse out the string values into the
+    // context variables.
+
+    char buffer[ECEZO_MAX_BUFFER_LEN];
+
+    // first issue the report command
+    int rv = ecezo_send_command(dev, "R", buffer, ECEZO_MAX_BUFFER_LEN);
+    if (rv == 0)
+    {
+        printf("%s: timed out waiting for data\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    else if (rv < 0)
+    {
+        printf("%s: error retrieving data\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // decode
+    if (decode_report(dev, buffer))
+    {
+        printf("%s: decode_report() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
+
+float ecezo_get_ec(const ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->ec;
+}
+
+float ecezo_get_tds(const ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->tds;
+}
+
+float ecezo_get_salinity(const ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->salinity;
+}
+
+float ecezo_get_sg(const ecezo_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->sg;
+}
+
+upm_result_t ecezo_calibrate(const ecezo_context dev, ECEZO_CALIBRATION_T cal,
+                             float ec)
+{
+    assert(dev != NULL);
+
+    char cmdBuffer[ECEZO_MAX_BUFFER_LEN];
+
+    switch(cal)
+    {
+    case ECEZO_CALIBRATE_CLEAR:
+        snprintf(cmdBuffer, ECEZO_MAX_BUFFER_LEN, "cal,clear");
+        break;
+
+    case ECEZO_CALIBRATE_DRY:
+        snprintf(cmdBuffer, ECEZO_MAX_BUFFER_LEN, "cal,dry");
+        break;
+
+    case ECEZO_CALIBRATE_ONE:
+        snprintf(cmdBuffer, ECEZO_MAX_BUFFER_LEN, "cal,one,%f", ec);
+        break;
+
+    case ECEZO_CALIBRATE_LOW:
+        snprintf(cmdBuffer, ECEZO_MAX_BUFFER_LEN, "cal,low,%f", ec);
+        break;
+
+    case ECEZO_CALIBRATE_HIGH:
+        snprintf(cmdBuffer, ECEZO_MAX_BUFFER_LEN, "cal,high,%f", ec);
+        break;
+
+    default:
+        // should be able to happen
+        printf("%s: invalid cal parameter\n", __FUNCTION__);
+        return UPM_ERROR_INVALID_PARAMETER;
+    }
+
+    return ecezo_send_command(dev, cmdBuffer, NULL, 0);
+}
diff --git a/ext/lib/upm/src/ecezo/ecezo.h b/ext/lib/upm/src/ecezo/ecezo.h
new file mode 100644
index 0000000..a6a738a
--- /dev/null
+++ b/ext/lib/upm/src/ecezo/ecezo.h
@@ -0,0 +1,267 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include <upm.h>
+#include <mraa/uart.h>
+#include <mraa/i2c.h>
+#include <mraa/gpio.h>
+
+#include "ecezo_defs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file ecezo.h
+     * @library ecezo
+     * @brief C API for the EC-EZO EC Sensor
+     *
+     * @include ecezo.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _ecezo_context {
+        mraa_uart_context        uart;
+        mraa_i2c_context         i2c;
+
+        // our values
+        float                    ec;          // electrical conductivity
+        float                    tds;         // total dissolved solids
+        float                    salinity;
+        float                    sg;          // specific gravity
+
+    } *ecezo_context;
+
+    /**
+     * ECEZO Initializer for UART operation
+     *
+     * @param uart Specify which uart to use.
+     * @param baudrate Specify the baudrate to use.  The device defaults
+     * to 9600 baud, though the datasheet implies the default is 38400.
+     * @return an initialized device context on success, NULL on error.
+     */
+    ecezo_context ecezo_uart_init(unsigned int uart, unsigned int baudrate);
+
+    /**
+     * ECEZO Initializer for I2C operation
+     *
+     * @param bus Specify which the I2C bus to use.
+     * @param addr Specify the I2C address to use.  This is
+     * configurable on the device, so there is no default.
+     * @return an initialized device context on success, NULL on error.
+     */
+    ecezo_context ecezo_i2c_init(unsigned int bus, uint8_t addr);
+
+    /**
+     * ECEZO sensor close function
+     */
+    void ecezo_close(ecezo_context dev);
+
+    /**
+     * Query the device for a reading, parse the response, and store
+     * the read values into the device context.  This function must be
+     * called prior to calling any function that returns the data,
+     * like ecezo_get_ec().
+     *
+     * @param dev Device context
+     * @return UPM result
+     */
+    upm_result_t ecezo_update(const ecezo_context dev);
+
+    /**
+     * For accurate readings, the temperature of the liquid being
+     * measured should be known. This function allows you to specify
+     * the liquid's temperature (in Celsius) so that proper
+     * compensation can take place.  How you measure this temperature
+     * is up to you.  By default, the device will assume a temperature
+     * of 25C.
+     *
+     * @param dev Device context
+     * @param temp The temperature of the liquid being measured
+     * @return UPM result
+     */
+    upm_result_t ecezo_set_temperature(const ecezo_context dev, float temp);
+
+    /**
+     * Set the K value of the probe being used.  By default, this is
+     * 1.0. Valid values are between 0.1 and 10.0.
+     *
+     * @param dev Device context
+     * @param k The K value of the probe
+     * @return UPM result
+     */
+    upm_result_t ecezo_set_k_value(const ecezo_context dev, float k);
+
+    /**
+     * Enable or disable Sleep mode.
+     *
+     * @param dev Device context
+     * @param enable True to enable sleep mode, false to wake up
+     * @return UPM result
+     */
+    upm_result_t ecezo_set_sleep(const ecezo_context dev, bool enable);
+
+    /**
+     * Retrieve the last measured Electrical Conductivity (EC) value
+     * in microsiemens.  ecezo_update() must have been called before
+     * calling this function.
+     *
+     * @param dev Device context
+     * @return EC value in microsiemens
+     */
+    float ecezo_get_ec(const ecezo_context dev);
+
+    /**
+     * Retrieve the last measured Total Dissolved solids (TDS) value.
+     * ecezo_update() must have been called before calling this
+     * function.
+     *
+     * @param dev Device context
+     * @return TDS value
+     */
+    float ecezo_get_tds(const ecezo_context dev);
+
+    /**
+     * Retrieve the last measured Salinity value.  ecezo_update() must
+     * have been called before calling this function.
+     *
+     * @param dev Device context
+     * @return Salinity value
+     */
+    float ecezo_get_salinity(const ecezo_context dev);
+
+    /**
+     * Retrieve the last measured Specific Gravity (SG) value.
+     * ecezo_update() must have been called before calling this
+     * function.
+     *
+     * @param dev Device context
+     * @return SG value
+     */
+    float ecezo_get_sg(const ecezo_context dev);
+
+    /**
+     * Specify calibration data for calibrating the device.  See the
+     * datasheet for details on how calibration is performed.  This
+     * function provides a mechanism for clearing out, and setting
+     * calibration data.
+     *
+     * A simple one point calibration might work as follows:
+     *
+     * 1. CLEAR the calibration data
+     * 2. with a dry probe, set the DRY point.
+     * 3. with the probe immersed in a standardized solution, set the
+     * ONE parameter to the solution's known EC value in microsiemens.
+     *
+     * A two point calibration might work as follows:
+     *
+     * 1. CLEAR the calibration data
+     * 2. with a dry probe, set the DRY point.
+     * 3. with the probe immersed in the lowest EC standardized
+     * solution, set the LOW parameter to the solution's known EC
+     * value in microsiemens.
+     * 4. with the probe immersed in the highest EC standardized
+     * solution, set the HIGH parameter to the solution's known EC
+     * value in microsiemens.
+     *
+     * @param dev Device context
+     * @param cal One of the ECEZO_CALIBRATION_T values
+     * @param ec The EC value of the calibration fluid.  This
+     * parameter is ignored when cal is either ECEZO_CALIBRATE_CLEAR
+     * or ECEZO_CALIBRATE_DRY.
+     * @return UPM result
+     */
+    upm_result_t ecezo_calibrate(const ecezo_context dev,
+                                 ECEZO_CALIBRATION_T cal,
+                                 float ec);
+
+    /**
+     * Enable or disable "continuous" operation.  In continuous
+     * operation, the device will sample and emit readings every
+     * second.  The driver disables this mode by default.  If you wish
+     * to use continuous mode, you will be responsible for reading and
+     * parsing the returned data yourself.
+     *
+     * The functionality of this driver depends on continuous mode
+     * being disabled.  When disabled, the driver will manually
+     * request a reading when desired via ecezo_update().
+     *
+     * @param dev Device context
+     * @param enable true to enable continuous mode, false to disable.
+     * @return UPM result
+     */
+    upm_result_t ecezo_set_continuous(const ecezo_context dev, bool enable);
+
+    /**
+     * Directly send a command to the device and optionally get a
+     * response.  This is a low level function and should not be
+     * called unless you know what you are doing.
+     *
+     * @param dev Device context
+     * @param cmd command to send to the device.  See the datasheet
+     * for valid commands.
+     * @param buffer Optional buffer in which to return any data.
+     * NULL if you are not interested in any returned data.
+     * @param len Length of the buffer, or 0 if you are not interested
+     * in returned data
+     * @return Number of characters read back, 0 if a timeout or no
+     * data, -1 if an error
+     */
+    int ecezo_send_command(const ecezo_context dev, char *cmd,
+                           char *buffer, int len);
+
+    /**
+     * Read character data from the device.  This is a low level
+     * function and should not be called unless you know what you are
+     * doing.
+     *
+     * @param dev sensor context
+     * @param buffer The character buffer to read data into.
+     * @param len The maximum size of the buffer
+     * @return The number of bytes successfully read, or -1 on error
+     */
+    int ecezo_read(const ecezo_context dev, char *buffer, size_t len);
+
+    /**
+     * Write character data to the device.  This is a low level
+     * function and should not be called unless you know what you are
+     * doing.
+     *
+     * @param dev sensor context
+     * @param buffer The character buffer containing data to write.
+     * @param len The number of bytes to write.
+     * @return The number of bytes successfully written, or -1 on error.
+     */
+    upm_result_t ecezo_write(const ecezo_context dev, char *buffer, size_t len);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/ecezo/ecezo_defs.h b/ext/lib/upm/src/ecezo/ecezo_defs.h
new file mode 100644
index 0000000..4773644
--- /dev/null
+++ b/ext/lib/upm/src/ecezo/ecezo_defs.h
@@ -0,0 +1,45 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// our maximum buffer size
+#define ECEZO_MAX_BUFFER_LEN (64)
+
+    // calibration commands
+    typedef enum {
+        ECEZO_CALIBRATE_CLEAR            = 0, // clear calibration
+        ECEZO_CALIBRATE_DRY,                  // cal dry point
+        ECEZO_CALIBRATE_ONE,                  // single point cal EC value
+        ECEZO_CALIBRATE_LOW,                  // 2-point cal, LOW EC value
+        ECEZO_CALIBRATE_HIGH                  // 2-point cal, HIGH EC value
+    } ECEZO_CALIBRATION_T;
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/emg/Kbuild b/ext/lib/upm/src/emg/Kbuild
new file mode 100644
index 0000000..a6371e4
--- /dev/null
+++ b/ext/lib/upm/src/emg/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_emg) += emg.o
diff --git a/ext/lib/upm/src/emg/Kconfig b/ext/lib/upm/src/emg/Kconfig
new file mode 100644
index 0000000..ec27014
--- /dev/null
+++ b/ext/lib/upm/src/emg/Kconfig
@@ -0,0 +1,9 @@
+config UPM_emg
+    bool "emg"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm emg muscle signal reader sensor module
+
diff --git a/ext/lib/upm/src/emg/Makefile b/ext/lib/upm/src/emg/Makefile
new file mode 100644
index 0000000..6e20b1b
--- /dev/null
+++ b/ext/lib/upm/src/emg/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_emg
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/emg
+endif
diff --git a/ext/lib/upm/src/emg/emg.c b/ext/lib/upm/src/emg/emg.c
new file mode 100644
index 0000000..68ef29b
--- /dev/null
+++ b/ext/lib/upm/src/emg/emg.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "emg.h"
+
+emg_context emg_init(int16_t pin)
+{
+    emg_context dev = (emg_context) malloc(sizeof(struct _emg_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void emg_close(emg_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t emg_set_aref(const emg_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t emg_set_scale(const emg_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t emg_set_offset(const emg_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float emg_get_aref(const emg_context dev)
+{
+    return dev->m_aRef;
+}
+
+float emg_get_scale(const emg_context dev)
+{
+    return dev->m_scale;
+}
+
+float emg_get_offset(const emg_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t emg_get_normalized(const emg_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t emg_get_raw_volts(const emg_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t emg_get_volts(const emg_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+     /* Scale to aRef */
+    *value *= dev->m_aRef;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/emg/emg.h b/ext/lib/upm/src/emg/emg.h
new file mode 100644
index 0000000..e28678b
--- /dev/null
+++ b/ext/lib/upm/src/emg/emg.h
@@ -0,0 +1,133 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * driver context
+ */
+typedef struct _emg_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *emg_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+emg_context emg_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void emg_close(emg_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t emg_set_aref(const emg_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t emg_set_scale(const emg_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     value = value + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t emg_set_offset(const emg_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float emg_get_aref(const emg_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float emg_get_scale(const emg_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float emg_get_offset(const emg_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t emg_get_normalized(const emg_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t emg_get_raw_volts(const emg_context dev, float *value);
+
+/**
+ * Read scaled/offset voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor voltage
+ * @return Function result code
+ */
+upm_result_t emg_get_volts(const emg_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/flex/Kbuild b/ext/lib/upm/src/flex/Kbuild
new file mode 100644
index 0000000..a80afa8
--- /dev/null
+++ b/ext/lib/upm/src/flex/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_flex) += flex.o
diff --git a/ext/lib/upm/src/flex/Kconfig b/ext/lib/upm/src/flex/Kconfig
new file mode 100644
index 0000000..744ffba
--- /dev/null
+++ b/ext/lib/upm/src/flex/Kconfig
@@ -0,0 +1,9 @@
+config UPM_flex
+    bool "flex"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm flex sensor module
+
diff --git a/ext/lib/upm/src/flex/Makefile b/ext/lib/upm/src/flex/Makefile
new file mode 100644
index 0000000..9fedda4
--- /dev/null
+++ b/ext/lib/upm/src/flex/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_flex
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/flex
+endif
diff --git a/ext/lib/upm/src/flex/flex.c b/ext/lib/upm/src/flex/flex.c
new file mode 100644
index 0000000..4cfe6b9
--- /dev/null
+++ b/ext/lib/upm/src/flex/flex.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "flex.h"
+
+flex_context flex_init(int16_t pin)
+{
+    flex_context dev = (flex_context) malloc(sizeof(struct _flex_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void flex_close(flex_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t flex_set_aref(const flex_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t flex_set_scale(const flex_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t flex_set_offset(const flex_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float flex_get_aref(const flex_context dev)
+{
+    return dev->m_aRef;
+}
+
+float flex_get_scale(const flex_context dev)
+{
+    return dev->m_scale;
+}
+
+float flex_get_offset(const flex_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t flex_get_normalized(const flex_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t flex_get_raw_volts(const flex_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t flex_get_volts(const flex_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+     /* Scale to aRef */
+    *value *= dev->m_aRef;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/flex/flex.h b/ext/lib/upm/src/flex/flex.h
new file mode 100644
index 0000000..de18829
--- /dev/null
+++ b/ext/lib/upm/src/flex/flex.h
@@ -0,0 +1,133 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * driver context
+ */
+typedef struct _flex_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *flex_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+flex_context flex_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void flex_close(flex_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t flex_set_aref(const flex_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t flex_set_scale(const flex_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     value = value + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t flex_set_offset(const flex_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float flex_get_aref(const flex_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float flex_get_scale(const flex_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float flex_get_offset(const flex_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t flex_get_normalized(const flex_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t flex_get_raw_volts(const flex_context dev, float *value);
+
+/**
+ * Read scaled/offset voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor voltage
+ * @return Function result code
+ */
+upm_result_t flex_get_volts(const flex_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/gas/Kbuild b/ext/lib/upm/src/gas/Kbuild
new file mode 100644
index 0000000..4da5f99
--- /dev/null
+++ b/ext/lib/upm/src/gas/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_gas) += mqx.o
diff --git a/ext/lib/upm/src/gas/Kconfig b/ext/lib/upm/src/gas/Kconfig
new file mode 100644
index 0000000..b90469f
--- /dev/null
+++ b/ext/lib/upm/src/gas/Kconfig
@@ -0,0 +1,9 @@
+config UPM_gas
+    bool "gas"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        Gas sensors
+
diff --git a/ext/lib/upm/src/gas/Makefile b/ext/lib/upm/src/gas/Makefile
new file mode 100644
index 0000000..8fc3e8f
--- /dev/null
+++ b/ext/lib/upm/src/gas/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_gas
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/gas
+endif
diff --git a/ext/lib/upm/src/gas/mqx.c b/ext/lib/upm/src/gas/mqx.c
new file mode 100644
index 0000000..8f8443f
--- /dev/null
+++ b/ext/lib/upm/src/gas/mqx.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "mqx.h"
+
+mqx_context mqx_init(int16_t pin)
+{
+    mqx_context dev = (mqx_context) malloc(sizeof(struct _mqx_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void mqx_close(mqx_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t mqx_set_aref(const mqx_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t mqx_set_scale(const mqx_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t mqx_set_offset(const mqx_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float mqx_get_aref(const mqx_context dev)
+{
+    return dev->m_aRef;
+}
+
+float mqx_get_scale(const mqx_context dev)
+{
+    return dev->m_scale;
+}
+
+float mqx_get_offset(const mqx_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t mqx_get_normalized(const mqx_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t mqx_get_raw_volts(const mqx_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mqx_get_volts(const mqx_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+     /* Scale to aRef */
+    *value *= dev->m_aRef;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/gas/mqx.h b/ext/lib/upm/src/gas/mqx.h
new file mode 100644
index 0000000..49c1cef
--- /dev/null
+++ b/ext/lib/upm/src/gas/mqx.h
@@ -0,0 +1,153 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The mqx gas sensor driver can be used to read a wide range of sensors.  The
+ * list below shows the currently supported sensors:
+ *
+ *      mq2: H2/LPG/CH4/CO/alcohol/smoke/propane/etc
+ *          LPG/propane 200-5000 ppm
+ *          butane 300-5000 ppm
+ *          CH4 5000-2000 ppm
+ *          H2 300-5000 ppm
+ *          alcohol 100-2000 ppm
+ *      mq3: Alcohol/benzine/CH4/hexane/LPG/CO .05-10 mg/L
+ *      mq4: CNG (mostly methane) 200-10000 ppm
+ *      mq5: H2/LPG/CH4/CO/alcohol 200-10000 ppm
+ *      mq6: LPG (mostly propane/butane) 200-10000 ppm
+ *      mq7: CO 20-2000 ppm
+ *      mq8: H 100-10000 ppm
+ *      mq9: CO/CH4/LPG 200-1000/10000/10000 ppm
+ *
+ */
+
+/**
+ * driver context
+ */
+typedef struct _mqx_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *mqx_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+mqx_context mqx_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void mqx_close(mqx_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t mqx_set_aref(const mqx_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t mqx_set_scale(const mqx_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     counts = counts + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t mqx_set_offset(const mqx_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float mqx_get_aref(const mqx_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float mqx_get_scale(const mqx_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float mqx_get_offset(const mqx_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t mqx_get_normalized(const mqx_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t mqx_get_raw_volts(const mqx_context dev, float *value);
+
+/**
+ * Read scaled/offset voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor voltage
+ * @return Function result code
+ */
+upm_result_t mqx_get_volts(const mqx_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/gp2y0a/Kbuild b/ext/lib/upm/src/gp2y0a/Kbuild
new file mode 100644
index 0000000..b49ae5c
--- /dev/null
+++ b/ext/lib/upm/src/gp2y0a/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_gp2y0a) += gp2y0a.o
diff --git a/ext/lib/upm/src/gp2y0a/Kconfig b/ext/lib/upm/src/gp2y0a/Kconfig
new file mode 100644
index 0000000..0fb3d45
--- /dev/null
+++ b/ext/lib/upm/src/gp2y0a/Kconfig
@@ -0,0 +1,9 @@
+config UPM_gp2y0a
+    bool "gp2y0a"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm gp2y0a family of IR distance detectors
+
diff --git a/ext/lib/upm/src/gp2y0a/Makefile b/ext/lib/upm/src/gp2y0a/Makefile
new file mode 100644
index 0000000..474cff7
--- /dev/null
+++ b/ext/lib/upm/src/gp2y0a/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_gp2y0a
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/gp2y0a
+endif
diff --git a/ext/lib/upm/src/gp2y0a/gp2y0a.c b/ext/lib/upm/src/gp2y0a/gp2y0a.c
new file mode 100644
index 0000000..f1bd715
--- /dev/null
+++ b/ext/lib/upm/src/gp2y0a/gp2y0a.c
@@ -0,0 +1,62 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "gp2y0a.h"
+
+gp2y0a_context gp2y0a_init(uint8_t pin, float a_ref){
+    gp2y0a_context dev = (gp2y0a_context) malloc(sizeof(struct _gp2y0a_context));
+
+    dev->pin = pin;
+    dev->aio = mraa_aio_init(dev->pin);
+    if(dev->aio == NULL){
+        return NULL;
+    }
+    dev->a_res = (1 << mraa_aio_get_bit(dev->aio));
+
+    return dev;
+}
+
+void gp2y0a_close(gp2y0a_context dev){
+    free(dev);
+}
+
+upm_result_t gp2y0a_get_value(gp2y0a_context dev, float a_ref,
+                              uint8_t samples, float* value){
+    int val;
+    int sum = 0;
+    int i = 0;
+
+    if (samples <= 0)
+      samples = 1;
+
+    for(i=0; i<samples; i++) {
+        val = mraa_aio_read(dev->aio);
+        sum += val;
+    }
+    val = sum/samples;
+    float volts = (float)(val * a_ref) / (float)dev->a_res;
+    *value = volts;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/gp2y0a/gp2y0a.h b/ext/lib/upm/src/gp2y0a/gp2y0a.h
new file mode 100644
index 0000000..8e3292f
--- /dev/null
+++ b/ext/lib/upm/src/gp2y0a/gp2y0a.h
@@ -0,0 +1,98 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef GP2Y0A_GP2Y0A_H_
+#define GP2Y0A_GP2Y0A_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <malloc.h>
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+/**
+ * device context
+ */
+typedef struct _gp2y0a_context {
+    mraa_aio_context            aio;
+    uint8_t                     pin;
+    int                         a_res;
+} *gp2y0a_context;
+
+/**
+ * @brief GP2Y0A-based IR Proximity Sensor library
+ * @defgroup gp2y0a libupm-gp2y0a
+ * @ingroup seeed analog light
+ */
+
+/**
+ * @library gp2y0a
+ * @sensor gp2y0a
+ * @comname GP2Y0A IR Proximity Sensor
+ * @altname Grove 80cm IR Proximity Sensor
+ * @type light
+ * @man seeed
+ * @con analog
+ *
+ * @brief API for the GP2Y0A family of IR Proximity Sensors
+ *
+ * Sensors of this family return an analog voltage corresponding to
+ * the distance of an object from the sensor. The voltage is lower
+ * when objects are far away; the voltage increases as objects get
+ * closer to the sensor.
+ *
+ * @image html gp2y0a.jpg
+ * @snippet gp2y0a.cxx Interesting
+ */
+
+/**
+ * GP2Y0A sensor init function
+ *
+ * @param pin Analog pin to use
+ * @param a_ref reference voltage
+ */
+gp2y0a_context gp2y0a_init(uint8_t pin, float a_ref);
+
+/**
+ * GP2Y0A close function
+ *
+ * @param dev sensor struct
+ */
+void gp2y0a_close(gp2y0a_context dev);
+
+/**
+ * Gets an average voltage value from the sensor
+ *
+ * @param dev sensor struct
+ * @param aref Reference voltage in use (usually 5.0V or 3.3V)
+ * @param samples Number of samples to average over
+ * @return Average voltage reading
+ */
+upm_result_t gp2y0a_get_value(gp2y0a_context dev, float a_ref, uint8_t samples,
+                              float* val);
+
+#endif /* GP2Y0A_GP2Y0A_H_ */
diff --git a/ext/lib/upm/src/gsr/Kbuild b/ext/lib/upm/src/gsr/Kbuild
new file mode 100644
index 0000000..e44bd13
--- /dev/null
+++ b/ext/lib/upm/src/gsr/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_gsr) += gsr.o
diff --git a/ext/lib/upm/src/gsr/Kconfig b/ext/lib/upm/src/gsr/Kconfig
new file mode 100644
index 0000000..0b6ce9e
--- /dev/null
+++ b/ext/lib/upm/src/gsr/Kconfig
@@ -0,0 +1,9 @@
+config UPM_gsr
+    bool "gsr"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm gsr galvanic skin response sensor module
+
diff --git a/ext/lib/upm/src/gsr/Makefile b/ext/lib/upm/src/gsr/Makefile
new file mode 100644
index 0000000..a2e043a
--- /dev/null
+++ b/ext/lib/upm/src/gsr/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_gsr
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/gsr
+endif
diff --git a/ext/lib/upm/src/gsr/gsr.c b/ext/lib/upm/src/gsr/gsr.c
new file mode 100644
index 0000000..3cfebd5
--- /dev/null
+++ b/ext/lib/upm/src/gsr/gsr.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "gsr.h"
+
+gsr_context gsr_init(int16_t pin)
+{
+    gsr_context dev = (gsr_context) malloc(sizeof(struct _gsr_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void gsr_close(gsr_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t gsr_set_aref(const gsr_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t gsr_set_scale(const gsr_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t gsr_set_offset(const gsr_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float gsr_get_aref(const gsr_context dev)
+{
+    return dev->m_aRef;
+}
+
+float gsr_get_scale(const gsr_context dev)
+{
+    return dev->m_scale;
+}
+
+float gsr_get_offset(const gsr_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t gsr_get_normalized(const gsr_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t gsr_get_raw_volts(const gsr_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t gsr_get_volts(const gsr_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+     /* Scale to aRef */
+    *value *= dev->m_aRef;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/gsr/gsr.h b/ext/lib/upm/src/gsr/gsr.h
new file mode 100644
index 0000000..6fa6a68
--- /dev/null
+++ b/ext/lib/upm/src/gsr/gsr.h
@@ -0,0 +1,133 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * driver context
+ */
+typedef struct _gsr_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *gsr_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+gsr_context gsr_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void gsr_close(gsr_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t gsr_set_aref(const gsr_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t gsr_set_scale(const gsr_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     value = value + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t gsr_set_offset(const gsr_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float gsr_get_aref(const gsr_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float gsr_get_scale(const gsr_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float gsr_get_offset(const gsr_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t gsr_get_normalized(const gsr_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t gsr_get_raw_volts(const gsr_context dev, float *value);
+
+/**
+ * Read scaled/offset voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor voltage
+ * @return Function result code
+ */
+upm_result_t gsr_get_volts(const gsr_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/guvas12d/Kbuild b/ext/lib/upm/src/guvas12d/Kbuild
new file mode 100644
index 0000000..9f21bad
--- /dev/null
+++ b/ext/lib/upm/src/guvas12d/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_guvas12d) += guvas12d.o
diff --git a/ext/lib/upm/src/guvas12d/Kconfig b/ext/lib/upm/src/guvas12d/Kconfig
new file mode 100644
index 0000000..1bea864
--- /dev/null
+++ b/ext/lib/upm/src/guvas12d/Kconfig
@@ -0,0 +1,8 @@
+config UPM_guvas12d
+    bool "guvas12d"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm GUVAS12D Analog UV Sensor
diff --git a/ext/lib/upm/src/guvas12d/Makefile b/ext/lib/upm/src/guvas12d/Makefile
new file mode 100644
index 0000000..aa8eadb
--- /dev/null
+++ b/ext/lib/upm/src/guvas12d/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_guvas12d
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/guvas12d
+endif
diff --git a/ext/lib/upm/src/guvas12d/guvas12d.c b/ext/lib/upm/src/guvas12d/guvas12d.c
new file mode 100644
index 0000000..e63f2fe
--- /dev/null
+++ b/ext/lib/upm/src/guvas12d/guvas12d.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#include <assert.h>
+#include <string.h>
+#include <upm_utilities.h>
+
+#include "guvas12d.h"
+
+guvas12d_context guvas12d_init(int pin, float aref)
+{
+    guvas12d_context dev =
+        (guvas12d_context)malloc(sizeof(struct _guvas12d_context));
+
+    if (!dev)
+        return NULL;
+
+    memset((void *)dev, 0, sizeof(struct _guvas12d_context));
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        guvas12d_close(dev);
+        return NULL;
+    }
+
+    // initialize the MRAA context
+
+    if (!(dev->aio = mraa_aio_init(pin)))
+    {
+        printf("%s: mraa_aio_init failed.\n", __FUNCTION__);
+        guvas12d_close(dev);
+
+        return NULL;
+    }
+
+    dev->ares = (float)((1 << mraa_aio_get_bit(dev->aio)) - 1);
+    dev->aref = aref;
+    dev->scale = 1.0;
+    dev->offset = 0.0;
+
+    return dev;
+}
+
+void guvas12d_close(guvas12d_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->aio)
+        mraa_aio_close(dev->aio);
+
+    free(dev);
+}
+
+upm_result_t guvas12d_get_volts(const guvas12d_context dev, float *volts)
+{
+    assert(dev != NULL);
+
+    int val;
+
+    val = mraa_aio_read(dev->aio);
+    if (val < 0)
+    {
+        printf("%s: mraa_aio_read() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    *volts = (float)val * (dev->aref / dev->ares);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t guvas12d_get_intensity(const guvas12d_context dev,
+                                    float *intensity)
+{
+    assert(dev != NULL);
+
+    float volts;
+    if (guvas12d_get_volts(dev, &volts))
+    {
+        printf("%s: guvas12d_get_volts() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Seeed magic number 307.0
+    *intensity = volts * 307.0;
+
+    *intensity = *intensity * dev->scale + (dev->offset * dev->scale);
+
+    return UPM_SUCCESS;
+}
+
+void guvas12d_set_offset(const guvas12d_context dev, float offset)
+{
+    assert(dev != NULL);
+
+    dev->offset = offset;
+}
+
+void guvas12d_set_scale(const guvas12d_context dev, float scale)
+{
+    assert(dev != NULL);
+
+    dev->scale = scale;
+}
diff --git a/ext/lib/upm/src/guvas12d/guvas12d.h b/ext/lib/upm/src/guvas12d/guvas12d.h
new file mode 100644
index 0000000..f4d8658
--- /dev/null
+++ b/ext/lib/upm/src/guvas12d/guvas12d.h
@@ -0,0 +1,108 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+#include <mraa/aio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file guvas12d.h
+     * @library guvas12d
+     * @brief C API for the guvas12d driver
+     *
+     * @include guvas12d.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _guvas12d_context {
+        mraa_aio_context    aio;
+
+        // ADC reference voltage
+        float               aref;
+        // ADC resolution
+        float               ares;
+
+        float               scale;
+        float               offset;
+    } *guvas12d_context;
+
+    /**
+     * GUVA-S12D UV sensor constructor
+     *
+     * @param pin Analog pin to use
+     */
+    guvas12d_context guvas12d_init(int pin, float aref);
+
+    /**
+     * GUVAS12D destructor
+     */
+    void guvas12d_close(guvas12d_context dev);
+
+    /**
+     * Gets the voltage value from the sensor
+     *
+     * @param volts Pointer to average voltage reading
+     * @return UPM status.
+     */
+    upm_result_t guvas12d_get_volts(const guvas12d_context dev, float *volts);
+
+    /**
+     * Gets the illumination intensity in mW/m^2
+     *
+     * @param volts Pointer to average voltage reading
+     * @return UPM status.
+     * @return illumination intensity in mW/m^2
+     */
+    upm_result_t guvas12d_get_intensity(const guvas12d_context dev,
+                                        float *intensity);
+
+    /**
+     * Set sensor offset.  This offset is applied to the illumination
+     * intensity value before scaling.  Default is 0.0.
+     *
+     * @param dev sensor context pointer
+     * @param offset Offset to apply.
+     */
+    void guvas12d_set_offset(const guvas12d_context dev, float offset);
+
+    /**
+     * Set sensor scale.  This offset is applied to the illumination
+     * intensity value before scaling.  Default is 1.0.
+     *
+     * @param dev sensor context pointer
+     * @param scale Scale to apply.
+     */
+    void guvas12d_set_scale(const guvas12d_context dev, float scale);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/hka5/Kbuild b/ext/lib/upm/src/hka5/Kbuild
new file mode 100644
index 0000000..cff023f
--- /dev/null
+++ b/ext/lib/upm/src/hka5/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_hka5) += hka5.o
diff --git a/ext/lib/upm/src/hka5/Kconfig b/ext/lib/upm/src/hka5/Kconfig
new file mode 100644
index 0000000..23e366e
--- /dev/null
+++ b/ext/lib/upm/src/hka5/Kconfig
@@ -0,0 +1,9 @@
+config UPM_hka5
+    bool "hka5"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM driver for DFRobot HKA5 PM2.5 particle sensor
+
diff --git a/ext/lib/upm/src/hka5/Makefile b/ext/lib/upm/src/hka5/Makefile
new file mode 100644
index 0000000..0f8c790
--- /dev/null
+++ b/ext/lib/upm/src/hka5/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_hka5
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/hka5
+endif
diff --git a/ext/lib/upm/src/hka5/hka5.c b/ext/lib/upm/src/hka5/hka5.c
new file mode 100644
index 0000000..0f04170
--- /dev/null
+++ b/ext/lib/upm/src/hka5/hka5.c
@@ -0,0 +1,257 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+
+#include "upm_utilities.h"
+#include "hka5.h"
+
+#define HKA5_BAUDRATE 9600 // Only baud supported
+#define HKA5_PKT_SIZE 32
+#define HKA5_PKT_START1 0x42
+#define HKA5_PKT_START2 0x4d
+
+static bool verify_cksum(uint8_t *pkt)
+{
+  uint16_t pkt_cksum = (pkt[30] << 8) | pkt[31];
+
+  int i;
+  uint16_t cksum = 0;
+  for (i=0; i<(HKA5_PKT_SIZE - 2); i++)
+    cksum += pkt[i];
+
+  if (pkt_cksum == cksum)
+    return true; // all good
+  else
+    return false; // :(
+}
+
+hka5_context hka5_init(unsigned int uart, int set_pin, int reset_pin)
+{
+  hka5_context dev =
+    (hka5_context)malloc(sizeof(struct _hka5_context));
+
+  if (!dev)
+    return NULL;
+
+  // zero out context
+  memset((void *)dev, 0, sizeof(struct _hka5_context));
+
+  dev->uart = NULL;
+  dev->gpio_reset = NULL;
+  dev->gpio_set = NULL;
+
+  // initialize the MRAA contexts
+
+  // uart, default should be 8N1
+  if (!(dev->uart = mraa_uart_init(uart)))
+    {
+      printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
+      hka5_close(dev);
+      return NULL;
+    }
+
+  if (mraa_uart_set_baudrate(dev->uart, HKA5_BAUDRATE))
+    {
+      printf("%s: mraa_uart_set_baudrate(%d) failed.\n", __FUNCTION__,
+             HKA5_BAUDRATE);
+      hka5_close(dev);
+      return NULL;
+    }
+
+  mraa_uart_set_flowcontrol(dev->uart, false, false);
+
+  // now the set_pin, if enabled
+  if (set_pin >= 0)
+    {
+      if (!(dev->gpio_set = mraa_gpio_init(set_pin)))
+        {
+          printf("%s: mraa_gpio_init(set) failed.\n", __FUNCTION__);
+          hka5_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_set, MRAA_GPIO_OUT);
+
+      // wake up
+      hka5_enable(dev, true);
+    }
+
+  // now the reset_pin, if enabled
+  if (set_pin >= 0)
+    {
+      if (!(dev->gpio_reset = mraa_gpio_init(reset_pin)))
+        {
+          printf("%s: mraa_gpio_init(reset) failed.\n", __FUNCTION__);
+          hka5_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_reset, MRAA_GPIO_OUT);
+
+      // reset
+      hka5_reset(dev);
+    }
+  return dev;
+}
+
+void hka5_close(hka5_context dev)
+{
+  assert(dev != NULL);
+
+  // sleep
+  hka5_enable(dev, false);
+
+  if (dev->uart)
+    mraa_uart_stop(dev->uart);
+  if (dev->gpio_set)
+    mraa_gpio_close(dev->gpio_set);
+  if (dev->gpio_reset)
+    mraa_gpio_close(dev->gpio_reset);
+
+  free(dev);
+}
+
+upm_result_t hka5_enable(const hka5_context dev, bool enable)
+{
+  assert(dev != NULL);
+
+  if (!dev->gpio_set)
+    return UPM_ERROR_NO_RESOURCES;
+
+  if (enable)
+    mraa_gpio_write(dev->gpio_set, 1);
+  else
+    mraa_gpio_write(dev->gpio_set, 0);
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t hka5_reset(const hka5_context dev)
+{
+  assert(dev != NULL);
+
+  if (!dev->gpio_reset)
+    return UPM_ERROR_NO_RESOURCES;
+
+  mraa_gpio_write(dev->gpio_set, 0);
+  upm_delay(1);
+  mraa_gpio_write(dev->gpio_set, 1);
+  upm_delay(1);
+
+return UPM_SUCCESS;
+}
+
+upm_result_t hka5_update(const hka5_context dev)
+{
+  assert(dev != NULL);
+
+  uint8_t pkt[HKA5_PKT_SIZE];
+  int idx = 0;
+  bool done = false;
+  char byte;
+
+  memset((void *)pkt, 0, HKA5_PKT_SIZE);
+
+  while (!done)
+    {
+      // wait up to 2 seconds for data and start
+      if (mraa_uart_data_available(dev->uart, 2000))
+        {
+          while ((mraa_uart_read(dev->uart, &byte, 1) == 1) &&
+                 idx < HKA5_PKT_SIZE)
+            {
+              // first look for a byte starting with HKA5_PKT_START1
+              if (idx == 0 && byte != HKA5_PKT_START1)
+                continue;
+
+              // look for second byte, make sure it matches
+              // HKA5_PKT_START1.  Start over if it's not found.
+              if (idx == 1 && byte != HKA5_PKT_START2)
+                {
+                  // start over
+                  idx = 0;
+                  continue;
+                }
+
+              // else we found the byte, store it and start reading
+              // the rest
+              pkt[idx++] = (uint8_t)byte;
+            }
+
+          if (idx == HKA5_PKT_SIZE)
+            {
+              done = true;
+            }
+          else
+            {
+              // error
+              printf("%s: read failed.\n", __FUNCTION__);
+              return UPM_ERROR_OPERATION_FAILED;
+            }
+        }
+      else
+        {
+          printf("%s: read timed out.\n", __FUNCTION__);
+          return UPM_ERROR_TIMED_OUT;
+        }
+    }
+
+  // we have our data
+  if (verify_cksum(pkt))
+    {
+      dev->pm1   = (pkt[4] << 8) | pkt[5];
+      dev->pm2_5 = (pkt[6] << 8) | pkt[7];
+      dev->pm10  = (pkt[8] << 8) | pkt[9];
+    }
+  else
+    {
+      printf("%s: checksum failure.\n", __FUNCTION__);
+      // could fail here, but occasional cksum failures are not unusual...
+    }
+
+  return UPM_SUCCESS;
+}
+
+unsigned int hka5_get_pm1(const hka5_context dev)
+{
+  assert(dev != NULL);
+
+  return (unsigned int)dev->pm1;
+}
+
+unsigned int hka5_get_pm2_5(const hka5_context dev)
+{
+  assert(dev != NULL);
+
+  return (unsigned int)dev->pm2_5;
+}
+
+unsigned int hka5_get_pm10(const hka5_context dev)
+{
+  assert(dev != NULL);
+
+  return (unsigned int)dev->pm10;
+}
diff --git a/ext/lib/upm/src/hka5/hka5.h b/ext/lib/upm/src/hka5/hka5.h
new file mode 100644
index 0000000..77fb56d
--- /dev/null
+++ b/ext/lib/upm/src/hka5/hka5.h
@@ -0,0 +1,143 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/uart.h"
+#include "mraa/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /**
+   * @brief UPM C API for the DFRobot Laser PM2.5 Sensor
+   *
+   * This driver was tested with a DFRobot Laser PM2.5 Sensor.  It
+   * connects to a UART at 9600 baud.  This is the only baud rate
+   * supported.  It optionally supports Reset and Set/Sleep gpios as
+   * well.
+   *
+   * @snippet hka5.c Interesting
+   */
+
+  /**
+   * Device context
+   */
+  typedef struct _hka5_context {
+    mraa_uart_context        uart;
+
+    // these two are optional
+    mraa_gpio_context        gpio_set;
+    mraa_gpio_context        gpio_reset;
+
+    // PM 1.0
+    uint16_t                 pm1;
+    // PM 2.5
+    uint16_t                 pm2_5;
+    // PM 10.0
+    uint16_t                 pm10;
+  } *hka5_context;
+
+  /**
+   * HKA5 Initializer for generic UART operation
+   *
+   * @param uart Specify which uart to use.
+   * @param set_pin Specify the GPIO pin to use for Set.  -1 to not
+   * use a set pin.
+   * @param reset_pin Specify the GPIO pin to use for Reset.  -1 to
+   * not use a reset pin.
+   * @return an initialized device context on success, NULL on error.
+   */
+  hka5_context hka5_init(unsigned int uart, int set_pin, int reset_pin);
+
+  /**
+   * HKA5 sensor close function
+   */
+  void hka5_close(hka5_context dev);
+
+  /**
+   * Enable or disable the device.  When disabled, the device enters a
+   * low power mode and does not emit data.  You must have initialized
+   * and connected the Set pin for this function to work.
+   *
+   * @param dev sensor context
+   * @param enable true to enable the device, false otherwise.
+   * @return UPM result
+   */
+  upm_result_t hka5_enable(const hka5_context dev, bool enable);
+
+  /**
+   * Reset the device.  You must have initialized and connected the
+   * Reset pin for this function to work.
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  upm_result_t hka5_reset(const hka5_context dev);
+
+  /**
+   * Query the device and store the latest values.  You must call this
+   * function before calling any of the hka5_get_*() functions.
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  upm_result_t hka5_update(const hka5_context dev);
+
+  /**
+   * Return the last read PM 1.0 value.  The value is in micrograms
+   * per cubic meter (ug/m3). You must have called the hka5_update()
+   * function before calling this function.
+   *
+   * @param dev sensor context
+   * @return The value in ug/m3
+   */
+  unsigned int hka5_get_pm1(const hka5_context dev);
+
+  /**
+   * Return the last read PM 2.5 value.  The value is in micrograms
+   * per cubic meter (ug/m3). You must have called the hka5_update()
+   * function before calling this function.
+   *
+   * @param dev sensor context
+   * @return The value in ug/m3
+   */
+  unsigned int hka5_get_pm2_5(const hka5_context dev);
+
+  /**
+   * Return the last read PM 10.0 value.  The value is in micrograms
+   * per cubic meter (ug/m3). You must have called the hka5_update()
+   * function before calling this function.
+   *
+   * @param dev sensor context
+   * @return The value in ug/m3
+   */
+  unsigned int hka5_get_pm10(const hka5_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/ims/Kbuild b/ext/lib/upm/src/ims/Kbuild
new file mode 100644
index 0000000..f5699be
--- /dev/null
+++ b/ext/lib/upm/src/ims/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ims) += ims.o
diff --git a/ext/lib/upm/src/ims/Kconfig b/ext/lib/upm/src/ims/Kconfig
new file mode 100644
index 0000000..e5a8f32
--- /dev/null
+++ b/ext/lib/upm/src/ims/Kconfig
@@ -0,0 +1,8 @@
+config UPM_ims
+    bool "ims"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        Catnip Electronics I2C moisture sensor
diff --git a/ext/lib/upm/src/ims/Makefile b/ext/lib/upm/src/ims/Makefile
new file mode 100644
index 0000000..45df512
--- /dev/null
+++ b/ext/lib/upm/src/ims/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ims
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ims
+endif
diff --git a/ext/lib/upm/src/ims/ims.c b/ext/lib/upm/src/ims/ims.c
new file mode 100644
index 0000000..e1ff52c
--- /dev/null
+++ b/ext/lib/upm/src/ims/ims.c
@@ -0,0 +1,206 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+
+#include "ims.h"
+
+ims_context* ims_init(int16_t i2c_bus, int16_t i2c_address)
+{
+    /* Allocate space for the sensor structure */
+    ims_context* dev = (ims_context*) malloc(sizeof(ims_context));
+    if(dev == NULL)
+    {
+        fprintf(stderr, "%s: malloc() failed\n", __FUNCTION__);
+        goto ims_init_fail;
+    }
+
+    /* Initilize mraa */
+    mraa_result_t result = mraa_init();
+    if (result != MRAA_SUCCESS)
+    {
+        fprintf(stderr, "%s: mraa_init() failed (%d)\n", __FUNCTION__, result);
+        goto ims_init_fail;
+    }
+
+    /* Init i2c */
+    dev->_i2c_context = mraa_i2c_init(i2c_bus);
+    if(dev->_i2c_context == NULL)
+    {
+        fprintf(stderr, "%s: mraa_i2c_init() failed\n", __FUNCTION__);
+        goto ims_init_fail;
+    }
+
+    /* Set the i2c slave address for this device */
+    if (mraa_i2c_address(dev->_i2c_context, i2c_address) != MRAA_SUCCESS)
+    {
+        fprintf(stderr, "%s: mraa_i2c_address() failed\n", __FUNCTION__);
+        goto ims_init_fail;
+    }
+
+    /* This device must run at 100kHz */
+    if (mraa_i2c_frequency(dev->_i2c_context, MRAA_I2C_STD))
+    {
+        fprintf(stderr, "%s: mraa_i2c_frequency() failed\n", __FUNCTION__);
+        goto ims_init_fail;
+    }
+
+    return dev;
+
+/* Handle all failing cases here */
+ims_init_fail:
+    /* Free structure memory if allocated */
+    if (dev != NULL)
+        free(dev);
+    return NULL;
+}
+
+void ims_close(ims_context* dev)
+{
+    if (dev == NULL) return;
+
+    /* Cleanup the I2C context */
+    mraa_i2c_stop(dev->_i2c_context);
+    free(dev);
+}
+
+upm_result_t ims_read(const ims_context* dev, IMS_RD_COMMAND cmd, uint16_t* rd_data)
+{
+    int32_t val = 0;
+    uint8_t readbuf[2] = {0, 0};
+    switch (cmd)
+    {
+        /* One byte reads */
+        case IMS_GET_ADDRESS:
+        case IMS_GET_VERSION:
+        case IMS_GET_BUSY:
+            val = mraa_i2c_read_bytes_data(dev->_i2c_context, cmd, readbuf, 1);
+            *rd_data = readbuf[0];
+            break;
+        /* Two byte reads */
+        case IMS_GET_CAPACITANCE:
+        case IMS_GET_LIGHT:
+        case IMS_GET_TEMPERATURE:
+            val = mraa_i2c_read_bytes_data(dev->_i2c_context, cmd, readbuf, 2);
+            *rd_data = readbuf[1];
+            *rd_data += ((uint16_t)readbuf[0] << 8) & 0xFF00;
+            break;
+        default:
+            fprintf(stderr, "%s: Invalid read command: 0x%02x\n", __FUNCTION__, cmd);
+            return UPM_ERROR_INVALID_PARAMETER;
+    }
+
+    /* val will be < 0 on failing case */
+    if (val < 0)
+    {
+        fprintf(stderr, "%s: mraa_i2c_read_byte/word_data() failed\n", __FUNCTION__);
+        return UPM_ERROR_NO_DATA;
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t ims_write(const ims_context* dev, IMS_WR_COMMAND cmd, uint8_t wr_data)
+{
+    mraa_result_t mr;
+    switch (cmd)
+    {
+        /* One byte write */
+        case IMS_SET_ADDRESS:
+            mr = mraa_i2c_write_byte_data(dev->_i2c_context, wr_data, cmd);
+            break;
+        /* Zero byte write */
+        case IMS_MEASURE_LIGHT:
+        case IMS_RESET:
+        case IMS_SLEEP:
+            mr = mraa_i2c_write(dev->_i2c_context, (const uint8_t *)&cmd, 1);
+            break;
+        default:
+            fprintf(stderr, "%s: Invalid read command: 0x%02x\n", __FUNCTION__, cmd);
+            return UPM_ERROR_INVALID_PARAMETER;
+    }
+
+    if (mr != MRAA_SUCCESS) return UPM_ERROR_OPERATION_FAILED;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t ims_get_version(const ims_context* dev, uint16_t* rd_data)
+{
+    return ims_read(dev, IMS_GET_VERSION, rd_data);
+}
+
+upm_result_t ims_get_moisture(const ims_context* dev, uint16_t* rd_data)
+{
+    return ims_read(dev, IMS_GET_CAPACITANCE, rd_data);
+}
+
+upm_result_t ims_get_light(const ims_context* dev, uint16_t* rd_data)
+{
+    /* Initiate a light measurement */
+    upm_result_t res = ims_write(dev, IMS_MEASURE_LIGHT, 0);
+    if (res != UPM_SUCCESS) return res;
+
+    /* Technical data for the ISM specifies a 3 second wait.  Check the BUSY
+     * command every 100 ms for 3 seconds.  The sensor will return quickly in
+     * bright light and much slower in less light. */
+    int retry = 30;
+    *rd_data = 1;
+    while ((retry-- > 0) && (*rd_data != 0))
+    {
+        // Always delay at least 100 ms
+        upm_delay_ms(100);
+        res = ims_read(dev, IMS_GET_BUSY, rd_data);
+        if (res != UPM_SUCCESS) return res;
+    }
+
+    /* If the sensor is STILL not ready, go ahead and perform the read.
+     * From testing, this appears to happen only in complete darkness,
+     * at which point the sensor get light read returns 0xffff anyway.*/
+
+    return ims_read(dev, IMS_GET_LIGHT, rd_data);
+}
+
+upm_result_t ims_get_temperature(const ims_context* dev, uint16_t* rd_data)
+{
+    return ims_read(dev, IMS_GET_TEMPERATURE, rd_data);
+}
+
+upm_result_t ims_reset(const ims_context* dev)
+{
+    return ims_write(dev, IMS_RESET, 0);
+}
+
+upm_result_t ims_reset_i2c_address(const ims_context* dev, uint8_t address_new)
+{
+    upm_result_t res = ims_write(dev, IMS_SET_ADDRESS, address_new);
+    if (res != UPM_SUCCESS) return res;
+
+    return ims_reset(dev);
+}
+
+upm_result_t ims_sleep(const ims_context* dev)
+{
+    return ims_write(dev, IMS_SLEEP, 0);
+}
diff --git a/ext/lib/upm/src/ims/ims.h b/ext/lib/upm/src/ims/ims.h
new file mode 100644
index 0000000..07af130
--- /dev/null
+++ b/ext/lib/upm/src/ims/ims.h
@@ -0,0 +1,178 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <errno.h>
+#include <stdint.h>
+
+#include "mraa/i2c.h"
+#include "upm.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IMS_ADDRESS_DEFAULT 0x20
+
+ /* @brief Moisture sensor I2C READ commands */
+typedef enum _IMS_RD_COMMAND {
+        /* Read capacitance (moisture) register */
+        IMS_GET_CAPACITANCE = 0x00, /*    (r) 2 */
+        /* Read I2C address register */
+        IMS_GET_ADDRESS     = 0x02, /*    (r) 1 */
+        /* Read light register (requires write to IMS_MEASURE_LIGHT) */
+        IMS_GET_LIGHT       = 0x04, /*    (r) 2 */
+        /* Read temperature register */
+        IMS_GET_TEMPERATURE = 0x05, /*    (r) 2 */
+        /* Read version register */
+        IMS_GET_VERSION     = 0x07, /*    (r) 1 */
+        /* Read busy register (0 = ready, 1 = sampling) */
+        IMS_GET_BUSY        = 0x09, /*    (r) 1 */
+} IMS_RD_COMMAND;
+
+ /* @brief Moisture sensor I2C WRITE commands */
+typedef enum {
+        /* Write I2C address register (latched w/IMS_RESET) */
+        IMS_SET_ADDRESS     = 0x01, /*    (w) 1 */
+        /* Initiate light measurement */
+        IMS_MEASURE_LIGHT   = 0x03, /*    (w) 0 */
+        /* Reset device */
+        IMS_RESET           = 0x06, /*    (w) 0 */
+        /* Sleep microcontroller, wake on any I2C request */
+        IMS_SLEEP           = 0x08, /*    (w) 0 */
+} IMS_WR_COMMAND;
+
+/**
+ * @file ims.h
+ * @library ims
+ * @brief C API for the Catnip Electronics I2C moisture sensor.  This sensor
+ * must run at 100 kHz.
+ *
+ * @include ims.c
+ */
+
+/**
+ * device context
+ */
+typedef struct {
+    /* mraa i2c context */
+    mraa_i2c_context _i2c_context;
+} ims_context;
+
+/**
+ * Initialize sensor
+ * @param i2c_bus Target I2C bus
+ * @param i2c_address Target I2C address (default is 0x20)
+ * @return sensor context pointer
+ */
+ims_context* ims_init(int16_t i2c_bus, int16_t i2c_address);
+
+/**
+ * Sensor close method.
+ * Cleans up any memory held by this device
+ * @param sensor context pointer
+ */
+void ims_close(ims_context* dev);
+
+/**
+ * Read I2C Moisture Sensor registers
+ * @param dev Sensor context pointer
+ * @param cmd Read command
+ * @param rd_data Data returned from sensor (1 or 2 bytes depending on cmd)
+ * @return Function result code
+ */
+upm_result_t ims_read(const ims_context* dev, IMS_RD_COMMAND cmd, uint16_t* rd_data);
+
+/**
+ * Write I2C Moisture Sensor registers
+ * @param dev Sensor context pointer
+ * @param cmd Write command
+ * @param wr_data Target data to write (only used for IMS_SET_ADDRESS)
+ * @return Function result code
+ */
+upm_result_t ims_write(const ims_context* dev, IMS_WR_COMMAND cmd, uint8_t wr_data);
+
+/**
+ * Get sensor version
+ * @param dev Sensor context pointer
+ * @param rd_data Sensor version
+ * @return Function result code
+ */
+upm_result_t ims_get_version(const ims_context* dev, uint16_t* rd_data);
+
+/**
+ * Get moisture reading from sensor
+ * @param dev Sensor context pointer
+ * @param rd_data Unitless, relative capacitance value (used to determine moisture)
+ * @return Function result code
+ */
+upm_result_t ims_get_moisture(const ims_context* dev, uint16_t* rd_data);
+
+/**
+ * Get light reading from LED on device.  The technical data for the I2C
+ * moisture sensor specifies a 3 second wait.  Loop for 3 seconds checking
+ * the GET_BUSY register.  IF the sensor is NOT ready after 3 seconds,
+ * assume there is NO light and return a max uint16_t (dark) value.
+ * @param dev Sensor context pointer
+ * @param rd_data Unitless, relative value for brightness
+ *        dark (0xFFFF) ---> light (0x0000)
+ * @return Function result code
+ */
+upm_result_t ims_get_light(const ims_context* dev, uint16_t* rd_data);
+
+/**
+ * Get temperature reading from device
+ * @param dev Sensor context pointer
+ * @param rd_data Temperature in degrees Celsius * 10
+ *        ie, 256 = 25.6 C
+ * @return Function result code
+ */
+upm_result_t ims_get_temperature(const ims_context* dev, uint16_t* rd_data);
+
+/**
+ * Reset sensor
+ * @param dev Sensor context pointer
+ * @return Function result code
+ */
+upm_result_t ims_reset(const ims_context* dev);
+
+/**
+ * Set I2C address AND reset sensor
+ * @param dev Sensor context pointer
+ * @param address_new New I2C for device
+ * @return Function result code
+ */
+upm_result_t ims_reset_i2c_address(const ims_context* dev, uint8_t address_new);
+
+/**
+ * Put device into low-power mode.  Device wakes on any I2C command.
+ * @param dev Sensor context pointer
+ * @return Function result code
+ */
+upm_result_t ims_sleep(const ims_context* dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/jhd1313m1/Kbuild b/ext/lib/upm/src/jhd1313m1/Kbuild
new file mode 100644
index 0000000..857d0ea
--- /dev/null
+++ b/ext/lib/upm/src/jhd1313m1/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_jhd1313m1) += jhd1313m1.o
diff --git a/ext/lib/upm/src/jhd1313m1/Kconfig b/ext/lib/upm/src/jhd1313m1/Kconfig
new file mode 100644
index 0000000..a0759ba
--- /dev/null
+++ b/ext/lib/upm/src/jhd1313m1/Kconfig
@@ -0,0 +1,8 @@
+config UPM_jhd1313m1
+    bool "jhd1313m1"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm JHD1313M1 RGB LCD display
diff --git a/ext/lib/upm/src/jhd1313m1/Makefile b/ext/lib/upm/src/jhd1313m1/Makefile
new file mode 100644
index 0000000..8dd2882
--- /dev/null
+++ b/ext/lib/upm/src/jhd1313m1/Makefile
@@ -0,0 +1,5 @@
+ifdef CONFIG_UPM_jhd1313m1
+# jhd1313m1 needs hd48770_bits.h from lcm1602
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/lcm1602
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/jhd1313m1
+endif
diff --git a/ext/lib/upm/src/jhd1313m1/jhd1313m1.c b/ext/lib/upm/src/jhd1313m1/jhd1313m1.c
new file mode 100644
index 0000000..c18c60e
--- /dev/null
+++ b/ext/lib/upm/src/jhd1313m1/jhd1313m1.c
@@ -0,0 +1,367 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Based on UPM C++ drivers originally developed by:
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+
+#include <upm_utilities.h>
+
+#include "jhd1313m1.h"
+#include "hd44780_bits.h"
+
+jhd1313m1_context jhd1313m1_init(int bus, int lcd_addr, int rgb_addr)
+{
+    jhd1313m1_context dev =
+        (jhd1313m1_context)malloc(sizeof(struct _jhd1313m1_context));
+
+    if (!dev)
+        return NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        jhd1313m1_close(dev);
+        return NULL;
+    }
+
+    memset((void *)dev, 0, sizeof(struct _jhd1313m1_context));
+
+    // initialize the MRAA contexts
+
+    if (!(dev->i2cLCD = mraa_i2c_init(bus)))
+    {
+        printf("%s: mraa_i2c_init(LCD) failed.\n", __FUNCTION__);
+        jhd1313m1_close(dev);
+
+        return NULL;
+    }
+
+    // now check the address...
+    if (mraa_i2c_address(dev->i2cLCD, lcd_addr) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_i2c_address(LCD) failed.\n", __FUNCTION__);
+
+        jhd1313m1_close(dev);
+
+        return NULL;
+    }
+
+    if (!(dev->i2cRGB = mraa_i2c_init(bus)))
+    {
+        printf("%s: mraa_i2c_init(RGB) failed.\n", __FUNCTION__);
+        jhd1313m1_close(dev);
+
+        return NULL;
+    }
+
+    // now check the address...
+    if (mraa_i2c_address(dev->i2cRGB, rgb_addr) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_i2c_address(RGB) failed.\n", __FUNCTION__);
+
+        jhd1313m1_close(dev);
+
+        return NULL;
+    }
+
+    /* HD44780 requires writing three times to initialize or reset
+       according to the hardware errata on page 45 figure 23 of
+       the Hitachi HD44780 datasheet */
+
+    /* First try */
+    upm_delay_us(50000);
+    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE);
+
+    /* Second try */
+    upm_delay_us(4500);
+    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE);
+
+    /* Third try */
+    upm_delay_us(150);
+    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE);
+
+    /* Set 2 row mode and font size */
+    jhd1313m1_command(dev, HD44780_FUNCTIONSET | HD44780_8BITMODE
+                      | HD44780_2LINE | HD44780_5x10DOTS);
+    upm_delay_us(100);
+
+    jhd1313m1_display_on(dev, true);
+    upm_delay_us(100);
+
+    jhd1313m1_clear(dev);
+    upm_delay_us(2000);
+
+    jhd1313m1_command(dev, HD44780_ENTRYMODESET | HD44780_ENTRYLEFT
+                      | HD44780_ENTRYSHIFTDECREMENT);
+
+    jhd1313m1_backlight_on(dev, true);
+    // full white
+    jhd1313m1_set_color(dev, 0xff, 0xff, 0xff);
+
+    return dev;
+}
+
+void jhd1313m1_close(jhd1313m1_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->i2cLCD)
+        mraa_i2c_stop(dev->i2cLCD);
+    if (dev->i2cRGB)
+        mraa_i2c_stop(dev->i2cRGB);
+
+    free(dev);
+}
+
+upm_result_t jhd1313m1_set_color(jhd1313m1_context dev, uint8_t r, uint8_t g,
+                                 uint8_t b)
+{
+    assert(dev != NULL);
+
+    mraa_result_t rv = MRAA_SUCCESS;
+    rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0, 0);
+    rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0, 1);
+
+    rv = mraa_i2c_write_byte_data(dev->i2cRGB, r, 0x04);
+    rv = mraa_i2c_write_byte_data(dev->i2cRGB, g, 0x03);
+    rv = mraa_i2c_write_byte_data(dev->i2cRGB, b, 0x02);
+
+    if (rv)
+    {
+        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t jhd1313m1_write(const jhd1313m1_context dev, char *buffer,
+                             int len)
+{
+    assert(dev != NULL);
+
+    upm_result_t error = UPM_SUCCESS;
+
+    int i;
+    for (i=0; i<len; ++i)
+        error = jhd1313m1_data(dev, buffer[i]);
+
+    return error;
+}
+
+upm_result_t jhd1313m1_set_cursor(const jhd1313m1_context dev, unsigned int row,
+                                  unsigned int column)
+{
+    assert(dev != NULL);
+
+    column = column % 16;
+    uint8_t offset = column;
+
+    // this should work for any display with two rows
+    // DDRAM mapping:
+    // 00 .. 27
+    // 40 .. 67
+    offset += row * 0x40;
+
+    return jhd1313m1_command(dev, HD44780_CMD | offset);
+}
+
+upm_result_t jhd1313m1_clear(const jhd1313m1_context dev)
+{
+    assert(dev != NULL);
+
+    upm_result_t ret;
+    ret = jhd1313m1_command(dev, HD44780_CLEARDISPLAY);
+    upm_delay_us(2000); // this command takes awhile
+    return ret;
+}
+
+upm_result_t jhd1313m1_home(const jhd1313m1_context dev)
+{
+    assert(dev != NULL);
+
+    upm_result_t ret;
+    ret = jhd1313m1_command(dev, HD44780_RETURNHOME);
+    upm_delay_us(2000); // this command takes awhile
+    return ret;
+}
+
+upm_result_t jhd1313m1_create_char(const jhd1313m1_context dev,
+                                 unsigned int slot,
+                                 jhd1313m1_custom_char_t data)
+{
+    assert(dev != NULL);
+
+    upm_result_t error = UPM_SUCCESS;
+
+    slot &= 0x07; // only have 8 positions we can set
+
+    error = jhd1313m1_command(dev, HD44780_SETCGRAMADDR | (slot << 3));
+
+    if (error == UPM_SUCCESS)
+    {
+        int i;
+        for (i = 0; i < 8; i++) {
+            error = jhd1313m1_data(dev, data[i]);
+        }
+    }
+
+    return error;
+}
+
+upm_result_t jhd1313m1_display_on(const jhd1313m1_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->displayControl |= HD44780_DISPLAYON;
+    else
+        dev->displayControl &= ~HD44780_DISPLAYON;
+
+    return jhd1313m1_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+}
+
+upm_result_t jhd1313m1_cursor_on(const jhd1313m1_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->displayControl |= HD44780_CURSORON;
+    else
+        dev->displayControl &= ~HD44780_CURSORON;
+
+    return jhd1313m1_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+}
+
+upm_result_t jhd1313m1_cursor_blink_on(const jhd1313m1_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->displayControl |= HD44780_BLINKON;
+    else
+        dev->displayControl &= ~HD44780_BLINKON;
+
+    return jhd1313m1_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+}
+
+upm_result_t jhd1313m1_backlight_on(const jhd1313m1_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    mraa_result_t rv = MRAA_SUCCESS;
+    if (on)
+        rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0xaa, 0x08);
+    else
+        rv = mraa_i2c_write_byte_data(dev->i2cRGB, 0x00, 0x08);
+
+    if (rv)
+    {
+        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t jhd1313m1_scroll(const jhd1313m1_context dev, bool direction)
+{
+    if (direction)
+        return jhd1313m1_scroll_display_left(dev);
+    else
+        return jhd1313m1_scroll_display_right(dev);
+}
+
+upm_result_t jhd1313m1_scroll_display_left(const jhd1313m1_context dev)
+{
+    assert(dev != NULL);
+
+    return jhd1313m1_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
+                             | HD44780_MOVELEFT);
+}
+
+upm_result_t jhd1313m1_scroll_display_right(const jhd1313m1_context dev)
+{
+    assert(dev != NULL);
+
+    return jhd1313m1_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
+                             | HD44780_MOVERIGHT);
+}
+
+upm_result_t jhd1313m1_entry_left_to_right(const jhd1313m1_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->entryDisplayMode |= HD44780_ENTRYLEFT;
+    else
+        dev->entryDisplayMode &= ~HD44780_ENTRYLEFT;
+
+    return jhd1313m1_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
+}
+
+upm_result_t jhd1313m1_autoscroll_on(const jhd1313m1_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->entryDisplayMode |= HD44780_ENTRYSHIFTINCREMENT;
+    else
+        dev->entryDisplayMode &= ~HD44780_ENTRYSHIFTINCREMENT;
+
+    return jhd1313m1_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
+}
+
+upm_result_t jhd1313m1_command(const jhd1313m1_context dev, uint8_t cmd)
+{
+    assert(dev != NULL);
+
+    if (mraa_i2c_write_byte_data(dev->i2cLCD, cmd, HD44780_CMD))
+    {
+        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t jhd1313m1_data(const jhd1313m1_context dev, uint8_t cmd)
+{
+    assert(dev != NULL);
+
+    if (mraa_i2c_write_byte_data(dev->i2cLCD, cmd, HD44780_DATA))
+    {
+        printf("%s: mraa_i2c_write_byte_data() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/jhd1313m1/jhd1313m1.h b/ext/lib/upm/src/jhd1313m1/jhd1313m1.h
new file mode 100644
index 0000000..c79c179
--- /dev/null
+++ b/ext/lib/upm/src/jhd1313m1/jhd1313m1.h
@@ -0,0 +1,250 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Based on UPM C++ drivers originally developed by:
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/i2c.h>
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+    /**
+     * @file jhd1313m1.h
+     * @library jhd1313m1
+     * @brief C API for the JHD1313M1 family of LCD displays, like the
+     * Grove RGB LCD
+     *
+     * @include jhd1313m1.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _jhd1313m1_context {
+        // I2C LCD command (lcm1602-like)
+        mraa_i2c_context         i2cLCD;
+        // I2C RGB backlight control
+        mraa_i2c_context         i2cRGB;
+
+        // display command
+        uint8_t                  displayControl;
+        uint8_t                  entryDisplayMode;
+    } *jhd1313m1_context;
+
+    /**
+     * Custom character.
+     */
+    typedef char jhd1313m1_custom_char_t[8];
+
+    /**
+     * JHD1313M1 I2C initialization.
+     *
+     * @param bus I2C bus to use.
+     * @param lcd_addr I2C address the LCD controller is on.
+     * @param rgb_addr I2C address the RGB backlight controller is on.
+     * @return Device Ccontext, or NULL on error.
+     */
+    jhd1313m1_context jhd1313m1_init(int bus, int lcd_addr, int rgb_addr);
+
+    /**
+     * JHD1313M1 close.
+     *
+     * @param dev The device context.
+     */
+    void jhd1313m1_close(jhd1313m1_context dev);
+
+    /**
+     * Writes a string to the LCD.
+     *
+     * @param dev The device context.
+     * @param buffer Character buffer containing characters to write to
+     * the display; note: only ASCII characters are supported
+     * @param len The number of characters to write.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_write(const jhd1313m1_context dev, char *buffer,
+                                 int len);
+
+    /**
+     * Sets the cursor to specified coordinates
+     *
+     * @param dev The device context.
+     * @param row Row to set the cursor to.
+     * @param column Column to set the cursor to.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_set_cursor(const jhd1313m1_context dev,
+                                      unsigned int row, unsigned int column);
+
+    /**
+     * Clears the display of all characters.
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_clear(const jhd1313m1_context dev);
+
+    /**
+     * Returns to the home coordinates (0,0).
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_home(const jhd1313m1_context dev);
+
+    /**
+     * Sets the color of the backlight
+     * Can be used to change the color even when the backlight is off
+     *
+     * @param dev The device context.
+     * @param r 0-255 value for red
+     * @param g 0-255 value for green
+     * @param b 0-255 value for blue
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_set_color(const jhd1313m1_context dev,
+                                     uint8_t r, uint8_t g, uint8_t b);
+
+    /**
+     * Create a custom character.
+     *
+     * @param dev The device context.
+     * @param slot The character slot to write, only 8 are available.
+     * @param data The character data (8 bytes) making up the character.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_create_char(const jhd1313m1_context dev,
+                                       unsigned int slot,
+                                       jhd1313m1_custom_char_t data);
+
+    /**
+     * Turn the display on.
+     *
+     * @param dev The device context.
+     * @param on true to turn display on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_display_on(const jhd1313m1_context dev, bool on);
+
+    /**
+     * Turn the cursor on.
+     *
+     * @param dev The device context.
+     * @param on true to turn cursor on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_cursor_on(const jhd1313m1_context dev, bool on);
+
+    /**
+     * Turn cursor blink on.
+     *
+     * @param dev The device context.
+     * @param on true to turn cursor blink on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_cursor_blink_on(const jhd1313m1_context dev,
+                                           bool on);
+
+    /**
+     * Turn backlight on.
+     *
+     * @param dev The device context.
+     * @param on true to turn backlight on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_backlight_on(const jhd1313m1_context dev, bool on);
+
+    /**
+     * Scroll the display left, without changing the character RAM.
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_scroll_display_left(const jhd1313m1_context dev);
+
+    /**
+     * Scroll the display right, without changing the character RAM.
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_scroll_display_right(const jhd1313m1_context dev);
+
+    /**
+     * Set the entry mode so that characters are added left to right.
+     *
+     * @param dev The device context.
+     * @param on true to add characters left to right, false for right
+     * to left.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_entry_left_to_right(const jhd1313m1_context dev,
+                                               bool on);
+
+    /**
+     * Right justify text entered from the cursor.
+     *
+     * @param dev The device context.
+     * @param on true right justify text, false to left justify text.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_autoscroll_on(const jhd1313m1_context dev, bool on);
+
+    /**
+     * Send a command byte to the LCD controller.  This is a low level
+     * function that should not be used directly unless you know what
+     * you are doing.
+     *
+     * @param dev The device context.
+     * @param cmd The command byte to send.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_command(const jhd1313m1_context dev, uint8_t cmd);
+
+    /**
+     * Send a data byte the LCD controller.  This is a low level
+     * function that should not be used directly unless you know what
+     * you are doing.
+     *
+     * @param dev The device context.
+     * @param cmd The command byte to send.
+     * @return UPM result.
+     */
+    upm_result_t jhd1313m1_data(const jhd1313m1_context dev, uint8_t data);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/joystick12/Kbuild b/ext/lib/upm/src/joystick12/Kbuild
new file mode 100644
index 0000000..119c441
--- /dev/null
+++ b/ext/lib/upm/src/joystick12/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_joystick12) += joystick12.o
diff --git a/ext/lib/upm/src/joystick12/Kconfig b/ext/lib/upm/src/joystick12/Kconfig
new file mode 100644
index 0000000..54cb2c4
--- /dev/null
+++ b/ext/lib/upm/src/joystick12/Kconfig
@@ -0,0 +1,9 @@
+config UPM_joystick12
+    bool "joystick12"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        ElecFreaks Joystick 1.2
+
diff --git a/ext/lib/upm/src/joystick12/Makefile b/ext/lib/upm/src/joystick12/Makefile
new file mode 100644
index 0000000..8eaee72
--- /dev/null
+++ b/ext/lib/upm/src/joystick12/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_joystick12
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/joystick12
+endif
diff --git a/ext/lib/upm/src/joystick12/joystick12.c b/ext/lib/upm/src/joystick12/joystick12.c
new file mode 100644
index 0000000..ec3a1fa
--- /dev/null
+++ b/ext/lib/upm/src/joystick12/joystick12.c
@@ -0,0 +1,206 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "joystick12.h"
+
+joystick12_context joystick12_init(int16_t apin_x, int16_t apin_y)
+{
+    joystick12_context dev =
+      (joystick12_context) malloc(sizeof(struct _joystick12_context));
+
+    if(dev == NULL) return NULL;
+
+    /* Init analog pins */
+    dev->ai_x = mraa_aio_init(apin_x);
+    dev->ai_y = mraa_aio_init(apin_y);
+
+    /* Set the ref, zero the offset */
+    dev->m_count_offset_x = 0.0;
+    dev->m_count_scale_x = 2.0;
+    dev->m_count_offset_y = 0.0;
+    dev->m_count_scale_y = 2.0;
+
+    if((dev->ai_x == NULL) || (dev->ai_y == NULL))
+    {
+        free(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void joystick12_close(joystick12_context dev)
+{
+    mraa_aio_close(dev->ai_x);
+    mraa_aio_close(dev->ai_y);
+    free(dev);
+}
+
+upm_result_t joystick12_read_data(const joystick12_context dev, int* values)
+{
+    /* Throw away first read */
+    mraa_aio_read(dev->ai_x);
+    values[0] = mraa_aio_read(dev->ai_x);
+    /* Throw away first read */
+    mraa_aio_read(dev->ai_y);
+    values[1] = mraa_aio_read(dev->ai_y);
+
+    if (values[0] < 0 || values[1] < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_set_offset_x(const joystick12_context dev, float offset)
+{
+    dev->m_count_offset_x = offset;
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_set_offset_y(const joystick12_context dev, float offset)
+{
+    dev->m_count_offset_y = offset;
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_set_scale_x(const joystick12_context dev, float scale)
+{
+    dev->m_count_scale_x = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_set_scale_y(const joystick12_context dev, float scale)
+{
+    dev->m_count_scale_y = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_get_value_x(const joystick12_context dev, float *value)
+{
+    int counts[2] = {0,0};
+
+    /* Read counts from the generic read method */
+    joystick12_read_data(dev, counts);
+
+    /* Get max adc value range 1023, 2047, 4095, etc... */
+    float max_adc = (1 << mraa_aio_get_bit(dev->ai_x)) - 1;
+
+    /* Apply raw offset */
+    *value = counts[0] + dev->m_count_offset_x;
+
+    // Scale to +/- 1.0
+    *value =  -2.0 * (((max_adc/2.0 - *value))/max_adc * dev->m_count_scale_x);
+
+    // Clip to +/- 1.0
+    if (*value > 1.0) *value = 1.0;
+    else if (*value < -1.0) *value = -1.0;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_get_value_y(const joystick12_context dev, float *value)
+{
+    int counts[2] = {0,0};
+
+    /* Read counts from the generic read method */
+    joystick12_read_data(dev, counts);
+
+    /* Get max adc value range 1023, 2047, 4095, etc... */
+    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
+
+    /* Apply raw offset */
+    *value = counts[1] + dev->m_count_offset_y;
+
+    // Scale to +/- 1.0
+    *value =  -2.0 * (((max_adc/2.0 - *value))/max_adc * dev->m_count_scale_y);
+
+    // Clip to +/- 1.0
+    if (*value > 1.0) *value = 1.0;
+    else if (*value < -1.0) *value = -1.0;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_zero(const joystick12_context dev)
+{
+    int counts[2] = {0, 0};
+
+    /* Read counts from the generic read method */
+    joystick12_read_data(dev, counts);
+
+    /* Get max adc value range 1023, 2047, 4095, etc... */
+    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
+
+    dev->m_count_offset_x = max_adc/2.0 - counts[0];
+    dev->m_count_offset_y = max_adc/2.0 - counts[1];
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_calibrate_x(const joystick12_context dev)
+{
+    int counts[2] = {0, 0};
+
+    /* Read counts from the generic read method */
+    joystick12_read_data(dev, counts);
+
+    /* Get max adc value range 1023, 2047, 4095, etc... */
+    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
+
+    float fcounts = counts[0];
+
+    /* no need to scale if counts is a max or min value */
+    if ((fcounts == 0) || (fcounts == max_adc)) return UPM_SUCCESS;
+
+    dev->m_count_scale_x =
+      1.0 / (1.0 - 2.0 * fcounts/max_adc);
+    dev->m_count_scale_x = fabs(dev->m_count_scale_x);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t joystick12_calibrate_y(const joystick12_context dev)
+{
+    int counts[2] = {0, 0};
+
+    /* Read counts from the generic read method */
+    joystick12_read_data(dev, counts);
+
+    /* Get max adc value range 1023, 2047, 4095, etc... */
+    float max_adc = (1 << mraa_aio_get_bit(dev->ai_y)) - 1;
+
+    float fcounts = counts[1];
+
+    /* no need to scale if counts is a max or min value */
+    if ((fcounts == 0) || (fcounts == max_adc)) return UPM_SUCCESS;
+
+    dev->m_count_scale_y =
+      1.0 / (1.0 - 2.0 * fcounts/max_adc);
+    dev->m_count_scale_y = fabs(dev->m_count_scale_y);
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/joystick12/joystick12.h b/ext/lib/upm/src/joystick12/joystick12.h
new file mode 100644
index 0000000..5b6706a
--- /dev/null
+++ b/ext/lib/upm/src/joystick12/joystick12.h
@@ -0,0 +1,151 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * device context
+ */
+typedef struct _joystick12_context {
+    /* mraa ai_x pin context */
+    mraa_aio_context ai_x;
+    /* mraa ai_y pin context */
+    mraa_aio_context ai_y;
+    /* Raw count offset - x axis */
+    float m_count_offset_x;
+    /* Raw count offset - y axis */
+    float m_count_offset_y;
+    /* Raw count scale - x axis */
+    float m_count_scale_x;
+    /* Raw count scale - y axis */
+    float m_count_scale_y;
+} *joystick12_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin is Analog pin
+ * @return sensor context as void pointer
+ */
+joystick12_context joystick12_init(int16_t apin_x, int16_t apin_y);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer deallocate memory
+ */
+void joystick12_close(joystick12_context dev);
+
+/**
+ * Generic read joystick data method
+ * @param dev sensor device context pointer
+ * @param value pointer to an int[2] in which data is returned
+ */
+upm_result_t joystick12_read_data(const joystick12_context dev, int* values);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     counts = counts + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t joystick12_set_offset_x(const joystick12_context dev,
+                                     float offset);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     counts = counts + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t joystick12_set_offset_y(const joystick12_context dev,
+                                     float offset);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t joystick12_set_scale_x(const joystick12_context dev, float scale);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t joystick12_set_scale_y(const joystick12_context dev, float scale);
+
+/**
+ * Read value from sensor
+ * @param dev sensor context pointer
+ * @param *value normalized value from sensor, units depend on unit enum
+ * @param unit Enum which specifies units returned in *value
+ * @return Function result code
+ */
+upm_result_t joystick12_get_value_x(const joystick12_context dev, float *value);
+
+/**
+ * Read value from sensor
+ * @param dev sensor context pointer
+ * @param *value normalized value from sensor, units depend on unit enum
+ * @param unit Enum which specifies units returned in *value
+ * @return Function result code
+ */
+upm_result_t joystick12_get_value_y(const joystick12_context dev, float *value);
+
+/**
+ * Zero out the sensor x and y axis
+ * @param dev sensor context pointer
+ * @return Function result code
+ */
+upm_result_t joystick12_zero(const joystick12_context dev);
+
+/**
+ * Set x scale.  Move joystick to min or max x and call calibrate
+ * @param dev sensor context pointer
+ * @return Function result code
+ */
+upm_result_t joystick12_calibrate_x(const joystick12_context dev);
+
+/**
+ * Set y scale.  Move joystick to min or max y and call calibrate
+ * @param dev sensor context pointer
+ * @return Function result code
+ */
+upm_result_t joystick12_calibrate_y(const joystick12_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/lcm1602/Kbuild b/ext/lib/upm/src/lcm1602/Kbuild
new file mode 100644
index 0000000..0731b8d
--- /dev/null
+++ b/ext/lib/upm/src/lcm1602/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_lcm1602) += lcm1602.o
diff --git a/ext/lib/upm/src/lcm1602/Kconfig b/ext/lib/upm/src/lcm1602/Kconfig
new file mode 100644
index 0000000..7e34f6a
--- /dev/null
+++ b/ext/lib/upm/src/lcm1602/Kconfig
@@ -0,0 +1,8 @@
+config UPM_lcm1602
+    bool "lcm1602"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm LCM1602 LCD display
diff --git a/ext/lib/upm/src/lcm1602/Makefile b/ext/lib/upm/src/lcm1602/Makefile
new file mode 100644
index 0000000..66a6c71
--- /dev/null
+++ b/ext/lib/upm/src/lcm1602/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_lcm1602
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/lcm1602
+endif
diff --git a/ext/lib/upm/src/lcm1602/hd44780_bits.h b/ext/lib/upm/src/lcm1602/hd44780_bits.h
new file mode 100644
index 0000000..846c401
--- /dev/null
+++ b/ext/lib/upm/src/lcm1602/hd44780_bits.h
@@ -0,0 +1,82 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+// This file contains bit definitions for the HD44780 and compatible
+// LCD controllers.  It is used primarily my the lcm1602 driver and
+// it's derivatives.
+//
+// Those values (DATA, CMD) are specific to the implementation of the
+// i2C expander in use, so may not be appropriate for inclusion into
+// this file.  But for now, we will leave them here.
+
+#include <stdint.h>
+
+// commands
+const uint8_t HD44780_CLEARDISPLAY = 0x01;
+const uint8_t HD44780_RETURNHOME = 0x02;
+const uint8_t HD44780_ENTRYMODESET = 0x04;
+const uint8_t HD44780_DISPLAYCONTROL = 0x08;
+const uint8_t HD44780_CURSORSHIFT = 0x10;
+const uint8_t HD44780_FUNCTIONSET = 0x20;
+
+// flags for display entry mode
+const uint8_t HD44780_ENTRYRIGHT = 0x00;
+const uint8_t HD44780_ENTRYLEFT = 0x02;
+const uint8_t HD44780_ENTRYSHIFTINCREMENT = 0x01;
+const uint8_t HD44780_ENTRYSHIFTDECREMENT = 0x00;
+
+// flags for display on/off control
+const uint8_t HD44780_DISPLAYON = 0x04;
+const uint8_t HD44780_DISPLAYOFF = 0x00;
+const uint8_t HD44780_CURSORON = 0x02;
+const uint8_t HD44780_CURSOROFF = 0x00;
+const uint8_t HD44780_BLINKON = 0x01;
+const uint8_t HD44780_BLINKOFF = 0x00;
+
+// flags for display/cursor shift
+const uint8_t HD44780_DISPLAYMOVE = 0x08;
+const uint8_t HD44780_MOVERIGHT = 0x04;
+const uint8_t HD44780_MOVELEFT = 0x00;
+
+// flags for function set
+const uint8_t HD44780_8BITMODE = 0x10;
+const uint8_t HD44780_4BITMODE = 0x00;
+const uint8_t HD44780_2LINE = 0x08;
+const uint8_t HD44780_1LINE = 0x00;
+const uint8_t HD44780_5x10DOTS = 0x04;
+const uint8_t HD44780_5x8DOTS = 0x00;
+
+// flags for CGRAM
+const uint8_t HD44780_SETCGRAMADDR = 0x40;
+
+// may be implementation specific
+const uint8_t HD44780_EN = 0x04; // Enable bit
+const uint8_t HD44780_RW = 0x02; // Read/Write bit
+const uint8_t HD44780_RS = 0x01; // Register select bit
+const uint8_t HD44780_DATA = 0x40;
+const uint8_t HD44780_CMD = 0x80;
+
+const uint8_t HD44780_BACKLIGHT = 0x08;
+const uint8_t HD44780_NOBACKLIGHT = 0x00;
diff --git a/ext/lib/upm/src/lcm1602/lcm1602.c b/ext/lib/upm/src/lcm1602/lcm1602.c
new file mode 100644
index 0000000..6bb1cee
--- /dev/null
+++ b/ext/lib/upm/src/lcm1602/lcm1602.c
@@ -0,0 +1,640 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Based on UPM C++ drivers originally developed by:
+ * Author: Daniel Mosquera
+ * Copyright (c) 2013 Daniel Mosquera
+ *
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+
+#include <upm_utilities.h>
+
+#include "lcm1602.h"
+#include "hd44780_bits.h"
+
+// forward declarations
+static upm_result_t send(const lcm1602_context dev, uint8_t value, int mode);
+static upm_result_t write4bits(const lcm1602_context dev, uint8_t value);
+static upm_result_t expandWrite(const lcm1602_context dev, uint8_t value);
+static upm_result_t pulseEnable(const lcm1602_context dev, uint8_t value);
+
+lcm1602_context lcm1602_i2c_init(int bus, int address, bool is_expander,
+                                 uint8_t num_columns, uint8_t num_rows)
+{
+    lcm1602_context dev =
+        (lcm1602_context)malloc(sizeof(struct _lcm1602_context));
+
+    if (!dev)
+        return NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        lcm1602_close(dev);
+        return NULL;
+    }
+
+    memset((void *)dev, 0, sizeof(struct _lcm1602_context));
+
+    // initialize the MRAA context
+
+    if (!(dev->i2c = mraa_i2c_init(bus)))
+    {
+        printf("%s: mraa_i2c_init failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+
+        return NULL;
+    }
+
+    // now check the address...
+    if (mraa_i2c_address(dev->i2c, address) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_i2c_address failed.\n", __FUNCTION__);
+
+        lcm1602_close(dev);
+
+        return NULL;
+    }
+
+    dev->isI2C = true;
+    dev->backlight = HD44780_BACKLIGHT;
+    dev->columns = num_columns;
+    dev->rows = num_rows;
+
+    // if we are not dealing with an expander we will only initialize
+    // the I2C context and bail, leaving it up to the caller to handle
+    // further communications (like JHD1313M1)
+
+    if (!is_expander)
+        return dev;
+
+    upm_delay_us(50000);
+    lcm1602_backlight_on(dev, true);
+    upm_delay_us(100000);
+
+    // try to put us into 4 bit mode
+    write4bits(dev, 0x03 << 4);
+    upm_delay_us(4500);
+
+    write4bits(dev, 0x30);
+    upm_delay_us(4500);
+
+    write4bits(dev,0x30);
+    upm_delay_us(150);
+
+    // Put us into 4 bit mode, for realz yo.
+    write4bits(dev, 0x20);
+
+    // Set number of lines
+    lcm1602_command(dev, HD44780_FUNCTIONSET | 0x0f);
+
+    // default display control
+    dev->displayControl = HD44780_DISPLAYON | HD44780_CURSOROFF
+        | HD44780_BLINKOFF;
+
+    lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+    upm_delay_us(2000);
+    lcm1602_clear(dev);
+
+    // Set entry mode.
+    dev->entryDisplayMode = HD44780_ENTRYLEFT | HD44780_ENTRYSHIFTDECREMENT;
+    lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
+
+    lcm1602_home(dev);
+
+    return dev;
+}
+
+lcm1602_context lcm1602_gpio_init(uint8_t rs, uint8_t enable,
+                                  uint8_t d0, uint8_t d1, uint8_t d2,
+                                  uint8_t d3, uint8_t num_columns,
+                                  uint8_t num_rows)
+{
+    lcm1602_context dev =
+        (lcm1602_context)malloc(sizeof(struct _lcm1602_context));
+
+    if (!dev)
+        return NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        lcm1602_close(dev);
+        return NULL;
+    }
+
+    memset((void *)dev, 0, sizeof(struct _lcm1602_context));
+
+    // initialize the MRAA contexts
+
+    if (!(dev->gpioRS = mraa_gpio_init(rs)))
+    {
+        printf("%s: mraa_gpio_init(rs) failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->gpioRS, MRAA_GPIO_OUT);
+
+    if (!(dev->gpioEN = mraa_gpio_init(enable)))
+    {
+        printf("%s: mraa_gpio_init(enable) failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->gpioEN, MRAA_GPIO_OUT);
+
+    if (!(dev->gpioD0 = mraa_gpio_init(d0)))
+    {
+        printf("%s: mraa_gpio_init(d0) failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->gpioD0, MRAA_GPIO_OUT);
+
+    if (!(dev->gpioD1 = mraa_gpio_init(d1)))
+    {
+        printf("%s: mraa_gpio_init(d1) failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->gpioD1, MRAA_GPIO_OUT);
+
+    if (!(dev->gpioD2 = mraa_gpio_init(d2)))
+    {
+        printf("%s: mraa_gpio_init(d2) failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->gpioD2, MRAA_GPIO_OUT);
+
+    if (!(dev->gpioD3 = mraa_gpio_init(d3)))
+    {
+        printf("%s: mraa_gpio_init(d3) failed.\n", __FUNCTION__);
+        lcm1602_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->gpioD3, MRAA_GPIO_OUT);
+
+    dev->isI2C = false;
+    // no backlight for GPIO
+    dev->backlight = 0;
+    dev->columns = num_columns;
+    dev->rows = num_rows;
+
+    // set RS and Enable low to begin issuing commands
+    mraa_gpio_write(dev->gpioRS, 0);
+    mraa_gpio_write(dev->gpioEN, 0);
+
+    // wait to stabilize
+    upm_delay_us(100000);
+
+    // set 4bit mode
+
+    // These steps are adapted from the HD44780 datasheet, figure 24
+
+    // try 1
+    write4bits(dev, 0x03);
+    upm_delay_us(4500);
+
+    // try 2
+    write4bits(dev, 0x03);
+    upm_delay_us(4500);
+
+    // try 3
+    write4bits(dev, 0x03);
+    upm_delay_us(150);
+
+    // Finally, put into 4 bit mode
+    write4bits(dev, 0x02);
+
+    // Set number of lines
+    lcm1602_command(dev, HD44780_FUNCTIONSET | HD44780_2LINE | HD44780_4BITMODE
+                    | HD44780_5x8DOTS);
+
+
+    dev->displayControl = HD44780_DISPLAYON | HD44780_CURSOROFF
+        | HD44780_BLINKOFF;
+    lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+    upm_delay_us(2000);
+    lcm1602_clear(dev);
+
+    // Set entry mode.
+    dev->entryDisplayMode = HD44780_ENTRYLEFT | HD44780_ENTRYSHIFTDECREMENT;
+    lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
+
+    lcm1602_home(dev);
+
+    return dev;
+}
+
+void lcm1602_close(lcm1602_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->i2c)
+        mraa_i2c_stop(dev->i2c);
+
+    if (dev->gpioRS)
+        mraa_gpio_close(dev->gpioRS);
+    if (dev->gpioEN)
+        mraa_gpio_close(dev->gpioEN);
+    if (dev->gpioD0)
+        mraa_gpio_close(dev->gpioD0);
+    if (dev->gpioD1)
+        mraa_gpio_close(dev->gpioD1);
+    if (dev->gpioD2)
+        mraa_gpio_close(dev->gpioD2);
+    if (dev->gpioD3)
+        mraa_gpio_close(dev->gpioD3);
+
+    free(dev);
+}
+
+upm_result_t lcm1602_write(const lcm1602_context dev, char *buffer,
+                           int len)
+{
+    assert(dev != NULL);
+
+    upm_result_t error = UPM_SUCCESS;
+
+    int i;
+    for (i=0; i<len; ++i)
+        error = lcm1602_data(dev, buffer[i]);
+
+    return error;
+}
+
+upm_result_t lcm1602_set_cursor(const lcm1602_context dev, unsigned int row,
+                                unsigned int column)
+{
+    assert(dev != NULL);
+
+    column = column % dev->columns;
+    uint8_t offset = column;
+
+    switch (dev->rows)
+    {
+    case 1:
+        // Single row displays with more than 8 columns usually have their
+        // DDRAM split in two halves. The first half starts at address 00.
+        // The second half starts at address 40. E.g. 16x2 DDRAM mapping:
+        // 00 01 02 03 04 05 06 07 40 41 42 43 44 45 46 47
+        if (dev->columns > 8)
+        {
+            offset = (column % (dev->columns / 2)) +
+                (column / (dev->columns / 2)) * 0x40;
+        }
+        break;
+
+    case 2:
+        // this should work for any display with two rows
+        // DDRAM mapping:
+        // 00 .. 27
+        // 40 .. 67
+        offset += row * 0x40;
+        break;
+
+    case 4:
+        if (dev->columns == 16)
+        {
+            // 16x4 display
+            // DDRAM mapping:
+            // 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
+            // 40 41 42 43 43 45 46 47 48 49 4A 4B 4C 4D 4E 4F
+            // 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
+            // 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F
+            int row_addr[] = { 0x00, 0x40, 0x10, 0x50 };
+            offset += row_addr[row];
+        }
+        else
+        {
+            // 20x4 display
+            // DDRAM mapping:
+            // 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13
+            // 40 41 42 43 43 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 51 52 53
+            // 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27
+            // 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67
+            int row_addr[] = { 0x00, 0x40, 0x14, 0x54 };
+            offset += row_addr[row];
+        }
+        break;
+    }
+
+    return lcm1602_command(dev, HD44780_CMD | offset);
+}
+
+upm_result_t lcm1602_clear(const lcm1602_context dev)
+{
+    assert(dev != NULL);
+
+    upm_result_t ret;
+    ret = lcm1602_command(dev, HD44780_CLEARDISPLAY);
+    upm_delay_us(2000); // this command takes awhile
+    return ret;
+}
+
+upm_result_t lcm1602_home(const lcm1602_context dev)
+{
+    assert(dev != NULL);
+
+    upm_result_t ret;
+    ret = lcm1602_command(dev, HD44780_RETURNHOME);
+    upm_delay_us(2000); // this command takes awhile
+    return ret;
+}
+
+upm_result_t lcm1602_create_char(const lcm1602_context dev,
+                                 unsigned int slot,
+                                 lcm1602_custom_char_t data)
+{
+    assert(dev != NULL);
+
+    upm_result_t error = UPM_SUCCESS;
+
+    slot &= 0x07; // only have 8 positions we can set
+
+    error = lcm1602_command(dev, HD44780_SETCGRAMADDR | (slot << 3));
+
+    if (error == UPM_SUCCESS)
+    {
+        int i;
+        for (i = 0; i < 8; i++) {
+            error = lcm1602_data(dev, data[i]);
+        }
+    }
+
+    return error;
+}
+
+upm_result_t lcm1602_display_on(const lcm1602_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->displayControl |= HD44780_DISPLAYON;
+    else
+        dev->displayControl &= ~HD44780_DISPLAYON;
+
+    return lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+}
+
+upm_result_t lcm1602_cursor_on(const lcm1602_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->displayControl |= HD44780_CURSORON;
+    else
+        dev->displayControl &= ~HD44780_CURSORON;
+
+    return lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+}
+
+upm_result_t lcm1602_cursor_blink_on(const lcm1602_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->displayControl |= HD44780_BLINKON;
+    else
+        dev->displayControl &= ~HD44780_BLINKON;
+
+    return lcm1602_command(dev, HD44780_DISPLAYCONTROL | dev->displayControl);
+}
+
+upm_result_t lcm1602_backlight_on(const lcm1602_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->backlight = HD44780_BACKLIGHT;
+    else
+        dev->backlight = HD44780_NOBACKLIGHT;
+
+    return expandWrite(dev, dev->backlight);
+}
+
+upm_result_t lcm1602_scroll_display_left(const lcm1602_context dev)
+{
+    assert(dev != NULL);
+
+    return lcm1602_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
+                           | HD44780_MOVELEFT);
+}
+
+upm_result_t lcm1602_scroll_display_right(const lcm1602_context dev)
+{
+    assert(dev != NULL);
+
+    return lcm1602_command(dev, HD44780_CURSORSHIFT | HD44780_DISPLAYMOVE
+                           | HD44780_MOVERIGHT);
+}
+
+upm_result_t lcm1602_entry_left_to_right(const lcm1602_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->entryDisplayMode |= HD44780_ENTRYLEFT;
+    else
+        dev->entryDisplayMode &= ~HD44780_ENTRYLEFT;
+
+    return lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
+}
+
+upm_result_t lcm1602_autoscroll_on(const lcm1602_context dev, bool on)
+{
+    assert(dev != NULL);
+
+    if (on)
+        dev->entryDisplayMode |= HD44780_ENTRYSHIFTINCREMENT;
+    else
+        dev->entryDisplayMode &= ~HD44780_ENTRYSHIFTINCREMENT;
+
+    return lcm1602_command(dev, HD44780_ENTRYMODESET | dev->entryDisplayMode);
+}
+
+upm_result_t lcm1602_command(const lcm1602_context dev, uint8_t cmd)
+{
+    assert(dev != NULL);
+
+    return send(dev, cmd, 0);
+}
+
+upm_result_t lcm1602_data(const lcm1602_context dev, uint8_t cmd)
+{
+    assert(dev != NULL);
+    return send(dev, cmd, HD44780_RS); // 1
+}
+
+
+// static declarations
+static upm_result_t send(const lcm1602_context dev, uint8_t value,
+                         int mode)
+{
+    assert(dev != NULL);
+
+    uint8_t h;
+    uint8_t l;
+
+    upm_result_t rv = UPM_SUCCESS;
+
+    if (dev->isI2C)
+    {
+        h = value & 0xf0;
+        l = (value << 4) & 0xf0;
+        if (write4bits(dev, h | mode))
+            rv = UPM_ERROR_OPERATION_FAILED;
+        if (write4bits(dev, l | mode))
+            rv = UPM_ERROR_OPERATION_FAILED;
+
+        return rv;
+    }
+
+    // else, gpio (4 bit)
+
+    // register select
+    if (mraa_gpio_write(dev->gpioRS, mode))
+    {
+        printf("%s: mraa_gpio_write() failed\n", __FUNCTION__);
+        rv = UPM_ERROR_OPERATION_FAILED;
+    }
+
+    h = value >> 4;
+    l = value & 0x0f;
+
+    if (write4bits(dev, h))
+        rv = UPM_ERROR_OPERATION_FAILED;
+    if (write4bits(dev, l))
+        rv = UPM_ERROR_OPERATION_FAILED;
+
+    return rv;
+}
+
+static upm_result_t write4bits(const lcm1602_context dev,
+                               uint8_t value)
+{
+    assert(dev != NULL);
+
+    upm_result_t rv = UPM_SUCCESS;
+
+    if (dev->isI2C)
+    {
+        if (expandWrite(dev, value))
+            rv = UPM_ERROR_OPERATION_FAILED;
+        if (pulseEnable(dev, value))
+            rv = UPM_ERROR_OPERATION_FAILED;
+
+        return rv;
+    }
+
+    // else gpio
+    mraa_result_t mrv = MRAA_SUCCESS;
+    mrv = mraa_gpio_write(dev->gpioD0, ((value >> 0) & 0x01) );
+    mrv = mraa_gpio_write(dev->gpioD1, ((value >> 1) & 0x01) );
+    mrv = mraa_gpio_write(dev->gpioD2, ((value >> 2) & 0x01) );
+    mrv = mraa_gpio_write(dev->gpioD3, ((value >> 3) & 0x01) );
+
+    if (mrv)
+    {
+        printf("%s: mraa_gpio_write() failed\n", __FUNCTION__);
+        rv = UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if (pulseEnable(dev, value)) // value is ignored here for gpio
+    {
+        printf("%s: pulseEnable() failed\n", __FUNCTION__);
+        rv = UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return rv;
+}
+
+static upm_result_t expandWrite(const lcm1602_context dev,
+                               uint8_t value)
+{
+    assert(dev != NULL);
+
+    // invalid for gpio
+    if (!dev->isI2C)
+        return UPM_ERROR_NO_RESOURCES;
+
+    uint8_t buffer = value | dev->backlight;
+
+    if (mraa_i2c_write_byte(dev->i2c, buffer))
+    {
+        printf("%s: mraa_i2c_write_byte() failed\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
+
+static upm_result_t pulseEnable(const lcm1602_context dev,
+                                uint8_t value)
+{
+    assert(dev != NULL);
+
+    upm_result_t rv = UPM_SUCCESS;
+
+    if (dev->isI2C)
+    {
+        if (expandWrite(dev, value | HD44780_EN))
+            rv = UPM_ERROR_OPERATION_FAILED;
+        upm_delay_us(1);
+
+        if (expandWrite(dev, value & ~HD44780_EN))
+            rv = UPM_ERROR_OPERATION_FAILED;
+
+        upm_delay_us(50);
+        return rv;
+    }
+
+    // else gpio
+
+    mraa_result_t mrv = MRAA_SUCCESS;
+    mrv = mraa_gpio_write(dev->gpioEN, 1);
+    upm_delay_us(1); // must be > 450ns
+    mrv = mraa_gpio_write(dev->gpioEN, 0);
+    upm_delay_us(100); // must be >37us
+
+    if (mrv)
+    {
+        printf("%s: mraa_gpio_write() failed\n", __FUNCTION__);
+        rv = UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return rv;
+}
diff --git a/ext/lib/upm/src/lcm1602/lcm1602.h b/ext/lib/upm/src/lcm1602/lcm1602.h
new file mode 100644
index 0000000..000a6ae
--- /dev/null
+++ b/ext/lib/upm/src/lcm1602/lcm1602.h
@@ -0,0 +1,269 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Based on UPM C++ drivers originally developed by:
+ * Author: Daniel Mosquera
+ * Copyright (c) 2013 Daniel Mosquera
+ *
+ * Author: Thomas Ingleby <thomas.c.ingleby@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Contributions: Sergey Kiselev <sergey.kiselev@intel.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/i2c.h>
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+    /**
+     * @file lcm1602.h
+     * @library lcm1602
+     * @brief C API for the LCM1602 family of LCD displays
+     *
+     * @include lcm1602.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _lcm1602_context {
+        // A large number of GPIOs
+        mraa_gpio_context        gpioRS;
+        mraa_gpio_context        gpioEN;
+        mraa_gpio_context        gpioD0;
+        mraa_gpio_context        gpioD1;
+        mraa_gpio_context        gpioD2;
+        mraa_gpio_context        gpioD3;
+
+        // I2C command control
+        mraa_i2c_context         i2c;
+
+        // what interface are we using?
+        bool                     isI2C;
+
+        // configuration
+        unsigned int             columns;
+        unsigned int             rows;
+
+        // display command
+        uint8_t                  displayControl;
+        uint8_t                  entryDisplayMode;
+        uint8_t                  backlight;
+    } *lcm1602_context;
+
+    /**
+     * Custom character.
+     */
+    typedef char lcm1602_custom_char_t[8];
+
+    /**
+     * LCM1602 I2C initialization.  This is used for those devices
+     * using an I2C expander, or other I2C interface.  If you are
+     * using an expander, you must specify true for the is_expander
+     * argument.  If not, then the caller of this function is
+     * responsible for any transfers to the I2C device.  Internally,
+     * only direct access to an I2C expander is supported.
+     *
+     * @param bus I2C bus to use.
+     * @param address I2C address the LCD is configured for.
+     * @param is_expander True if we are dealing with an I2C expander,
+     * false otherwise.
+     * @param num_columns Number of columns the display has.
+     * @param num_rows Number of rows the display has.
+     * @return Device Ccontext, or NULL on error.
+     */
+    lcm1602_context lcm1602_i2c_init(int bus, int address, bool is_expander,
+                                     uint8_t num_columns, uint8_t num_rows);
+
+    /**
+     * LCM1602 GPIO (parallel) initialization, used for GPIO based
+     * HD44780 controllers supporting RS, Enable, and 4 data pins in
+     * 4-bit mode.
+     *
+     * @param rs Register select pin
+     * @param enable Enable pin
+     * @param d0 Data 0 pin
+     * @param d1 Data 1 pin
+     * @param d2 Data 2 pin
+     * @param d3 Data 3 pin
+     * @param num_columns Number of columns the display has. Default 16.
+     * @param num_rows Number of rows the display has. Default 2.
+     * @return Device Ccontext, or NULL on error.
+     */
+    lcm1602_context lcm1602_gpio_init(uint8_t rs, uint8_t enable,
+                                      uint8_t d0, uint8_t d1, uint8_t d2,
+                                      uint8_t d3, uint8_t num_columns,
+                                      uint8_t num_rows);
+
+    /**
+     * LCM1602 close.
+     *
+     * @param dev The device context.
+     */
+    void lcm1602_close(lcm1602_context dev);
+
+    /**
+     * Writes a string to the LCD.
+     *
+     * @param dev The device context.
+     * @param buffer Character buffer containing characters to write to
+     * the display; note: only ASCII characters are supported
+     * @param len The number of characters to write.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_write(const lcm1602_context dev, char *buffer,
+                               int len);
+
+    /**
+     * Sets the cursor to specified coordinates
+     *
+     * @param dev The device context.
+     * @param row Row to set the cursor to.
+     * @param column Column to set the cursor to.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_set_cursor(const lcm1602_context dev,
+                                    unsigned int row, unsigned int column);
+
+    /**
+     * Clears the display of all characters.
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_clear(const lcm1602_context dev);
+
+    /**
+     * Returns to the home coordinates (0,0).
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_home(const lcm1602_context dev);
+
+    /**
+     * Create a custom character.
+     *
+     * @param dev The device context.
+     * @param slot The character slot to write, only 8 are available.
+     * @param data The character data (8 bytes) making up the character.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_create_char(const lcm1602_context dev,
+                                     unsigned int slot,
+                                     lcm1602_custom_char_t data);
+
+    /**
+     * Turn the display on.
+     *
+     * @param dev The device context.
+     * @param on true to turn display on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_display_on(const lcm1602_context dev, bool on);
+
+    /**
+     * Turn the cursor on.
+     *
+     * @param dev The device context.
+     * @param on true to turn cursor on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_cursor_on(const lcm1602_context dev, bool on);
+
+    /**
+     * Turn cursor blink on.
+     *
+     * @param dev The device context.
+     * @param on true to turn cursor blink on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_cursor_blink_on(const lcm1602_context dev, bool on);
+
+    /**
+     * Turn backlight on.
+     *
+     * @param dev The device context.
+     * @param on true to turn backlight on, false otherwise.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_backlight_on(const lcm1602_context dev, bool on);
+
+    /**
+     * Scroll the display left, without changing the character RAM.
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_scroll_display_left(const lcm1602_context dev);
+
+    /**
+     * Scroll the display right, without changing the character RAM.
+     *
+     * @param dev The device context.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_scroll_display_right(const lcm1602_context dev);
+
+    /**
+     * Set the entry mode so that characters are added left to right.
+     *
+     * @param dev The device context.
+     * @param on true to add characters left to right, false for right
+     * to left.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_entry_left_to_right(const lcm1602_context dev,
+                                             bool on);
+
+    /**
+     * Right justify text entered from the cursor.
+     *
+     * @param dev The device context.
+     * @param on true right justify text, false to left justify text.
+     * @return UPM result.
+     */
+    upm_result_t lcm1602_autoscroll_on(const lcm1602_context dev, bool on);
+
+
+    // Add a command() and data() virtual member functions, with a
+    // default implementation in lcm1602.  This is expected to be
+    // implemented by derived classes with different needs (Jhd1313m1,
+    // for example).
+    upm_result_t lcm1602_command(const lcm1602_context dev, uint8_t cmd);
+    upm_result_t lcm1602_data(const lcm1602_context dev, uint8_t data);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/ldt0028/Kbuild b/ext/lib/upm/src/ldt0028/Kbuild
new file mode 100644
index 0000000..acea3cb
--- /dev/null
+++ b/ext/lib/upm/src/ldt0028/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ldt0028) += ldt0028.o
diff --git a/ext/lib/upm/src/ldt0028/Kconfig b/ext/lib/upm/src/ldt0028/Kconfig
new file mode 100644
index 0000000..0caeb7b
--- /dev/null
+++ b/ext/lib/upm/src/ldt0028/Kconfig
@@ -0,0 +1,9 @@
+config UPM_ldt0028
+    bool "ldt0028"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        ldt0028 Piezo Vibration Sensor
+
diff --git a/ext/lib/upm/src/ldt0028/Makefile b/ext/lib/upm/src/ldt0028/Makefile
new file mode 100644
index 0000000..fd571a0
--- /dev/null
+++ b/ext/lib/upm/src/ldt0028/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ldt0028
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ldt0028
+endif
diff --git a/ext/lib/upm/src/ldt0028/ldt0028.c b/ext/lib/upm/src/ldt0028/ldt0028.c
new file mode 100644
index 0000000..c8999d1
--- /dev/null
+++ b/ext/lib/upm/src/ldt0028/ldt0028.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "ldt0028.h"
+
+ldt0028_context ldt0028_init(int16_t pin)
+{
+    ldt0028_context dev = (ldt0028_context) malloc(sizeof(struct _ldt0028_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void ldt0028_close(ldt0028_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t ldt0028_set_aref(const ldt0028_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t ldt0028_set_scale(const ldt0028_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t ldt0028_set_offset(const ldt0028_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float ldt0028_get_aref(const ldt0028_context dev)
+{
+    return dev->m_aRef;
+}
+
+float ldt0028_get_scale(const ldt0028_context dev)
+{
+    return dev->m_scale;
+}
+
+float ldt0028_get_offset(const ldt0028_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t ldt0028_get_normalized(const ldt0028_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t ldt0028_get_raw_volts(const ldt0028_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t ldt0028_get_volts(const ldt0028_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+     /* Scale to aRef */
+    *value *= dev->m_aRef;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/ldt0028/ldt0028.h b/ext/lib/upm/src/ldt0028/ldt0028.h
new file mode 100644
index 0000000..23f21e5
--- /dev/null
+++ b/ext/lib/upm/src/ldt0028/ldt0028.h
@@ -0,0 +1,133 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * driver context
+ */
+typedef struct _ldt0028_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *ldt0028_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+ldt0028_context ldt0028_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void ldt0028_close(ldt0028_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t ldt0028_set_aref(const ldt0028_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t ldt0028_set_scale(const ldt0028_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     value = value + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t ldt0028_set_offset(const ldt0028_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float ldt0028_get_aref(const ldt0028_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float ldt0028_get_scale(const ldt0028_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float ldt0028_get_offset(const ldt0028_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t ldt0028_get_normalized(const ldt0028_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t ldt0028_get_raw_volts(const ldt0028_context dev, float *value);
+
+/**
+ * Read scaled/offset voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor voltage
+ * @return Function result code
+ */
+upm_result_t ldt0028_get_volts(const ldt0028_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/led/Kbuild b/ext/lib/upm/src/led/Kbuild
new file mode 100644
index 0000000..7767d4c
--- /dev/null
+++ b/ext/lib/upm/src/led/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_led) += led.o
diff --git a/ext/lib/upm/src/led/Kconfig b/ext/lib/upm/src/led/Kconfig
new file mode 100644
index 0000000..02e98d4
--- /dev/null
+++ b/ext/lib/upm/src/led/Kconfig
@@ -0,0 +1,9 @@
+config UPM_led
+    bool "led"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm led module
+
diff --git a/ext/lib/upm/src/led/Makefile b/ext/lib/upm/src/led/Makefile
new file mode 100644
index 0000000..b4dac9e
--- /dev/null
+++ b/ext/lib/upm/src/led/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_led
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/led
+endif
diff --git a/ext/lib/upm/src/led/led.c b/ext/lib/upm/src/led/led.c
new file mode 100644
index 0000000..c9649c7
--- /dev/null
+++ b/ext/lib/upm/src/led/led.c
@@ -0,0 +1,62 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * Contributions: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
+ * Contributions: Sarah Knepper <sarah.knepper@intel.com>
+ *                Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "led.h"
+#include "upm_types.h"
+
+led_context led_init(uint8_t pin){
+    led_context dev =
+      (led_context)malloc(sizeof(struct _led_context));
+
+    if (!dev)
+      return NULL;
+
+    dev->led_pin = pin;
+    dev->gpio = mraa_gpio_init(dev->led_pin);
+
+    if (mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT) != MRAA_SUCCESS)
+      return NULL;
+
+    return dev;
+}
+
+void led_close(led_context dev){
+    free(dev);
+}
+
+upm_result_t led_on(led_context dev){
+    if (mraa_gpio_write(dev->gpio, 1) != MRAA_SUCCESS)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t led_off(led_context dev){
+    if (mraa_gpio_write(dev->gpio, 0) != MRAA_SUCCESS)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/led/led.h b/ext/lib/upm/src/led/led.h
new file mode 100644
index 0000000..17ddb40
--- /dev/null
+++ b/ext/lib/upm/src/led/led.h
@@ -0,0 +1,93 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * Contributions: Mihai Tudor Panu <mihai.tudor.panu@intel.com>
+ * Contributions: Sarah Knepper <sarah.knepper@intel.com>
+ *                Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef LED_LED_H_
+#define LED_LED_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/gpio.h"
+
+/**
+ * @type led
+ * @con gpio
+ * @kit gsk
+ *
+ * @brief API for the Grove LED
+ *
+ * UPM module for the Grove LED (or other similar light-emitting diodes).
+ * An LED is a small lightbulb that emits light in
+ * response to a small current. The longer wire of an LED connects
+ * to the positive seat (anode); the shorter wire connects to the
+ * negative seat (cathode). The flat side of the bulb corresponds
+ * to the cathode, while the rounded side corresponds to the anode.
+ *
+ * @image html led.jpg
+ */
+
+/**
+ * device context
+ */
+typedef struct _led_context {
+    mraa_gpio_context        gpio;
+    uint8_t                  led_pin;
+} *led_context;
+
+/**
+ * LED Initialization function
+ *
+ * @param pin GPIO pin to use
+ * @return The sensor context
+ */
+led_context led_init(uint8_t pin);
+
+/**
+ * LED Initialization function
+ *
+ * @param The sensor context
+ */
+void led_close(led_context dev);
+
+/**
+ * Function to turn LED on
+ *
+ * @param The sensor context
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t led_on(led_context dev);
+
+/**
+ * Function to turn LED off
+ *
+ * @param The sensor context
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t led_off(led_context dev);
+
+#endif /* LED_LED_H_ */
diff --git a/ext/lib/upm/src/light/Kbuild b/ext/lib/upm/src/light/Kbuild
new file mode 100644
index 0000000..093cdc6
--- /dev/null
+++ b/ext/lib/upm/src/light/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_light) += light.o
diff --git a/ext/lib/upm/src/light/Kconfig b/ext/lib/upm/src/light/Kconfig
new file mode 100644
index 0000000..208c928
--- /dev/null
+++ b/ext/lib/upm/src/light/Kconfig
@@ -0,0 +1,9 @@
+config UPM_light
+    bool "light"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm light sensor module
+
diff --git a/ext/lib/upm/src/light/Makefile b/ext/lib/upm/src/light/Makefile
new file mode 100644
index 0000000..ab0f6a7
--- /dev/null
+++ b/ext/lib/upm/src/light/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_light
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/light
+endif
diff --git a/ext/lib/upm/src/light/light.c b/ext/lib/upm/src/light/light.c
new file mode 100644
index 0000000..c945023
--- /dev/null
+++ b/ext/lib/upm/src/light/light.c
@@ -0,0 +1,132 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "light.h"
+
+light_context light_init(int16_t pin)
+{
+    light_context dev = (light_context) malloc(sizeof(struct _light_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void light_close(light_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t light_set_aref(const light_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t light_set_scale(const light_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t light_set_offset(const light_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float light_get_aref(const light_context dev)
+{
+    return dev->m_aRef;
+}
+
+float light_get_scale(const light_context dev)
+{
+    return dev->m_scale;
+}
+
+float light_get_offset(const light_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t light_get_normalized(const light_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t light_get_raw_volts(const light_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t light_get_lux(const light_context dev, float *value)
+{
+    *value = mraa_aio_read(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Get max adc value range 1023, 2047, 4095, etc... */
+    float max_adc = (1 << mraa_aio_get_bit(dev->aio)) - 1;
+
+    /* Convert the value to lux */
+    *value = 10000.0/pow(((max_adc - *value) * 10.0 / *value)*15.0,4.0/3.0);
+
+     /* Apply scale */
+    *value *= dev->m_scale;
+
+    /* Apply the offset in lux */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/light/light.h b/ext/lib/upm/src/light/light.h
new file mode 100644
index 0000000..adce216
--- /dev/null
+++ b/ext/lib/upm/src/light/light.h
@@ -0,0 +1,133 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * driver context
+ */
+typedef struct _light_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *light_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+light_context light_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void light_close(light_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t light_set_aref(const light_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t light_set_scale(const light_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     value = value + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t light_set_offset(const light_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float light_get_aref(const light_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float light_get_scale(const light_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float light_get_offset(const light_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t light_get_normalized(const light_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t light_get_raw_volts(const light_context dev, float *value);
+
+/**
+ * Read scaled/offset light value in lux
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor value in lux
+ * @return Function result code
+ */
+upm_result_t light_get_lux(const light_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/linefinder/Kbuild b/ext/lib/upm/src/linefinder/Kbuild
new file mode 100644
index 0000000..0f6799b
--- /dev/null
+++ b/ext/lib/upm/src/linefinder/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_linefinder) += linefinder.o
diff --git a/ext/lib/upm/src/linefinder/Kconfig b/ext/lib/upm/src/linefinder/Kconfig
new file mode 100644
index 0000000..ef04bd7
--- /dev/null
+++ b/ext/lib/upm/src/linefinder/Kconfig
@@ -0,0 +1,8 @@
+config UPM_linefinder
+    bool "linefinder"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm LINEFINDER Sensor
diff --git a/ext/lib/upm/src/linefinder/Makefile b/ext/lib/upm/src/linefinder/Makefile
new file mode 100644
index 0000000..30395cb
--- /dev/null
+++ b/ext/lib/upm/src/linefinder/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_linefinder
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/linefinder
+endif
diff --git a/ext/lib/upm/src/linefinder/linefinder.c b/ext/lib/upm/src/linefinder/linefinder.c
new file mode 100644
index 0000000..18e5f08
--- /dev/null
+++ b/ext/lib/upm/src/linefinder/linefinder.c
@@ -0,0 +1,84 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+
+#include "linefinder.h"
+
+linefinder_context linefinder_init(int pin)
+{
+    linefinder_context dev =
+        (linefinder_context)malloc(sizeof(struct _linefinder_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->gpio = NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        linefinder_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->gpio = mraa_gpio_init(pin)) )
+    {
+        printf("%s: mraa_gpio_init() failed\n",
+               __FUNCTION__);
+        linefinder_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+    return dev;
+}
+
+void linefinder_close(linefinder_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->gpio)
+        mraa_gpio_close(dev->gpio);
+
+    free(dev);
+}
+
+bool linefinder_white_detected(const linefinder_context dev)
+{
+    assert(dev != NULL);
+
+    return (!mraa_gpio_read(dev->gpio) ? true : false);
+}
+
+bool linefinder_black_detected(const linefinder_context dev)
+{
+    assert(dev != NULL);
+
+    return (mraa_gpio_read(dev->gpio) ? true : false);
+}
diff --git a/ext/lib/upm/src/linefinder/linefinder.h b/ext/lib/upm/src/linefinder/linefinder.h
new file mode 100644
index 0000000..098671b
--- /dev/null
+++ b/ext/lib/upm/src/linefinder/linefinder.h
@@ -0,0 +1,77 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * Device context
+     */
+    typedef struct _linefinder_context {
+        mraa_gpio_context gpio;
+    } *linefinder_context;
+
+    /**
+     *  Line Finder inititialization
+     *
+     * @param pin Digital pin to use
+     * @return device context
+     */
+    linefinder_context linefinder_init(int pin);
+
+    /**
+     * LineFinder close
+     *
+     * @param Device context
+     */
+    void linefinder_close(linefinder_context dev);
+
+    /**
+     * Determines whether white has been detected
+     *
+     * @param Device context
+     * @return True if white is detected
+     */
+    bool linefinder_white_detected(const linefinder_context dev);
+
+    /**
+     * Determines whether black has been detected
+     *
+     * @param Device context
+     * @return True if black is detected
+     */
+    bool linefinder_black_detected(const linefinder_context dev);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/lm35/Kbuild b/ext/lib/upm/src/lm35/Kbuild
new file mode 100644
index 0000000..b48cbd3
--- /dev/null
+++ b/ext/lib/upm/src/lm35/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_lm35) += lm35.o
diff --git a/ext/lib/upm/src/lm35/Kconfig b/ext/lib/upm/src/lm35/Kconfig
new file mode 100644
index 0000000..5b3c653
--- /dev/null
+++ b/ext/lib/upm/src/lm35/Kconfig
@@ -0,0 +1,8 @@
+config UPM_lm35
+    bool "lm35"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm LM35 Analog Temperature Sensor
diff --git a/ext/lib/upm/src/lm35/Makefile b/ext/lib/upm/src/lm35/Makefile
new file mode 100644
index 0000000..9199c2e
--- /dev/null
+++ b/ext/lib/upm/src/lm35/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_lm35
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/lm35
+endif
diff --git a/ext/lib/upm/src/lm35/lm35.c b/ext/lib/upm/src/lm35/lm35.c
new file mode 100644
index 0000000..59c0fe6
--- /dev/null
+++ b/ext/lib/upm/src/lm35/lm35.c
@@ -0,0 +1,106 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include "lm35.h"
+
+lm35_context lm35_init(int pin, float aref)
+{
+    lm35_context dev =
+        (lm35_context)malloc(sizeof(struct _lm35_context));
+
+    if (!dev)
+        return NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        lm35_close(dev);
+        return NULL;
+    }
+
+    // initialize the MRAA context
+
+    if (!(dev->aio = mraa_aio_init(pin)))
+    {
+        printf("%s: mraa_aio_init failed.\n", __FUNCTION__);
+        lm35_close(dev);
+
+        return NULL;
+    }
+
+    dev->ares = (float)((1 << mraa_aio_get_bit(dev->aio)) - 1);
+    dev->aref = aref;
+    dev->scale = 1.0;
+    dev->offset = 0.0;
+
+    return dev;
+}
+
+void lm35_close(lm35_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->aio)
+        mraa_aio_close(dev->aio);
+
+    free(dev);
+}
+
+upm_result_t lm35_get_temperature(const lm35_context dev, float *temperature)
+{
+    assert(dev != NULL);
+
+    int val = mraa_aio_read(dev->aio);
+    if (val < 0)
+    {
+        printf("%s: mraa_aio_read() failed\n", __FUNCTION__);
+        *temperature = 0.0;
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // convert to mV
+    float mV = ((float)val * (dev->aref / dev->ares) * 1000.0);
+
+    // 10mV/degree C
+    *temperature = mV / 10.0;
+    *temperature = *temperature * dev->scale + (dev->offset * dev->scale);
+    return UPM_SUCCESS;
+}
+
+void lm35_set_offset(const lm35_context dev, float offset)
+{
+    assert(dev != NULL);
+
+    dev->offset = offset;
+}
+
+void lm35_set_scale(const lm35_context dev, float scale)
+{
+    assert(dev != NULL);
+
+    dev->scale = scale;
+}
diff --git a/ext/lib/upm/src/lm35/lm35.h b/ext/lib/upm/src/lm35/lm35.h
new file mode 100644
index 0000000..0a1d984
--- /dev/null
+++ b/ext/lib/upm/src/lm35/lm35.h
@@ -0,0 +1,104 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+#include <mraa/aio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file lm35.h
+     * @library lm35
+     * @brief C API for the LM35 Temperature Sensor
+     *
+     * @include lm35.c
+     */
+
+    /**
+     * device context
+     */
+    typedef struct _lm35_context
+    {
+        mraa_aio_context    aio;
+
+        // ADC reference voltage
+        float               aref;
+        // ADC resolution
+        float               ares;
+
+        // scale and offset
+        float               scale;
+        float               offset;
+    } *lm35_context;
+
+    /**
+     * LM35 initialization.
+     *
+     * @param pin Analog pin to use
+     * @param aref Analog reference voltage
+     */
+    lm35_context lm35_init(int pin, float aref);
+
+    /**
+     * LM35 close.
+     */
+    void lm35_close(lm35_context dev);
+
+    /**
+     * Returns the temperature in degrees Celsius
+     *
+     * @param temperature A pointer to a float that will contain the
+     * measured temperature.
+     * @return UPM status
+     */
+    upm_result_t lm35_get_temperature(const lm35_context dev,
+                                      float *temperature);
+
+    /**
+     * Set sensor offset.  This offset is applied to the return values
+     * before scaling.  Default is 0.0.
+     *
+     * @param dev sensor context pointer
+     * @param offset Offset to apply.
+     */
+    void lm35_set_offset(const lm35_context dev, float offset);
+
+    /**
+     * Set sensor scale.  This scale is applied to the return values
+     * before the offset is applied.  Default is 1.0.
+     *
+     * @param dev sensor context pointer
+     * @param scale Scale to apply.
+     */
+    void lm35_set_scale(const lm35_context dev, float scale);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/loudness/Kbuild b/ext/lib/upm/src/loudness/Kbuild
new file mode 100644
index 0000000..7ee59c2
--- /dev/null
+++ b/ext/lib/upm/src/loudness/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_loudness) += loudness.o
diff --git a/ext/lib/upm/src/loudness/Kconfig b/ext/lib/upm/src/loudness/Kconfig
new file mode 100644
index 0000000..30bcd32
--- /dev/null
+++ b/ext/lib/upm/src/loudness/Kconfig
@@ -0,0 +1,9 @@
+config UPM_loudness
+    bool "loudness"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm loudness sensor module
+
diff --git a/ext/lib/upm/src/loudness/Makefile b/ext/lib/upm/src/loudness/Makefile
new file mode 100644
index 0000000..8348984
--- /dev/null
+++ b/ext/lib/upm/src/loudness/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_loudness
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/loudness
+endif
diff --git a/ext/lib/upm/src/loudness/loudness.c b/ext/lib/upm/src/loudness/loudness.c
new file mode 100644
index 0000000..99a2c52
--- /dev/null
+++ b/ext/lib/upm/src/loudness/loudness.c
@@ -0,0 +1,54 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "loudness.h"
+
+loudness_context loudness_init(int pin) {
+    loudness_context dev =
+      (loudness_context) malloc(sizeof(struct _loudness_context));
+
+    if (!dev)
+      return NULL;
+
+    dev->aio = mraa_aio_init(pin);
+
+    if (!dev->aio)
+      {
+        free(dev);
+        return NULL;
+      }
+
+    return dev;
+}
+
+void loudness_close(loudness_context dev) {
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t loudness_get_value(loudness_context dev, int* val) {
+    *val = mraa_aio_read(dev->aio);
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/loudness/loudness.h b/ext/lib/upm/src/loudness/loudness.h
new file mode 100644
index 0000000..2dbc1c7
--- /dev/null
+++ b/ext/lib/upm/src/loudness/loudness.h
@@ -0,0 +1,67 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LOUDNESS_LOUDNESS_H_
+#define LOUDNESS_LOUDNESS_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+/**
+ * device context
+ */
+typedef struct _loudness_context {
+    mraa_aio_context            aio;
+} *loudness_context;
+
+/**
+ * Loudness Initialization function
+ *
+ * @param pin AIO pin to use
+ * @return void* pointer to the sensor struct
+ */
+loudness_context loudness_init(int pin);
+
+/**
+ * Loudness destructor
+ *
+ * @param void* pointer to the sensor struct
+ */
+void loudness_close(loudness_context dev);
+
+/**
+ * Function gets the loudness raw value (currently)
+ *
+ * @param void* pointer to the sensor struct
+ * @param int* pointer to store the loudness value.
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t loudness_get_value(loudness_context dev, int* val);
+
+#endif /* LOUDNESS_LOUDNESS_H_ */
diff --git a/ext/lib/upm/src/m24lr64e/Kbuild b/ext/lib/upm/src/m24lr64e/Kbuild
new file mode 100644
index 0000000..064631e
--- /dev/null
+++ b/ext/lib/upm/src/m24lr64e/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_m24lr64e) += m24lr64e.o
diff --git a/ext/lib/upm/src/m24lr64e/Kconfig b/ext/lib/upm/src/m24lr64e/Kconfig
new file mode 100644
index 0000000..0f8f301
--- /dev/null
+++ b/ext/lib/upm/src/m24lr64e/Kconfig
@@ -0,0 +1,9 @@
+config UPM_m24lr64e
+    bool "m24lr64e"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm m24lr64esensor module
+
diff --git a/ext/lib/upm/src/m24lr64e/Makefile b/ext/lib/upm/src/m24lr64e/Makefile
new file mode 100644
index 0000000..9cb81ec
--- /dev/null
+++ b/ext/lib/upm/src/m24lr64e/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_m24lr64e
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/m24lr64e
+endif
diff --git a/ext/lib/upm/src/m24lr64e/m24lr64e.c b/ext/lib/upm/src/m24lr64e/m24lr64e.c
new file mode 100644
index 0000000..925bfeb
--- /dev/null
+++ b/ext/lib/upm/src/m24lr64e/m24lr64e.c
@@ -0,0 +1,335 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ *
+ * This code was adapted from the Seeed Studio code at:
+ * https://github.com/Seeed-Studio/NFC_Tag_M24LR6E
+ *
+ * Copyright (c) 2014 seeed technology inc.
+ * Website    : www.seeed.cc
+ * Author     : lawliet zou
+ * Create Time: March 2014
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "m24lr64e.h"
+
+// forward declarations - these were protected methods in original C++
+// code.  Might need to expose them?
+upm_result_t m24lr64e_eeprom_read_byte(m24lr64e_context dev,
+                                       uint32_t address, uint8_t* data);
+upm_result_t m24lr64e_eeprom_read_bytes(m24lr64e_context dev,
+                                        uint32_t address,
+                                        uint8_t* data, int len);
+upm_result_t m24lr64e_eeprom_write_byte(m24lr64e_context dev,
+                                        uint32_t address, uint8_t data);
+upm_result_t m24lr64e_eeprom_write_bytes(m24lr64e_context dev,
+                                         uint32_t address,
+                                         uint8_t* data, int len);
+
+m24lr64e_context m24lr64e_init(int bus, m24lr64e_access_mode mode){
+    m24lr64e_context dev =
+      (m24lr64e_context)malloc(sizeof(struct _m24lr64e_context));
+
+    if (!dev)
+      return NULL;
+
+    dev->bus = bus;
+    dev->mode = mode;
+
+    if (dev->mode == M24LR64E_USER_MODE)
+        dev->address = M24LR64E_DEFAULT_I2C_ADDR;
+    else
+        dev->address = M24LR64E_DEFAULT_I2C_ADDR_E2;
+
+    dev->i2c = mraa_i2c_init(dev->bus);
+    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS) {
+        return NULL;
+    }
+
+    return dev;
+}
+
+void m24lr64e_close(m24lr64e_context dev){
+    mraa_i2c_stop(dev->i2c);
+    free(dev);
+}
+
+upm_result_t m24lr64e_submit_password(m24lr64e_context dev,
+                                      uint32_t password){
+    // this device actually uses two bytes to address a register
+    const int pktLen = 11;
+    uint8_t buf[pktLen];
+
+    buf[0] = 0x09;
+    buf[1] = 0x00;
+
+    buf[2] = ((password >> 24) & 0xff);
+    buf[3] = ((password >> 16) & 0xff);
+    buf[4] = ((password >> 8) & 0xff);
+    buf[5] = (password & 0xff);
+
+    buf[6] = 0x09;
+
+    // the password is written twice
+    buf[7] = ((password >> 24) & 0xff);
+    buf[8] = ((password >> 16) & 0xff);
+    buf[9] = ((password >> 8) & 0xff);
+    buf[10] = (password & 0xff);
+
+    if (mraa_i2c_write(dev->i2c, buf, pktLen) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_write_password(m24lr64e_context dev, uint32_t password){
+    const int pktLen = 11;
+    uint8_t buf[pktLen];
+
+    buf[0] = 0x09;
+    buf[1] = 0x00;
+
+    buf[2] = ((password >> 24) & 0xff);
+    buf[3] = ((password >> 16) & 0xff);
+    buf[4] = ((password >> 8) & 0xff);
+    buf[5] = (password & 0xff);
+
+    buf[6] = 0x07;
+
+    // the password is written twice
+    buf[7] = ((password >> 24) & 0xff);
+    buf[8] = ((password >> 16) & 0xff);
+    buf[9] = ((password >> 8) & 0xff);
+    buf[10] = (password & 0xff);
+
+    if(mraa_i2c_write(dev->i2c, buf, pktLen) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_sector_protect_config(m24lr64e_context dev,
+                                            uint32_t sector_number,
+                                            bool protect_enable,
+                                            sector_access_right access_right,
+                                            sector_select_password password){
+    if(!protect_enable){
+        m24lr64e_write_byte(dev, sector_number, 0x0);
+    }
+    else{
+        m24lr64e_write_byte(dev, sector_number,
+                            (protect_enable | (access_right << 1) |
+                             (password << 2)));
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_clear_sector_protect(m24lr64e_context dev){
+    uint8_t buf[64]={0x0};
+    return m24lr64e_eeprom_write_bytes(dev, 0, buf, 64);
+}
+
+upm_result_t m24lr64e_sector_write_lock_bit(m24lr64e_context dev,
+                                                uint32_t sector_number,
+                                                bool sock_enable){
+    uint32_t sector_address = M24LR64E_SECTOR_SECURITY_STATUS_BASE_ADDR
+        + (sector_number/8);
+
+    uint8_t sector_bit = sector_number % 8;
+    // byte read from the EEPROM into pre_status
+    uint8_t pre_status;
+    m24lr64e_eeprom_read_byte(dev, sector_address, &pre_status);
+
+    bool status = (pre_status >> sector_bit) & 0x01;
+    if(status != sock_enable){
+        if(status == true){
+            // Call to write byte function
+            m24lr64e_write_byte(dev, sector_address, pre_status&(~(1<<sector_bit)));
+        }
+        else{
+            // another call to write byte function
+            m24lr64e_write_byte(dev, sector_address, pre_status|(1<<sector_bit));
+        }
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_get_dsfid(m24lr64e_context dev, uint8_t* dsfid){
+    // EEPROM read byte function call
+    return m24lr64e_eeprom_read_byte(dev, M24LR64E_DSFID_ADDRESS, dsfid);
+}
+
+upm_result_t m24lr64e_get_afi(m24lr64e_context dev, uint8_t* afi){
+    // call to EEPROM read byte
+    return m24lr64e_eeprom_read_byte(dev, M24LR64E_AFI_ADDRESS, afi);
+}
+
+upm_result_t m24lr64e_get_uid(m24lr64e_context dev, uint8_t* uid){
+    //uint8_t* buffer;
+    //uint8_t arr[M24LR64E_UID_LENGTH];
+    //buffer = arr;
+    // call to EEPROM read bytes
+    m24lr64e_eeprom_read_bytes(dev, M24LR64E_UID_ADDRESS, uid,
+                               M24LR64E_UID_LENGTH);
+    // not so sure about this
+//#warning "THIS NEEDS FIXING"
+    //*uid = *buffer;
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_get_memory_size(m24lr64e_context dev,
+                                      uint32_t* memory_size){
+    uint32_t volume = 0x0;
+    uint8_t temp_vol = 0x0;
+    // us the EEPROM read byte function to calculate the volume
+    if (m24lr64e_eeprom_read_byte(dev, M24LR64E_MEM_SIZE_ADDRESS,
+                                 &temp_vol) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    volume = temp_vol;
+    if (m24lr64e_eeprom_read_byte(dev, M24LR64E_MEM_SIZE_ADDRESS+1,
+                                  &temp_vol) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    volume = volume<<8|temp_vol;
+    temp_vol = 0x0;
+    if (m24lr64e_eeprom_read_byte(dev, M24LR64E_MEM_SIZE_ADDRESS+2,
+                                  &temp_vol) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    volume = volume << 8 | temp_vol;
+    *memory_size = volume;
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_clear_memory(m24lr64e_context dev){
+    int i=0;
+    for(i = 0; i < M24LR64E_EEPROM_I2C_LENGTH; i++){
+        // call to write byte function
+        m24lr64e_write_byte(dev, i, 0x0);
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_write_byte(m24lr64e_context dev, uint32_t address,
+                                 uint8_t data){
+    // call to EEPROM write byte
+    return m24lr64e_eeprom_write_byte(dev, address, data);
+}
+
+upm_result_t m24lr64e_write_bytes(m24lr64e_context dev,
+                                  uint32_t address, uint8_t* buffer, int len){
+    // call to EEPROM write bytes
+    return m24lr64e_eeprom_write_bytes(dev, address, buffer, len);
+}
+
+upm_result_t m24lr64e_read_byte(m24lr64e_context dev, uint32_t address,
+                                uint8_t* data){
+    // call to EEPROM read byte
+    return m24lr64e_eeprom_read_byte(dev, address, data);
+}
+
+upm_result_t m24lr64e_read_bytes(m24lr64e_context dev, uint32_t address,
+                                 uint8_t* buffer, int len){
+    // call to EEPROM read bytes
+    return m24lr64e_eeprom_write_bytes(dev, address, buffer, len);
+}
+
+upm_result_t m24lr64e_eeprom_write_byte(m24lr64e_context dev, uint32_t address,
+                                        uint8_t data){
+    int pkt_len = 3;
+    uint8_t buf[pkt_len];
+    buf[0] = ((address >> 8) & 0xff);
+    buf[1] = (address & 0xff);
+    buf[2] = data;
+
+    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    upm_delay_us(M24LR64E_I2C_WRITE_TIME*1000);
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_eeprom_write_bytes(m24lr64e_context dev,
+                                         uint32_t address, uint8_t* data,
+                                         int len){
+    uint32_t pkt_len = 2 + len;
+    uint8_t buf[pkt_len];
+
+    buf[0] = ((address >> 8) & 0xff);
+    buf[1] = (address & 0xff);
+
+    int i = 0;
+    for (i=0; i<len; i++)
+        buf[2+i] = data[i];
+
+    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    upm_delay_us(M24LR64E_I2C_WRITE_TIME*1000);
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_eeprom_read_byte(m24lr64e_context dev, uint32_t address,
+                                       uint8_t* data){
+    uint32_t pkt_len = 2;
+    uint8_t buf[pkt_len];
+
+    buf[0] = ((address >> 8) & 0xff);
+    buf[1] = (address & 0xff);
+
+    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    pkt_len = 1;
+    uint8_t abuf[pkt_len];
+    abuf[0] = 0;
+
+    if (mraa_i2c_read(dev->i2c, abuf, pkt_len) != pkt_len){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    *data = abuf[0];
+    return UPM_SUCCESS;
+}
+
+upm_result_t m24lr64e_eeprom_read_bytes(m24lr64e_context dev, uint32_t address,
+                                        uint8_t* data, int len){
+    uint32_t pkt_len = 2;
+    uint8_t buf[pkt_len];
+
+    buf[0] = ((address >> 8) & 0xff);
+    buf[1] = (address & 0xff);
+
+    if (mraa_i2c_write(dev->i2c, buf, pkt_len) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if(mraa_i2c_read(dev->i2c, data, len) != len){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/m24lr64e/m24lr64e.h b/ext/lib/upm/src/m24lr64e/m24lr64e.h
new file mode 100644
index 0000000..f28bad4
--- /dev/null
+++ b/ext/lib/upm/src/m24lr64e/m24lr64e.h
@@ -0,0 +1,300 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ *
+ * This code was adapted from the Seeed Studio code at:
+ * https://github.com/Seeed-Studio/NFC_Tag_M24LR6E
+ *
+ * Copyright (c) 2014 seeed technology inc.
+ * Website    : www.seeed.cc
+ * Author     : lawliet zou
+ * Create Time: March 2014
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef M24LR64E_H_
+#define M24LR64E_H_
+
+#include "upm.h"
+#include "mraa/i2c.h"
+
+#define M24LR64E_I2C_BUS 0
+#define M24LR64E_DEFAULT_I2C_ADDR 0x53
+#define M24LR64E_DEFAULT_I2C_ADDR_E2 (M24LR64E_DEFAULT_I2C_ADDR | 0x04)
+
+#define M24LR64E_EEPROM_I2C_LENGTH 8192
+#define M24LR64E_PASSWORD_LENGTH 4
+#define M24LR64E_SECTOR_SECURITY_STATUS_BASE_ADDR 0x800
+#define M24LR64E_LOCK_PROTECT_BIT 0x01
+#define M24LR64E_WRITE_READ_PROTECT_BIT 0x02
+#define M24LR64E_PASSWORD_CTRL_BIT 0x04
+
+#define M24LR64E_UID_LENGTH 8
+#define M24LR64E_I2C_WRITE_TIME 5
+
+/**
+ * @brief Grove NFC Tag
+ * @defgroup m24lr64e libupm-m24lr64e
+ * @ingroup seeed i2c other
+ */
+
+/**
+ * @library m24lr64e
+ * @sensor m24lr64e
+ * @comname Grove NFC Tag
+ * @type other
+ * @man seeed
+ * @web http://www.seeedstudio.com/wiki/Grove_-_NFC_Tag
+ * @con i2c
+ *
+ * @brief C++ API for the M24LR64E-based Grove NFC Tag
+ *
+ * Grove NFC tag is an 8KB electrically erasable programmable read-only memory (EEPROM)
+ * that can be written to or read from using I2C and NFC-equipped devices.
+ *
+ * The user mode (default) allows read and write access to all 8KB
+ * of space, provided the sector security status (SSS) allows it.
+ * The root mode allows modification of the SSS data and other
+ * information, provided the proper password is submitted.  The
+ * default password for a new tag is 0x00000000. See the datasheet
+ * for more details.
+ *
+ * The Seeed Studio* wiki page for this device includes a link to an
+ * Android* application that can be used to also read and write the
+ * device via NFC, as well as set NFC passwords, which cannot be
+ * done via I2C.
+ *
+ * @image html m24lr64e.jpg
+ * @snippet m24lr64e.cxx Interesting
+ */
+
+#include <stdint.h>
+
+typedef enum {
+    M24LR64E_I2C_PASSWORD_ADDRESS                  = 2304,
+    M24LR64E_RF_PASSWORD_1_ADDRESS                 = 2308, // RF pwds not available in
+    M24LR64E_RF_PASSWORD_2_ADDRESS                 = 2312, // I2C access modes
+    M24LR64E_RF_PASSWORD_3_ADDRESS                 = 2316,
+    M24LR64E_DSFID_ADDRESS                         = 2320, // 1 byte
+    M24LR64E_AFI_ADDRESS                           = 2321, // 1 byte
+    M24LR64E_RESV_ADDRESS                          = 2322, // 1 bytes
+    M24LR64E_CONFIG_ADDRESS                        = 2323, // 1 bytes
+    M24LR64E_UID_ADDRESS                           = 2324, // 8 bytes
+    M24LR64E_MEM_SIZE_ADDRESS                      = 2332, // 3 bytes
+    M24LR64E_IC_REF_ADDRESS                        = 2335, // 1 byte
+    M24LR64E_PROG_COMP_ENERGY_HARVEST_ADDRESS      = 2339  // 1 byte
+} M24LR64E_ADDR_T;
+
+typedef enum {
+    M24LR64E_USER_MODE = 0x0,   // offers simple read/write access right
+    M24LR64E_ROOT_MODE = 0x1    // offers password change access right
+} m24lr64e_access_mode;
+
+typedef enum {
+    //      **********************************
+    //      *  submit passWd *   no submit   *
+    //b2,b1 *  Read * Write  *  Read * Write *
+    // 00   *    1       1        1      0   *
+    // 01   *    1       1        1      1   *
+    // 10   *    1       1        0      0   *
+    // 11   *    0       1        0      0   *
+    //      **********************************
+    m24lr64e_access_1110 = 0,
+    m24lr64e_access_1111 = 1,
+    m24lr64e_access_1100 = 2,
+    m24lr64e_access_0111 = 3,
+} sector_access_right;
+
+typedef enum {
+    //00 => no passwd protect
+    //01 => passWd 1
+    //10 => passWd 2
+    //11 => passwd 3
+    m24lr64e_no_password = 0,
+    m24lr64e_password_1 = 1,
+    m24lr64e_password_2 = 2,
+    m24lr64e_password_3 = 3,
+} sector_select_password;
+
+/*
+ * device context
+ */
+typedef struct _m24lr64e_context {
+    mraa_i2c_context            i2c;
+    uint8_t                     bus;
+    uint8_t                     address;
+    m24lr64e_access_mode    mode;
+} *m24lr64e_context;
+
+/**
+ * M24LR64E Init function
+ *
+ * @param bus I2C bus to use
+ * @param mode Access mode (user or root) to use
+ */
+m24lr64e_context m24lr64e_init(int bus, m24lr64e_access_mode mode);
+
+/**
+ * M24LR64E close function
+ *
+ * @param dev void pointer to sensor struct
+ */
+void m24lr64e_close(m24lr64e_context dev);
+
+/**
+ * Submits an I2C access password
+ *
+ * @param dev void pointer to sensor struct
+ * @param passwd 4-byte access password
+ */
+upm_result_t m24lr64e_submit_password(m24lr64e_context dev, uint32_t password);
+
+/**
+ * Writes a new I2C password
+ *
+ * @param dev void pointer to sensor struct
+ * @param passwd 4-byte access password
+ */
+upm_result_t m24lr64e_write_password(m24lr64e_context dev, uint32_t password);
+
+/**
+ * Sets a protection bit for a sector. Must be in the root mode
+ *
+ * @param dev void pointer to sensor struct
+ * @param sectorNumber Sector whose protection you are modifying
+ * @param protectEnable True if you are enabling protection
+ * @param accessRight Access rights to set
+ * @param passwd Password number to enable, if any
+ */
+upm_result_t m24lr64e_sector_protect_config(m24lr64e_context dev,
+                                            uint32_t sector_number,
+                                            bool protect_enable,
+                                            sector_access_right access_right,
+                                            sector_select_password password);
+
+/**
+ * Clears sector protection bits. Must be in the root mode.
+ *
+ * @param dev void pointer to sensor struct
+ */
+upm_result_t m24lr64e_clear_sector_protect(m24lr64e_context dev);
+
+/**
+ * Sets or clears a sector security status lock bit for a sector.
+ * Must be in the root mode.
+ *
+ * @param dev void pointer to sensor struct
+ * @param sectorNumber Sector whose SSS you want to modify
+ * @param sockEnable True to set the bit, false to clear it
+ */
+upm_result_t m24lr64e_sector_write_lock_bit(m24lr64e_context dev,
+                                            uint32_t sector_number,
+                                            bool sock_enable);
+
+/**
+ * Returns a data storage family identifier (DSFID)
+ * Must be in the root mode.
+ *
+ * @param dev void pointer to sensor struct
+ * @param dsfid pointer to hold return value
+ */
+upm_result_t m24lr64e_get_dsfid(m24lr64e_context dev, uint8_t* dsfid);
+
+/**
+ * Returns an application family identifier (AFI)
+ * Must be in the root mode.
+ *
+ * @param dev void pointer to sensor struct
+ * @param afi pointer to hold return value
+ */
+upm_result_t m24lr64e_get_afi(m24lr64e_context dev, uint8_t* afi);
+
+/**
+ * Returns a unique ID.
+ * Must be in the root mode.
+ * Maintained to preserve compatibility with older code.
+ *
+ * @param dev void pointer to sensor struct
+ * @param uid pointer to hold return value
+ */
+upm_result_t m24lr64e_get_uid(m24lr64e_context dev, uint8_t* uid);
+
+/**
+ * Returns the memory size
+ * Must be in the root mode.
+ *
+ * @param dev void pointer to sensor struct
+ * @param memory_size pointer to hold return value
+ */
+upm_result_t m24lr64e_get_memory_size(m24lr64e_context dev, uint32_t* memory_size);
+
+/**
+ * Sets all memory to 0, if permissions allow
+ *
+ * @param dev void pointer to sensor struct
+ */
+upm_result_t m24lr64e_clear_memory(m24lr64e_context dev);
+
+/**
+ * Writes a byte to the EEPROM
+ *
+ * @param dev void pointer to sensor struct
+ * @param address Address to write to
+ * @param data Data to write
+ */
+upm_result_t m24lr64e_write_byte(m24lr64e_context dev, uint32_t address,
+                                 uint8_t data);
+
+/**
+ * Writes bytes to the EEPROM
+ *
+ * @param dev void pointer to sensor struct
+ * @param address Address to write to
+ * @param data Data to write
+ * @param data Length of the data buffer
+ */
+upm_result_t m24lr64e_write_bytes(m24lr64e_context dev, uint32_t address,
+                                  uint8_t* buffer, int len);
+
+/**
+ * Reads a byte from the EEPROM
+ *
+ * @param dev void pointer to sensor struct
+ * @param address Address to read from
+ * @param data holds return value
+ */
+upm_result_t m24lr64e_read_byte(m24lr64e_context dev, uint32_t address,
+                                uint8_t* data);
+
+/**
+ * Reads multiple bytes from the EEPROM
+ *
+ * @param dev void pointer to sensor struct
+ * @param address Address to read from
+ * @param buffer Buffer to store data
+ * @param len Number of bytes to read
+ */
+upm_result_t m24lr64e_read_bytes(m24lr64e_context dev, uint32_t address,
+                                 uint8_t* buffer, int len);
+
+#endif /* M24LR64E_H_ */
diff --git a/ext/lib/upm/src/mb704x/Kbuild b/ext/lib/upm/src/mb704x/Kbuild
new file mode 100644
index 0000000..749a5bc
--- /dev/null
+++ b/ext/lib/upm/src/mb704x/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_mb704x) += mb704x.o
diff --git a/ext/lib/upm/src/mb704x/Kconfig b/ext/lib/upm/src/mb704x/Kconfig
new file mode 100644
index 0000000..96fd34c
--- /dev/null
+++ b/ext/lib/upm/src/mb704x/Kconfig
@@ -0,0 +1,8 @@
+config UPM_mb704x
+    bool "mb704x"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm MB704X MaxSonar-WR Ultrasonic Ranger
diff --git a/ext/lib/upm/src/mb704x/Makefile b/ext/lib/upm/src/mb704x/Makefile
new file mode 100644
index 0000000..d17cf21
--- /dev/null
+++ b/ext/lib/upm/src/mb704x/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_mb704x
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/mb704x
+endif
diff --git a/ext/lib/upm/src/mb704x/mb704x.c b/ext/lib/upm/src/mb704x/mb704x.c
new file mode 100644
index 0000000..085d4ee
--- /dev/null
+++ b/ext/lib/upm/src/mb704x/mb704x.c
@@ -0,0 +1,115 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include <upm_utilities.h>
+
+#include "mb704x.h"
+
+// The delay to wait (in ms) for a ranging command to complete before
+// requesting the range data.
+#define MB704X_RANGE_DELAY     (100)
+
+// range command
+#define MB704X_CMD_RANGE       (81)
+
+mb704x_context mb704x_init(unsigned int bus, int addr)
+{
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        return NULL;
+    }
+
+    mb704x_context dev =
+        (mb704x_context)malloc(sizeof(struct _mb704x_context));
+
+    if (!dev)
+        return NULL;
+
+    // zero out context
+    memset((void *)dev, 0, sizeof(struct _mb704x_context));
+
+    // initialize the MRAA contexts
+
+    if (!(dev->i2c = mraa_i2c_init(bus)))
+    {
+        printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
+        mb704x_close(dev);
+        return NULL;
+    }
+
+    if (mraa_i2c_address(dev->i2c, (uint8_t)addr))
+    {
+        printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
+        mb704x_close(dev);
+        return NULL;
+    }
+
+    // max power up delay
+    upm_delay_ms(135);
+
+    return dev;
+}
+
+void mb704x_close(mb704x_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->i2c)
+        mraa_i2c_stop(dev->i2c);
+
+    free(dev);
+}
+
+int mb704x_get_range(const mb704x_context dev)
+{
+    assert(dev != NULL);
+
+    // first, send the range command.
+    uint8_t cmd = MB704X_CMD_RANGE;
+    if (mraa_i2c_write(dev->i2c, &cmd, 1))
+    {
+        printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
+        return -1;
+    }
+
+    // delay for measurement
+    upm_delay_ms(MB704X_RANGE_DELAY);
+
+    // At this point, we should be able to do our read of the data
+    uint8_t buffer[2];
+    if (mraa_i2c_read(dev->i2c, buffer, 2) != 2)
+    {
+        printf("%s: mraa_i2c_read() failed.\n", __FUNCTION__);
+        return -1;
+    }
+
+    return ((buffer[0] << 8) | buffer[1]);
+}
diff --git a/ext/lib/upm/src/mb704x/mb704x.h b/ext/lib/upm/src/mb704x/mb704x.h
new file mode 100644
index 0000000..5b98d30
--- /dev/null
+++ b/ext/lib/upm/src/mb704x/mb704x.h
@@ -0,0 +1,78 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include <upm.h>
+#include <mraa/i2c.h>
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file mb704x.h
+     * @library mb704x
+     * @brief C API for the MB704x MaxSonar-WR Ultrasonic Ranger
+     *
+     * @include mb704x.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _mb704x_context {
+        mraa_i2c_context         i2c;
+    } *mb704x_context;
+
+    /**
+     * MB704X Initializer
+     *
+     * @param bus Specify which the I2C bus to use.
+     * @param addr Specify the I2C address to use.  The default is 112.
+     * @return an initialized device context on success, NULL on error.
+     */
+    mb704x_context mb704x_init(unsigned int bus, int addr);
+
+    /**
+     * MB704X sensor close function
+     */
+    void mb704x_close(mb704x_context dev);
+
+    /**
+     * Query the device for a range reading.  The range will be
+     * reported in centimeters (cm).
+     *
+     * @param dev Device context
+     * @return Measured range, -1 on error. The range is reported in
+     * centimeters (cm).
+     */
+    int mb704x_get_range(const mb704x_context dev);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/md/Kbuild b/ext/lib/upm/src/md/Kbuild
new file mode 100644
index 0000000..22a4d2e
--- /dev/null
+++ b/ext/lib/upm/src/md/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_md) += md.o
diff --git a/ext/lib/upm/src/md/Kconfig b/ext/lib/upm/src/md/Kconfig
new file mode 100644
index 0000000..d3f741a
--- /dev/null
+++ b/ext/lib/upm/src/md/Kconfig
@@ -0,0 +1,8 @@
+config UPM_md
+    bool "md"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM driver for Grove Motor Driver (MD)
diff --git a/ext/lib/upm/src/md/Makefile b/ext/lib/upm/src/md/Makefile
new file mode 100644
index 0000000..ae2d832
--- /dev/null
+++ b/ext/lib/upm/src/md/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_md
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/md
+endif
diff --git a/ext/lib/upm/src/md/md.c b/ext/lib/upm/src/md/md.c
new file mode 100644
index 0000000..21b8580
--- /dev/null
+++ b/ext/lib/upm/src/md/md.c
@@ -0,0 +1,265 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+
+#include <upm_utilities.h>
+
+#include "md.h"
+
+// static (private) functions
+static void md_stepper_step(const md_context dev)
+{
+    assert(dev != NULL);
+
+    int step = dev->currentStep % 4;
+
+    switch (step)
+    {
+    case 0:
+        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b0101, MD_NOOP);
+        break;
+    case 1:
+        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b0110, MD_NOOP);
+        break;
+    case 2:
+        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b1010, MD_NOOP);
+        break;
+    case 3:
+        md_write_packet(dev, MD_REG_SET_DIRECTION, 0b1001, MD_NOOP);
+        break;
+    default:
+        // can't happen in this universe
+        break;
+    }
+}
+
+md_context md_init(int bus, uint8_t address)
+{
+    md_context dev =
+        (md_context)malloc(sizeof(struct _md_context));
+
+    if (!dev)
+        return NULL;
+
+    memset((void *)dev, 0, sizeof(struct _md_context));
+    dev->i2c = NULL;
+    dev->initialized = false;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        md_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->i2c = mraa_i2c_init(bus)) )
+    {
+        printf("%s: mraa_gpio_init() failed\n",
+               __FUNCTION__);
+        md_close(dev);
+        return NULL;
+    }
+
+    // this board *requires* 100Khz i2c bus only
+    if (mraa_i2c_frequency(dev->i2c, MRAA_I2C_STD))
+    {
+        printf("%s: mraa_i2c_frequency(MRAA_I2C_STD) failed\n", __FUNCTION__);
+        md_close(dev);
+        return NULL;
+    }
+
+    if (mraa_i2c_address(dev->i2c, address))
+    {
+        printf("%s: mraa_i2c_frequency(MRAA_I2C_STD) failed\n", __FUNCTION__);
+        md_close(dev);
+        return NULL;
+    }
+
+    // default to mode1 stepper operation, 200 steps per rev.
+    md_config_stepper(dev, 200, MD_STEP_MODE1);
+
+    dev->initialized = true;
+
+    return dev;
+}
+
+void md_close(md_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->initialized)
+    {
+        md_set_motor_speeds(dev, 0, 0);
+        md_write_packet(dev, MD_REG_SET_DIRECTION, 0, MD_NOOP);
+    }
+
+    if (dev->i2c)
+        mraa_i2c_stop(dev->i2c);
+
+    free(dev);
+}
+
+bool md_write_packet(const md_context dev, MD_REG_T reg,
+                     uint8_t data1, uint8_t data2)
+{
+    assert(dev != NULL);
+
+    uint8_t buf[3];
+
+    buf[0] = reg;
+    buf[1] = data1;
+    buf[2] = data2;
+
+    if (mraa_i2c_write(dev->i2c, buf, 3))
+    {
+        printf("%s: mraa_i2c_write() failed\n", __FUNCTION__);
+        return false;
+    }
+
+    // This sleep appears to be required.  Without it, writes randomly
+    // fail (no ACK received).  This happens most often on the SET_SPEED
+    // packet.  I am guessing that there is a timing problem and/or bug
+    // in the motor driver's firmware.
+
+    upm_delay_us(100);
+
+    return true;
+}
+
+bool md_set_motor_speeds(const md_context dev, uint8_t speedA, uint8_t speedB)
+{
+    assert(dev != NULL);
+
+    return md_write_packet(dev, MD_REG_SET_SPEED, speedA, speedB);
+}
+
+bool md_set_pwm_frequency_prescale(const md_context dev, uint8_t freq)
+{
+    assert(dev != NULL);
+
+    return md_write_packet(dev, MD_REG_SET_PWM_FREQ, freq, MD_NOOP);
+}
+
+bool md_set_motor_directions(const md_context dev, MD_DC_DIRECTION_T dirA,
+                             MD_DC_DIRECTION_T dirB)
+{
+    assert(dev != NULL);
+
+    uint8_t dir = ((dirB & 0x03) << 2) | (dirA & 0x03);
+    return md_write_packet(dev, MD_REG_SET_DIRECTION, dir, MD_NOOP);
+}
+
+bool md_enable_stepper(const md_context dev, MD_STEP_DIRECTION_T dir,
+                       uint8_t speed)
+{
+    assert(dev != NULL);
+
+    // If mode 2, send the command and return immediately
+    if (dev->stepMode == MD_STEP_MODE2)
+        return md_write_packet(dev, MD_REG_STEPPER_ENABLE, dir, speed);
+
+    // otherwise, mode 1, setup the basics and start stepping.
+
+    dev->stepDelay = 60 * 1000 / dev->stepsPerRev / speed;
+    dev->stepDirection = ((dir == MD_STEP_DIR_CW) ? 1 : -1);
+
+    // seeed says speed should always be 255,255 for stepper operation
+    md_set_motor_speeds(dev, 255, 255);
+
+    while (dev->totalSteps > 0)
+    {
+        upm_delay_ms(dev->stepDelay);
+
+        dev->currentStep += dev->stepDirection;
+
+        if (dev->stepDirection == 1)
+        {
+            if (dev->currentStep >= dev->stepsPerRev)
+                dev->currentStep = 0;
+        }
+        else
+        {
+            if (dev->currentStep <= 0)
+                dev->currentStep = dev->stepsPerRev;
+        }
+
+        dev->totalSteps--;
+        md_stepper_step(dev);
+    }
+
+    // and... we're done
+    return true;
+}
+
+bool md_disable_stepper(const md_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->stepMode == MD_STEP_MODE2)
+        return md_write_packet(dev, MD_REG_STEPPER_DISABLE, MD_NOOP, MD_NOOP);
+
+    // else, mode 1
+    md_write_packet(dev, MD_REG_SET_DIRECTION, 0, MD_NOOP);
+    return md_set_motor_speeds(dev, 0, 0);
+}
+
+bool md_set_stepper_steps(const md_context dev, unsigned int steps)
+{
+    assert(dev != NULL);
+
+    if (dev->stepMode == MD_STEP_MODE2)
+    {
+        if (steps == 0)
+        {
+            // invalid
+            printf("%s: invalid number of steps. "
+                   "Valid values are between 1 and 255. \n", __FUNCTION__);
+            return false;
+        }
+        return md_write_packet(dev, MD_REG_STEPPER_NUM_STEPS, steps, MD_NOOP);
+    }
+
+    // for mode one, just store it for future use by enableStepper()
+    dev->totalSteps = steps;
+    return true;
+}
+
+void md_config_stepper(const md_context dev, unsigned int stepsPerRev,
+                       MD_STEP_MODE_T mode)
+{
+    assert(dev != NULL);
+
+    dev->stepsPerRev = stepsPerRev;
+    dev->stepMode = mode;
+    dev->currentStep = 0;
+    dev->stepDelay = 0;
+    dev->stepDirection = 1;
+    dev->totalSteps = 0;
+}
diff --git a/ext/lib/upm/src/md/md.h b/ext/lib/upm/src/md/md.h
new file mode 100644
index 0000000..0c4790c
--- /dev/null
+++ b/ext/lib/upm/src/md/md.h
@@ -0,0 +1,220 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <upm.h>
+#include <mraa/i2c.h>
+
+#define MD_I2C_BUS 0
+#define MD_DEFAULT_I2C_ADDR 0x0f
+
+// This is a NOOP value used to pad packets
+#define MD_NOOP 0x01
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file md.h
+     * @library md
+     * @brief C API for the md driver
+     *
+     * @include md.c
+     */
+
+    // MD registers
+    typedef enum {
+        MD_REG_SET_SPEED           = 0x82,
+        MD_REG_SET_PWM_FREQ        = 0x84,
+        MD_REG_SET_DIRECTION       = 0xaa,
+        MD_REG_SET_MOTOR_A         = 0xa1, // not documented
+        MD_REG_SET_MOTOR_B         = 0xa5, // not documented
+        MD_REG_STEPPER_ENABLE      = 0x1a,
+        MD_REG_STEPPER_DISABLE     = 0x1b,
+        MD_REG_STEPPER_NUM_STEPS   = 0x1c
+    } MD_REG_T;
+
+    // legal directions for the stepper
+    typedef enum {
+        MD_STEP_DIR_CCW    = 0x01,
+        MD_STEP_DIR_CW     = 0x00
+    } MD_STEP_DIRECTION_T;
+
+    // legal directions for individual DC motors
+    typedef enum {
+        MD_DIR_CCW    = 0x02,
+        MD_DIR_CW     = 0x01
+    } MD_DC_DIRECTION_T;
+
+    // stepper modes
+    typedef enum {
+        MD_STEP_MODE1 = 0x00,
+        MD_STEP_MODE2 = 0x01
+    } MD_STEP_MODE_T;
+
+    /**
+     * Device context
+     */
+    typedef struct _md_context {
+        mraa_i2c_context i2c;
+
+        // steps per revolution
+        int stepsPerRev;
+        int currentStep;
+        uint32_t stepDelay;
+        uint32_t totalSteps;
+        MD_STEP_MODE_T stepMode;
+
+        // step direction: - 1 = forward, -1 = backward
+        int stepDirection;
+
+        // initialized?
+        bool initialized;
+
+    } *md_context;
+
+    /**
+     * MD initializer.
+     *
+     * @param bus I2C bus to use
+     * @param address I2C address to use
+     * @return Device context.
+     */
+    md_context md_init(int bus, uint8_t address);
+
+    /**
+     * MD close.
+     *
+     * @param dev Device context.
+     */
+    void md_close(md_context dev);
+
+    /**
+     * Composes and writes a 3-byte packet to the controller
+     *
+     * @param dev Device context.
+     * @param reg Register location
+     * @param data1 First byte of data
+     * @param data2 Second byte of data
+     * @return True if successful
+     */
+    bool md_write_packet(const md_context dev, MD_REG_T reg, uint8_t data1,
+                         uint8_t data2);
+
+    /**
+     * To control DC motors, sets the speed of motors A & B.
+     * Valid values are 0-255.
+     *
+     * @param dev Device context.
+     * @param speedA Speed of motor A
+     * @param speedB Speed of motor B
+     * @return True if successful
+     */
+    bool md_set_motor_speeds(const md_context dev, uint8_t speedA,
+                             uint8_t speedB);
+
+    /**
+     * To control DC motors, sets the PWM frequency prescale
+     * factor. Note: this register is not ducumented other than to say
+     * the default value is 0x03. Presumably, this is the timer
+     * prescale factor used on the ATMega MCU timer driving the PWM.
+     *
+     * @param dev Device context.
+     * @param freq PWM prescale frequency; default should be 0x03
+     * @return True if successful
+     */
+    bool md_set_pwm_frequency_prescale(const md_context dev, uint8_t freq);
+
+    /**
+     * To control DC motors, sets the directions of motors A & B
+     *
+     * @param dev Device context.
+     * @param dirA Direction for motor A, MD_DIR_CW or MD_DIR_CCW
+     * @param dirB Direction for motor B, MD_DIR_CW or MD_DIR_CCW
+     * @return True if successful
+     */
+    bool md_set_motor_directions(const md_context dev, MD_DC_DIRECTION_T dirA,
+                                 MD_DC_DIRECTION_T dirB);
+
+    /**
+     * To control a stepper motor, sets its direction and speed, and
+     * then starts operation.  For Mode2, this method will return
+     * immediately.  For Mode1 (the default) this method returns when
+     * the number of steps specified by md_set_stepper_steps() has
+     * completed.
+     *
+     * @param dev Device context.
+     * @param dir Direction, MD_STEP_DIR_CW or MD_STEP_DIR_CCW
+     * @param speed Motor speed. Valid range is 1-255. For Mode 1
+     * (default), this specifies the speed in RPM's.  For Mode 2,
+     * speed is multiplied by 4ms by the board, so higher numbers
+     * will mean a slower speed.
+     * @return True if successful
+     */
+    bool md_enable_stepper(const md_context dev, MD_STEP_DIRECTION_T dir,
+                           uint8_t speed);
+
+    /**
+     * To control a stepper motor, stops the stepper motor.
+     *
+     * @param dev Device context.
+     * @return True if successful
+     */
+    bool md_disable_stepper(const md_context dev);
+
+    /**
+     * To control a stepper motor, specifies the number of steps to
+     * execute. For Mode2, valid values are between 1-255, 255 means
+     * continuous rotation.
+     *
+     * For Mode1 (the default) steps can be any positive integer.
+     *
+     * @param dev Device context.
+     * @param steps Number of steps to execute. 255 (only in Mode2)
+     * means continuous rotation.
+     * @return True if successful
+     */
+    bool md_set_stepper_steps(const md_context dev, unsigned int steps);
+
+    /**
+     * Configure the initial Stepper parameters.  This should be
+     * called before any other stepper method.
+     *
+     * @param dev Device context.
+     * @param stepsPerRev The number of steps required to complete one
+     * full revolution.
+     * @param mode The stepper operating mode.  MD_STEP_MODE1 is more
+     * flexible, and is handled directly by this driver.
+     * MD_STEP_MODE2 is handled completely by the MCU on board the
+     * motor driver, but is much more restrictive and requires updated
+     * firmware.  We generally recommend MODE1.
+     */
+    void md_config_stepper(const md_context dev, unsigned int stepsPerRev,
+                           MD_STEP_MODE_T mode);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/mic/Kbuild b/ext/lib/upm/src/mic/Kbuild
new file mode 100644
index 0000000..791b3ed
--- /dev/null
+++ b/ext/lib/upm/src/mic/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_mic) += mic.o
diff --git a/ext/lib/upm/src/mic/Kconfig b/ext/lib/upm/src/mic/Kconfig
new file mode 100644
index 0000000..8be8e67
--- /dev/null
+++ b/ext/lib/upm/src/mic/Kconfig
@@ -0,0 +1,9 @@
+config UPM_mic
+    bool "mic"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        Simple Microphone API
+
diff --git a/ext/lib/upm/src/mic/Makefile b/ext/lib/upm/src/mic/Makefile
new file mode 100644
index 0000000..b9cc07b
--- /dev/null
+++ b/ext/lib/upm/src/mic/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_mic
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/mic
+endif
diff --git a/ext/lib/upm/src/mic/mic.c b/ext/lib/upm/src/mic/mic.c
new file mode 100644
index 0000000..7a6c6c5
--- /dev/null
+++ b/ext/lib/upm/src/mic/mic.c
@@ -0,0 +1,58 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ * 	   
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "mic.h"
+
+mic_context mic_init(int pin)
+{
+    mic_context dev = (mic_context)malloc(sizeof(struct _mic_context));
+
+    if(dev == NULL) return NULL;
+
+    dev->analog_pin = pin;
+    dev->aio = mraa_aio_init(dev->analog_pin);
+
+    if(dev->aio == NULL)
+    {
+        printf("unable to initialize the AIO pin");
+        free(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void mic_close(mic_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t mic_get_value(mic_context dev, float *micval)
+{
+    *micval =  mraa_aio_read(dev->aio);
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/mic/mic.h b/ext/lib/upm/src/mic/mic.h
new file mode 100644
index 0000000..22fd5dd
--- /dev/null
+++ b/ext/lib/upm/src/mic/mic.h
@@ -0,0 +1,51 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef MIC_H_
+#define MIC_H_
+
+#pragma once
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+/**
+ * device context
+ */
+typedef struct _mic_context {
+    mraa_aio_context aio;
+    uint16_t analog_pin;
+} *mic_context;
+
+mic_context mic_init(int pin);
+
+void mic_close(mic_context dev);
+
+upm_result_t mic_get_value(mic_context dev, float* micval);
+
+#endif /* MIC_H_ */
diff --git a/ext/lib/upm/src/mma7361/Kbuild b/ext/lib/upm/src/mma7361/Kbuild
new file mode 100644
index 0000000..2ed1d8f
--- /dev/null
+++ b/ext/lib/upm/src/mma7361/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_mma7361) += mma7361.o
diff --git a/ext/lib/upm/src/mma7361/Kconfig b/ext/lib/upm/src/mma7361/Kconfig
new file mode 100644
index 0000000..f6c7b78
--- /dev/null
+++ b/ext/lib/upm/src/mma7361/Kconfig
@@ -0,0 +1,9 @@
+config UPM_mma7361
+    bool "mma7361"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm dfrobot MMA7361 analog accelerometer
+
diff --git a/ext/lib/upm/src/mma7361/Makefile b/ext/lib/upm/src/mma7361/Makefile
new file mode 100644
index 0000000..c85b57d
--- /dev/null
+++ b/ext/lib/upm/src/mma7361/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_mma7361
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/mma7361
+endif
diff --git a/ext/lib/upm/src/mma7361/mma7361.c b/ext/lib/upm/src/mma7361/mma7361.c
new file mode 100644
index 0000000..1549b2f
--- /dev/null
+++ b/ext/lib/upm/src/mma7361/mma7361.c
@@ -0,0 +1,395 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+#include <stdlib.h>
+
+#include "mma7361.h"
+
+#include "upm_utilities.h"
+
+// arduino map() function in macro form (Public Domain)
+#define MAP(_value, _in_min, _in_max, _out_min, _out_max) \
+  ( ((_value) - (_in_min)) * ((_out_max) - (_out_min)) /  \
+    ((_in_max) - (_in_min)) + _out_min )
+
+// While the DFR board can be powered at 5.0 to 3.3v, the analog
+// outputs are always going to be 3.3v - ie: the outputs are not
+// scaled to 5v, so we need to account for that.
+// We may need to make this configurable too in the future...
+#define MMA_OUTPUT_AREF 3.3
+
+mma7361_context mma7361_init(int x_pin, int y_pin, int z_pin,
+                             int selftest_pin, int sleep_pin,
+                             int freefall_pin, int range_pin,
+                             float a_ref)
+{
+  // sanity check - at least one axis needs to be enabled, or what's
+  // the point?
+  if (x_pin < 0 && y_pin < 0 && z_pin < 0)
+    {
+      printf("%s: At least one axis must be enabled.\n", __FUNCTION__);
+      return NULL;
+    }
+
+  mma7361_context dev =
+    (mma7361_context)malloc(sizeof(struct _mma7361_context));
+
+  if (!dev)
+    return NULL;
+
+  // zero out context
+  memset((void *)dev, 0, sizeof(struct _mma7361_context));
+  
+  dev->aio_x = NULL;
+  dev->aio_y = NULL;
+  dev->aio_z = NULL;
+
+  dev->gpio_selftest = NULL;
+  dev->gpio_sleep = NULL;
+  dev->gpio_freefall = NULL;
+  dev->gpio_range = NULL;
+
+  dev->a_res = 0;
+  dev->a_ref = a_ref;
+  dev->g_range = 1.5;
+
+  dev->offset_x = dev->offset_y = dev->offset_z = 0.0;
+  dev->scale_x = dev->scale_y = dev->scale_z = 1.0;
+
+  dev->accel_x = 0.0;
+  dev->accel_y = 0.0;
+  dev->accel_z = 0.0;
+
+  dev->volts_x = 0.0;
+  dev->volts_y = 0.0;
+  dev->volts_z = 0.0;
+
+  dev->normalized_x = 0;
+  dev->normalized_y = 0;
+  dev->normalized_z = 0;
+
+  // initialize the MRAA contexts (only what we need)
+
+  // analogs
+  if (x_pin >= 0)
+    {
+      if (!(dev->aio_x = mraa_aio_init(x_pin)))
+        {
+          printf("%s: mraa_aio_init(x) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+      // set our analog resolution
+      dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio_x)) - 1;
+    }
+
+  if (y_pin >= 0)
+    {
+      if (!(dev->aio_y = mraa_aio_init(y_pin)))
+        {
+          printf("%s: mraa_aio_init(y) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+
+      // set our analog resolution if not already set
+      if (!dev->a_res)
+        dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio_y)) - 1;
+    }
+
+  if (z_pin >= 0)
+    {
+      if (!(dev->aio_z = mraa_aio_init(z_pin)))
+        {
+          printf("%s: mraa_aio_init(z) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+
+      // set our analog resolution if not already set
+      if (!dev->a_res)
+        dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio_z)) - 1;
+    }
+
+  // now the gpios
+  if (selftest_pin >= 0)
+    {
+      if (!(dev->gpio_selftest = mraa_gpio_init(selftest_pin)))
+        {
+          printf("%s: mraa_gpio_init(selftest) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_selftest, MRAA_GPIO_OUT);
+      mma7361_selftest(dev, false);
+    }
+
+  if (sleep_pin >= 0)
+    {
+      if (!(dev->gpio_sleep = mraa_gpio_init(sleep_pin)))
+        {
+          printf("%s: mraa_gpio_init(sleep) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_sleep, MRAA_GPIO_OUT);
+      mma7361_sleep(dev, false);
+    }
+
+  if (freefall_pin >= 0)
+    {
+      if (!(dev->gpio_freefall = mraa_gpio_init(freefall_pin)))
+        {
+          printf("%s: mraa_gpio_init(freefall) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_freefall, MRAA_GPIO_IN);
+    }
+
+  if (range_pin >= 0)
+    {
+      if (!(dev->gpio_range = mraa_gpio_init(range_pin)))
+        {
+          printf("%s: mraa_gpio_init(range) failed.\n", __FUNCTION__);
+          mma7361_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_range, MRAA_GPIO_OUT);
+      mma7361_set_range(dev, false);
+    }
+
+  return dev;
+}
+
+void mma7361_close(mma7361_context dev)
+{
+  assert(dev != NULL);
+
+  // analogs
+  if (dev->aio_x)
+    mraa_aio_close(dev->aio_x);
+  if (dev->aio_y)
+    mraa_aio_close(dev->aio_y);
+  if (dev->aio_z)
+    mraa_aio_close(dev->aio_z);
+
+  // gpios
+  if (dev->gpio_selftest)
+    mraa_gpio_close(dev->gpio_selftest);
+  if (dev->gpio_sleep)
+    mraa_gpio_close(dev->gpio_sleep);
+  if (dev->gpio_freefall)
+    mraa_gpio_close(dev->gpio_freefall);
+  if (dev->gpio_range)
+    mraa_gpio_close(dev->gpio_range);
+
+  free(dev);
+}
+
+upm_result_t mma7361_selftest(const mma7361_context dev, bool selftest)
+{
+  assert(dev != NULL);
+
+  if (!dev->gpio_selftest)
+    return UPM_ERROR_NO_RESOURCES;
+
+  if (selftest)
+    mraa_gpio_write(dev->gpio_selftest, 1);
+  else
+    mraa_gpio_write(dev->gpio_selftest, 0);
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t mma7361_sleep(const mma7361_context dev, bool sleep)
+{
+  assert(dev != NULL);
+
+  if (!dev->gpio_sleep)
+    return UPM_ERROR_NO_RESOURCES;
+
+  if (sleep)
+    mraa_gpio_write(dev->gpio_sleep, 0);
+  else
+    mraa_gpio_write(dev->gpio_sleep, 1);
+
+  upm_delay_ms(2);
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t mma7361_freefall(const mma7361_context dev, bool *freefall)
+{
+  assert(dev != NULL);
+
+  if (!dev->gpio_freefall)
+    return UPM_ERROR_NO_RESOURCES;
+
+  *freefall = mraa_gpio_read(dev->gpio_freefall) ? true : false;
+
+  return UPM_SUCCESS;
+}
+
+void mma7361_set_range(const mma7361_context dev, bool range)
+{
+  assert(dev != NULL);
+
+  // for this one, if there is no actual GPIO available, we will not
+  // error out, but still set the internal range.
+
+  if (range)
+    dev->g_range = 6.0;
+  else
+    dev->g_range = 1.5;
+
+  if (dev->gpio_range)
+    {
+      if (range)
+        mraa_gpio_write(dev->gpio_range, 1);
+      else
+        mraa_gpio_write(dev->gpio_range, 0);
+    }
+}
+
+void mma7361_set_offset(const mma7361_context dev, float x, float y, float z)
+{
+  assert(dev != NULL);
+
+  dev->offset_x = x;
+  dev->offset_y = y;
+  dev->offset_z = z;
+}
+
+void mma7361_set_scale(const mma7361_context dev, float x, float y, float z)
+{
+  assert(dev != NULL);
+
+  dev->scale_x = x;
+  dev->scale_y = y;
+  dev->scale_z = z;
+}
+
+upm_result_t mma7361_update(const mma7361_context dev)
+{
+  assert(dev != NULL);
+
+  float sample;
+
+  if (dev->aio_x)
+    {
+      if ((sample = (float)mraa_aio_read(dev->aio_x)) < 0.0)
+        {
+          printf("%s: mraa_aio_read(x) failed.\n", __FUNCTION__);
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      dev->normalized_x = sample / dev->a_res;
+      dev->volts_x = dev->normalized_x * dev->a_ref;
+      dev->accel_x = MAP(dev->volts_x, 0.0, MMA_OUTPUT_AREF,
+                         -dev->g_range, dev->g_range);
+    }
+
+  if (dev->aio_y)
+    {
+      if ((sample = (float)mraa_aio_read(dev->aio_y)) < 0.0)
+        {
+          printf("%s: mraa_aio_read(y) failed.\n", __FUNCTION__);
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      dev->normalized_y = sample / dev->a_res;
+      dev->volts_y = dev->normalized_y * dev->a_ref;
+      dev->accel_y = MAP(dev->volts_y, 0.0, MMA_OUTPUT_AREF,
+                         -dev->g_range, dev->g_range);
+    }
+
+  if (dev->aio_z)
+    {
+      if ((sample = (float)mraa_aio_read(dev->aio_z)) < 0.0)
+        {
+          printf("%s: mraa_aio_read(z) failed.\n", __FUNCTION__);
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      dev->normalized_z = sample / dev->a_res;
+      dev->volts_z = dev->normalized_z * dev->a_ref;
+      dev->accel_z = MAP(dev->volts_z, 0.0, MMA_OUTPUT_AREF,
+                         -dev->g_range, dev->g_range);
+    }
+
+  return UPM_SUCCESS;
+}
+
+void mma7361_get_acceleration(const mma7361_context dev,
+                              float *x, float *y, float *z)
+{
+  assert(dev != NULL);
+
+  if (x)
+    *x = dev->accel_x * dev->scale_x + (dev->offset_x * dev->scale_x);
+
+  if (y)
+    *y = dev->accel_y * dev->scale_y + (dev->offset_y * dev->scale_y);
+
+  if (z)
+    *z = dev->accel_z * dev->scale_z + (dev->offset_z * dev->scale_z);
+}
+
+void mma7361_get_volts(const mma7361_context dev,
+                       float *x, float *y, float *z)
+{
+  assert(dev != NULL);
+
+  if (x)
+    *x = dev->volts_x;
+
+  if (y)
+    *y = dev->volts_y;
+
+  if (z)
+    *z = dev->volts_z;
+}
+
+void mma7361_get_normalized(const mma7361_context dev,
+                            float *x, float *y, float *z)
+{
+  assert(dev != NULL);
+
+  if (x)
+    *x = dev->normalized_x;
+
+  if (y)
+    *y = dev->normalized_y;
+
+  if (z)
+    *z = dev->normalized_z;
+}
+
diff --git a/ext/lib/upm/src/mma7361/mma7361.h b/ext/lib/upm/src/mma7361/mma7361.h
new file mode 100644
index 0000000..70d13d2
--- /dev/null
+++ b/ext/lib/upm/src/mma7361/mma7361.h
@@ -0,0 +1,250 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/aio.h"
+#include "mraa/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /**
+   * @brief UPM C API for the DFRobot MMA7361 Analog Accelerometer
+   *
+   * The driver was tested with the DFRobot MMA7361 Analog
+   * Accelerometer.  It supports 3 Axes with a selectable 1.5G and 6G
+   * sensitivity.
+   *
+   * @snippet mma7361.c Interesting
+   */
+  
+  /**
+   * Device context
+   */
+  typedef struct _mma7361_context {
+    // at least one of these must be intialized
+    mraa_aio_context    aio_x;
+    mraa_aio_context    aio_y;
+    mraa_aio_context    aio_z;
+    
+    // optional - enable selftest
+    mraa_gpio_context   gpio_selftest;
+    
+    // optional - enable sleep mode
+    mraa_gpio_context   gpio_sleep;
+    
+    // optional - detect free fall (0g)
+    mraa_gpio_context   gpio_freefall;
+    
+    // optional - if unconnected, range is 1.5g
+    mraa_gpio_context   gpio_range;
+    
+    // selected G range
+    float g_range;
+
+    // analog ADC resolution
+    float               a_res;
+
+    // analog reference voltage
+    float               a_ref;
+    
+    // for external offset and scaling of the results
+    float               offset_x;
+    float               offset_y;
+    float               offset_z;
+
+    float               scale_x;
+    float               scale_y;
+    float               scale_z;
+    
+    // our measurements
+    float               accel_x;
+    float               accel_y;
+    float               accel_z;
+
+    // volts
+    float               volts_x;
+    float               volts_y;
+    float               volts_z;
+
+    // normalized ADC
+    float               normalized_x;
+    float               normalized_y;
+    float               normalized_z;
+  } *mma7361_context;
+  
+  /**
+   * MMA7361 Initializer
+   *
+   * This sensor isn't designed for navigational purposes - rather
+   * it's intended for less precise measurements such as determining
+   * tilt and orientation.
+   *
+   * All of these pins are optional, and will depend on how your
+   * device is connected.  For those pins you do not need, supply -1
+   * as the pin. You must supply a valid pin for at least one of the
+   * axes, or what's the point?
+   *
+   * The DFRobot variant of this sensor uses a mechanical switch on
+   * the board to determine the G-range to use, so on this board you
+   * would supply -1 for the range_pin, but be sure to call
+   * mma7361_set_range() with the correct parameter so that the
+   * internal logic will generate correct results.
+   *
+   * @param x_pin Analog pin to use for X axis. -1 to disable.
+   * @param y_pin Analog pin to use for Y axis. -1 to disable.
+   * @param z_pin Analog pin to use for Z axis. -1 to disable.
+   * @param selftest_pin GPIO pin to use for self test. -1 to disable.
+   * @param sleep_pin GPIO pin to use for sleep function. -1 to disable.
+   * @param freefall_pin GPIO pin to use for free fall (0g)
+   * detection. -1 to disable.
+   * @param range_pin GPIO pin to select range (1.5g or 6g).  -1 to
+   * disable.
+   * @param a_ref The analog reference voltage in use
+   */
+  mma7361_context mma7361_init(int x_pin, int y_pin, int z_pin,
+                               int selftest_pin, int sleep_pin,
+                               int freefall_pin, int range_pin,
+                               float a_ref);
+
+  /**
+   * MMA7361 sensor close function
+   */
+  void mma7361_close(mma7361_context dev);
+
+  /**
+   * Set the range of the device.  This device supports two G ranges:
+   * 1.5 and 6.  The default is 1.5G.
+   *
+   * @param dev sensor context
+   * @param range true for 6G, false for 1.5G
+   */
+  void mma7361_set_range(const mma7361_context dev, bool range);
+
+  /**
+   * Set sleep mode.  When in sleep mode the sensor uses minimal power.
+   *
+   * @param dev sensor context
+   * @param sleep true to go into sleep mode, false to wake up
+   * @return UPM result
+   */
+  upm_result_t mma7361_sleep(const mma7361_context dev, bool sleep);
+
+  /**
+   * Get freefall detection status.
+   *
+   * @param dev sensor context
+   * @param freefall O pointer to a boolean value indicating whether a
+   * freefall condition is being detected.
+   * @return UPM result
+   */
+  upm_result_t mma7361_freefall(const mma7361_context dev, bool *freefall);
+
+  /**
+   * Enable self test mode.
+   *
+   * @param dev sensor context
+   * @param selftest true to enable the self test mode, false otherwise.
+   * @return UPM result
+   */
+  upm_result_t mma7361_selftest(const mma7361_context dev, bool selftest);
+
+  /**
+   * Read the sensor status an update internal state.
+   * mma7361_update() must have been called before calling
+   * mma7361_get_acceleration(), mma7361_get_normalized(), or
+   * mma7361_get_volts().
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  upm_result_t mma7361_update(const mma7361_context dev);
+
+  /**
+   * Set sensor offset.  This offset is applied to the return values
+   * before scaling.  Default is 0.0.
+   *
+   * @param dev sensor context pointer
+   * @param x Scale to apply to X value
+   * @param y Scale to apply to Y value
+   * @param z Scale to apply to Z value
+   */
+  void mma7361_set_offset(const mma7361_context dev, float x, float y,
+                          float z);
+
+  /**
+   * Set sensor scale.  The acceleration return values are scaled by
+   * this value before the offset is applied.  Default is 1.0.
+   *
+   * @param dev sensor context pointer
+   * @param x Offset to apply to X value
+   * @param y Offset to apply to Y value
+   * @param z Offset to apply to Z value
+   */
+  void mma7361_set_scale(const mma7361_context dev, float x, float y,
+                         float z);
+
+  /**
+   * Get computed acceleration from the sensor. mma7361_update() must
+   * have been called prior to calling this function.
+   *
+   * @param dev sensor context pointer
+   * @param x a pointer in which X acceleration data will be returned
+   * @param y a pointer in which Y acceleration data will be returned
+   * @param z a pointer in which Z acceleration data will be returned
+   */
+  void mma7361_get_acceleration(const mma7361_context dev,
+                                float *x, float *y, float *z);
+
+  /**
+   * Get the measured volts from the sensor. mma7361_update() must
+   * have been called prior to calling this function.
+   *
+   * @param dev sensor context pointer
+   * @param x a pointer in which X volt data will be returned
+   * @param y a pointer in which Y volt data will be returned
+   * @param z a pointer in which Z volt data will be returned
+   */
+  void mma7361_get_volts(const mma7361_context dev,
+                         float *x, float *y, float *z);
+
+  /**
+   * Get the normalized ADC values from the sensor.  mma7361_update() must
+   * have been called prior to calling this function.
+   *
+   * @param dev sensor context pointer
+   * @param x a pointer in which X normalized ADC data will be returned
+   * @param y a pointer in which Y normalized ADC data will be returned
+   * @param z a pointer in which Z normalized ADC data will be returned
+   */
+  void mma7361_get_normalized(const mma7361_context dev,
+                              float *x, float *y, float *z);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/mma7660/Kbuild b/ext/lib/upm/src/mma7660/Kbuild
new file mode 100644
index 0000000..0bc20d8
--- /dev/null
+++ b/ext/lib/upm/src/mma7660/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_mma7660) += mma7660.o
diff --git a/ext/lib/upm/src/mma7660/Kconfig b/ext/lib/upm/src/mma7660/Kconfig
new file mode 100644
index 0000000..e7a6a3a
--- /dev/null
+++ b/ext/lib/upm/src/mma7660/Kconfig
@@ -0,0 +1,8 @@
+config UPM_mma7660
+    bool "mma7660"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm MMA7660 I2C Accelerometer (1.5g)
diff --git a/ext/lib/upm/src/mma7660/Makefile b/ext/lib/upm/src/mma7660/Makefile
new file mode 100644
index 0000000..0312747
--- /dev/null
+++ b/ext/lib/upm/src/mma7660/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_mma7660
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/mma7660
+endif
diff --git a/ext/lib/upm/src/mma7660/mma7660.c b/ext/lib/upm/src/mma7660/mma7660.c
new file mode 100644
index 0000000..7ffe47a
--- /dev/null
+++ b/ext/lib/upm/src/mma7660/mma7660.c
@@ -0,0 +1,367 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+#include "mma7660.h"
+
+mma7660_context mma7660_init(int bus, uint8_t address)
+{
+    mma7660_context dev =
+        (mma7660_context)malloc(sizeof(struct _mma7660_context));
+
+    if (!dev)
+        return NULL;
+
+    memset((void *)dev, 0, sizeof(struct _mma7660_context));
+
+    dev->i2c = NULL;
+    dev->gpio = NULL;
+    dev->isrInstalled = false;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        mma7660_close(dev);
+        return NULL;
+    }
+
+    // setup our i2c
+    if ( !(dev->i2c = mraa_i2c_init(bus)) )
+    {
+        printf("%s: mraa_i2c_init() failed\n", __FUNCTION__);
+        mma7660_close(dev);
+        return NULL;
+    }
+
+    if (mraa_i2c_address(dev->i2c, address))
+    {
+        printf("%s: mraa_i2c_address() failed\n", __FUNCTION__);
+        mma7660_close(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void mma7660_close(mma7660_context dev)
+{
+    assert(dev != NULL);
+
+    mma7660_uninstall_isr(dev);
+
+    if (dev->i2c)
+    {
+        mma7660_set_mode_standby(dev);
+        mraa_i2c_stop(dev->i2c);
+    }
+
+    free(dev);
+}
+
+upm_result_t mma7660_write_byte(const mma7660_context dev,
+                                uint8_t reg, uint8_t byte)
+{
+    assert(dev != NULL);
+
+    if (mraa_i2c_write_byte_data(dev->i2c, byte, reg))
+    {
+        printf("%s: mraa_i2c_write_byte_data() failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_read_byte(const mma7660_context dev, uint8_t reg,
+                               uint8_t *byte)
+{
+    assert(dev != NULL);
+
+    int x = mraa_i2c_read_byte_data(dev->i2c, reg);
+
+    if (x < 0)
+    {
+        printf("%s: mraa_i2c_read_byte_data() failed.\n", __FUNCTION__);
+        if (byte)
+            *byte = 0;
+
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if (byte)
+        *byte = (uint8_t)(x & 0xff);
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_get_raw_values(const mma7660_context dev,
+                                    int *x, int *y, int *z)
+{
+    assert(dev != NULL);
+
+    int rv;
+    if (x)
+    {
+        if ( (rv = mma7660_get_verified_axis(dev, MMA7660_REG_XOUT, x)) )
+            return rv;
+    }
+    if (y)
+    {
+        if ( (rv = mma7660_get_verified_axis(dev, MMA7660_REG_YOUT, y)) )
+            return rv;
+    }
+    if (z)
+    {
+        if ( (rv = mma7660_get_verified_axis(dev, MMA7660_REG_ZOUT, z)) )
+            return rv;
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_set_mode_active(const mma7660_context dev)
+{
+    assert(dev != NULL);
+
+    uint8_t modeReg;
+    if (mma7660_read_byte(dev, MMA7660_REG_MODE, &modeReg))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    // The D2 (TON bit) should be cleared, and the MODE bit set
+
+    modeReg &= ~MMA7660_MODE_TON;
+    modeReg |= MMA7660_MODE_MODE;
+
+    return mma7660_write_byte(dev, MMA7660_REG_MODE, modeReg);
+}
+
+upm_result_t mma7660_set_mode_standby(const mma7660_context dev)
+{
+    assert(dev != NULL);
+
+    uint8_t modeReg;
+    if (mma7660_read_byte(dev, MMA7660_REG_MODE, &modeReg))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    // the D0 (mode bit) and D2 (TON bit) should be cleared.
+
+    modeReg &= ~MMA7660_MODE_TON;
+    modeReg &= ~MMA7660_MODE_MODE;
+
+    return mma7660_write_byte(dev, MMA7660_REG_MODE, modeReg);
+}
+
+// read an axis value, verifying it's validity
+upm_result_t mma7660_get_verified_axis(const mma7660_context dev,
+                                       MMA7660_REG_T axis, int *val)
+{
+    assert(dev != NULL);
+
+    *val = 0;
+    // We only want one of the 3 axes
+
+    if (axis > 2)
+    {
+        printf("%s: axis must be 0, 1, or 2.\n", __FUNCTION__);
+        return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+    // we need to check the alert bit and sign bits if the alert bit is
+    // set, this means that the register was being updated when the
+    // register was read, so re-read until it's clear.
+
+    uint8_t value = 0;
+    do {
+        if (mma7660_read_byte(dev, axis, &value))
+            return UPM_ERROR_OPERATION_FAILED;
+
+        // check alert bit
+    } while (value & 0x40);
+
+    // shift the sign bit over, and compensate
+    *val = ((int8_t)(value << 2) / 4);
+
+    return UPM_SUCCESS;
+}
+
+// read the tilt register, verifying it's validity
+upm_result_t mma7660_get_verified_tilt(const mma7660_context dev,
+                                       uint8_t *val)
+{
+    assert(dev != NULL);
+
+    // we need to check the alert bit and sign bits if the alert bit is
+    // set, this means that the register was being updated when the
+    // register was read, so re-read until it's clear.
+
+    do {
+        if (mma7660_read_byte(dev, MMA7660_REG_TILT, val))
+            return UPM_ERROR_OPERATION_FAILED;
+
+        // check alert bit
+    } while (*val & 0x40);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_tilt_back_front(const mma7660_context dev,
+                                     uint8_t *bits)
+{
+    assert(dev != NULL);
+
+    if (mma7660_get_verified_tilt(dev, bits))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    // mask off the bits we don't care about
+    *bits &= 0x03;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_tilt_landscape_portrait(const mma7660_context dev,
+                                             uint8_t *bits)
+{
+    assert(dev != NULL);
+
+    if (mma7660_get_verified_tilt(dev, bits))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    // mask off the bits we don't care about
+    *bits >>= 2;
+    *bits &= 0x07;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_tilt_tap(const mma7660_context dev, bool *tap)
+{
+    assert(dev != NULL);
+
+    uint8_t val = 0;
+    if (mma7660_get_verified_tilt(dev, &val))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    if (val & 0x20)
+        *tap = true;
+    else
+        *tap = false;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_tilt_shake(const mma7660_context dev, bool *shake)
+{
+    assert(dev != NULL);
+
+    uint8_t val = 0;
+    if (mma7660_get_verified_tilt(dev, &val))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    if (val & 0x80)
+        *shake = true;
+    else
+        *shake = false;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mma7660_install_isr(const mma7660_context dev, int pin,
+                                 void (*isr)(void *), void *arg)
+{
+    assert(dev != NULL);
+
+    mma7660_uninstall_isr(dev);
+
+    if ( !(dev->gpio = mraa_gpio_init(pin)) )
+    {
+        printf("%s: mraa_gpio_init failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+    // install our interrupt handler
+    mraa_gpio_isr(dev->gpio, MRAA_GPIO_EDGE_RISING,
+                  isr, arg);
+    dev->isrInstalled = true;
+
+    return UPM_SUCCESS;
+}
+
+void mma7660_uninstall_isr(const mma7660_context dev)
+{
+    assert(dev != NULL);
+
+    if (!dev->isrInstalled)
+        return;
+
+    mraa_gpio_isr_exit(dev->gpio);
+    dev->isrInstalled = false;
+    mraa_gpio_close(dev->gpio);
+    dev->gpio = NULL;
+}
+
+upm_result_t mma7660_set_interrupt_bits(const mma7660_context dev,
+                                        uint8_t ibits)
+{
+    assert(dev != NULL);
+
+    return mma7660_write_byte(dev, MMA7660_REG_INTSU, ibits);
+}
+
+upm_result_t mma7660_set_sample_rate(const mma7660_context dev,
+                                     MMA7660_AUTOSLEEP_T sr)
+{
+    assert(dev != NULL);
+
+    return mma7660_write_byte(dev, MMA7660_REG_SR, sr);
+}
+
+upm_result_t mma7660_get_acceleration(const mma7660_context dev,
+                                      float *ax, float *ay, float *az)
+{
+    assert(dev != NULL);
+
+    int x, y, z;
+
+    if (mma7660_get_raw_values(dev, &x, &y, &z))
+    {
+        printf("%s: mma7660_get_raw_values() failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // 21.33, typical counts/g
+
+    if (ax)
+        *ax = x/21.33;
+    if (ay)
+        *ay = y/21.33;
+    if (az)
+        *az = z/21.33;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/mma7660/mma7660.h b/ext/lib/upm/src/mma7660/mma7660.h
new file mode 100644
index 0000000..6109455
--- /dev/null
+++ b/ext/lib/upm/src/mma7660/mma7660.h
@@ -0,0 +1,251 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/i2c.h>
+#include <mraa/gpio.h>
+
+#include <mma7660_regs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file mma7660.h
+     * @library mma7660
+     * @brief C API for the mma7660 driver
+     *
+     * @include mma7660.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _mma7660_context {
+        mraa_i2c_context  i2c;
+        mraa_gpio_context gpio;
+
+        bool              isrInstalled;
+    } *mma7660_context;
+
+    /**
+     * MMA7660 initialization.
+     *
+     * @param bus I2C bus to use
+     * @param address Address for this sensor
+     */
+    mma7660_context mma7660_init(int bus, uint8_t address);
+
+    /**
+     * MMA7660 destructor
+     *
+     * @param dev Device context.
+     */
+    void mma7660_close(mma7660_context dev);
+
+    /**
+     * Writes a byte value into a register
+     *
+     * @param dev Device context.
+     * @param reg Register location to write into
+     * @param byte Byte to write
+     * @return UPM result
+     */
+    upm_result_t mma7660_write_byte(const mma7660_context dev,
+                                    uint8_t reg, uint8_t byte);
+
+    /**
+     * Reads a byte value from a register
+     *
+     * @param dev Device context.
+     * @param reg Register location to read from
+     * @param byte A pointer to hold the value that was read
+     * @return UPM result
+     */
+    upm_result_t mma7660_read_byte(const mma7660_context dev, uint8_t reg,
+                                   uint8_t *byte);
+
+    /**
+     * Reads the current value of conversion
+     *
+     * @param dev Device context.
+     * @param x Returned x value
+     * @param y Returned y value
+     * @param z Returned z value
+     * @return UPM result
+     */
+    upm_result_t mma7660_get_raw_values(const mma7660_context dev,
+                                        int *x, int *y, int *z);
+
+    /**
+     * Gets the computed acceleration
+     *
+     * @param dev Device context.
+     * @param ax Returned computed acceleration of the X-axis
+     * @param ay Returned computed acceleration of the Y-axis
+     * @param az Returned computed acceleration of the Z-axis
+     * @return UPM result
+     */
+    upm_result_t mma7660_get_acceleration(const mma7660_context dev,
+                                          float *ax, float *ay, float *az);
+
+    /**
+     * Reads an axis, verifying its validity. The value passed must be
+     * one of MMA7660_REG_XOUT, MMA7660_REG_YOUT, or MMA7660_REG_ZOUT.
+     *
+     * @param dev Device context.
+     * @param axis Axis to read
+     * @param val pointer containing returned value
+     * @return UPM result
+     */
+    upm_result_t mma7660_get_verified_axis(const mma7660_context dev,
+                                           MMA7660_REG_T axis, int *val);
+
+    /**
+     * Reads the tilt register, verifying its validity
+     *
+     * @param dev Device context.
+     * @param val Pointer to returned value
+     * @return UPM result
+     */
+    upm_result_t mma7660_get_verified_tilt(const mma7660_context dev,
+                                           uint8_t *val);
+
+    /**
+     * Puts the device in the active mode. In this mode, register
+     * writes are not allowed. Place the device in the standby mode before
+     * attempting to write registers.
+     *
+     * @param dev Device context.
+     * @return UPM result
+     */
+    upm_result_t mma7660_set_mode_active(const mma7660_context dev);
+
+    /**
+     * Puts the device in the standby (power saving) mode. Note: when in
+     * the standby mode, there is no valid data in the registers. In
+     * addition, the only way to write a register is to put the
+     * device in the standby mode.
+     *
+     * @param dev Device context.
+     * @return UPM result
+     */
+    upm_result_t mma7660_set_mode_standby(const mma7660_context dev);
+
+    /**
+     * Reads tiltBackFront bits
+     *
+     * The value returned is one of the MMA7660_TILT_BF_T values
+     *
+     * @param dev Device context.
+     * @param bits Pointer to returned bits corresponding to the
+     * BackFront tilt status
+     * @return UPM result
+     */
+    upm_result_t mma7660_tilt_back_front(const mma7660_context dev,
+                                         uint8_t *bits);
+
+    /**
+     * Reads tiltLandscapePortrait bits
+     *
+     * The value returned is one of the MMA7660_TILT_LP_T values
+     *
+     * @param dev Device context.
+     * @param bits Pointer to returned bits corresponding to the
+     * LandscapePortrait tilt status
+     * @return UPM result
+     */
+    upm_result_t mma7660_tilt_landscape_portrait(const mma7660_context dev,
+                                                 uint8_t *bits);
+
+    /**
+     * Reads the tiltTap status
+     *
+     * @param dev Device context.
+     * @param tap Pointer to a bool indicating tap detection
+     * @return UPM result
+     */
+    upm_result_t mma7660_tilt_tap(const mma7660_context dev, bool *tap);
+
+    /**
+     * Reads the tiltShake status
+     *
+     * @param dev Device context.
+     * @param shake Pointer to a bool indicating shake detection
+     * @return UPM result
+     */
+    upm_result_t mma7660_tilt_shake(const mma7660_context dev, bool *shake);
+
+    /**
+     * Installs an interrupt service routine (ISR) to be called when
+     * an interrupt occurs
+     *
+     * @param dev Device context.
+     * @param pin GPIO pin to use as the interrupt pin
+     * @param fptr Pointer to a function to be called on interrupt
+     * @param arg Pointer to an object to be supplied as an
+     * argument to the ISR.
+     * @return UPM result
+     */
+    upm_result_t mma7660_install_isr(const mma7660_context dev, int pin,
+                                     void (*isr)(void *), void *arg);
+
+    /**
+     * Uninstalls the previously installed ISR
+     *
+     * @param dev Device context.
+     */
+    void mma7660_uninstall_isr(const mma7660_context dev);
+
+    /**
+     * Enables interrupt generation based on passed interrupt bits.
+     * The bits are a bitmask of the requested MMA7660_INTR_T values.
+     * Note: the device must be in the standby mode to set this register.
+     *
+     * @param dev Device context.
+     * @param ibits Sets the requested interrupt bits
+     * @return UPM result
+     */
+    upm_result_t mma7660_set_interrupt_bits(const mma7660_context dev,
+                                            uint8_t ibits);
+
+    /**
+     * Sets the sampling rate of the sensor. The value supplied must
+     * be one of the MMA7660_AUTOSLEEP_T values.
+     *
+     * @param dev Device context.
+     * @param sr One of the MMA7660_AUTOSLEEP_T values
+     * @return UPM result
+     */
+    upm_result_t mma7660_set_sample_rate(const mma7660_context dev,
+                                         MMA7660_AUTOSLEEP_T sr);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/mma7660/mma7660_regs.h b/ext/lib/upm/src/mma7660/mma7660_regs.h
new file mode 100644
index 0000000..d1086d8
--- /dev/null
+++ b/ext/lib/upm/src/mma7660/mma7660_regs.h
@@ -0,0 +1,104 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#define MMA7660_DEFAULT_I2C_BUS 0
+#define MMA7660_DEFAULT_I2C_ADDR 0x4c
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    // MMA7660 registers
+    typedef enum {
+        MMA7660_REG_XOUT       = 0x00,
+        MMA7660_REG_YOUT       = 0x01,
+        MMA7660_REG_ZOUT       = 0x02,
+        MMA7660_REG_TILT       = 0x03,
+        MMA7660_REG_SRST       = 0x04, // Sampling Rate Status
+        MMA7660_REG_SPCNT      = 0x05, // sleep count
+        MMA7660_REG_INTSU      = 0x06, // Interrupt setup
+        MMA7660_REG_MODE       = 0x07, // operating mode
+        MMA7660_REG_SR         = 0x08, // auto-wake/sleep, SPS, and debounce
+        MMA7660_REG_PDET       = 0x09, // tap detection
+        MMA7660_REG_PD         = 0x0a  // tap debounce count
+        // 0x0b-0x1f reserved
+    } MMA7660_REG_T;
+
+    // interrupt enable register bits
+    typedef enum {
+        MMA7660_INTR_NONE          = 0x00, // disabled
+        MMA7660_INTR_FBINT         = 0x01, // front/back
+        MMA7660_INTR_PLINT         = 0x02, // up/down/right/left
+        MMA7660_INTR_PDINT         = 0x04, // tap detection
+        MMA7660_INTR_ASINT         = 0x08, // exit auto-sleep
+        MMA7660_INTR_GINT          = 0x10, // measurement intr
+        MMA7660_INTR_SHINTZ        = 0x20, // shake on Z
+        MMA7660_INTR_SHINTY        = 0x40, // shake on Y
+        MMA7660_INTR_SHINTX        = 0x80  // shake on X
+    } MMA7660_INTR_T;
+
+    // operating mode register bits
+    typedef enum {
+        MMA7660_MODE_MODE          = 0x01, // determines mode with MODE_TON
+        // 0x02 reserved
+        MMA7660_MODE_TON           = 0x04, // determines mode with MODE_MODE
+        MMA7660_MODE_AWE           = 0x08, // auto-wake
+        MMA7660_MODE_ASE           = 0x10, // auto-sleep
+        MMA7660_MODE_SCPS          = 0x20, // sleep count prescale
+        MMA7660_MODE_IPP           = 0x40, // intr out push-pull/open drain
+        MMA7660_MODE_IAH           = 0x80  // intr active low/high
+    } MMA7660_MODE_T;
+
+    // tilt BackFront (BF) bits
+    typedef enum {
+        MMA7660_BF_UNKNOWN          = 0x00,
+        MMA7660_BF_LYING_FRONT      = 0x01,
+        MMA7660_BF_LYING_BACK       = 0x02
+    } MMA7660_TILT_BF_T;
+
+    // tilt LandscapePortrait (LP) bits
+    typedef enum {
+        MMA7660_LP_UNKNOWN          = 0x00,
+        MMA7660_LP_LANDSCAPE_LEFT   = 0x01,
+        MMA7660_LP_LANDSCAPE_RIGHT  = 0x02,
+        MMA7660_LP_VERT_DOWN        = 0x05,
+        MMA7660_LP_VERT_UP          = 0x06
+    } MMA7660_TILT_LP_T;
+
+    // sample rate (auto-sleep) values
+    typedef enum {
+        MMA7660_AUTOSLEEP_120   = 0x00,
+        MMA7660_AUTOSLEEP_64    = 0x01,
+        MMA7660_AUTOSLEEP_32    = 0x02,
+        MMA7660_AUTOSLEEP_16    = 0x03,
+        MMA7660_AUTOSLEEP_8     = 0x04,
+        MMA7660_AUTOSLEEP_4     = 0x05,
+        MMA7660_AUTOSLEEP_2     = 0x06,
+        MMA7660_AUTOSLEEP_1     = 0x07
+    } MMA7660_AUTOSLEEP_T;
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/moisture/Kbuild b/ext/lib/upm/src/moisture/Kbuild
new file mode 100644
index 0000000..16a03bd
--- /dev/null
+++ b/ext/lib/upm/src/moisture/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_moisture) += moisture.o
diff --git a/ext/lib/upm/src/moisture/Kconfig b/ext/lib/upm/src/moisture/Kconfig
new file mode 100644
index 0000000..da0a2b6
--- /dev/null
+++ b/ext/lib/upm/src/moisture/Kconfig
@@ -0,0 +1,9 @@
+config UPM_moisture
+    bool "moisture"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm analog moisture module
+
diff --git a/ext/lib/upm/src/moisture/Makefile b/ext/lib/upm/src/moisture/Makefile
new file mode 100644
index 0000000..3cdc417
--- /dev/null
+++ b/ext/lib/upm/src/moisture/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_moisture
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/moisture
+endif
diff --git a/ext/lib/upm/src/moisture/moisture.c b/ext/lib/upm/src/moisture/moisture.c
new file mode 100644
index 0000000..b56c734
--- /dev/null
+++ b/ext/lib/upm/src/moisture/moisture.c
@@ -0,0 +1,61 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "moisture.h"
+
+moisture_context moisture_init(int pin) {
+    moisture_context dev =
+      (moisture_context) malloc(sizeof(struct _moisture_context));
+
+    if (dev == NULL) {
+        printf("Unable to allocate memory for device context\n");
+        return NULL;
+    }
+
+    dev->analog_pin = pin;
+    dev->aio = mraa_aio_init(dev->analog_pin);
+
+    if (dev->aio == NULL) {
+        printf("mraa_aio_init() failed.\n");
+        free(dev);
+
+        return NULL;
+    }
+
+    return dev;
+}
+
+void moisture_close(moisture_context dev) {
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t moisture_get_moisture(moisture_context dev,
+                                            int* moisture) {
+
+    *moisture = mraa_aio_read(dev->aio);
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/moisture/moisture.h b/ext/lib/upm/src/moisture/moisture.h
new file mode 100644
index 0000000..ab8869e
--- /dev/null
+++ b/ext/lib/upm/src/moisture/moisture.h
@@ -0,0 +1,74 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * device context
+ */
+typedef struct _moisture_context {
+    mraa_aio_context    aio;
+    uint16_t            analog_pin;
+} *moisture_context;
+
+/**
+ * Init function
+ *
+ * @param pin analog pin number
+ * @return void* pointer to the sensor struct
+ */
+moisture_context moisture_init(int pin);
+
+/**
+ * Close function
+ *
+ * @param dev pointer to the sensor structure
+ */
+void moisture_close(moisture_context dev);
+
+/**
+ * Get Moisture function.
+ *
+ * @param dev pointer to the sensor struct
+ * @param moisture pointer that will be used to store the
+ * output value from the sensor
+ */
+upm_result_t moisture_get_moisture(moisture_context dev,
+                                        int* moisture);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/mpr121/Kbuild b/ext/lib/upm/src/mpr121/Kbuild
new file mode 100644
index 0000000..5128bec
--- /dev/null
+++ b/ext/lib/upm/src/mpr121/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_mpr121) += mpr121.o
diff --git a/ext/lib/upm/src/mpr121/Kconfig b/ext/lib/upm/src/mpr121/Kconfig
new file mode 100644
index 0000000..f8e0f6b
--- /dev/null
+++ b/ext/lib/upm/src/mpr121/Kconfig
@@ -0,0 +1,9 @@
+config UPM_mpr121
+    bool "mpr121"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm mpr121sensor module
+
diff --git a/ext/lib/upm/src/mpr121/Makefile b/ext/lib/upm/src/mpr121/Makefile
new file mode 100644
index 0000000..4399e7f
--- /dev/null
+++ b/ext/lib/upm/src/mpr121/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_mpr121
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/mpr121
+endif
diff --git a/ext/lib/upm/src/mpr121/mpr121.c b/ext/lib/upm/src/mpr121/mpr121.c
new file mode 100644
index 0000000..c63fb8d
--- /dev/null
+++ b/ext/lib/upm/src/mpr121/mpr121.c
@@ -0,0 +1,205 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "mpr121.h"
+
+mpr121_context mpr121_init(int bus, uint8_t address){
+    mpr121_context dev = (mpr121_context)malloc(sizeof(struct _mpr121_context));
+
+    if (!dev)
+      return NULL;
+
+    dev->bus = bus;
+    dev->address = address;
+    dev->i2c = mraa_i2c_init(dev->bus);
+
+    if(dev->i2c == NULL){
+        free(dev);
+        return NULL;
+    }
+
+    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS){
+        free(dev);
+        printf("error using i2c address: %x\n", dev->address);
+        return NULL;
+    }
+
+    dev->over_current_fault = false;
+    return dev;
+}
+
+void mpr121_close(mpr121_context dev){
+    mraa_i2c_stop(dev->i2c);
+    free(dev);
+}
+
+upm_result_t mpr121_write_bytes(mpr121_context dev, uint8_t reg,
+                                uint8_t *buffer, int len){
+    if(!len || !buffer)
+        return UPM_ERROR_INVALID_SIZE;
+
+    // create a buffer 1 byte larger than the supplied buffer,
+    // store the register in the first byte
+    uint8_t buf2[len + 1];
+    buf2[0] = reg;
+
+    // copy in the buffer after the reg byte
+
+    int i;
+    for(i=1; i<(len + 1); i++)
+        buf2[i] = buffer[i-1];
+
+    if(mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS){
+        printf("write byte error address\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if(mraa_i2c_write(dev->i2c, buf2, len+1) != MRAA_SUCCESS){
+        printf("write byte error while writing\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    return UPM_SUCCESS;
+}
+
+upm_result_t mpr121_read_bytes(mpr121_context dev, uint8_t reg,
+                               uint8_t *buffer, int len){
+    if(!len || !buffer)
+        return UPM_ERROR_INVALID_SIZE;
+
+    // The usual m_i2c.read() does not work here, so we need to
+    // read each byte individually.
+    int i;
+    for (i=0; i<len; i++)
+        buffer[i] = mraa_i2c_read_byte_data(dev->i2c, reg+i);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mpr121_read_buttons(mpr121_context dev, uint32_t* states,
+                                     int num){
+    int len = 2;
+    uint8_t buffer[2];
+
+    // read in the 2 bytes at register 0x00-0x01, and setup the member
+    // variables accordingly.
+    mpr121_read_bytes(dev, 0x00, buffer, len);
+
+    *states = (buffer[0] | ((buffer[1] & 0x1f) << 8));
+    if (buffer[1] & 0x80)
+        dev->over_current_fault = true;
+    else
+        dev->over_current_fault = false;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mpr121_config_an3944(mpr121_context dev){
+    // Configure the mpr121 chip as recommended in the AN3944 MPR121
+    // Quick Start Guide
+    // First, turn off all electrodes by zeroing out the Electrode Configuration
+    // register.
+    // If this one fails, it's unlikely any of the others will succeed.
+    uint8_t eleConf = 0x00;
+    if (mpr121_write_bytes(dev, 0x5e, &eleConf, 1) != UPM_SUCCESS){
+        printf("write to electrode configuration register failed\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Section A
+    // Filtering when data is greater than baseline
+    // regs 0x2b-0x2e
+
+    uint8_t sectA[] = {0x01, 0x01, 0x00, 0x00};
+    if (mpr121_write_bytes(dev, 0x2b, sectA, 4) != UPM_SUCCESS){
+        printf("write to section a failed\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Section B
+    // Filtering when data is less than baseline
+    // regs 0x2f-0x32
+
+    uint8_t sectB[] = {0x01, 0x01, 0xff, 0x02};
+    if (mpr121_write_bytes(dev, 0x2f, sectB, 4) != UPM_SUCCESS){
+        printf("write to section b failed\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Section C
+    // Touch Threshold/Release registers, ELE0-ELE11
+    // regs 0x41-0x58
+    //                    __T_  __R_
+    uint8_t sectC[] =  {0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a,
+        0x0f, 0x0a};
+
+    if (mpr121_write_bytes(dev, 0x41, sectC, 24) != UPM_SUCCESS){
+        printf("failed to configure touch threshold/release regs\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Section D
+    // Filter configuration
+    // reg 0x5d
+    uint8_t filterConf = 0x04;
+    if (mpr121_write_bytes(dev, 0x5d, &filterConf, 1) != UPM_SUCCESS){
+        printf("unable to configure filters\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Section F
+    // Autoconfiguration registers
+    // regs 0x7b-0x7f
+    uint8_t sectF0 = 0x0b;
+    if (mpr121_write_bytes(dev, 0x7b, &sectF0, 1) != UPM_SUCCESS){
+        printf("unable to configure auto config regs\n");
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    uint8_t sectF1[] = {0x9c, 0x65, 0x8c};
+    if (mpr121_write_bytes(dev, 0x7d, sectF1, 3) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Section E - this one must be set last, and switches to run mode
+    // Enable all 12 electrodes, and set a pre-calibration to avoid
+    // excessive calibration delay on startup.
+    // reg 0x5e
+    eleConf = 0x8c;
+    if (mpr121_write_bytes(dev, 0x5e, &eleConf, 3) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/mpr121/mpr121.h b/ext/lib/upm/src/mpr121/mpr121.h
new file mode 100644
index 0000000..69b815a
--- /dev/null
+++ b/ext/lib/upm/src/mpr121/mpr121.h
@@ -0,0 +1,111 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef MPR121_H_
+#define MPR121_H_
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/i2c.h"
+
+#define MPR121_I2C_BUS     0
+#define MPR121_DEFAULT_I2C_ADDR    0x5a
+
+/**
+ * device context
+ */
+typedef struct _mpr121_context {
+    mraa_i2c_context    i2c;
+    int                 bus;
+    uint8_t             address;
+    uint8_t             over_current_fault;
+} *mpr121_context;
+
+/**
+ * MPR121 Init function
+ *
+ * @param bus i2c bus
+ * @param address i2c address of the sensor
+ * @return void* pointer to the sensor struct
+ */
+mpr121_context mpr121_init(int bus, uint8_t address);
+
+/**
+ * MPR121 Close function
+ *
+ * @param dev pointer to sensor struct
+ */
+void mpr121_close(mpr121_context dev);
+
+/**
+ * Sets up a default configuration, based on Application Note 3944
+ * (AN3944):
+ * http://cache.freescale.com/files/sensors/doc/app_note/AN3944.pdf
+ *
+ * After configuration, the sensor is left in the run state.
+ *
+ * @param dev pointer to the sensor struct
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t mpr121_config_an3944(mpr121_context dev);
+
+/**
+ * Function to read the individual button values
+ *
+ * @param dev pointer to the sensor struct
+ * @param states Pointer to store the states of the individual buttons
+ * @param num used to retrieve the state of a particular button
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t mpr121_read_buttons(mpr121_context dev, uint32_t* states, int num);
+
+/**
+ * Function used to write multiple bytes to the i2c bus
+ *
+ * @param dev sensor struct
+ * @param reg i2c register to read from
+ * @param *buffer pointer that contains the values that have to be
+ * written to the registers
+ * @param len length of the values that have to be written to the regs
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t mpr121_write_bytes(mpr121_context dev, uint8_t reg,
+                                uint8_t *buffer, int len);
+
+/**
+ * Function used to read multiple bytes from the i2c bus
+ *
+ * @param dev sensor struct
+ * @param reg i2c register to read from
+ * @param *buffer pointer that contains the values that have been
+ * read from the registers
+ * @param len length of the values that have to be read
+ * @return upm_result_t UPM success/error code
+ */
+
+upm_result_t mpr121_read_bytes(mpr121_context dev, uint8_t reg,
+                               uint8_t *buffer, int len);
+
+#endif /* MPR121_H_ */
diff --git a/ext/lib/upm/src/mq303a/Kbuild b/ext/lib/upm/src/mq303a/Kbuild
new file mode 100644
index 0000000..bd7b0fb
--- /dev/null
+++ b/ext/lib/upm/src/mq303a/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_mq303a) += mq303a.o
diff --git a/ext/lib/upm/src/mq303a/Kconfig b/ext/lib/upm/src/mq303a/Kconfig
new file mode 100644
index 0000000..f09276d
--- /dev/null
+++ b/ext/lib/upm/src/mq303a/Kconfig
@@ -0,0 +1,9 @@
+config UPM_mq303a
+    bool "mq303a"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm mq303a sensor module
+
diff --git a/ext/lib/upm/src/mq303a/Makefile b/ext/lib/upm/src/mq303a/Makefile
new file mode 100644
index 0000000..e29bef8
--- /dev/null
+++ b/ext/lib/upm/src/mq303a/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_mq303a
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/mq303a
+endif
diff --git a/ext/lib/upm/src/mq303a/mq303a.c b/ext/lib/upm/src/mq303a/mq303a.c
new file mode 100644
index 0000000..512db2b
--- /dev/null
+++ b/ext/lib/upm/src/mq303a/mq303a.c
@@ -0,0 +1,69 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "mq303a.h"
+
+mq303a_context mq303a_init(int pin, int heater_pin){
+    mq303a_context dev =
+      (mq303a_context)malloc(sizeof(struct _mq303a_context));
+
+    if (!dev)
+      return NULL;
+
+    dev->aio_pin = pin;
+    dev->gpio_pin = heater_pin;
+    dev->aio = mraa_aio_init(dev->aio_pin);
+    dev->gpio = mraa_gpio_init(dev->gpio_pin);
+
+    if(mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT) != MRAA_SUCCESS)
+      {
+        free(dev);
+        return NULL;
+      }
+
+    return dev;
+}
+
+void mq303a_close(mq303a_context dev){
+    free(dev);
+}
+
+upm_result_t mq303a_heater_enable(mq303a_context dev, bool enable){
+    if(enable)
+        mraa_gpio_write(dev->gpio, 0);
+    else
+        mraa_gpio_write(dev->gpio, 1);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t mq303a_get_value(mq303a_context dev, int* val){
+    *val = mraa_aio_read(dev->aio);
+
+    if (*val < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/mq303a/mq303a.h b/ext/lib/upm/src/mq303a/mq303a.h
new file mode 100644
index 0000000..976fcba
--- /dev/null
+++ b/ext/lib/upm/src/mq303a/mq303a.h
@@ -0,0 +1,103 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef MQ303A_MQ303A_H_
+#define MQ303A_MQ303A_H_
+
+#include "upm.h"
+#include "mraa/aio.h"
+#include "mraa/gpio.h"
+
+/**
+ * @brief MQ303A Alcohol Sensor library
+ * @defgroup mq303a libupm-mq303a
+ * @ingroup analog gpio gaseous tsk
+ */
+/**
+ * @library mq303a
+ * @sensor mq303a
+ * @comname MQ303A Alcohol Sensor
+ * @type gaseous
+ * @man seeed
+ * @web http://www.seeedstudio.com/document/pdf/MQ303A.pdf
+ * @con analog gpio
+ * @kit tsk
+ *
+ * @brief API for the MQ303A Alcohol Sensor
+ *
+ * UPM module for the MQ303A alcohol sensor.
+ * This sensor needs to be warmed up before stable results are
+ * obtained. The higher the value returned from value(),
+ * the higher the amount of alcohol detected.
+ *
+ * @image html mq303a.jpg
+ * @snippet mq303a.cxx Interesting
+ */
+
+/**
+ * device context
+ */
+typedef struct _mq303a_context {
+    mraa_gpio_context       gpio;
+    mraa_aio_context        aio;
+    uint8_t                 gpio_pin;
+    uint8_t                 aio_pin;
+} *mq303a_context;
+
+/**
+ * MQ303A Initialization function
+ *
+ * @param pin Analog pin to use
+ * @param heaterPin Digital pin mapped to the analog pin to use
+ * @return void* pointer to the sensor struct
+ */
+mq303a_context mq303a_init(int pin, int heater_pin);
+
+/**
+ * MQ303A Initialization function
+ *
+ * @param void* pointer to the sensor struct
+ */
+void mq303a_close(mq303a_context dev);
+
+/**
+ * This function gets the value of the alcohol content
+ *
+ * @param void* pointer to the sensor struct
+ * @param *val pointer to store the reading
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t mq303a_get_value(mq303a_context dev, int* val);
+
+/**
+ * This function enables/disables the heater
+ * on board the sensor.
+ *
+ * @param void* pointer to the sensor struct
+ * @param bool to turn on/off heater
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t mq303a_heater_enable(mq303a_context dev, bool enable);
+
+#endif /* MQ303A_MQ303A_H_ */
diff --git a/ext/lib/upm/src/ms5803/Kbuild b/ext/lib/upm/src/ms5803/Kbuild
new file mode 100644
index 0000000..8aa78f3
--- /dev/null
+++ b/ext/lib/upm/src/ms5803/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ms5803) += ms5803.o
diff --git a/ext/lib/upm/src/ms5803/Kconfig b/ext/lib/upm/src/ms5803/Kconfig
new file mode 100644
index 0000000..a009f41
--- /dev/null
+++ b/ext/lib/upm/src/ms5803/Kconfig
@@ -0,0 +1,8 @@
+config UPM_ms5803
+    bool "ms5803"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm MS5803 Pressure and Temperature sensor
diff --git a/ext/lib/upm/src/ms5803/Makefile b/ext/lib/upm/src/ms5803/Makefile
new file mode 100644
index 0000000..405ceb2
--- /dev/null
+++ b/ext/lib/upm/src/ms5803/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ms5803
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ms5803
+endif
diff --git a/ext/lib/upm/src/ms5803/ms5803.c b/ext/lib/upm/src/ms5803/ms5803.c
new file mode 100644
index 0000000..d33dd03
--- /dev/null
+++ b/ext/lib/upm/src/ms5803/ms5803.c
@@ -0,0 +1,504 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <assert.h>
+
+#include "ms5803.h"
+
+#include <upm_math.h>
+#include <upm_platform.h>
+#include <upm_utilities.h>
+
+// quick binary power of 2 function
+#define POWB(type, exp) ((type)1 << exp)
+
+// For SPI, these are our CS on/off functions, if needed
+static void ms5803_cs_on(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->gpio)
+        mraa_gpio_write(dev->gpio, 0);
+}
+
+static void ms5803_cs_off(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->gpio)
+        mraa_gpio_write(dev->gpio, 1);
+}
+
+static upm_result_t ms5803_get_adc_value(const ms5803_context dev,
+                                         MS5803_CMD_T cmd,
+                                         MS5803_OSR_T dly,
+                                         uint32_t *value)
+{
+    assert(dev != NULL);
+
+    uint8_t buf[3];
+
+    if (ms5803_bus_write(dev, cmd, NULL, 0))
+    {
+        printf("%s: ms5802_bus_write() failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // need to delay for the appropriate time
+    upm_delay_ms(dly);
+
+    // now, get the 3 byte sample
+    if (ms5803_bus_read(dev, MS5803_CMD_ADC_READ, buf, 3))
+    {
+        printf("%s: ms5802_bus_read() failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    *value = ((buf[0] << 16) | (buf[1] << 8) | buf[2]);
+
+    return UPM_SUCCESS;
+}
+
+ms5803_context ms5803_init(unsigned int bus, int address, int cs_pin)
+{
+    ms5803_context dev =
+        (ms5803_context)malloc(sizeof(struct _ms5803_context));
+
+    if (!dev)
+        return NULL;
+
+    // zero out context
+    memset((void *)dev, 0, sizeof(struct _ms5803_context));
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        ms5803_close(dev);
+        return NULL;
+    }
+
+    if (address > 0)
+    {
+        // we are doing I2C
+        dev->isSPI = false;
+
+        if (!(dev->i2c = mraa_i2c_init(bus)))
+        {
+            printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
+            ms5803_close(dev);
+            return NULL;
+        }
+
+        if (mraa_i2c_address(dev->i2c, address) != MRAA_SUCCESS)
+        {
+            printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
+            ms5803_close(dev);
+            return NULL;
+        }
+
+#if defined(UPM_PLATFORM_ZEPHYR)
+        // we seem to need to stick qith 100khz for some reason with
+        // this device on Zephyr.  Even at 100Khz, while calibration
+        // data is now read correctly, there are other issues yet to
+        // be determined.  But as a first step, 100Khz is a
+        // requirement for this driver on Zephyr.
+        if (mraa_i2c_frequency(dev->i2c, MRAA_I2C_STD))
+        {
+            printf("%s: mraa_i2c_frequency() failed.\n", __FUNCTION__);
+            ms5803_close(dev);
+            return NULL;
+        }
+#endif // UPM_PLATFORM_ZEPHYR
+
+    }
+    else
+    {
+        // we are doing SPI
+        dev->isSPI = true;
+
+        if (!(dev->spi = mraa_spi_init(bus)))
+        {
+            printf("%s: mraa_spi_init() failed.\n", __FUNCTION__);
+            ms5803_close(dev);
+            return NULL;
+        }
+
+        // Only create cs context if we are actually using a valid pin.
+        // A hardware controlled pin should specify cs as -1.
+        if (cs_pin >= 0)
+        {
+            if (!(dev->gpio = mraa_gpio_init(cs_pin)))
+            {
+                printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
+                ms5803_close(dev);
+                return NULL;
+            }
+
+            mraa_gpio_dir(dev->gpio, MRAA_GPIO_OUT);
+            ms5803_cs_off(dev);
+        }
+
+        if (mraa_spi_mode(dev->spi, MRAA_SPI_MODE0))
+        {
+            printf("%s: mraa_spi_mode() failed.\n", __FUNCTION__);
+            ms5803_close(dev);
+            return NULL;
+        }
+
+        if (mraa_spi_frequency(dev->spi, 10000000))
+        {
+            printf("%s: mraa_spi_frequency() failed.\n", __FUNCTION__);
+            ms5803_close(dev);
+            return NULL;
+        }
+    }
+
+    // read factory coefficients
+    if (ms5803_load_coefficients(dev))
+    {
+        printf("%s: ms5803_load_coefficients() failed.\n", __FUNCTION__);
+        ms5803_close(dev);
+        return NULL;
+    }
+
+    // set the default OSR to the highest resolution
+    ms5803_set_temperature_osr(dev, MS5803_OSR_4096);
+    ms5803_set_pressure_osr(dev, MS5803_OSR_4096);
+
+    return dev;
+}
+
+void ms5803_close(ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->i2c)
+        mraa_i2c_stop(dev->i2c);
+
+    if (dev->spi)
+        mraa_spi_stop(dev->spi);
+
+    if (dev->gpio)
+        mraa_gpio_close(dev->gpio);
+
+    free(dev);
+}
+
+upm_result_t ms5803_update(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    // start by getting temperature and then pressure
+
+    uint32_t rawTemperature;
+    uint32_t rawPressure;
+
+    // temperature
+    if (ms5803_get_adc_value(dev, dev->temperatureCmd, dev->temperatureDelay,
+                             &rawTemperature))
+    {
+        printf("%s: ms5803_get_adc_value() failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // pressure
+    if (ms5803_get_adc_value(dev, dev->pressureCmd, dev->pressureDelay,
+                             &rawPressure))
+    {
+        printf("%s: ms5803_get_adc_value() failed.\n", __FUNCTION__);
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    printf("raw T = %u P = %u\n", rawTemperature, rawPressure);
+
+    // This algorithm comes from the datasheet.
+
+    // calc 1st order compensated temperature
+    int32_t dT = rawTemperature - dev->C[5] * POWB(int32_t, 8);
+    int32_t TEMP = 2000 + (int64_t)dT * dev->C[6] / POWB(int32_t, 23);
+
+    // calc compensated temp and pressure
+    int64_t OFF, SENS;
+    int32_t P = 0;
+
+    // first order compensation
+    OFF = dev->C[2] * POWB(int64_t, 16) + (dev->C[4] * dT)/POWB(int64_t, 7);
+    SENS = dev->C[1] * POWB(int64_t, 15) + (dev->C[3] * dT)/POWB(int64_t, 8);
+
+    // second order compensation
+    int64_t T2 = 0, OFF2 = 0, SENS2 = 0;
+    if (TEMP >= 2000)
+    {
+        // >=20C
+        T2 = 7 * (((uint64_t)dT * dT) / POWB(int64_t, 37));
+        OFF2 =  ((TEMP - 2000) * (TEMP - 2000)) / POWB(int64_t, 4);
+        SENS2 = 0;
+    }
+    else
+    {
+        T2 = 3 * (((uint64_t)dT * dT) / POWB(int64_t, 33));
+        OFF2 = 3 * ((TEMP - 2000) * (TEMP - 2000)) / POWB(int64_t, 1);
+        SENS2 = 5 * ((TEMP - 2000) * (TEMP - 2000)) / POWB(int64_t, 3);
+
+        // further compensation for very low temps
+        if (TEMP < 1500)
+        {
+            // <15C
+            OFF2 = OFF2 + 7 * ((TEMP + 1500) * (TEMP + 1500));
+            SENS2 = SENS2 + 4 * ((TEMP + 1500) * (TEMP + 1500));
+        }
+    }
+
+    // final caculation
+    TEMP = TEMP - T2;
+    OFF = OFF - OFF2;
+    SENS = SENS - SENS2;
+    P = (rawPressure * SENS/POWB(int64_t, 21) - OFF)/POWB(int64_t, 15);
+
+    dev->temperature = (float)TEMP / 100.0;
+    dev->pressure = (float)P/10.0;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t ms5803_load_coefficients(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    // we will load them all, even though only 6 of them are of use to us
+    uint8_t buffer[2];
+
+    for (int i=0; i<MS5803_MAX_COEFFICIENTS; i++)
+    {
+        uint8_t cmd = MS5803_CMD_PROM_READ | ((i & 7) << 1);
+        if (ms5803_bus_read(dev, cmd, buffer, 2))
+        {
+            printf("%s: ms5802_bus_read() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+
+        dev->C[i] = (buffer[0] << 8) | buffer[1];
+        printf("C[%d] = %u\n", i, dev->C[i]);
+    }
+
+    return UPM_SUCCESS;
+}
+
+// i2c bus read and write functions
+upm_result_t ms5803_bus_read(const ms5803_context dev, uint8_t cmd,
+                             uint8_t *data, uint8_t len)
+{
+    assert(dev != NULL);
+
+    if (dev->isSPI)
+    {
+        // SPI
+
+        uint8_t sbuf[len + 1];
+        memset((void *)sbuf, 0, len + 1);
+        sbuf[0] = cmd;
+
+        ms5803_cs_on(dev);
+
+        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
+        {
+            ms5803_cs_off(dev);
+            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+        ms5803_cs_off(dev);
+
+        // now copy it into user buffer
+        for (int i=0; i<len; i++)
+            data[i] = sbuf[i + 1];
+    }
+    else
+    {
+        // I2C
+
+        if (mraa_i2c_read_bytes_data(dev->i2c, cmd, data, len) < 0)
+        {
+            printf("%s: mraa_i2c_read_bytes() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+    }
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t ms5803_bus_write(const ms5803_context dev, uint8_t cmd,
+                              uint8_t *data, uint8_t len)
+{
+    assert(dev != NULL);
+
+    if (dev->isSPI)
+    {
+        // SPI
+
+        uint8_t sbuf[len + 1];
+        memset((void *)sbuf, 0, len + 1);
+        sbuf[0] = cmd;
+
+        // copy in the data to write...
+        if (data && len)
+        {
+            for (int i=0; i<len; i++)
+                sbuf[i + 1] = data[i];
+        }
+
+        ms5803_cs_on(dev);
+
+        if (mraa_spi_transfer_buf(dev->spi, sbuf, sbuf, len + 1))
+        {
+            ms5803_cs_off(dev);
+            printf("%s: mraa_spi_transfer_buf() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+        ms5803_cs_off(dev);
+    }
+    else
+    {
+        // I2C...
+
+        uint8_t buffer[len + 1];
+
+        buffer[0] = cmd;
+
+        if (data && len)
+        {
+            for (int i=0; i<len; i++)
+                buffer[i+1] = data[i];
+        }
+
+        mraa_result_t rv = mraa_i2c_write(dev->i2c, buffer, len+1);
+
+        if (rv != MRAA_SUCCESS)
+        {
+            printf("%s: mraa_i2c_write() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+    }
+
+    return UPM_SUCCESS;
+}
+
+void ms5803_set_temperature_osr(const ms5803_context dev, MS5803_OSR_T osr)
+{
+    assert(dev != NULL);
+
+    switch(osr)
+    {
+    case MS5803_OSR_256:
+        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_256;
+        break;
+
+    case MS5803_OSR_512:
+        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_512;
+        break;
+
+    case MS5803_OSR_1024:
+        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_1024;
+        break;
+
+    case MS5803_OSR_2048:
+        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_2048;
+        break;
+
+    case MS5803_OSR_4096:
+        dev->temperatureCmd = MS5803_CMD_CONVERT_D2_OSR_4096;
+        break;
+
+    default:
+        // can't happen in this universe
+        printf("%s: Internal error, invalid osr value %d\n", __FUNCTION__,
+               (int)osr);
+        return;
+    }
+
+    dev->temperatureDelay = osr;
+}
+
+void ms5803_set_pressure_osr(const ms5803_context dev, MS5803_OSR_T osr)
+{
+    assert(dev != NULL);
+
+    switch(osr)
+    {
+    case MS5803_OSR_256:
+        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_256;
+        break;
+
+    case MS5803_OSR_512:
+        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_512;
+        break;
+
+    case MS5803_OSR_1024:
+        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_1024;
+        break;
+
+    case MS5803_OSR_2048:
+        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_2048;
+        break;
+
+    case MS5803_OSR_4096:
+        dev->pressureCmd = MS5803_CMD_CONVERT_D1_OSR_4096;
+        break;
+
+    default:
+        // can't happen in this universe
+        printf("%s: Internal error, invalid osr value %d\n", __FUNCTION__,
+               (int)osr);
+        return;
+    }
+
+    dev->pressureDelay = osr;
+}
+
+upm_result_t ms5803_reset(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    upm_result_t rv = ms5803_bus_write(dev, MS5803_CMD_RESET, NULL, 0);
+    upm_delay_ms(5);
+
+    return rv;
+}
+
+float ms5803_get_temperature(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->temperature;
+}
+
+float ms5803_get_pressure(const ms5803_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->pressure;
+}
diff --git a/ext/lib/upm/src/ms5803/ms5803.h b/ext/lib/upm/src/ms5803/ms5803.h
new file mode 100644
index 0000000..dd68e5d
--- /dev/null
+++ b/ext/lib/upm/src/ms5803/ms5803.h
@@ -0,0 +1,205 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/i2c.h>
+#include <mraa/spi.h>
+#include <mraa/gpio.h>
+
+#include <ms5803_defs.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file ms5803
+     * @library ms5803
+     * @brief C API for the MS5803 Pressure and Temperature sensor
+     *
+     * @include ms5803.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _ms5803_context {
+        mraa_i2c_context        i2c;
+        mraa_spi_context        spi;
+        // CS pin, if we are using one
+        mraa_gpio_context       gpio;
+
+        // whether we are doing I2C or SPI
+        bool                    isSPI;
+
+        // stored calibration coefficients
+        uint16_t                C[MS5803_MAX_COEFFICIENTS];
+
+        // the command sent to chip depending on OSR configuration for
+        // temperature and pressure measurement.
+        MS5803_CMD_T            temperatureCmd;
+        MS5803_OSR_T            temperatureDelay;
+
+        MS5803_CMD_T            pressureCmd;
+        MS5803_OSR_T            pressureDelay;
+
+        // compensated temperature in C
+        float                   temperature;
+        // compensated pressure in millibars
+        float                   pressure;
+    } *ms5803_context;
+
+    /**
+     * MS5803 initializer
+     *
+     * @param bus i2c/spi bus to use
+     * @param address The address for this device if using I2C.  If
+     * using SPI, supply -1 for this parameter.
+     * @param cs_pin The GPIO pin to use for Chip Select (CS).  This is
+     * only needed for SPI, and only if your SPI implementation
+     * requires it.  Otherwise, just pass -1 if not using SPI, or your
+     * CS is handled automatically by your SPI implementation.
+     * @return an initialized device context on success, NULL on error.
+     */
+    ms5803_context ms5803_init(unsigned int bus, int address, int cs_pin);
+
+    /**
+     * MS5803 close
+     *
+     * @param dev Device context.
+     */
+    void ms5803_close(ms5803_context dev);
+
+    /**
+     * Reset the device.
+     *
+     * @param dev Device context.
+     * @return UPM Status.
+     */
+    upm_result_t ms5803_reset(const ms5803_context dev);
+
+    /**
+     * Take measurements and store the current sensor values
+     * internally.  This function must be called prior to retrieving
+     * any sensor values, for example ms5803_get_temperature().
+     *
+     * @param dev Device context.
+     */
+    upm_result_t ms5803_update(const ms5803_context dev);
+
+    /**
+     * Set the output sampling resolution of the temperature
+     * measurement.  Higher values provide a more precise value.  In
+     * addition, more precise values require more time to measure.
+     * The default set at device intialization is the highest
+     * precision supported: MS5803_OSR_4096
+     *
+     * @param dev Device context.
+     * @param dev One of the MS5803_OSR_T values.
+     */
+    void ms5803_set_temperature_osr(const ms5803_context dev,
+                                    MS5803_OSR_T osr);
+
+    /**
+     * Set the output sampling resolution of the pressure
+     * measurement.  Higher values provide a more precise value.  In
+     * addition, more precise values require more time to measure.
+     * The default set at device intialization is the highest
+     * precision supported: MS5803_OSR_4096
+     *
+     * @param dev Device context.
+     * @param dev One of the MS5803_OSR_T values.
+     */
+    void ms5803_set_pressure_osr(const ms5803_context dev,
+                                 MS5803_OSR_T osr);
+
+    /**
+     * Return the latest measured temperature.  ms5803_update() must
+     * have been called prior to calling this function.  The returned
+     * value is in degrees Celsius.
+     *
+     * @param dev Device context.
+     * @return Temperature in degrees C
+     */
+    float ms5803_get_temperature(const ms5803_context dev);
+
+    /**
+     * Return the latest measured pressure.  ms5803_update() must have
+     * been called prior to calling this function.  The returned value
+     * is in millibars.
+     *
+     * @param dev Device context.
+     * @return Pressure in mbar
+     */
+    float ms5803_get_pressure(const ms5803_context dev);
+
+    /**
+     * Load a series of factory installed compensation coefficients.
+     * This function is called during ms5803_init(), so it should
+     * never need to be called again.  It is provided here anyway
+     * "just in case".
+     *
+     * @param dev Device context.
+     * @return UPM Status.
+     */
+    upm_result_t ms5803_load_coefficients(const ms5803_context dev);
+
+    /**
+     * Perform a bus read.  This function is bus agnostic.  It is
+     * exposed here for those users wishing to perform their own low
+     * level accesses.  This is a low level function, and should not
+     * be used unless you know what you are doing.
+     *
+     * @param dev Device context
+     * @param cmd The command to send.
+     * @param data A pointer to a buffer in which data will be read into.
+     * @param len The number of bytes to read.
+     * @return UPM Status
+     */
+    upm_result_t ms5803_bus_read(const ms5803_context dev, uint8_t cmd,
+                                 uint8_t *data, uint8_t len);
+
+    /**
+     * Perform a bus write.  This function is bus agnostic.  It is
+     * exposed here for those users wishing to perform their own low
+     * level accesses.  This is a low level function, and should not
+     * be used unless you know what you are doing.
+     *
+     * @param dev Device context
+     * @param cmd The command to send.
+     * @param data A pointer to a buffer containing data to write.
+     * @param len The number of bytes to write.
+     * @return UPM Status
+     */
+    upm_result_t ms5803_bus_write(const ms5803_context dev, uint8_t cmd,
+                                  uint8_t *data, uint8_t len);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/ms5803/ms5803_defs.h b/ext/lib/upm/src/ms5803/ms5803_defs.h
new file mode 100644
index 0000000..825fce4
--- /dev/null
+++ b/ext/lib/upm/src/ms5803/ms5803_defs.h
@@ -0,0 +1,77 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// default I2C address
+#define MS5803_DEFAULT_I2C_ADDR 0x76
+
+#define MS5803_MAX_COEFFICIENTS (8)
+
+    // valid commands
+    typedef enum {
+        MS5803_CMD_RESET                = 0x1e,
+
+        // D1 = pressure
+        MS5803_CMD_CONVERT_D1_OSR_256   = 0x40,
+        MS5803_CMD_CONVERT_D1_OSR_512   = 0x42,
+        MS5803_CMD_CONVERT_D1_OSR_1024  = 0x44,
+        MS5803_CMD_CONVERT_D1_OSR_2048  = 0x46,
+        MS5803_CMD_CONVERT_D1_OSR_4096  = 0x48,
+
+        // D2 = temperature
+        MS5803_CMD_CONVERT_D2_OSR_256   = 0x50,
+        MS5803_CMD_CONVERT_D2_OSR_512   = 0x52,
+        MS5803_CMD_CONVERT_D2_OSR_1024  = 0x54,
+        MS5803_CMD_CONVERT_D2_OSR_2048  = 0x56,
+        MS5803_CMD_CONVERT_D2_OSR_4096  = 0x58,
+
+        // ADC read
+        MS5803_CMD_ADC_READ             = 0x00,
+
+        // PROM read.  Bits 1, 2, and 3 indicate the address. Bit 0 is
+        // always 0 (in all commands).  There are 7 PROM locations,
+        // each 2 bytes in length.  These locations store factory
+        // loaded compensation coefficients.
+        MS5803_CMD_PROM_READ            = 0xa0
+    } MS5803_CMD_T;
+
+    // output sampling resolution for temperature and pressure.  We
+    // set the numeric values here to indicate the required wait time
+    // for each in milliseconds (rounded up from the datasheet
+    // maximums), so do not change these numbers.
+    typedef enum {
+        MS5803_OSR_256                  = 1, // 1ms
+        MS5803_OSR_512                  = 2,
+        MS5803_OSR_1024                 = 3,
+        MS5803_OSR_2048                 = 5,
+        MS5803_OSR_4096                 = 10
+    } MS5803_OSR_T;
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/my9221/Kbuild b/ext/lib/upm/src/my9221/Kbuild
new file mode 100644
index 0000000..bd3d7a3
--- /dev/null
+++ b/ext/lib/upm/src/my9221/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_my9221) += my9221.o
diff --git a/ext/lib/upm/src/my9221/Kconfig b/ext/lib/upm/src/my9221/Kconfig
new file mode 100644
index 0000000..85b63d9
--- /dev/null
+++ b/ext/lib/upm/src/my9221/Kconfig
@@ -0,0 +1,8 @@
+config UPM_my9221
+    bool "my9221"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm MY9221 LED Controller
diff --git a/ext/lib/upm/src/my9221/Makefile b/ext/lib/upm/src/my9221/Makefile
new file mode 100644
index 0000000..6981dcd
--- /dev/null
+++ b/ext/lib/upm/src/my9221/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_my9221
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/my9221
+endif
diff --git a/ext/lib/upm/src/my9221/my9221.c b/ext/lib/upm/src/my9221/my9221.c
new file mode 100644
index 0000000..5329408
--- /dev/null
+++ b/ext/lib/upm/src/my9221/my9221.c
@@ -0,0 +1,286 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * These modules were rewritten, based on original work by:
+ *
+ * (original my9221/groveledbar driver)
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * (grovecircularled driver)
+ * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Contributions: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include <string.h>
+
+#include <upm_utilities.h>
+#include <upm_platform.h>
+
+#include "my9221.h"
+
+// 12 LED channels per chip (instance)
+#define LEDS_PER_INSTANCE (12)
+
+// forward declarations
+static void my9221_lock_data(const my9221_context dev);
+static void my9221_send_16bit_block(const my9221_context dev, uint16_t data);
+
+my9221_context my9221_init(uint8_t dataPin, uint8_t clockPin,
+                           int instances)
+{
+    if (instances < 1)
+        instances = 1;
+
+    my9221_context dev =
+        (my9221_context)malloc(sizeof(struct _my9221_context));
+
+    if (!dev)
+        return NULL;
+
+    memset((void *)dev, 0, sizeof(struct _my9221_context));
+    dev->gpioClk = NULL;
+    dev->gpioData = NULL;
+
+    // make sure MRAA is initialized
+    mraa_result_t mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        my9221_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->gpioClk = mraa_gpio_init(clockPin)) )
+    {
+        printf("%s: mraa_gpio_init(clk) failed\n",
+               __FUNCTION__);
+        my9221_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpioClk, MRAA_GPIO_OUT);
+
+
+    if ( !(dev->gpioData = mraa_gpio_init(dataPin)) )
+    {
+        printf("%s: mraa_gpio_init(data) failed\n",
+               __FUNCTION__);
+        my9221_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpioData, MRAA_GPIO_OUT);
+
+#if defined(UPM_PLATFORM_LINUX)
+    // we warn if these fail, since it may not be possible to handle
+    // more than one instance
+
+    if (mraa_gpio_use_mmaped(dev->gpioClk, 1))
+        printf("%s: Warning: mmap of Clk pin failed, correct operation "
+               "may be affected.\n", __FUNCTION__);
+
+    if (mraa_gpio_use_mmaped(dev->gpioData, 1))
+        printf("%s: Warning: mmap of Data pin failed, correct operation "
+               "may be affected.\n", __FUNCTION__);
+#endif // UPM_PLATFORM_LINUX
+
+    my9221_set_low_intensity_value(dev, 0x00);   // full off
+    my9221_set_high_intensity_value(dev, 0xff);  // full bright
+
+    dev->commandWord = 0x0000;       // all defaults
+    dev->instances = instances;
+
+    if ( !(dev->bitStates =
+           malloc(sizeof(uint16_t) * instances * LEDS_PER_INSTANCE) ) )
+    {
+        printf("%s: bit state allocation failed\n",
+               __FUNCTION__);
+        my9221_close(dev);
+        return NULL;
+    }
+
+    my9221_set_auto_refresh(dev, true);
+    my9221_clear_all(dev);
+
+
+    dev->maxLEDS = dev->instances * LEDS_PER_INSTANCE;
+    dev->initialized = true;
+    return dev;
+}
+
+void my9221_close(my9221_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->initialized)
+    {
+        my9221_clear_all(dev);
+
+        if (!dev->autoRefresh)
+            my9221_refresh(dev);
+    }
+
+    if (dev->bitStates)
+        free(dev->bitStates);
+
+    if (dev->gpioClk)
+        mraa_gpio_close(dev->gpioClk);
+    if (dev->gpioData)
+        mraa_gpio_close(dev->gpioData);
+
+    free(dev);
+}
+
+void my9221_set_led(const my9221_context dev, int led, bool on)
+{
+    assert(dev != NULL);
+
+    int maxLed = dev->maxLEDS - 1;
+
+    if (led > maxLed)
+        led = maxLed;
+    if (led < 0)
+        led = 0;
+
+    dev->bitStates[led] = (on) ? dev->highIntensity : dev->lowIntensity;
+
+    if (dev->autoRefresh)
+        my9221_refresh(dev);
+}
+
+void my9221_set_low_intensity_value(const my9221_context dev,
+                                    int intensity)
+{
+    assert(dev != NULL);
+
+    dev->lowIntensity = (intensity & 0xff);
+}
+
+void my9221_set_high_intensity_value(const my9221_context dev,
+                                     int intensity)
+{
+    assert(dev != NULL);
+
+    dev->highIntensity = (intensity & 0xff);
+}
+
+void my9221_set_all(const my9221_context dev)
+{
+    assert(dev != NULL);
+
+    for (unsigned int i=0; i<dev->maxLEDS; i++)
+        dev->bitStates[i] = dev->highIntensity;
+
+    if (dev->autoRefresh)
+        my9221_refresh(dev);
+}
+
+void my9221_clear_all(const my9221_context dev)
+{
+    assert(dev != NULL);
+
+    for (unsigned int i=0; i<dev->maxLEDS; i++)
+        dev->bitStates[i] = dev->lowIntensity;
+
+    if (dev->autoRefresh)
+        my9221_refresh(dev);
+}
+
+void my9221_refresh(const my9221_context dev)
+{
+    assert(dev != NULL);
+
+    for (unsigned int i=0; i<dev->maxLEDS; i++)
+    {
+        if (i % 12 == 0)
+        {
+            my9221_send_16bit_block(dev, dev->commandWord);
+        }
+        my9221_send_16bit_block(dev, dev->bitStates[i]);
+    }
+
+    my9221_lock_data(dev);
+}
+
+void my9221_set_auto_refresh(const my9221_context dev, bool enable)
+{
+    assert(dev != NULL);
+
+    dev->autoRefresh = enable;
+}
+
+int my9221_get_max_leds(const my9221_context dev)
+{
+    assert(dev != NULL);
+
+    return dev->maxLEDS;
+}
+
+static void my9221_lock_data(const my9221_context dev)
+{
+    assert(dev != NULL);
+
+    mraa_gpio_write(dev->gpioData, 0);
+    upm_delay_us(220);
+
+    for (int idx = 0; idx < 4; idx++)
+    {
+        mraa_gpio_write(dev->gpioData, 1);
+        mraa_gpio_write(dev->gpioData, 0);
+    }
+
+    // in reality, we only need > 200ns + (dev->instances * 10ns), so the
+    // following should be good for up to dev->instances < 80), if the
+    // datasheet is to be believed :)
+    upm_delay_us(1);
+
+    return;
+}
+
+static void my9221_send_16bit_block(const my9221_context dev, uint16_t data)
+{
+    assert(dev != NULL);
+
+    for (uint8_t bit_idx = 0; bit_idx < 16; bit_idx++)
+    {
+        uint32_t state = (data & 0x8000) ? 1 : 0;
+        mraa_gpio_write(dev->gpioData, state);
+
+        state = mraa_gpio_read(dev->gpioClk);
+
+        if (state)
+            state = 0;
+        else
+            state = 1;
+
+        mraa_gpio_write(dev->gpioClk, state);
+
+        data <<= 1;
+    }
+
+    return;
+}
diff --git a/ext/lib/upm/src/my9221/my9221.h b/ext/lib/upm/src/my9221/my9221.h
new file mode 100644
index 0000000..c64c7c4
--- /dev/null
+++ b/ext/lib/upm/src/my9221/my9221.h
@@ -0,0 +1,180 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * These modules were rewritten, based on original work by:
+ *
+ * (original my9221/groveledbar)
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * (grovecircularled)
+ * Author: Jun Kato and Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ * Contributions: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file my9221.h
+     * @library my9221
+     * @brief C API for the my9221 driver
+     *
+     * @include my9221.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _my9221_context {
+        mraa_gpio_context gpioClk;
+        mraa_gpio_context gpioData;
+
+        bool              autoRefresh;
+        // we're only doing 8-bit greyscale, so the high order bits are
+        // always 0
+        uint16_t          lowIntensity;
+        uint16_t          highIntensity;
+
+        unsigned int      instances;
+        unsigned int      maxLEDS;
+
+        // an array of uint16_t's representing our bit states (on/off)
+        // intensities.  Only the low 8 bits are used, but in the future
+        // 16bit support can work here as well.
+        uint16_t          *bitStates;
+
+        uint16_t          commandWord;
+
+        bool              initialized;
+    } *my9221_context;
+
+
+    /**
+     * Instantiates an MY9221 object
+     *
+     * @param dataPin Data pin
+     * @param clockPin Clock pin
+     * @param instances Number of daisy-chained my9221s, must be at
+     * least 1
+     * @return Device context
+     */
+    my9221_context my9221_init(uint8_t dataPin, uint8_t clockPin,
+                               int instances);
+
+    /**
+     * MY9221 close
+     *
+     * @param dev Device context
+     */
+    void my9221_close(my9221_context dev);
+
+    /**
+     * Enable or disable auto refresh.  When auto refresh is enabled,
+     * update the LED display as soon as the internal state changes.
+     * When false, the display(s) will not be updated until the
+     * refresh() method is called.
+     *
+     * @param dev Device context
+     * @param enable true to enable auto refresh, false otherwise
+     */
+    void my9221_set_auto_refresh(const my9221_context dev, bool enable);
+
+    /**
+     * Set an LED to a specific on (high intensity) or off (low
+     * intensity) value.
+     *
+     * @param dev Device context
+     * @param led The LED whose state you wish to change
+     * @param on true to turn on the LED, false to turn the LED off
+     */
+    void my9221_set_led(const my9221_context dev, int led, bool on);
+
+    /**
+     * Set the greyscale intensity of an LED in the OFF state.  The
+     * intensity is a value from 0 (fully off) to 255 (fully on).
+     * This will take effect on any future LED set or clear
+     * operations.
+     *
+     * @param dev Device context
+     * @param intensity a value from 0 (fully off) to 255 (fully on)
+     */
+    void my9221_set_low_intensity_value(const my9221_context dev,
+                                        int intensity);
+
+    /**
+     * Set the greyscale intensity of an LED in the ON state.  The
+     * intensity is a value from 0 (fully off) to 255 (fully on).
+     * This will take effect on any future LED set or clear
+     * operations.
+     *
+     * @param dev Device context
+     * @param intensity a value from 0 (fully off) to 255 (fully on)
+     */
+    void my9221_set_high_intensity_value(const my9221_context dev,
+                                         int intensity);
+
+    /**
+     * Set all of the LEDS to the ON (high intensity value) state.
+     *
+     * @param dev Device context
+     */
+    void my9221_set_all(const my9221_context dev);
+
+    /**
+     * Set all of the LEDS to the OFF (low intensity value) state.
+     *
+     * @param dev Device context
+     */
+    void my9221_clear_all(const my9221_context dev);
+
+    /**
+     * Set the LED states to match the internal stored states.  This
+     * is useful when auto refresh (setAutoRefresh()) is false to
+     * update the display.
+     *
+     * @param dev Device context
+     */
+    void my9221_refresh(const my9221_context dev);
+
+    /**
+     * Return the maximum number of LEDs present, based on the number
+     * of instances specified when the device context was initialized.
+     *
+     * @param dev Device context
+     * @return The number of LEDs that can be controlled.
+     */
+    int my9221_get_max_leds(const my9221_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/nmea_gps/Kbuild b/ext/lib/upm/src/nmea_gps/Kbuild
new file mode 100644
index 0000000..2785a63
--- /dev/null
+++ b/ext/lib/upm/src/nmea_gps/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_nmea_gps) += nmea_gps.o
diff --git a/ext/lib/upm/src/nmea_gps/Kconfig b/ext/lib/upm/src/nmea_gps/Kconfig
new file mode 100644
index 0000000..44fa300
--- /dev/null
+++ b/ext/lib/upm/src/nmea_gps/Kconfig
@@ -0,0 +1,9 @@
+config UPM_nmea_gps
+    bool "nmea_gps"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM Generic driver for GPS NMEA sensors
+
diff --git a/ext/lib/upm/src/nmea_gps/Makefile b/ext/lib/upm/src/nmea_gps/Makefile
new file mode 100644
index 0000000..f954349
--- /dev/null
+++ b/ext/lib/upm/src/nmea_gps/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_nmea_gps
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/nmea_gps
+endif
diff --git a/ext/lib/upm/src/nmea_gps/nmea_gps.c b/ext/lib/upm/src/nmea_gps/nmea_gps.c
new file mode 100644
index 0000000..03a8b2c
--- /dev/null
+++ b/ext/lib/upm/src/nmea_gps/nmea_gps.c
@@ -0,0 +1,291 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+
+#include "nmea_gps.h"
+
+#include "upm_utilities.h"
+
+// For ublox6 and compatible I2C communications (see the u-blox6
+// Receiver Description Protocol Specification datasheet for details).
+
+#define UBLOX6_I2C_BYTES_AVAIL_H                0xfd
+#define UBLOX6_I2C_BYTES_AVAIL_L                0xfe
+#define UBLOX6_I2C_BYTE_STREAM                  0xff
+
+#define UBLOX6_I2C_BYTE_NONE                    0xff // read if no data avail
+
+// static helpers for i2c reading
+static uint8_t readReg(const nmea_gps_context dev, uint8_t reg)
+{
+  assert(dev != NULL);
+  assert(dev->i2c != NULL);
+
+  int rv;
+  if ((rv = mraa_i2c_read_byte_data(dev->i2c, reg)) < 0)
+    printf("%s: mraa_i2c_read_byte_data() failed.\n", __FUNCTION__);
+
+  // This will return 0xff on errors, which is invalid NMEA data anyway.
+  return (uint8_t)rv;
+}
+
+static int readRegs(const nmea_gps_context dev, uint8_t reg,
+                    uint8_t *buffer, int len)
+{
+  assert(dev != NULL);
+  assert(dev->i2c != NULL);
+
+  int rv;
+  if ((rv = mraa_i2c_read_bytes_data(dev->i2c, reg, buffer, len)) < 0)
+    {
+      printf("%s: mraa_i2c_read_bytes_data() failed.\n", __FUNCTION__);
+    }
+
+  return rv;
+}
+
+// uart init
+nmea_gps_context nmea_gps_init(unsigned int uart, unsigned int baudrate,
+                               int enable_pin)
+{
+  nmea_gps_context dev =
+    (nmea_gps_context)malloc(sizeof(struct _nmea_gps_context));
+
+  if (!dev)
+    return NULL;
+
+  // zero out context
+  memset((void *)dev, 0, sizeof(struct _nmea_gps_context));
+  
+  dev->uart = NULL;
+  dev->i2c = NULL;
+  dev->gpio_en = NULL;
+
+  // initialize the MRAA contexts
+
+  // uart, default should be 8N1
+  if (!(dev->uart = mraa_uart_init(uart)))
+    {
+      printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
+      nmea_gps_close(dev);
+      return NULL;
+    }
+
+  if (nmea_gps_set_baudrate(dev, baudrate))
+    {
+      printf("%s: nmea_gps_set_baudrate() failed.\n", __FUNCTION__);
+      nmea_gps_close(dev);
+      return NULL;
+    }      
+
+  mraa_uart_set_flowcontrol(dev->uart, false, false);
+
+  // now the gpio_en, if enabled
+  if (enable_pin >= 0)
+    {
+      if (!(dev->gpio_en = mraa_gpio_init(enable_pin)))
+        {
+          printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
+          nmea_gps_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_en, MRAA_GPIO_OUT);
+
+      // wake up
+      nmea_gps_enable(dev, true);
+    }
+
+  return dev;
+}
+
+// i2c ublox init
+nmea_gps_context nmea_gps_init_ublox_i2c(unsigned int bus, uint8_t addr)
+{
+  nmea_gps_context dev =
+    (nmea_gps_context)malloc(sizeof(struct _nmea_gps_context));
+
+  if (!dev)
+    return NULL;
+
+  // zero out context
+  memset((void *)dev, 0, sizeof(struct _nmea_gps_context));
+
+  dev->uart = NULL;
+  dev->i2c = NULL;
+  dev->gpio_en = NULL;
+
+  // initialize the MRAA contexts
+
+  if (!(dev->i2c = mraa_i2c_init(bus)))
+    {
+      printf("%s: mraa_i2c_init() failed.\n", __FUNCTION__);
+      nmea_gps_close(dev);
+      return NULL;
+    }
+
+  // This device cannot operate at more than 100Khz, so we set that
+  // here and bail if it fails.
+
+  if (mraa_i2c_frequency(dev->i2c, MRAA_I2C_STD))
+    {
+      printf("%s: mraa_i2c_frequency(MRAA_I2C_STD) failed.\n", __FUNCTION__);
+      nmea_gps_close(dev);
+      return NULL;
+    }
+
+  if (mraa_i2c_address(dev->i2c, addr))
+    {
+      printf("%s: mraa_i2c_address() failed.\n", __FUNCTION__);
+      nmea_gps_close(dev);
+      return NULL;
+    }
+
+  return dev;
+}
+
+void nmea_gps_close(nmea_gps_context dev)
+{
+  assert(dev != NULL);
+
+  // sleepy-time
+  nmea_gps_enable(dev, false);
+
+  if (dev->uart)
+    mraa_uart_stop(dev->uart);
+  if (dev->i2c)
+    mraa_i2c_stop(dev->i2c);
+  if (dev->gpio_en)
+    mraa_gpio_close(dev->gpio_en);
+
+  free(dev);
+}
+
+upm_result_t nmea_gps_enable(const nmea_gps_context dev, bool enable)
+{
+  assert(dev != NULL);
+
+  if (!dev->gpio_en)
+    return UPM_ERROR_NO_RESOURCES;
+
+  if (enable)
+    mraa_gpio_write(dev->gpio_en, 1);
+  else
+    mraa_gpio_write(dev->gpio_en, 0);
+
+  return UPM_SUCCESS;
+}
+
+int nmea_gps_read(const nmea_gps_context dev, char *buffer, size_t len)
+{
+  assert(dev != NULL);
+
+  // i2c ublox
+  if (dev->i2c)
+    {
+      int rv;
+      if ((rv = readRegs(dev, UBLOX6_I2C_BYTE_STREAM, buffer, len)) < 0)
+        return rv;
+
+      // now we need to go through the bytes returned, and stop
+      // counting "real" bytes when we hit any character with the high
+      // bit set.  The documentation implies that only a 0xff will be
+      // sent when no new data is available, but it seems sometimes
+      // the return contains 0xbf and 0xc3 bytes.  So we stop counting
+      // as soon as we see any "8 bit" character (which isn't allowed
+      // by NMEA anyway).
+      int realBytes = 0;
+      int i;
+
+      for (i=0; i<rv; i++)
+        {
+          if (buffer[i] & 0x80)
+            break;
+
+          realBytes++;
+        }
+
+      return realBytes;
+    }
+
+  // uart
+  return mraa_uart_read(dev->uart, buffer, len);
+}
+
+int nmea_gps_write(const nmea_gps_context dev, char *buffer, size_t len)
+{
+  assert(dev != NULL);
+
+  if (!dev->uart)
+    return UPM_ERROR_NO_RESOURCES;
+
+  return mraa_uart_write(dev->uart, buffer, len);
+}
+
+bool nmea_gps_data_available(const nmea_gps_context dev, unsigned int millis)
+{
+  assert(dev != NULL);
+
+  // i2c ublox
+  if (dev->i2c)
+    {
+      // here millis is ignored
+      uint8_t h, l;
+
+      h = readReg(dev, UBLOX6_I2C_BYTES_AVAIL_H);
+      l = readReg(dev, UBLOX6_I2C_BYTES_AVAIL_L);
+
+      uint16_t total = (h << 8) | l;
+      // 0 means no data available, 0xffff means read errors
+      if (total == 0x0000 || total == 0xffff)
+        return false;
+      else
+        return true;
+    }
+
+  // uart
+  if (mraa_uart_data_available(dev->uart, millis))
+    return true;
+  else
+    return false;
+}
+
+upm_result_t nmea_gps_set_baudrate(const nmea_gps_context dev,
+                                   unsigned int baudrate)
+{
+  assert(dev != NULL);
+
+  if (!dev->uart)
+    return UPM_ERROR_NO_RESOURCES;
+
+  if (mraa_uart_set_baudrate(dev->uart, baudrate))
+    {
+      printf("%s: mraa_uart_set_baudrate() failed.\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }      
+
+  return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/nmea_gps/nmea_gps.h b/ext/lib/upm/src/nmea_gps/nmea_gps.h
new file mode 100644
index 0000000..e8e72b6
--- /dev/null
+++ b/ext/lib/upm/src/nmea_gps/nmea_gps.h
@@ -0,0 +1,152 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/uart.h"
+#include "mraa/i2c.h"
+#include "mraa/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /**
+   * @brief UPM C API for a generic GPS serial device reporting NMEA data
+   *
+   * This driver was tested with a number of GPS devices that emit
+   * NMEA data via a serial interface of some sort (typically a UART).
+   *
+   * The I2C capablity was tested with a UBLOX LEA-6H based GPS shield
+   * from DFRobot.  Currently, the I2C capability is only supported
+   * for UBLOX devices (or compatibles) that conform to the
+   * specifications outlined in the u-blox6 Receiver Description
+   * Protocol Specification, Chapter 4, DDC Port.
+   *
+   * An example using the UART.
+   * @snippet nmea_gps.c Interesting
+   * An example using I2C.
+   * @snippet nmea_gps_i2c.c Interesting
+   */
+  
+  /**
+   * Device context
+   */
+  typedef struct _nmea_gps_context {
+    mraa_uart_context        uart;
+    mraa_gpio_context        gpio_en;
+    mraa_i2c_context         i2c;
+  } *nmea_gps_context;
+  
+  /**
+   * NMEA_GPS Initializer for generic UART operation
+   *
+   * @param uart Specify which uart to use.
+   * @param baudrate Specify the baudrate to use.  The device defaults
+   * to 9600 baud.
+   * @param enable_pin Specify the GPIO pin to use for the enable pin,
+   * -1 to not use an enable pin.
+   * @return an initialized device context on success, NULL on error.
+   */
+  nmea_gps_context nmea_gps_init(unsigned int uart, unsigned int baudrate,
+                                 int enable_pin);
+
+  /**
+   * NMEA_GPS Initializer for UBLOX I2C operation
+   *
+   * @param bus Specify which the I2C bus to use.
+   * @param addr Specify the I2C address to use.  For UBLOX devices,
+   * this typically defaults to 0x42.
+   * @return an initialized device context on success, NULL on error.
+   */
+  nmea_gps_context nmea_gps_init_ublox_i2c(unsigned int bus, uint8_t addr);
+
+  /**
+   * NMEA_GPS sensor close function
+   */
+  void nmea_gps_close(nmea_gps_context dev);
+
+  /**
+   * Read character data from the device.
+   *
+   * @param dev sensor context
+   * @param buffer The character buffer to read data into.
+   * @param len The maximum size of the buffer
+   * @return The number of bytes successfully read, or -1 on error
+   */
+  int nmea_gps_read(const nmea_gps_context dev, char *buffer, size_t len);
+
+  /**
+   * Write character data to the device.  This is only valid for a
+   * UART device.
+   *
+   * @param dev sensor context
+   * @param buffer The character buffer containing data to write.
+   * @param len The number of bytes to write.
+   * @return The number of bytes successfully written, or -1 on error.
+   */
+  int nmea_gps_write(const nmea_gps_context dev, char *buffer, size_t len);
+
+  /**
+   * Enable or disable the device.  When disabled, the device enters a
+   * low power mode and does not emit NMEA data.  It will still
+   * maintain location data however.
+   *
+   * @param dev sensor context
+   * @param enable true to enable the device, false otherwise.
+   * @return UPM result
+   */
+  upm_result_t nmea_gps_enable(const nmea_gps_context dev, bool enable);
+
+  /**
+   * Set the baudrate of the device.  By default, nmea_gps_init() will
+   * set the baudrate to 9600.  This is only valid for UART devices.
+   *
+   * @param dev sensor context
+   * @param baudrate The baud rate to set for the device.
+   * @return UPM result
+   */
+  upm_result_t nmea_gps_set_baudrate(const nmea_gps_context dev,
+                                     unsigned int baudrate);
+
+  /**
+   * Determine whether there is data available to be read.  In the
+   * case of a UART, this function will wait up to "millis"
+   * milliseconds for data to become available.  In the case of an I2C
+   * device, the millis argument is ignored and the function will
+   * return immediately, indicating whether data is available.
+   *
+   * @param dev sensor context
+   * @param millis The number of milliseconds to wait for data to
+   * become available.
+   * @return true if data is available to be read, false otherwise.
+   */
+  bool nmea_gps_data_available(const nmea_gps_context dev,
+                               unsigned int millis);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/o2/Kbuild b/ext/lib/upm/src/o2/Kbuild
new file mode 100644
index 0000000..d58252b
--- /dev/null
+++ b/ext/lib/upm/src/o2/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_o2) += o2.o
diff --git a/ext/lib/upm/src/o2/Kconfig b/ext/lib/upm/src/o2/Kconfig
new file mode 100644
index 0000000..b447a4f
--- /dev/null
+++ b/ext/lib/upm/src/o2/Kconfig
@@ -0,0 +1,9 @@
+config UPM_o2
+    bool "o2"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm O2 oxygen concentration sensor module
+
diff --git a/ext/lib/upm/src/o2/Makefile b/ext/lib/upm/src/o2/Makefile
new file mode 100644
index 0000000..0a5b33a
--- /dev/null
+++ b/ext/lib/upm/src/o2/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_o2
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/o2
+endif
diff --git a/ext/lib/upm/src/o2/o2.c b/ext/lib/upm/src/o2/o2.c
new file mode 100644
index 0000000..06c5397
--- /dev/null
+++ b/ext/lib/upm/src/o2/o2.c
@@ -0,0 +1,131 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "o2.h"
+o2_context o2_init(int16_t pin)
+{
+    o2_context dev = (o2_context)malloc(sizeof(struct _o2_context));
+
+    if(dev == NULL) return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+    if(dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set defaults */
+    dev->m_aRef = 5.0;
+    dev->m_offset = 0.0;
+    dev->m_scale = 1.0;
+
+    return dev;
+}
+
+void o2_close(o2_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t o2_set_aref(const o2_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+float o2_get_aref(const o2_context dev)
+{
+    return dev->m_aRef;
+}
+
+upm_result_t o2_set_offset(const o2_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float o2_get_offset(const o2_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t o2_set_scale(const o2_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+float o2_get_scale(const o2_context dev)
+{
+    return dev->m_scale;
+}
+
+upm_result_t o2_get_counts(const o2_context dev, int *value)
+{
+    /* Read counts */
+    *value = mraa_aio_read(dev->aio);
+    if (*value < 0) return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t o2_get_raw_volts(const o2_context dev, float *value)
+{
+    /* Read normalized adc value */
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0.0) return UPM_ERROR_OPERATION_FAILED;
+
+    /* Convert normalized value to voltage via aRef */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t o2_get_value(const o2_context dev, float *value)
+{
+    /* Read normalized value */
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0.0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Apply raw scale */
+    *value *= dev->m_scale;
+
+    /* Convert to %oxygen
+       Datasheet for grove o2 shows a linear response for the sensor.  Assuming
+       20.5% oxygen @ 25 celsius, with an gain = 1 + 12k/100 = 121, a
+       dynamic range of 0->25% oxygen, and opamp rails of 0->3.3v (the grove o2
+       sensor uses a high-accuracy 3.3v regulator),
+     */
+    *value *= 25 * dev->m_aRef/3.3;
+
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
+
diff --git a/ext/lib/upm/src/o2/o2.h b/ext/lib/upm/src/o2/o2.h
new file mode 100644
index 0000000..f26747f
--- /dev/null
+++ b/ext/lib/upm/src/o2/o2.h
@@ -0,0 +1,135 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * device context
+ */
+typedef struct _o2_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *o2_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin is Analog pin
+ * @return sensor context as void pointer
+ */
+o2_context o2_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer deallocate memory
+ */
+void o2_close(o2_context dev);
+
+/**
+ * Set sensor adc vref.
+ * @param dev sensor context pointer
+ * @param aref Voltage reference routed to ADC ref pin
+ * @return Function result code
+ */
+upm_result_t o2_set_aref(const o2_context dev, float aref);
+
+/**
+ * Get sensor adc vref
+ * @param dev sensor context pointer
+ * @return Current adc vref
+ */
+float o2_get_aref(const o2_context dev);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     counts = counts * scale + offset * scale
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t o2_set_offset(const o2_context dev, float offset);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Current sensor offset
+ */
+float o2_get_offset(const o2_context dev);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale + offset * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t o2_set_scale(const o2_context dev, float scale);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Current sensor scale
+ */
+float o2_get_scale(const o2_context dev);
+
+/**
+ * Read raw adc counts from sensor
+ * @param dev sensor context pointer
+ * @param *value Raw adc value
+ * @return Function result code
+ */
+upm_result_t o2_get_counts(const o2_context dev, int *value);
+
+/**
+ * Read voltage from sensor
+ * @param dev sensor context pointer
+ * @param *value Voltage (v)
+ * @return Function result code
+ */
+upm_result_t o2_get_raw_volts(const o2_context dev, float *value);
+
+/**
+ * Read value from sensor
+ * @param dev sensor context pointer
+ * @param *value O2 percentage
+ * @return Function result code
+ */
+upm_result_t o2_get_value(const o2_context dev, float *value);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/otp538u/Kbuild b/ext/lib/upm/src/otp538u/Kbuild
new file mode 100644
index 0000000..3f97684
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_otp538u) += otp538u.o
diff --git a/ext/lib/upm/src/otp538u/Kconfig b/ext/lib/upm/src/otp538u/Kconfig
new file mode 100644
index 0000000..b15f653
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/Kconfig
@@ -0,0 +1,8 @@
+config UPM_otp538u
+    bool "otp538u"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm OTP538U IR Temperature Sensor
diff --git a/ext/lib/upm/src/otp538u/Makefile b/ext/lib/upm/src/otp538u/Makefile
new file mode 100644
index 0000000..cf17751
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_otp538u
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/otp538u
+endif
diff --git a/ext/lib/upm/src/otp538u/otp538u.c b/ext/lib/upm/src/otp538u/otp538u.c
new file mode 100644
index 0000000..acc8341
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/otp538u.c
@@ -0,0 +1,374 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include <string.h>
+
+#include <upm_utilities.h>
+#include <upm_platform.h>
+
+#include <otp538u.h>
+
+#include "thermopile_vt_table.h"
+#include "thermister_rt_table.h"
+
+
+// To save memory space, we disable debugging on non-linux platforms
+// by default (Zephyr).  For other systems, enable as desired/possible.
+#if defined(UPM_PLATFORM_LINUX)
+# define OTP538U_DEBUG_ENABLED
+#endif // UPM_PLATFORM_LINUX
+
+otp538u_context otp538u_init(int pinA, int pinO, float aref)
+{
+    otp538u_context dev =
+        (otp538u_context)malloc(sizeof(struct _otp538u_context));
+
+    if (!dev)
+        return NULL;
+
+    memset((void *)dev, 0, sizeof(struct _otp538u_context));
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        otp538u_close(dev);
+        return NULL;
+    }
+
+    // initialize the MRAA contexts
+
+    if (!(dev->aioA = mraa_aio_init(pinA)))
+    {
+        printf("%s: mraa_aio_init(pinA) failed.\n", __FUNCTION__);
+        otp538u_close(dev);
+
+        return NULL;
+    }
+
+    if (!(dev->aioO = mraa_aio_init(pinO)))
+    {
+        printf("%s: mraa_aio_init(pinO) failed.\n", __FUNCTION__);
+        otp538u_close(dev);
+
+        return NULL;
+    }
+
+    // for subplatforms like the Arduino 101 with Firmata, we need to
+    // limit ADC resolution to 10b currently.  For this sensor
+    // unfortunately, this means readings will be less accurate.  This
+    // sensor really does need to measure with about 1mV accuracy.
+    const int adcHighRes = 4095;
+    const int adcLowRes = 1023;
+
+    bool isSubplatform = false;
+
+    dev->debug = false;
+
+    if (pinA >= 512 || pinO >= 512)
+        isSubplatform = true;
+
+    // this is the internal voltage reference on the Grove IR temp
+    // sensor module for the thermistor.
+
+    dev->internalVRef = 2.5;
+
+    // analog reference in use
+    dev->aref = aref;
+
+    // This is the value of the output resistor of the Grove IR
+    // temp sensor's SIG2 output (ambient)
+    dev->vResistance = 2000000;      // 2M ohms
+
+    // This was the default offset voltage in the seeedstudio code.  You
+    // can adjust as neccessary depending on your calibration.
+    dev->offsetVoltage = 0.014;
+
+    // We need around 1mV resolution (preferred), so use 12 bit
+    // resolution (4096) if we can.
+    //
+    // This logic is over complicated due to the fact that it is
+    // currently difficult to determine exactly what the capabilities of
+    // the platform (sub or otherwise) actually are.  So for
+    // subplatforms, we always limit to 1024.  Otherwise, we try 12b if
+    // the mraa_adc_raw_bits() says we can, though this isn't
+    // particularly accurate either, as it reports that the G2 can do
+    // 12b, when in reality it can not.  We are just lucky that it works
+    // anyway (ie: will give 12b resolution, though underneath it's just
+    // scaling the real 10b value.).  Sigh.  But trying 12b resolution
+    // on the 101 via firmata will definitely break things, so don't
+    // even try until whatever the problem it has with 12b is fixed.
+    if (isSubplatform)
+    {
+        dev->adcResolution = adcLowRes; // 10b
+    }
+    else
+    {
+        if (mraa_adc_raw_bits() == 12)
+            dev->adcResolution = adcHighRes; // 12b
+        else
+            dev->adcResolution = adcLowRes; // 10b
+    }
+
+    // notify the user
+    if (dev->adcResolution == adcLowRes)
+        printf("Using 10 bit ADC resolution.  Values will be less accurate.\n");
+
+    // enable 12 bit resolution, if we can
+    if (dev->adcResolution == adcHighRes)
+        mraa_aio_set_bit(dev->aioA, 12);
+
+    if (dev->adcResolution == adcHighRes)
+        mraa_aio_set_bit(dev->aioO, 12);
+
+    if (isSubplatform)
+    {
+        // The first analog read always seems to return 0 on the 101
+        // with firmata, so just do a couple of reads here and discard
+        // them.  Then sleep for half a second.  THIS IS A HACK.  The
+        // real problem should be fixed elsewhere (Firmata?).
+        mraa_aio_read(dev->aioA);
+        mraa_aio_read(dev->aioO);
+
+        upm_delay_ms(500);
+    }
+
+    return dev;
+}
+
+void otp538u_close(otp538u_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->aioA)
+        mraa_aio_close(dev->aioA);
+    if (dev->aioO)
+        mraa_aio_close(dev->aioO);
+
+    free(dev);
+}
+
+upm_result_t otp538u_get_ambient_temperature(const otp538u_context dev,
+                                             float *temperature)
+{
+    assert(dev != NULL);
+
+    const int samples = 5;
+    int val = 0;
+    float temp = 0;
+    float res = 0;
+
+    for (int i=0; i<samples; i++)
+    {
+        val = mraa_aio_read(dev->aioA);
+        if (val == -1)
+        {
+            printf("%s: mraa_aio_read() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+
+        temp += (float)val;
+        upm_delay_ms(10);
+    }
+    temp = temp / samples;
+
+    float volts = temp * dev->aref / dev->adcResolution;
+
+#if defined(OTP538U_DEBUG_ENABLED)
+    if (dev->debug)
+    {
+        printf("\tAMB sample %f aref %f volts %f\n", temp, dev->aref,
+               volts);
+    }
+#endif // OTP538U_DEBUG_ENABLED
+
+    // compute the resistance of the thermistor
+    res = dev->vResistance * volts / (dev->internalVRef - volts);
+
+#if defined(OTP538U_DEBUG_ENABLED)
+    if (dev->debug)
+    {
+        printf("\tAMB computed resistance: %f\n", res);
+    }
+#endif // OTP538U_DEBUG_ENABLED
+
+    // look it up in the thermistor (RT) resistence/temperature table
+    int rawslot;
+    int j;
+    for (j=0; j<otp538u_rt_table_max; j++)
+        if (otp538u_rt_table[j] < res)
+        {
+            rawslot = j;
+            break;
+        }
+
+    if (j >= otp538u_rt_table_max)
+    {
+        printf("%s: Ambient temperature out of range (high)\n", __FUNCTION__);
+        return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+    // we need to compensate for the fact that we are supporting
+    // temperature values less than 0 (-20C), so adjust correspondingly
+    // so that we obtain the correct temperature 'slot'.  This will be
+    // our base temperature.
+    int slot = rawslot - 20;
+
+    // too cold
+    if (slot < 0)
+    {
+        printf("%s: Ambient temperature out of range (low)\n", __FUNCTION__);
+        return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+    // now compute the ambient temperature
+    float ambientTemp = slot - 1 +
+        (otp538u_rt_table[rawslot - 1]-res) / (otp538u_rt_table[rawslot - 1] -
+                                               otp538u_rt_table[rawslot]);
+
+    *temperature = ambientTemp;
+    return UPM_SUCCESS;
+}
+
+upm_result_t otp538u_get_object_temperature(const otp538u_context dev,
+                                            float *temperature)
+{
+    assert(dev != NULL);
+
+    const int samples = 5;
+    const float reference_vol = 0.5; // what is this value? (from seeedstudio)
+    const float tempIncrement = 10.0;
+    int val = 0;
+    float temp = 0;
+
+    float ambTemp = 0.0;
+    if (otp538u_get_ambient_temperature(dev, &ambTemp))
+        return UPM_ERROR_OPERATION_FAILED;
+
+    for (int i=0; i<samples; i++)
+    {
+        val = mraa_aio_read(dev->aioO);
+        if (val == -1)
+        {
+            printf("%s: mraa_aio_read() failed.\n", __FUNCTION__);
+            return UPM_ERROR_OPERATION_FAILED;
+        }
+        temp += val;
+        upm_delay_ms(10);
+    }
+
+    temp = temp / samples;
+
+#if defined(OTP538U_DEBUG_ENABLED)
+    if (dev->debug)
+        printf("\tOBJ sample %f ", temp);
+#endif // OTP538U_DEBUG_ENABLED
+
+    float volts = temp * dev->aref / dev->adcResolution;
+
+#if defined(OTP538U_DEBUG_ENABLED)
+    if (dev->debug)
+        printf("VOLTS: %f ", volts);
+#endif // OTP538U_DEBUG_ENABLED
+
+    float sensorVolts = volts - (reference_vol + dev->offsetVoltage);
+
+#if defined(OTP538U_DEBUG_ENABLED)
+    if (dev->debug)
+        printf("Sensor Voltage (computed): %f\n", sensorVolts);
+#endif // OTP538U_DEBUG_ENABLED
+
+    // search the VT (voltage/temperature) table to find the object
+    // temperature.
+    int slot;
+    // add +2 to compensate for the -20C and -10C slots below zero
+    int voltOffset = (int)(ambTemp / 10) + 1 + 2;
+    float voltage = sensorVolts * 10.0;
+    for (slot=0; slot<(otp538u_vt_table_max - 1); slot++)
+    {
+        if ( (voltage > otp538u_vt_table[slot][voltOffset]) &&
+             (voltage < otp538u_vt_table[slot+1][voltOffset]) )
+        {
+            break;
+        }
+    }
+
+    if (slot >= (otp538u_vt_table_max - 1))
+    {
+        printf("%s: Object temperature out of range (high)\n", __FUNCTION__);
+        return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+    float objTemp = ((float)tempIncrement * voltage) /
+        ( otp538u_vt_table[slot + 1][voltOffset] -
+          otp538u_vt_table[slot][voltOffset] );
+
+#if defined(OTP538U_DEBUG_ENABLED)
+    if (dev->debug)
+    {
+        printf("\tVoltage (%f): TABLE VALUE [%d][%d] = %f\n", voltage,
+               slot, voltOffset, otp538u_vt_table[slot][voltOffset]);
+    }
+#endif // OTP538U_DEBUG_ENABLED
+
+    *temperature = ambTemp + objTemp;
+    return UPM_SUCCESS;
+}
+
+void otp538u_set_voltage_offset(const otp538u_context dev, float offset)
+{
+    assert(dev != NULL);
+
+    dev->offsetVoltage = offset;
+}
+
+void otp538u_set_output_resistence(const otp538u_context dev,
+                                   int resistance)
+{
+    assert(dev != NULL);
+
+    dev->vResistance = resistance;
+}
+
+void otp538u_set_ivref(const otp538u_context dev, float vref)
+{
+    assert(dev != NULL);
+
+    dev->internalVRef = vref;
+}
+
+void otp538u_set_debug(const otp538u_context dev, bool enable)
+{
+    assert(dev != NULL);
+
+    dev->debug = enable;
+
+#if !defined(UPM_PLATFORM_LINUX) && !defined(OTP538U_DEBUG_ENABLED)
+    if (enable)
+        printf("%s: Debugging not enabled at compilation time.\n",
+               __FUNCTION__);
+#endif // !UPM_PLATFORM_LINUX && !OTP538U_DEBUG_ENABLED
+}
diff --git a/ext/lib/upm/src/otp538u/otp538u.h b/ext/lib/upm/src/otp538u/otp538u.h
new file mode 100644
index 0000000..92a1d71
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/otp538u.h
@@ -0,0 +1,153 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+#include <mraa/aio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file otp538u.h
+     * @library otp538u
+     * @brief C API for the OTP538U IR Temperature Sensor
+     *
+     * @include otp538u.c
+     */
+
+    /**
+     * device context
+     */
+    typedef struct _otp538u_context
+    {
+        mraa_aio_context aioA;
+        mraa_aio_context aioO;
+
+        bool             debug;
+        float            internalVRef;
+        float            aref;
+        int              vResistance;
+        float            offsetVoltage;
+        int              adcResolution;
+    } *otp538u_context;
+
+
+    /**
+     * OTP538U constructor
+     *
+     * @param pinA Analog pin to use for the ambient temperature
+     * @param pinO Analog pin to use for the object temperature
+     * @param aref Analog reference voltage
+     * @return intialized context, or NULL if error
+     */
+    otp538u_context otp538u_init(int pinA, int pinO, float aref);
+
+    /**
+     * OTP538U destructor
+     *
+     * @param dev Device context
+     */
+    void otp538u_close(otp538u_context dev);
+
+    /**
+     * Gets the ambient temperature in Celsius
+     *
+     * @param dev Device context
+     * @param temp Ambient temperature
+     * @return UPM status
+     */
+    upm_result_t otp538u_get_ambient_temperature(const otp538u_context dev,
+                                                 float *temperature);
+
+    /**
+     * Gets the object temperature in Celsius
+     *
+     * @param dev Device context
+     * @param temp Object temperature
+     * @return UPM status
+     */
+    upm_result_t otp538u_get_object_temperature(const otp538u_context dev,
+                                                float *temperature);
+
+    /**
+     * Sets the offset voltage
+     *
+     * The Seeed Studio wiki gives an example of calibrating the sensor
+     * and calculating the offset voltage to apply. Currently, the
+     * default value is set, but you can use the function to set one
+     * of your own.
+     *
+     * @param dev Device context
+     * @param vOffset Desired offset voltage
+     */
+    void otp538u_set_voltage_offset(const otp538u_context dev, float offset);
+
+    /**
+     * Sets the output resistance value
+     *
+     * The Seeed Studio wiki example uses a value of 2,000,000 in one of
+     * the equations used to calculate voltage. The value is the
+     * resistance of a resistor they use in the output stage of their
+     * SIG2 output. This was 'decoded' by looking at the EAGLE* files
+     * containing their schematics for this device.
+     *
+     * @param dev Device context
+     * @param outResistance Value of the output resistor; default is 2M Ohm
+     */
+    void otp538u_set_output_resistence(const otp538u_context dev,
+                                       int resistance);
+
+    /**
+     * Sets the reference voltage of the internal Seeed Studio voltage
+     * regulator on the sensor board.
+     *
+     * The Seeed Studio wiki example uses a value of 2.5 in one of the
+     * equations used to calculate the resistance of the ambient
+     * thermistor. The value is the voltage of an internal voltage
+     * regulator used on the sensor board. This was 'decoded' by
+     * looking at the EAGLE files containing their schematics for this
+     * device.
+     *
+     * @param dev Device context
+     * @param vref Reference voltage of the internal sensor; default
+     * is 2.5
+     */
+    void otp538u_set_ivref(const otp538u_context dev, float vref);
+
+    /**
+     * Enable debugging output (linux platforms only).
+     *
+     * @param dev Device context
+     * @param true to enable some debug output, false otherwise
+     */
+    void otp538u_set_debug(const otp538u_context dev, bool enable);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/otp538u/thermister_rt_table.h b/ext/lib/upm/src/otp538u/thermister_rt_table.h
new file mode 100644
index 0000000..478a747
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/thermister_rt_table.h
@@ -0,0 +1,45 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+// This table was taken from the '538RT_table.pdf' datasheet. It maps
+// resistance values to ambient temperatures starting at -20C and
+// going up to 200C in increments of 1C
+
+static const int otp538u_rt_table_max = 121;
+
+static int otp538u_rt_table[121] = {
+  919730, 869299, 821942, 777454, 735644, 696336, 659365, 624578, 591834,
+  561002, 531958, 504588, 478788, 454457, 431504, 409843, 389394, 370082,
+  351839, 334598, 318300, 302903, 288329, 274533, 261471, 249100, 237381,
+  226276, 215750, 205768, 196300, 187316, 178788, 170691, 163002, 155700,
+  148766, 142183, 135936, 130012, 124400, 119038, 113928, 109059, 104420,
+  100000, 95788, 91775, 87950, 84305, 80830, 77517, 74357, 71342, 68466,
+  65720, 63098, 60595, 58202, 55916, 53730, 51645, 49652, 47746, 45924,
+  44180, 42511, 40912, 39380, 37910, 36500, 35155, 33866, 32631, 31446,
+  30311, 29222, 28177, 27175, 26213, 25290, 24403, 23554, 22738, 21955,
+  21202, 20479, 19783, 19115, 18472, 17854, 17260, 16688, 16138, 15608,
+  15098, 14608, 14135, 13680, 13242, 12819, 12412, 12020, 11642, 11278,
+  10926, 10587, 10260, 9945, 9641, 9347, 9063, 8789, 8525, 8270, 8023,
+  7785, 7555, 7333, 7118, 6911
+};
diff --git a/ext/lib/upm/src/otp538u/thermopile_vt_table.h b/ext/lib/upm/src/otp538u/thermopile_vt_table.h
new file mode 100644
index 0000000..c6b49ee
--- /dev/null
+++ b/ext/lib/upm/src/otp538u/thermopile_vt_table.h
@@ -0,0 +1,103 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+// This table was taken from the '538U VT Table__20_200(v1.3).pdf'
+// datasheet, but the 25C column has been removed for consistency.
+
+static const int otp538u_vt_table_max = 23;
+
+// Thermistor temperature (C)
+// { -20 -10 0 10 20 30 40 50 60 70 80 90 100 }
+
+static float otp538u_vt_table[23][13] = {
+                                                  // object temp (C)
+  {0.000, -0.246, -0.523, -0.832, -1.177, -1.559, // -20C
+   -1.981, -2.446, -2.957, -3.516, -4.126, -4.791, -5.513},
+
+  {0.243, 0.000, -0.274, -0.580, -0.922, -1.301, // -10
+   -1.721, -2.183, -2.691, -3.247, -3.854, -4.516, -5.236},
+
+  {0.511, 0.271, 0.000, -0.303, -0.642, -1.018, // 0
+   -1.434, -1.894, -2.398, -2.951, -3.556, -4.215, -4.931},
+
+  {0.804, 0.567, 0.300, 0.000, -0.335, -0.708, // 10
+   -1.121, -1.577, -2.078, -2.628, -3.229, -3.884, -4.597},
+
+  {1.125, 0.891, 0.628, 0.331, 0.000, -0.369, // 20
+   -0.778, -1.230, -1.728, -2.274, -2.871, -3.523, -4.232},
+
+  {1.474, 1.244, 0.985, 0.692, 0.365, 0.000, // 30
+   -0.405, -0.853, -1.347, -1.889, -2.482, -3.130, -3.835},
+
+  {1.852, 1.628, 1.372, 1.084, 0.761, 0.401, // 40
+   0.000, -0.444, -0.933, -1.470, -2.059, -2.702, -3.403},
+
+  {2.263, 2.043, 1.792, 1.509, 1.191, 0.835, // 50
+   0.439, 0.000, -0.484, -1.017, -1.601, -2.240, -2.936},
+
+  {2.706, 2.491, 2.246, 1.968, 1.655, 1.304, // 60
+   0.913, 0.479, 0.000, -0.528, -1.107, -1.740, -2.431},
+
+  {3.184, 2.975, 2.735, 2.462, 2.155, 1.809, // 70
+   1.424, 0.996, 0.522, 0.000, -0.573, -1.201, -1.887},
+
+  {3.698, 3.495, 3.261, 2.994, 2.692, 2.353, // 80
+   1.974, 1.552, 1.084, 0.568, 0.000, -0.622, -1.301},
+
+  {4.250, 4.053, 3.825, 3.565, 3.270, 2.937, // 90
+   2.564, 2.148, 1.687, 1.177, 0.616, 0.000, -0.673},
+
+  {4.841, 4.651, 4.430, 4.177, 3.888, 3.562, // 100
+   3.196, 2.787, 2.332, 1.829, 1.275, 0.666, 0.000},
+
+  {5.473, 5.290, 5.076, 4.830, 4.549, 4.231, // 110
+   3.872, 3.470, 3.023, 2.527, 1.980, 1.379, 0.720},
+
+  {6.147, 5.972, 5.767, 5.528, 5.255, 4.944, // 120
+   4.593, 4.199, 3.760, 3.272, 2.733, 2.139, 1.488},
+
+  {6.866, 6.699, 6.502, 6.272, 6.007, 5.705, // 130
+   5.362, 4.976, 4.545, 4.066, 3.535, 2.950, 2.307},
+
+  {7.631, 7.473, 7.285, 7.064, 6.808, 6.514, // 140
+   6.180, 5.803, 5.381, 4.910, 4.388, 3.812, 3.178},
+
+  {8.444, 8.295, 8.116, 7.905, 7.658, 7.373, // 150
+   7.049, 6.682, 6.269, 5.807, 5.295, 4.728, 4.103},
+
+  {9.306, 9.167, 8.998, 8.796, 8.560, 8.285, // 160
+   7.971, 7.613, 7.211, 6.759, 6.257, 5.700, 5.085},
+
+  {10.219, 10.091, 9.933, 9.741, 9.515, 9.251, // 170
+   8.947, 8.601, 8.208, 7.768, 7.276, 6.729, 6.125},
+
+  {11.185, 11.068, 10.921, 10.741, 10.526, 10.274, // 180
+   9.981, 9.645, 9.264, 8.835, 8.354, 7.818, 7.226},
+
+  {12.206, 12.101, 11.966, 11.798, 11.595, 11.354, // 190
+   11.073, 10.749, 10.380, 9.962, 9.493, 8.969, 8.388},
+
+  {13.284, 13.191, 13.068, 12.913, 12.722, 12.494, // 200
+   12.225, 11.914, 11.557, 11.152, 10.695, 10.184, 9.616}
+};
diff --git a/ext/lib/upm/src/ppd42ns/Kbuild b/ext/lib/upm/src/ppd42ns/Kbuild
new file mode 100644
index 0000000..0153c13
--- /dev/null
+++ b/ext/lib/upm/src/ppd42ns/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ppd42ns) += ppd42ns.o
diff --git a/ext/lib/upm/src/ppd42ns/Kconfig b/ext/lib/upm/src/ppd42ns/Kconfig
new file mode 100644
index 0000000..f41c24e
--- /dev/null
+++ b/ext/lib/upm/src/ppd42ns/Kconfig
@@ -0,0 +1,8 @@
+config UPM_ppd42ns
+    bool "ppd42ns"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm PPD42NS Dust Sensor
diff --git a/ext/lib/upm/src/ppd42ns/Makefile b/ext/lib/upm/src/ppd42ns/Makefile
new file mode 100644
index 0000000..810a7e2
--- /dev/null
+++ b/ext/lib/upm/src/ppd42ns/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ppd42ns
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ppd42ns
+endif
diff --git a/ext/lib/upm/src/ppd42ns/ppd42ns.c b/ext/lib/upm/src/ppd42ns/ppd42ns.c
new file mode 100644
index 0000000..f75a688
--- /dev/null
+++ b/ext/lib/upm/src/ppd42ns/ppd42ns.c
@@ -0,0 +1,167 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Rewritten Based on original C++ driver written by:
+ * Author: Zion Orent <sorent@ics.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdio.h>
+
+#include <upm_math.h>
+#include <upm_utilities.h>
+
+#include "ppd42ns.h"
+
+// Returns the amount of time it takes a pin to go from HIGH to LOW or
+// from LOW to HIGH
+static uint32_t ppd42ns_pulse_in(const ppd42ns_context dev,
+                                 bool high_low_value);
+
+ppd42ns_context ppd42ns_init(int pin)
+{
+    ppd42ns_context dev =
+        (ppd42ns_context)malloc(sizeof(struct _ppd42ns_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->gpio = NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        ppd42ns_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->gpio = mraa_gpio_init(pin)) )
+    {
+        printf("%s: mraa_gpio_init() failed\n",
+               __FUNCTION__);
+        ppd42ns_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+    return dev;
+}
+
+void ppd42ns_close(ppd42ns_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->gpio)
+        mraa_gpio_close(dev->gpio);
+}
+
+ppd42ns_dust_data ppd42ns_get_data(const ppd42ns_context dev)
+{
+    assert(dev != NULL);
+
+    ppd42ns_dust_data data;
+
+    // in ms, 30 seconds
+    const int pulse_check_time = 30000;
+    // loop timer
+    upm_clock_t max_loop_time;
+
+    unsigned int low_pulse_occupancy = 0;
+
+    upm_clock_init(&max_loop_time);
+
+    do {
+        low_pulse_occupancy += ppd42ns_pulse_in(dev, 0);
+    } while (upm_elapsed_ms(&max_loop_time) < pulse_check_time);
+
+    // Store dust data
+    // Integer percentage 0=>100
+    double ratio = (float)low_pulse_occupancy
+        / ((float)pulse_check_time * 10.0);
+
+     // using spec sheet curve
+    double concentration = (1.1 * pow(ratio,3)) - (3.8 * pow(ratio, 2))
+        + (520 * ratio) + 0.62;
+
+    data.lowPulseOccupancy = low_pulse_occupancy;
+    data.ratio = ratio;
+    data.concentration = concentration;
+
+    return data;
+}
+
+
+// Mimicking Arduino's pulseIn function
+// return how long it takes a pin to go from HIGH to LOW or LOW to HIGH
+static uint32_t ppd42ns_pulse_in(const ppd42ns_context dev,
+                                 bool high_low_value)
+{
+    assert(dev != NULL);
+
+    // we run for no more than 1 second at a time
+    upm_clock_t max_time;
+    upm_clock_t pulse_time;
+    uint32_t total_pulse_time = 0;
+
+    upm_clock_init(&max_time);
+    bool pin_level;
+    bool is_timing = false;
+
+    do {
+        pin_level = (bool)mraa_gpio_read(dev->gpio);
+
+        if (!is_timing && pin_level == high_low_value)
+        {
+            // level is desired level, but not currently timing
+            upm_clock_init(&pulse_time);
+            is_timing = true;
+        }
+        else if (is_timing && pin_level != high_low_value)
+        {
+            // we started timing, but level changed
+            total_pulse_time += upm_elapsed_us(&pulse_time);
+            is_timing = false;
+        }
+        else
+        {
+            // not timing and/or level is not equal to desired level
+            // so we "wait".
+            upm_delay_us(10);
+        }
+    } while (upm_elapsed_ms(&max_time) < 1000); // 1 second
+
+    if (is_timing)
+    {
+        // if we were still timing when the loop expired, add the
+        // accumulated time.
+        total_pulse_time += upm_elapsed_us(&pulse_time);
+    }
+
+    return total_pulse_time;
+}
diff --git a/ext/lib/upm/src/ppd42ns/ppd42ns.h b/ext/lib/upm/src/ppd42ns/ppd42ns.h
new file mode 100644
index 0000000..96d8d5e
--- /dev/null
+++ b/ext/lib/upm/src/ppd42ns/ppd42ns.h
@@ -0,0 +1,82 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Based on original C++ driver written by:
+ * Author: Zion Orent <sorent@ics.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/gpio.h>
+#include <ppd42ns_data.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file ppd42ns.h
+     * @library ppd42ns
+     * @brief C API for the ppd42ns driver
+     *
+     * @include ppd42ns.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _ppd42ns_context {
+        mraa_gpio_context gpio;
+
+    } *ppd42ns_context;
+
+    /**
+     * PPD42NS initialization
+     *
+     * @param pin Digital pin to use
+     * @return ppd42ns device context
+     */
+    ppd42ns_context ppd42ns_init(int pin);
+
+    /**
+     * PPD42NS close
+     *
+     * @param dev Device context.
+     */
+    void ppd42ns_close(ppd42ns_context dev);
+
+    /**
+     * Prints dust concentration
+     *
+     * @param dev Device context.
+     * @return ppd42ns_dust_data Contains data from the dust sensor
+     */
+    ppd42ns_dust_data ppd42ns_get_data(const ppd42ns_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/ppd42ns/ppd42ns_data.h b/ext/lib/upm/src/ppd42ns/ppd42ns_data.h
new file mode 100644
index 0000000..1b65e7f
--- /dev/null
+++ b/ext/lib/upm/src/ppd42ns/ppd42ns_data.h
@@ -0,0 +1,44 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Based on original C++ driver written by:
+ * Author: Zion Orent <sorent@ics.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    // This is a data struct used by the ppd42ns (dust sensor) driver.
+    typedef struct
+    {
+	unsigned int lowPulseOccupancy;
+	double ratio;
+	double concentration;
+    } ppd42ns_dust_data;
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/relay/Kbuild b/ext/lib/upm/src/relay/Kbuild
new file mode 100644
index 0000000..1dbf6b8
--- /dev/null
+++ b/ext/lib/upm/src/relay/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_relay) += relay.o
diff --git a/ext/lib/upm/src/relay/Kconfig b/ext/lib/upm/src/relay/Kconfig
new file mode 100644
index 0000000..bfb0868
--- /dev/null
+++ b/ext/lib/upm/src/relay/Kconfig
@@ -0,0 +1,9 @@
+config UPM_relay
+    bool "relay"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM Relay Module: relay
+
diff --git a/ext/lib/upm/src/relay/Makefile b/ext/lib/upm/src/relay/Makefile
new file mode 100644
index 0000000..ca64c38
--- /dev/null
+++ b/ext/lib/upm/src/relay/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_relay
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/relay
+endif
diff --git a/ext/lib/upm/src/relay/relay.c b/ext/lib/upm/src/relay/relay.c
new file mode 100644
index 0000000..a45f0fe
--- /dev/null
+++ b/ext/lib/upm/src/relay/relay.c
@@ -0,0 +1,83 @@
+/*
+ * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "relay.h"
+
+relay_context relay_init(int pin)
+{
+    relay_context dev = (relay_context)malloc(sizeof(struct _relay_context));
+
+    if (dev == NULL)
+        return NULL;
+
+    dev->gpio = mraa_gpio_init(pin);
+
+    if (dev->gpio == NULL)
+    {
+        free(dev);
+        return NULL;
+    }
+    return dev;
+}
+
+void relay_close(relay_context dev)
+{
+    mraa_gpio_close(dev->gpio);
+
+    free(dev);
+}
+
+upm_result_t relay_on(relay_context dev)
+{
+    mraa_gpio_write(dev->gpio, 1);
+    return UPM_SUCCESS;
+}
+
+upm_result_t relay_off(relay_context dev)
+{
+    mraa_gpio_write(dev->gpio, 0);
+    return UPM_SUCCESS;
+}
+
+bool relay_is_on(relay_context dev)
+{
+    int val;
+    val = mraa_gpio_read(dev->gpio);
+    if (val > 0)
+        return true;
+    else
+        return false;
+}
+
+bool relay_is_off(relay_context dev)
+{
+    int val;
+    val = mraa_gpio_read(dev->gpio);
+    if (!val)
+        return true;
+    else
+        return false;
+}
+
diff --git a/ext/lib/upm/src/relay/relay.h b/ext/lib/upm/src/relay/relay.h
new file mode 100644
index 0000000..58a3cf0
--- /dev/null
+++ b/ext/lib/upm/src/relay/relay.h
@@ -0,0 +1,57 @@
+/*
+ * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef RELAY_H_
+#define RELAY_H_
+
+#pragma once
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "upm.h"
+#include <mraa/gpio.h>
+
+/**
+ * device context
+ */
+typedef struct _relay_context{
+    mraa_gpio_context gpio;
+} *relay_context;
+
+typedef struct _relay_context *relay_context;
+
+relay_context relay_init(int pin);
+
+void relay_close(relay_context dev);
+
+upm_result_t relay_on(relay_context dev);
+
+upm_result_t relay_off(relay_context dev);
+
+bool relay_is_on(relay_context dev);
+
+bool relay_is_off(relay_context dev);
+
+#endif /* RELAY_H_ */
diff --git a/ext/lib/upm/src/rotary/Kbuild b/ext/lib/upm/src/rotary/Kbuild
new file mode 100644
index 0000000..a6475ac
--- /dev/null
+++ b/ext/lib/upm/src/rotary/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_rotary) += rotary.o
diff --git a/ext/lib/upm/src/rotary/Kconfig b/ext/lib/upm/src/rotary/Kconfig
new file mode 100644
index 0000000..f4f11d8
--- /dev/null
+++ b/ext/lib/upm/src/rotary/Kconfig
@@ -0,0 +1,9 @@
+config UPM_rotary
+    bool "rotary"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM Relay Module: rotary
+
diff --git a/ext/lib/upm/src/rotary/Makefile b/ext/lib/upm/src/rotary/Makefile
new file mode 100644
index 0000000..922f2f9
--- /dev/null
+++ b/ext/lib/upm/src/rotary/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_rotary
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/rotary
+endif
diff --git a/ext/lib/upm/src/rotary/rotary.c b/ext/lib/upm/src/rotary/rotary.c
new file mode 100644
index 0000000..8e29302
--- /dev/null
+++ b/ext/lib/upm/src/rotary/rotary.c
@@ -0,0 +1,78 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "rotary.h"
+
+rotary_context rotary_init(int pin, float aRef)
+{
+    rotary_context dev = (rotary_context)malloc(sizeof(struct _rotary_context));
+
+    if(dev == NULL) return NULL;
+
+    dev->aio = mraa_aio_init(pin);
+
+    if(dev->aio == NULL){
+        free(dev);
+        return NULL;
+    }
+
+    dev->m_aRef = aRef;
+
+    // get adc bit range
+    dev->m_aRes = (1 << mraa_aio_get_bit(dev->aio));
+
+    return dev;
+}
+
+void rotary_close(rotary_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t rotary_get_value_voltage (const rotary_context dev,
+                                       float* volts)
+{
+    float val = 0.0;
+    val = mraa_aio_read(dev->aio);
+    *volts = (dev->m_aRef / dev->m_aRes) * (float)val;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t rotary_get_value_angle (rotary_context dev, float* rotval)
+{
+    float val = 0.0;
+    val = mraa_aio_read(dev->aio);
+
+    // return degrees
+    *rotval = val * (float)ROTARY_MAX_ANGLE / dev->m_aRes;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/rotary/rotary.h b/ext/lib/upm/src/rotary/rotary.h
new file mode 100644
index 0000000..653d2fe
--- /dev/null
+++ b/ext/lib/upm/src/rotary/rotary.h
@@ -0,0 +1,57 @@
+/*
+ * Author: Brendan Le Foll <brendan.le.foll@intel.com>
+ * 	   Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef ROTARY_H_
+#define ROTARY_H_
+
+#include <unistd.h>
+
+#include "upm.h"
+#include <mraa/aio.h>
+
+/**
+ * driver context
+ */
+typedef struct _rotary_context {
+    mraa_aio_context aio;
+    float m_aRef;
+    int16_t m_aRes;
+} *rotary_context;
+
+#define ROTARY_MAX_ANGLE 300
+
+typedef struct _rotary_context* rotary_context;
+
+rotary_context rotary_init(int pin, float aRef);
+
+void rotary_close(rotary_context dev);
+
+upm_result_t rotary_get_value_voltage(const rotary_context dev, float* volts);
+
+// degrees only
+upm_result_t rotary_get_value_angle(rotary_context dev, float* rotval);
+
+#endif /* ROTARY_H_ */
diff --git a/ext/lib/upm/src/rotaryencoder/Kbuild b/ext/lib/upm/src/rotaryencoder/Kbuild
new file mode 100644
index 0000000..da1a9a1
--- /dev/null
+++ b/ext/lib/upm/src/rotaryencoder/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_rotaryencoder) += rotaryencoder.o
diff --git a/ext/lib/upm/src/rotaryencoder/Kconfig b/ext/lib/upm/src/rotaryencoder/Kconfig
new file mode 100644
index 0000000..08019bf
--- /dev/null
+++ b/ext/lib/upm/src/rotaryencoder/Kconfig
@@ -0,0 +1,8 @@
+config UPM_rotaryencoder
+    bool "rotaryencoder"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm Rotary Encoder
diff --git a/ext/lib/upm/src/rotaryencoder/Makefile b/ext/lib/upm/src/rotaryencoder/Makefile
new file mode 100644
index 0000000..08c4fd1
--- /dev/null
+++ b/ext/lib/upm/src/rotaryencoder/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_rotaryencoder
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/rotaryencoder
+endif
diff --git a/ext/lib/upm/src/rotaryencoder/rotaryencoder.c b/ext/lib/upm/src/rotaryencoder/rotaryencoder.c
new file mode 100644
index 0000000..c616d89
--- /dev/null
+++ b/ext/lib/upm/src/rotaryencoder/rotaryencoder.c
@@ -0,0 +1,129 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include "rotaryencoder.h"
+
+
+// our ISR
+static void rotaryencoder_isr(void *ctx)
+{
+    assert (ctx != NULL);
+
+    rotaryencoder_context dev = (rotaryencoder_context)ctx;
+
+    if (mraa_gpio_read(dev->gpioA))
+    {
+        if (mraa_gpio_read(dev->gpioB))
+            dev->position++;      // CW
+        else
+            dev->position--;      // CCW
+    }
+}
+
+rotaryencoder_context rotaryencoder_init(int pin_a, int pin_b)
+{
+    rotaryencoder_context dev =
+        (rotaryencoder_context)malloc(sizeof(struct _rotaryencoder_context));
+
+    if (!dev)
+        return NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        rotaryencoder_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->gpioA = mraa_gpio_init(pin_a)) )
+    {
+        printf("%s: mraa_gpio_init(pin_a) failed\n",
+               __FUNCTION__);
+        rotaryencoder_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpioA, MRAA_GPIO_IN);
+
+    if ( !(dev->gpioB = mraa_gpio_init(pin_b)) )
+    {
+        printf("%s: mraa_gpio_init(pin_b) failed\n",
+               __FUNCTION__);
+        rotaryencoder_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpioB, MRAA_GPIO_IN);
+
+    dev->position = 0;
+
+    // setup the ISR
+
+    // We would prefer to use MRAA_GPIO_EDGE_BOTH for better resolution,
+    // but that does not appear to be supported universally
+    if (mraa_gpio_isr(dev->gpioA, MRAA_GPIO_EDGE_RISING,
+                      &rotaryencoder_isr, dev))
+    {
+        printf("%s: mraa_gpio_isr() failed\n",
+               __FUNCTION__);
+        rotaryencoder_close(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void rotaryencoder_close(rotaryencoder_context dev)
+{
+    assert (dev != NULL);
+
+    if (dev->gpioA)
+    {
+        mraa_gpio_isr_exit(dev->gpioA);
+        mraa_gpio_close(dev->gpioA);
+    }
+
+    if (dev->gpioB)
+        mraa_gpio_close(dev->gpioB);
+
+    free(dev);
+}
+
+void rotaryencoder_set_position(const rotaryencoder_context dev, int count)
+{
+    assert (dev != NULL);
+
+    dev->position = count;
+}
+
+int rotaryencoder_get_position(const rotaryencoder_context dev)
+{
+    assert (dev != NULL);
+
+    return dev->position;
+}
diff --git a/ext/lib/upm/src/rotaryencoder/rotaryencoder.h b/ext/lib/upm/src/rotaryencoder/rotaryencoder.h
new file mode 100644
index 0000000..02f514d
--- /dev/null
+++ b/ext/lib/upm/src/rotaryencoder/rotaryencoder.h
@@ -0,0 +1,84 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file rotaryencoder.h
+     * @library rotaryencoder
+     * @brief C API for the rotaryencoder driver
+     *
+     * @include rotaryencoder.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _rotaryencoder_context {
+        mraa_gpio_context gpioA;
+        mraa_gpio_context gpioB;
+
+        volatile int position;
+    } *rotaryencoder_context;
+
+    /**
+     * RotaryEncoder initialization
+     *
+     * @param pinA Digital pin to use for signal A
+     * @param pinB Digital pin to use for signal B
+     */
+    rotaryencoder_context rotaryencoder_init(int pin_a, int pin_b);
+
+    /**
+     * RotaryEncoder close function
+     */
+    void rotaryencoder_close(rotaryencoder_context dev);
+
+    /**
+     * Resets the position to a given number.
+     *
+     * @param count Integer to initialize the position to
+     */
+    void rotaryencoder_set_position(const rotaryencoder_context dev,
+                                    int count);
+
+    /**
+     * Gets the position value.
+     *
+     */
+    int rotaryencoder_get_position(const rotaryencoder_context dev);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/rpr220/Kbuild b/ext/lib/upm/src/rpr220/Kbuild
new file mode 100644
index 0000000..550d908
--- /dev/null
+++ b/ext/lib/upm/src/rpr220/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_rpr220) += rpr220.o
diff --git a/ext/lib/upm/src/rpr220/Kconfig b/ext/lib/upm/src/rpr220/Kconfig
new file mode 100644
index 0000000..50798aa
--- /dev/null
+++ b/ext/lib/upm/src/rpr220/Kconfig
@@ -0,0 +1,8 @@
+config UPM_rpr220
+    bool "rpr220"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm RPR220 IR Reflective Sensor
diff --git a/ext/lib/upm/src/rpr220/Makefile b/ext/lib/upm/src/rpr220/Makefile
new file mode 100644
index 0000000..f3be0bf
--- /dev/null
+++ b/ext/lib/upm/src/rpr220/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_rpr220
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/rpr220
+endif
diff --git a/ext/lib/upm/src/rpr220/rpr220.c b/ext/lib/upm/src/rpr220/rpr220.c
new file mode 100644
index 0000000..0e8981c
--- /dev/null
+++ b/ext/lib/upm/src/rpr220/rpr220.c
@@ -0,0 +1,107 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+
+#include "rpr220.h"
+
+rpr220_context rpr220_init(int pin)
+{
+    rpr220_context dev =
+        (rpr220_context)malloc(sizeof(struct _rpr220_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->gpio = NULL;
+    dev->isrInstalled = false;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        rpr220_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->gpio = mraa_gpio_init(pin)) )
+    {
+        printf("%s: mraa_gpio_init() failed\n",
+               __FUNCTION__);
+        rpr220_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+    return dev;
+}
+
+void rpr220_close(rpr220_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->isrInstalled)
+        rpr220_uninstall_isr(dev);
+
+    if (dev->gpio)
+        mraa_gpio_close(dev->gpio);
+
+    free(dev);
+}
+
+bool rpr220_black_detected(const rpr220_context dev)
+{
+    assert(dev != NULL);
+
+    return (mraa_gpio_read(dev->gpio) ? true : false);
+}
+
+void rpr220_install_isr(const rpr220_context dev,
+                        void (*isr)(void *), void *arg)
+{
+    assert(dev != NULL);
+
+    if (dev->isrInstalled)
+        rpr220_uninstall_isr(dev);
+
+    // install our interrupt handler
+    if (mraa_gpio_isr(dev->gpio, MRAA_GPIO_EDGE_RISING, isr, arg))
+    {
+        printf("%s: mraa_gpio_isr() failed.\n", __FUNCTION__);
+        return;
+    }
+
+    dev->isrInstalled = true;
+}
+
+void rpr220_uninstall_isr(const rpr220_context dev)
+{
+    assert(dev != NULL);
+
+    mraa_gpio_isr_exit(dev->gpio);
+    dev->isrInstalled = false;
+}
diff --git a/ext/lib/upm/src/rpr220/rpr220.h b/ext/lib/upm/src/rpr220/rpr220.h
new file mode 100644
index 0000000..6b733b6
--- /dev/null
+++ b/ext/lib/upm/src/rpr220/rpr220.h
@@ -0,0 +1,98 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @file rpr220.h
+     * @library rpr220
+     * @brief C API for the rpr220 driver
+     *
+     * @include rpr220.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _rpr220_context {
+        mraa_gpio_context gpio;
+
+        bool isrInstalled;
+    } *rpr220_context;
+
+    /**
+     * RPR220 initialization.
+     *
+     * @param pin Digital pin to use.
+     * @return rpr220 device context
+     */
+    rpr220_context rpr220_init(int pin);
+
+    /**
+     * RPR220 destructor
+     *
+     * @param dev Device context.
+     */
+    void rpr220_close(rpr220_context dev);
+
+    /**
+     * Gets the status of the pin; true means black has been detected
+     *
+     * @param dev Device context.
+     * @return True if the sensor has detected black
+     */
+    bool rpr220_black_detected(const rpr220_context dev);
+
+    /**
+     * Installs an ISR to be called when
+     * black is detected
+     *
+     * @param dev Device context.
+     * @param isr Pointer to a function to be called on interrupt
+     * @param arg Pointer to an object to be supplied as an
+     * argument to the ISR.
+     */
+    void rpr220_install_isr(const rpr220_context dev,
+                            void (*isr)(void *), void *arg);
+
+    /**
+     * Uninstalls the previously installed ISR
+     *
+     * @param dev Device context.
+     */
+    void rpr220_uninstall_isr(const rpr220_context dev);
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/servo/Kbuild b/ext/lib/upm/src/servo/Kbuild
new file mode 100644
index 0000000..9d33b2d
--- /dev/null
+++ b/ext/lib/upm/src/servo/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_servo) += es08a.o es9257.o
diff --git a/ext/lib/upm/src/servo/Kconfig b/ext/lib/upm/src/servo/Kconfig
new file mode 100644
index 0000000..89aea16
--- /dev/null
+++ b/ext/lib/upm/src/servo/Kconfig
@@ -0,0 +1,9 @@
+config UPM_servo
+    bool "servo"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm servo module
+
diff --git a/ext/lib/upm/src/servo/Makefile b/ext/lib/upm/src/servo/Makefile
new file mode 100644
index 0000000..e752acd
--- /dev/null
+++ b/ext/lib/upm/src/servo/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_servo
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/servo
+endif
diff --git a/ext/lib/upm/src/servo/es08a.c b/ext/lib/upm/src/servo/es08a.c
new file mode 100644
index 0000000..aa7256f
--- /dev/null
+++ b/ext/lib/upm/src/servo/es08a.c
@@ -0,0 +1,107 @@
+/*
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "es08a.h"
+
+es08a_context es08a_init(int32_t pin, int32_t min_pulse_width,
+                         int32_t max_pulse_width){
+    es08a_context dev = (es08a_context) malloc(sizeof(struct _es08a_context));
+
+    if(dev == NULL){
+        printf("Unable to assign memory to the Servo motor structure");
+        return NULL;
+    }
+
+    dev->servo_pin = pin;
+
+    // second is the min pulse width
+    dev->min_pulse_width = min_pulse_width;
+    // third is the max pulse width
+    dev->max_pulse_width = max_pulse_width;
+
+    dev->pwm = mraa_pwm_init(dev->servo_pin);
+    if(dev->pwm == NULL){
+        printf("Unable to initialize the PWM pin");
+    }
+
+    es08a_set_angle(dev, 0);
+    return dev;
+}
+
+void es08a_halt(es08a_context dev){
+    mraa_pwm_enable(dev->pwm, 0);
+    free(dev);
+}
+
+upm_result_t es08a_set_angle(es08a_context dev, int32_t angle){
+
+    if(ES08A_MAX_ANGLE < angle || angle < 0){
+        printf("The angle specified is either above the max angle or below 0");
+        return UPM_ERROR_UNSPECIFIED;
+    }
+    printf("setting angle to: %d\n", angle);
+
+    mraa_pwm_enable(dev->pwm, 1);
+    mraa_pwm_period_us(dev->pwm, ES08A_PERIOD);
+    int32_t val = 0;
+
+    es08a_calc_pulse_travelling(dev, &val, angle);
+    mraa_pwm_pulsewidth_us(dev->pwm, val);
+
+    upm_delay(1);
+    mraa_pwm_enable(dev->pwm, 0);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t es08a_calc_pulse_travelling(const es08a_context dev,
+                                         int32_t* ret_val, int32_t value){
+    if (value > dev->max_pulse_width) {
+        return dev->max_pulse_width;
+    }
+
+    // if less than the boundaries
+    if (value  < 0) {
+        return dev->min_pulse_width;
+    }
+
+    *ret_val = (int) ((float)dev->min_pulse_width + ((float)value / ES08A_MAX_ANGLE) * ((float)dev->max_pulse_width - (float)dev->min_pulse_width));
+    return UPM_SUCCESS;
+}
+
+void es08a_set_min_pulse_width (es08a_context dev, int width){
+    dev->min_pulse_width = width;
+}
+
+void es08a_set_max_pulse_width (es08a_context dev, int width){
+    dev->max_pulse_width = width;
+}
+
+int es08a_get_min_pulse_width (es08a_context dev){
+    return dev->min_pulse_width;
+}
+
+int es08a_get_max_pulse_width (es08a_context dev){
+    return dev->max_pulse_width;
+}
\ No newline at end of file
diff --git a/ext/lib/upm/src/servo/es08a.h b/ext/lib/upm/src/servo/es08a.h
new file mode 100644
index 0000000..e3d772b
--- /dev/null
+++ b/ext/lib/upm/src/servo/es08a.h
@@ -0,0 +1,137 @@
+/*
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef ES08A_H_
+#define ES08A_H_
+
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "upm.h"
+#include "mraa/pwm.h"
+
+/**
+ * @library servo
+ * @sensor es08a
+ * @comname ES08A Servo
+ * @altname Grove Servo
+ * @type servos
+ * @man emax
+ * @web http://www.seeedstudio.com/wiki/Grove_-_Servo
+ * @con pwm
+ * @kit gsk
+ *
+ * @brief API for the ES08A Servo
+ *
+ * This module defines the ES08A interface for ES08A servos.
+ * Like other servos, the ES08A servo has a shaft that can be controlled
+ * by setting the desired angle. There are also routines for setting
+ * and getting the minimum and maximum pulse width as well as the
+ * maximum period.
+ *
+ * @image html es08a.jpg
+ * @snippet es08a.c Interesting
+ */
+
+#define ES08A_MIN_PULSE_WIDTH             600
+#define ES08A_MAX_PULSE_WIDTH             2200
+#define ES08A_PERIOD                      20000
+#define ES08A_MAX_ANGLE                   180.0
+
+/**
+ * device context
+ */
+typedef struct _es08a_context {
+    mraa_pwm_context    pwm;
+    uint16_t            servo_pin;
+    uint32_t            max_pulse_width;
+    uint32_t            min_pulse_width;
+} *es08a_context;
+
+/**
+ * Instantiates a the servo at the given pin
+ *
+ * @param pin Servo pin number
+ * @param minPulseWidth Minimum pulse width, in microseconds
+ * @param maxPulseWidth Maximum pulse width, in microseconds
+ * @param waitAndDisablePwm If 1, PWM is enabled only during the
+ * setAngle() execution for a period of 1 second, and then turned back
+ * off. If 0, PWM remains on afterward.
+ */
+
+
+es08a_context es08a_init(int32_t pin, int32_t min_pulse_width,
+                         int32_t max_pulse_width);
+
+/**
+ * Halts PWM for this servo and allows it to move freely.
+ */
+void es08a_halt(es08a_context dev);
+
+/**
+ * Sets the angle of the servo engine.
+ *
+ * @param angle Number between 0 and 180
+ * @return 0 if successful, non-zero otherwise
+ */
+upm_result_t es08a_set_angle(es08a_context dev, int32_t angle);
+
+/*
+ * Calculating relative pulse time to the value.
+ * */
+upm_result_t es08a_calc_pulse_travelling(const es08a_context dev,
+                                         int32_t* ret_val,
+                                         int32_t value);
+
+/**
+ * Sets the minimum pulse width
+ *
+ * @param width Minimum HIGH signal width
+ */
+void es08a_set_min_pulse_width (es08a_context dev, int width);
+
+/**
+ * Sets the maximum pulse width
+ *
+ * @param width Maximum HIGH signal width
+ */
+void es08a_set_max_pulse_width (es08a_context dev, int width);
+
+/**
+ * Returns the minimum pulse width
+ *
+ * @return Minimum pulse width
+ */
+int es08a_get_min_pulse_width (es08a_context dev);
+
+/**
+ * Returns the maximum pulse width
+ *
+ * @return Maximum pulse width
+ */
+int es08a_get_max_pulse_width (es08a_context dev);
+
+#endif /* ES08A_H_ */
diff --git a/ext/lib/upm/src/servo/es9257.c b/ext/lib/upm/src/servo/es9257.c
new file mode 100644
index 0000000..d5fe0d7
--- /dev/null
+++ b/ext/lib/upm/src/servo/es9257.c
@@ -0,0 +1,107 @@
+/*
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "es9257.h"
+
+es9257_context es9257_init(int32_t pin, int32_t min_pulse_width,
+                         int32_t max_pulse_width){
+    es9257_context dev = (es9257_context) malloc(sizeof(struct _es9257_context));
+
+    if(dev == NULL){
+        printf("Unable to assign memory to the Servo motor structure");
+        return NULL;
+    }
+
+    dev->servo_pin = pin;
+
+    // second is the min pulse width
+    dev->min_pulse_width = min_pulse_width;
+    // third is the max pulse width
+    dev->max_pulse_width = max_pulse_width;
+
+    dev->pwm = mraa_pwm_init(dev->servo_pin);
+    if(dev->pwm == NULL){
+        printf("Unable to initialize the PWM pin");
+    }
+
+    es9257_set_angle(dev, 0);
+    return dev;
+}
+
+void es9257_halt(es9257_context dev){
+    mraa_pwm_enable(dev->pwm, 0);
+    free(dev);
+}
+
+upm_result_t es9257_set_angle(es9257_context dev, int32_t angle){
+
+    if(ES9257_MAX_ANGLE < angle || angle < 0){
+        printf("The angle specified is either above the max angle or below 0");
+        return UPM_ERROR_UNSPECIFIED;
+    }
+    printf("setting angle to: %d\n", angle);
+
+    mraa_pwm_enable(dev->pwm, 1);
+    mraa_pwm_period_us(dev->pwm, ES9257_PERIOD);
+    int32_t val = 0;
+
+    es9257_calc_pulse_travelling(dev, &val, angle);
+    mraa_pwm_pulsewidth_us(dev->pwm, val);
+
+    upm_delay(1);
+    mraa_pwm_enable(dev->pwm, 0);
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t es9257_calc_pulse_travelling(const es9257_context dev,
+                                         int32_t* ret_val, int32_t value){
+    if (value > dev->max_pulse_width) {
+        return dev->max_pulse_width;
+    }
+
+    // if less than the boundaries
+    if (value  < 0) {
+        return dev->min_pulse_width;
+    }
+
+    *ret_val = (int) ((float)dev->min_pulse_width + ((float)value / ES9257_MAX_ANGLE) * ((float)dev->max_pulse_width - (float)dev->min_pulse_width));
+    return UPM_SUCCESS;
+}
+
+void es9257_set_min_pulse_width (es9257_context dev, int width){
+    dev->min_pulse_width = width;
+}
+
+void es9257_set_max_pulse_width (es9257_context dev, int width){
+    dev->max_pulse_width = width;
+}
+
+int es9257_get_min_pulse_width (es9257_context dev){
+    return dev->min_pulse_width;
+}
+
+int es9257_get_max_pulse_width (es9257_context dev){
+    return dev->max_pulse_width;
+}
diff --git a/ext/lib/upm/src/servo/es9257.h b/ext/lib/upm/src/servo/es9257.h
new file mode 100644
index 0000000..c872297
--- /dev/null
+++ b/ext/lib/upm/src/servo/es9257.h
@@ -0,0 +1,137 @@
+/*
+ * Author: Yevgeniy Kiveisha <yevgeniy.kiveisha@intel.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef ES9257_H_
+#define ES9257_H_
+
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "upm.h"
+#include "mraa/pwm.h"
+
+/**
+ * @library servo
+ * @sensor es9257
+ * @comname ES9257 Servo
+ * @altname Grove Servo
+ * @type servos
+ * @man emax
+ * @web http://www.seeedstudio.com/wiki/Grove_-_Servo
+ * @con pwm
+ * @kit gsk
+ *
+ * @brief API for the ES9257 Servo
+ *
+ * This module defines the ES9257 interface for ES9257 servos.
+ * Like other servos, the ES9257 servo has a shaft that can be controlled
+ * by setting the desired angle. There are also routines for setting
+ * and getting the minimum and maximum pulse width as well as the
+ * maximum period.
+ *
+ * @image html es9257.jpg
+ * @snippet es9257.c Interesting
+ */
+
+#define ES9257_MIN_PULSE_WIDTH             600
+#define ES9257_MAX_PULSE_WIDTH             2200
+#define ES9257_PERIOD                      20000
+#define ES9257_MAX_ANGLE                   180.0
+
+/*
+ * device context
+ */
+typedef struct _es9257_context {
+    mraa_pwm_context    pwm;
+    uint16_t            servo_pin;
+    uint32_t            max_pulse_width;
+    uint32_t            min_pulse_width;
+} *es9257_context;
+
+/**
+ * Instantiates a the servo at the given pin
+ *
+ * @param pin Servo pin number
+ * @param minPulseWidth Minimum pulse width, in microseconds
+ * @param maxPulseWidth Maximum pulse width, in microseconds
+ * @param waitAndDisablePwm If 1, PWM is enabled only during the
+ * setAngle() execution for a period of 1 second, and then turned back
+ * off. If 0, PWM remains on afterward.
+ */
+
+
+es9257_context es9257_init(int32_t pin, int32_t min_pulse_width,
+                         int32_t max_pulse_width);
+
+/**
+ * Halts PWM for this servo and allows it to move freely.
+ */
+void es9257_halt(es9257_context dev);
+
+/**
+ * Sets the angle of the servo engine.
+ *
+ * @param angle Number between 0 and 180
+ * @return 0 if successful, non-zero otherwise
+ */
+upm_result_t es9257_set_angle(es9257_context dev, int32_t angle);
+
+/*
+ * Calculating relative pulse time to the value.
+ * */
+upm_result_t es9257_calc_pulse_travelling(const es9257_context dev,
+                                         int32_t* ret_val,
+                                         int32_t value);
+
+/**
+ * Sets the minimum pulse width
+ *
+ * @param width Minimum HIGH signal width
+ */
+void es9257_set_min_pulse_width (es9257_context dev, int width);
+
+/**
+ * Sets the maximum pulse width
+ *
+ * @param width Maximum HIGH signal width
+ */
+void es9257_set_max_pulse_width (es9257_context dev, int width);
+
+/**
+ * Returns the minimum pulse width
+ *
+ * @return Minimum pulse width
+ */
+int es9257_get_min_pulse_width (es9257_context dev);
+
+/**
+ * Returns the maximum pulse width
+ *
+ * @return Maximum pulse width
+ */
+int es9257_get_max_pulse_width (es9257_context dev);
+
+#endif /* ES9257_H_ */
\ No newline at end of file
diff --git a/ext/lib/upm/src/sht1x/Kbuild b/ext/lib/upm/src/sht1x/Kbuild
new file mode 100644
index 0000000..ea0d6a3
--- /dev/null
+++ b/ext/lib/upm/src/sht1x/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_sht1x) += sht1x.o
diff --git a/ext/lib/upm/src/sht1x/Kconfig b/ext/lib/upm/src/sht1x/Kconfig
new file mode 100644
index 0000000..d94a5d9
--- /dev/null
+++ b/ext/lib/upm/src/sht1x/Kconfig
@@ -0,0 +1,9 @@
+config UPM_sht1x
+    bool "sht1x"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM driver for the SHT1X temperature/humidity sensor
+
diff --git a/ext/lib/upm/src/sht1x/Makefile b/ext/lib/upm/src/sht1x/Makefile
new file mode 100644
index 0000000..0d681da
--- /dev/null
+++ b/ext/lib/upm/src/sht1x/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_sht1x
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/sht1x
+endif
diff --git a/ext/lib/upm/src/sht1x/sht1x.c b/ext/lib/upm/src/sht1x/sht1x.c
new file mode 100644
index 0000000..83ebb45
--- /dev/null
+++ b/ext/lib/upm/src/sht1x/sht1x.c
@@ -0,0 +1,386 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <assert.h>
+
+#include "upm_utilities.h"
+#include "sht1x.h"
+
+sht1x_context sht1x_init(unsigned int clk_pin, unsigned int data_pin)
+{
+  sht1x_context dev =
+    (sht1x_context)malloc(sizeof(struct _sht1x_context));
+
+  if (!dev)
+    return NULL;
+
+  // zero out context
+  memset((void *)dev, 0, sizeof(struct _sht1x_context));
+
+  dev->gpio_clk = NULL;
+  dev->gpio_data = NULL;
+
+  // initialize the MRAA contexts
+
+  // clock
+  if (!(dev->gpio_clk = mraa_gpio_init(clk_pin)))
+    {
+      printf("%s: mraa_gpio_init(clk) failed.\n", __FUNCTION__);
+      sht1x_close(dev);
+      return NULL;
+    }
+
+  mraa_gpio_dir(dev->gpio_clk, MRAA_GPIO_OUT);
+
+  // data
+  if (!(dev->gpio_data = mraa_gpio_init(data_pin)))
+    {
+      printf("%s: mraa_gpio_init(data) failed.\n", __FUNCTION__);
+      sht1x_close(dev);
+      return NULL;
+    }
+
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
+  mraa_gpio_mode(dev->gpio_data, MRAA_GPIO_PULLUP);
+
+  // max init time
+  upm_delay_ms(15);
+
+  // now read the status register to see if we are highres (14b) or not
+  uint8_t status;
+  if (sht1x_read_status(dev, &status))
+    {
+      printf("%s: sht1x_read_status() failed.\n", __FUNCTION__);
+      sht1x_close(dev);
+      return NULL;
+    }
+
+  if (status & SHT1X_STATUS_RESOLUTION_LOW)
+    dev->hires = false;
+  else
+    dev->hires = true;
+
+  // setup our coefficients (see the datasheet).  We always assume 5v
+  // here.  We also only deal with Celcius.
+
+  // this will set coeff_d1
+  sht1x_set_volts(dev, SHT1X_VOLTS_5);
+
+  dev->coeff_c1 = -2.0468;
+  dev->coeff_t1 = 0.01;
+  if (dev->hires)
+    {
+      dev->coeff_d2 = 0.01;
+      dev->coeff_c2 = 0.0367;
+      dev->coeff_c3 = -1.5955e-6;
+      dev->coeff_t2 = 0.00008;
+    }
+  else
+    {
+      dev->coeff_d2 = 0.04;
+      dev->coeff_c2 = 0.5872;
+      dev->coeff_c3 = -4.0845e-4;
+      dev->coeff_t2 = 0.00128;
+    }
+
+  return dev;
+}
+
+void sht1x_close(sht1x_context dev)
+{
+  assert(dev != NULL);
+
+  if (dev->gpio_clk)
+    mraa_gpio_close(dev->gpio_clk);
+  if (dev->gpio_data)
+    mraa_gpio_close(dev->gpio_data);
+
+  free(dev);
+}
+
+upm_result_t sht1x_update(const sht1x_context dev)
+{
+  assert(dev != NULL);
+
+  // byte 3 is the checksum which we currently ignore
+  uint8_t byte1, byte2, byte3;
+
+  // first read the temperature
+  sht1x_send_command(dev, SHT1X_CMD_MEAS_TEMPERATURE);
+  if (sht1x_wait_for_response(dev))
+    {
+      printf("%s: wait_for_response(temp) failed.\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  sht1x_read_8bits(dev, &byte1);
+  sht1x_read_8bits(dev, &byte2);
+  sht1x_read_8bits(dev, &byte3);
+
+  int temp = (byte1 << 8) | byte2;
+
+  // compute temperature
+  dev->temperature = dev->coeff_d1 + dev->coeff_d2 * (float)temp;
+
+  // now get humidity
+  sht1x_send_command(dev, SHT1X_CMD_MEAS_HUMIDITY);
+  if (sht1x_wait_for_response(dev))
+    {
+      printf("%s: wait_for_response(hum) failed.\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  sht1x_read_8bits(dev, &byte1);
+  sht1x_read_8bits(dev, &byte2);
+  sht1x_read_8bits(dev, &byte3);
+
+  temp = (byte1 << 8) | byte2;
+
+  // first we compute a linear humidity reading, then apply temperature
+  // compensation
+  float linHumidity = dev->coeff_c1 + dev->coeff_c2 * (float)temp
+    + dev->coeff_c3 * (float)temp * (float)temp;
+
+  // convert to "true" RH (temperature compensated)
+  dev->humidity = (dev->temperature - 25.0) * (dev->coeff_t1 + dev->coeff_t2)
+    + linHumidity;
+
+  if (dev->humidity > 99.0)
+    dev->humidity = 100.0;
+
+  return UPM_SUCCESS;
+}
+
+void sht1x_start_xmit(const sht1x_context dev)
+{
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
+
+  // start sequence
+  mraa_gpio_write(dev->gpio_data, 1);
+  mraa_gpio_write(dev->gpio_clk, 1);
+
+  mraa_gpio_write(dev->gpio_data, 0);
+  mraa_gpio_write(dev->gpio_clk, 0);
+
+  mraa_gpio_write(dev->gpio_clk, 1);
+  mraa_gpio_write(dev->gpio_data, 1);
+
+  mraa_gpio_write(dev->gpio_clk, 0);
+}
+
+upm_result_t sht1x_write_8bits(const sht1x_context dev, uint8_t byte)
+{
+  // send the byte
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
+
+  int i;
+  for (i=0; i<8; i++)
+    {
+      if (byte & 0x80)
+        mraa_gpio_write(dev->gpio_data, 1);
+      else
+        mraa_gpio_write(dev->gpio_data, 0);
+
+      mraa_gpio_write(dev->gpio_clk, 1);
+      mraa_gpio_write(dev->gpio_clk, 0);
+
+      byte <<= 1;
+    }
+
+  // now wait for the ack response.  After the falling edge of the 8th
+  // clock (above), the data line should be pulled low.  Then, after
+  // the falling edge of the ninth clock pulse, the data line should
+  // go high.  We check the data line after the rising edge of the
+  // ninth clock to make sure it went low.
+  bool ackError = false;
+
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_IN);
+
+  // start 9th clock
+  mraa_gpio_write(dev->gpio_clk, 1);
+
+  // should be low.  If it's high, there is a problem.
+  if (mraa_gpio_read(dev->gpio_data))
+    ackError = true;
+
+  // finish 9th clock
+  mraa_gpio_write(dev->gpio_clk, 0);
+
+  if (ackError)
+    {
+      printf("%s: didn't receive proper ACK from SHT1X.\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t sht1x_send_command(const sht1x_context dev, SHT1X_CMD_T cmd)
+{
+  assert(dev != NULL);
+
+  sht1x_start_xmit(dev);
+
+  // send the command
+  return sht1x_write_8bits(dev, (uint8_t)cmd);
+}
+
+upm_result_t sht1x_wait_for_response(const sht1x_context dev)
+{
+  assert(dev != NULL);
+
+  const int maxRetries = 500;
+  int r = 0;
+
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_IN);
+
+  // we wait for some time (about .5 seconds, more than enough time)
+  // for the data line to be pulled low.
+  while (r++ < maxRetries)
+    {
+      if (!mraa_gpio_read(dev->gpio_data))
+        break;
+
+      upm_delay_ms(1);
+    }
+
+  if (r >= maxRetries)
+    {
+      printf("%s: no response to measurement request.\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  //  printf("%s: retries: %d\n", __FUNCTION__, r);
+
+  return UPM_SUCCESS;
+}
+
+void sht1x_read_8bits(const sht1x_context dev, uint8_t *value)
+{
+  assert(dev != NULL);
+
+  // we need to read a byte, and acknowlege it
+
+  uint8_t byte = 0;
+
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_IN);
+
+  int i;
+
+  for (i=0; i<8; i++)
+    {
+      mraa_gpio_write(dev->gpio_clk, 1);
+
+      if (mraa_gpio_read(dev->gpio_data))
+        byte |= 1;
+
+      // don't shift on the last bit!
+      if (i != 7)
+        byte <<= 1;
+
+      mraa_gpio_write(dev->gpio_clk, 0);
+    }
+
+  *value = byte;
+
+  // send the ack
+
+  mraa_gpio_dir(dev->gpio_data, MRAA_GPIO_OUT);
+
+  // pull data line low
+  mraa_gpio_write(dev->gpio_data, 0);
+  // cycle the clock
+  mraa_gpio_write(dev->gpio_clk, 1);
+  mraa_gpio_write(dev->gpio_clk, 0);
+  // release data line
+  mraa_gpio_write(dev->gpio_data, 1);
+}
+
+float sht1x_get_temperature(const sht1x_context dev)
+{
+  assert(dev != NULL);
+
+  return dev->temperature;
+}
+
+float sht1x_get_humidity(const sht1x_context dev)
+{
+  assert(dev != NULL);
+
+  return dev->humidity;
+}
+
+void sht1x_reset(const sht1x_context dev)
+{
+  assert(dev != NULL);
+
+  sht1x_send_command(dev, SHT1X_CMD_SOFT_RESET);
+  upm_delay_ms(20);
+}
+
+upm_result_t sht1x_read_status(const sht1x_context dev, uint8_t *status)
+{
+  assert(dev != NULL);
+
+  upm_result_t rv;
+
+  if ((rv = sht1x_send_command(dev, SHT1X_CMD_READ_STATUS)))
+    {
+      printf("%s: send_command() failed.\n", __FUNCTION__);
+      return rv;
+    }
+
+  sht1x_read_8bits(dev, status);
+  return UPM_SUCCESS;
+}
+
+upm_result_t sht1x_write_status(const sht1x_context dev, uint8_t status)
+{
+  assert(dev != NULL);
+
+  upm_result_t rv;
+
+  if ((rv = sht1x_send_command(dev, SHT1X_CMD_WRITE_STATUS)))
+    {
+      printf("%s: send_command() failed.\n", __FUNCTION__);
+      return rv;
+    }
+
+  return sht1x_write_8bits(dev, status);
+}
+
+void sht1x_set_volts(const sht1x_context dev, SHT1X_VOLTS_T volts)
+{
+  assert(dev != NULL);
+
+  switch (volts)
+    {
+    case SHT1X_VOLTS_5:   dev->coeff_d1 = -40.1; break;
+    case SHT1X_VOLTS_4:   dev->coeff_d1 = -39.8; break;
+    case SHT1X_VOLTS_3_5: dev->coeff_d1 = -39.7; break;
+    case SHT1X_VOLTS_3:   dev->coeff_d1 = -39.6; break;
+    case SHT1X_VOLTS_2_5: dev->coeff_d1 = -39.4; break;
+    }
+}
diff --git a/ext/lib/upm/src/sht1x/sht1x.h b/ext/lib/upm/src/sht1x/sht1x.h
new file mode 100644
index 0000000..5363a00
--- /dev/null
+++ b/ext/lib/upm/src/sht1x/sht1x.h
@@ -0,0 +1,243 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /**
+   * @brief SHT1X Temperature and Humidity Sensor
+   *
+   * This driver was tested with a DFRobot SHT10 Temperature and
+   * Humidity sensor.  This driver should work on all SHT1X devices.
+   *
+   * It requires a 10K pull-up resistor connected to the data pin.
+   * The sensor can be run at differing voltages from 2.5v to 5v.
+   *
+   * @snippet sht1x.c Interesting
+   */
+
+  /**
+   * Device context
+   */
+  typedef struct _sht1x_context {
+    mraa_gpio_context        gpio_clk;
+    mraa_gpio_context        gpio_data;
+
+    // high res? (temp/hum 14/12b vs. 12/8b)
+    bool                     hires;
+
+    // our data
+    float                    temperature;
+    float                    humidity;
+
+    // temperature coeff (we only care about C)
+    float                    coeff_d1;
+    float                    coeff_d2;
+
+    // humidity coeff
+    float                    coeff_c1;
+    float                    coeff_c2;
+    float                    coeff_c3;
+
+    float                    coeff_t1;
+    float                    coeff_t2;
+  } *sht1x_context;
+
+  // SHT1X commands.  The first 3 msb's are the address, which are
+  // always 0.  The following 5 bits are the actual command.
+  typedef enum {
+    SHT1X_CMD_MEAS_TEMPERATURE            = 0x03,
+    SHT1X_CMD_MEAS_HUMIDITY               = 0x05,
+    SHT1X_CMD_WRITE_STATUS                = 0x06,
+    SHT1X_CMD_READ_STATUS                 = 0x07,
+    SHT1X_CMD_SOFT_RESET                  = 0x1e
+  } SHT1X_CMD_T;
+
+  // status register bits
+  typedef enum {
+    SHT1X_STATUS_RESOLUTION_LOW           = 0x01, // 0=12b RH/14b temp (dflt)
+    SHT1X_STATUS_NO_RELOAD_FROM_OTP       = 0x02,
+    SHT1X_STATUS_HEATER_EN                = 0x04,
+
+    // 0x08-0x20 reserved
+
+    SHT1X_STATUS_LOW_VOLT                 = 0x40 // low battery
+
+    // 0x80 reserved
+  } SHT1X_STATUS_BITS_T;
+
+  // The Vdd voltage can affect the temperature coefficients, so we
+  // provide a way to indicate the closest voltage and set up the
+  // compensation accordingly.
+  typedef enum {
+    SHT1X_VOLTS_5                         = 0, // 5 volts
+    SHT1X_VOLTS_4                         = 1,
+    SHT1X_VOLTS_3_5                       = 2, // 3.5v
+    SHT1X_VOLTS_3                         = 3,
+    SHT1X_VOLTS_2_5                       = 4
+  } SHT1X_VOLTS_T;
+
+  /**
+   * SHT1X Initializer
+   *
+   * @param clk_pin Specify the GPIO pin to use for the clock.
+   * @param data_pin Specify the GPIO pin to use for data.
+   * @return an initialized device context on success, NULL on error.
+   */
+  sht1x_context sht1x_init(unsigned int clk_pin, unsigned int data_pin);
+
+  /**
+   * SHT1X sensor close function
+   */
+  void sht1x_close(sht1x_context dev);
+
+  /**
+   * Perform a soft reset of the device.
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  void sht1x_reset(const sht1x_context dev);
+
+  /**
+   * Query the device and store the latest values.  You must call this
+   * function before querying the temperature or the humidity.
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  upm_result_t sht1x_update(const sht1x_context dev);
+
+  /**
+   * Query the temperature in degrees Celsius.  sht1x_update() must
+   * have been called prior to calling this function.
+   *
+   * @param dev sensor context
+   * @return The temperature in Celsius
+   */
+  float sht1x_get_temperature(const sht1x_context dev);
+
+  /**
+   * Query the relative humidity.  sht1x_update() must have been
+   * called prior to calling this function.
+   *
+   * @param dev sensor context
+   * @return The relative humidity.
+   */
+  float sht1x_get_humidity(const sht1x_context dev);
+
+  /**
+   * Read the status register.
+   *
+   * @param dev sensor context
+   * @param status The pointer to a uint8_t the status register will
+   * be stored in.
+   * @return UPM result
+   */
+  upm_result_t sht1x_read_status(const sht1x_context dev, uint8_t *status);
+
+  /**
+   * Write a value to the status register.
+   *
+   * @param dev sensor context
+   * @param status The uint8_t to write to the register.
+   * @return UPM result
+   */
+  upm_result_t sht1x_write_status(const sht1x_context dev, uint8_t status);
+
+  /**
+   * The Vdd voltage the sensor is being driven at can affect the
+   * temperature measurements.  This function allows you to specify a
+   * voltage as close as you are using to power the sensor, so that
+   * the appropriate compensation can be made.  By default, the
+   * coefficients are set for 5v operation.
+   *
+   * @param dev sensor context
+   * @param volts One of the SHT1X_VOLTS_T values.
+   */
+  void sht1x_set_volts(const sht1x_context dev, SHT1X_VOLTS_T volts);
+
+  /**
+   * Send a command to the device.  This is a low level command that
+   * should not be used directly unless you know exactly what you are
+   * doing.
+   *
+   * @param dev sensor context
+   * @param cmd One of the SHT1X_CMD_T values.
+   * @return UPM result
+   */
+  upm_result_t sht1x_send_command(const sht1x_context dev, SHT1X_CMD_T cmd);
+
+  /**
+   * Wait for the appropriate response when starting a temperature or
+   * humidity measurement.  This is a low level command that should
+   * not be used directly unless you know exactly what you are doing.
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  upm_result_t sht1x_wait_for_response(const sht1x_context dev);
+
+  /**
+   * Issue the start transmission sequence.  This is a low level
+   * command that should not be used directly unless you know exactly
+   * what you are doing.
+   *
+   * @param dev sensor context
+   * @return UPM result
+   */
+  void sht1x_start_xmit(const sht1x_context dev);
+
+  /**
+   * Read 8 bits (a byte) from the device.  This is a low level
+   * command that should not be used directly unless you know exactly
+   * what you are doing.
+   *
+   * @param dev sensor context
+   * @param value Pointer to a uint8_t that will hold the received byte.
+   * @return UPM result
+   */
+  void sht1x_read_8bits(const sht1x_context dev, uint8_t *value);
+
+  /**
+   * Write 8 bits (a byte) to the device.  This is a low level command
+   * that should not be used directly unless you know exactly what you
+   * are doing.
+   *
+   * @param dev sensor context
+   * @param value A uint8_t that will be sent to the device.
+   * @return UPM result
+   */
+  upm_result_t sht1x_write_8bits(const sht1x_context dev, uint8_t byte);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/slide/Kbuild b/ext/lib/upm/src/slide/Kbuild
new file mode 100644
index 0000000..4f7b741
--- /dev/null
+++ b/ext/lib/upm/src/slide/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_slide) += slide.o
diff --git a/ext/lib/upm/src/slide/Kconfig b/ext/lib/upm/src/slide/Kconfig
new file mode 100644
index 0000000..d21375d
--- /dev/null
+++ b/ext/lib/upm/src/slide/Kconfig
@@ -0,0 +1,9 @@
+config UPM_slide
+    bool "slide"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        Slide potentiometer sensor
+
diff --git a/ext/lib/upm/src/slide/Makefile b/ext/lib/upm/src/slide/Makefile
new file mode 100644
index 0000000..14f6224
--- /dev/null
+++ b/ext/lib/upm/src/slide/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_slide
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/slide
+endif
diff --git a/ext/lib/upm/src/slide/slide.c b/ext/lib/upm/src/slide/slide.c
new file mode 100644
index 0000000..9536f3d
--- /dev/null
+++ b/ext/lib/upm/src/slide/slide.c
@@ -0,0 +1,128 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "slide.h"
+
+slide_context slide_init(int16_t pin)
+{
+    slide_context dev = (slide_context) malloc(sizeof(struct _slide_context));
+
+    if (dev == NULL)
+      return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set the ADC ref, scale, and offset defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+
+    return dev;
+}
+
+void slide_close(slide_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t slide_set_aref(const slide_context dev, float aref)
+{
+    dev->m_aRef = aref;
+    return UPM_SUCCESS;
+}
+
+upm_result_t slide_set_scale(const slide_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t slide_set_offset(const slide_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float slide_get_aref(const slide_context dev)
+{
+    return dev->m_aRef;
+}
+
+float slide_get_scale(const slide_context dev)
+{
+    return dev->m_scale;
+}
+
+float slide_get_offset(const slide_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t slide_get_normalized(const slide_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+    return UPM_SUCCESS;
+}
+
+upm_result_t slide_get_raw_volts(const slide_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t slide_get_volts(const slide_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+     /* Scale to aRef */
+    *value *= dev->m_aRef;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/slide/slide.h b/ext/lib/upm/src/slide/slide.h
new file mode 100644
index 0000000..65cac53
--- /dev/null
+++ b/ext/lib/upm/src/slide/slide.h
@@ -0,0 +1,133 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * driver context
+ */
+typedef struct _slide_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* Analog voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+} *slide_context;
+
+/**
+ * Initialize analog sensor
+ * @param pin Analog pin
+ * @return sensor context
+ */
+slide_context slide_init(int16_t pin);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer
+ */
+void slide_close(slide_context dev);
+
+/**
+ * Set ADC reference voltage
+ * @param dev sensor context pointer
+ * @param aref ADC reference voltage
+ * @return Function result code
+ */
+upm_result_t slide_set_aref(const slide_context dev, float aref);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t slide_set_scale(const slide_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     value = value + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t slide_set_offset(const slide_context dev, float offset);
+
+/**
+ * Get sensor aref
+ * @param dev sensor context pointer
+ * @return Sensor ADC reference voltage
+ */
+float slide_get_aref(const slide_context dev);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float slide_get_scale(const slide_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float slide_get_offset(const slide_context dev);
+
+/**
+ * Read normalized value for sensor
+ * @param dev sensor context pointer
+ * @param *value Normalized value (0.0 -> 1.0)
+ * @return Function result code
+ */
+upm_result_t slide_get_normalized(const slide_context dev, float *value);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t slide_get_raw_volts(const slide_context dev, float *value);
+
+/**
+ * Read scaled/offset voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Adjusted sensor voltage
+ * @return Function result code
+ */
+upm_result_t slide_get_volts(const slide_context dev, float *value);
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/temperature/Kbuild b/ext/lib/upm/src/temperature/Kbuild
new file mode 100644
index 0000000..18ed380
--- /dev/null
+++ b/ext/lib/upm/src/temperature/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_temperature) += temperature.o
diff --git a/ext/lib/upm/src/temperature/Kconfig b/ext/lib/upm/src/temperature/Kconfig
new file mode 100644
index 0000000..2865164
--- /dev/null
+++ b/ext/lib/upm/src/temperature/Kconfig
@@ -0,0 +1,9 @@
+config UPM_temperature
+    bool "temperature"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        Temperature Sensor
+
diff --git a/ext/lib/upm/src/temperature/Makefile b/ext/lib/upm/src/temperature/Makefile
new file mode 100644
index 0000000..f60a88a
--- /dev/null
+++ b/ext/lib/upm/src/temperature/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_temperature
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/temperature
+endif
diff --git a/ext/lib/upm/src/temperature/temperature.c b/ext/lib/upm/src/temperature/temperature.c
new file mode 100644
index 0000000..19e1a78
--- /dev/null
+++ b/ext/lib/upm/src/temperature/temperature.c
@@ -0,0 +1,77 @@
+/*
+ * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "temperature.h"
+#include "upm.h"
+
+temperature_context temperature_init(int pin)
+{
+    temperature_context dev =
+      (temperature_context)malloc(sizeof(struct _temperature_context));
+
+    if (dev == NULL) return NULL;
+
+    dev->aio = mraa_aio_init(pin);
+    if(dev->aio == NULL)
+    {
+        free(dev);
+        return NULL;
+    }
+
+    dev->m_aRes = (1 << mraa_aio_get_bit(dev->aio));
+
+    return dev;
+}
+
+void temperature_close(temperature_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t temperature_get_value(temperature_context dev,
+                                   float* tempval)
+{
+    float val = 0.0;
+    val = (float)mraa_aio_read(dev->aio);
+
+    if (val == -1.0)
+    {
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // From old C++ UPM code, needs rework!!!
+    float r = ((float)dev->m_aRes - val) * 10000.0 / val;
+    float t = 1.0 / (log(r / 10000.0) / 3975.0 + 1.0 / 298.15) -273.15;
+
+    // Celsius
+    *tempval = t;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/temperature/temperature.h b/ext/lib/upm/src/temperature/temperature.h
new file mode 100644
index 0000000..2eaaa55
--- /dev/null
+++ b/ext/lib/upm/src/temperature/temperature.h
@@ -0,0 +1,52 @@
+/*
+ * Author: Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ *
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef TEMPERATURE_H_
+#define TEMPERATURE_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+/**
+ * driver context
+ */
+typedef struct _temperature_context {
+    mraa_aio_context aio;
+    int16_t m_aRes;
+} *temperature_context;
+
+
+temperature_context temperature_init(int pin);
+
+void temperature_close(temperature_context dev);
+
+// Celsius
+upm_result_t temperature_get_value(temperature_context dev,
+                                   float* tempval);
+
+#endif /* TEMPERATURE_H_ */
diff --git a/ext/lib/upm/src/tsl2561/Kbuild b/ext/lib/upm/src/tsl2561/Kbuild
new file mode 100644
index 0000000..83c3fc3
--- /dev/null
+++ b/ext/lib/upm/src/tsl2561/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_tsl2561) += tsl2561.o
diff --git a/ext/lib/upm/src/tsl2561/Kconfig b/ext/lib/upm/src/tsl2561/Kconfig
new file mode 100644
index 0000000..ff04c36
--- /dev/null
+++ b/ext/lib/upm/src/tsl2561/Kconfig
@@ -0,0 +1,9 @@
+config UPM_tsl2561
+    bool "tsl2561"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm tsl2561 Digital Light Sensor
+
diff --git a/ext/lib/upm/src/tsl2561/Makefile b/ext/lib/upm/src/tsl2561/Makefile
new file mode 100644
index 0000000..2e5f200
--- /dev/null
+++ b/ext/lib/upm/src/tsl2561/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_tsl2561
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/tsl2561
+endif
diff --git a/ext/lib/upm/src/tsl2561/tsl2561.c b/ext/lib/upm/src/tsl2561/tsl2561.c
new file mode 100644
index 0000000..75e4849
--- /dev/null
+++ b/ext/lib/upm/src/tsl2561/tsl2561.c
@@ -0,0 +1,246 @@
+/*
+ * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
+ *   Inspiration and lux calculation formulas from data sheet
+ *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "tsl2561.h"
+
+// forward declaration
+upm_result_t tsl2561_compute_lux(const tsl2561_context dev, int *int_data);
+
+tsl2561_context tsl2561_init(int bus, uint8_t dev_address, uint8_t gain,
+                             uint8_t integration_time){
+    tsl2561_context dev =
+      (tsl2561_context)malloc(sizeof(struct _tsl2561_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->bus = bus;
+    dev->address = dev_address;
+    dev->gain = gain;
+    dev->integration_time = integration_time;
+
+    dev->i2c = mraa_i2c_init(dev->bus);
+    if(dev->i2c == NULL){
+        free(dev);
+        return NULL;
+    }
+
+    if (mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS)
+        {
+            mraa_i2c_stop(dev->i2c);
+            free(dev);
+            return NULL;
+        }
+
+    // POWER UP.
+    if(mraa_i2c_write_byte_data(dev->i2c, CONTROL_POWERON, REGISTER_Control) != MRAA_SUCCESS){
+        mraa_i2c_stop(dev->i2c);
+        free(dev);
+        return NULL;
+    }
+
+    // Power on Settling time
+    upm_delay_us(1000);
+
+    // Gain & Integration time.
+    if(mraa_i2c_write_byte_data(dev->i2c, (dev->gain | dev->integration_time), REGISTER_Timing) != MRAA_SUCCESS){
+        mraa_i2c_stop(dev->i2c);
+        free(dev);
+        return NULL;
+    }
+
+    // Set interrupt threshold to default.
+    if(mraa_i2c_write_byte_data(dev->i2c, 0x00, REGISTER_Interrupt) != MRAA_SUCCESS){
+        mraa_i2c_stop(dev->i2c);
+        free(dev);
+        return NULL;
+    }
+
+    return dev;
+}
+
+void tsl2561_close(tsl2561_context dev){
+    if (mraa_i2c_write_byte_data(dev->i2c, CONTROL_POWEROFF,
+                                 REGISTER_Control) != MRAA_SUCCESS){
+        printf("Unable turn off device\n");
+    }
+
+    mraa_i2c_stop(dev->i2c);
+    free(dev);
+}
+
+upm_result_t tsl2561_get_lux(const tsl2561_context dev, float* lux){
+    int lux_val=0;
+
+    tsl2561_compute_lux(dev, &lux_val);
+
+    *lux = (float) lux_val;
+    return UPM_SUCCESS;
+}
+
+upm_result_t tsl2561_i2c_write_reg(tsl2561_context dev, uint8_t reg,
+                                   uint8_t value){
+    // Start transmission to device
+    if(mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Write register to I2C
+    if(mraa_i2c_write_byte(dev->i2c, reg) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Write value to I2C
+    if(mraa_i2c_write_byte(dev->i2c, value) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    upm_delay_ms(100);
+    return UPM_SUCCESS;
+}
+
+upm_result_t tsl2561_i2c_read_reg(tsl2561_context dev, uint8_t reg,
+                                  uint8_t* data){
+   // Start transmission to dev
+    if(mraa_i2c_address(dev->i2c, dev->address) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Send address of register to be read.
+    if(mraa_i2c_write_byte(dev->i2c, reg) != MRAA_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    // Read byte.
+    *data = mraa_i2c_read_byte(dev->i2c);
+
+    //upm_delay(1);
+    return UPM_SUCCESS;
+}
+
+upm_result_t tsl2561_compute_lux(const tsl2561_context dev, int *int_data) {
+    int lux;
+    uint16_t raw_lux_ch_0;
+    uint16_t raw_lux_ch_1;
+    uint8_t ch0_low, ch0_high, ch1_low, ch1_high;
+	
+    if (tsl2561_i2c_read_reg(dev, REGISTER_Channal0L, &ch0_low) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal0H, &ch0_high) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    raw_lux_ch_0 = ch0_high*256 + ch0_low;
+
+    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal1L, &ch1_low) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+
+    if(tsl2561_i2c_read_reg(dev, REGISTER_Channal1H, &ch1_high) != UPM_SUCCESS){
+        return UPM_ERROR_OPERATION_FAILED;
+    }
+    raw_lux_ch_1 = ch1_high*256 + ch1_low;
+
+    uint64_t scale = 0;
+
+    switch(dev->integration_time){
+        case 0: // 13.7 msec
+            scale = LUX_CHSCALE_TINT0;
+            break;
+        case 1: // 101 msec
+            scale = LUX_CHSCALE_TINT1;
+            break;
+        case 2: // assume no scaling
+            scale = (1 << LUX_CHSCALE);
+            break;
+    }
+
+    // scale if gain is NOT 16X
+    if(!dev->gain)
+        scale = scale << 4;
+
+    uint64_t channel1 = 0;
+    uint64_t channel0 = 0;
+
+    // scale the channel values
+    channel0 = (raw_lux_ch_0 * scale) >> LUX_CHSCALE;
+    channel1 = (raw_lux_ch_1 * scale) >> LUX_CHSCALE;
+
+    // find the ratio of the channel values (Channel1/Channel0)
+    // protect against divide by zero
+    uint64_t ratio_1 = 0;
+    if (channel0 != 0)
+        ratio_1 = (channel1 << (LUX_RATIOSCALE+1)) / channel0;
+
+    // round the ratio value
+    unsigned long ratio = (ratio_1 + 1) >> 1;
+    unsigned int b, m;
+
+    // CS package
+    // Check if ratio <= eachBreak ?
+    if ((ratio >= 0) && (ratio <= LUX_K1C)){
+        b=LUX_B1C; m=LUX_M1C;
+    }
+    else if (ratio <= LUX_K2C){
+        b=LUX_B2C; m=LUX_M2C;
+    }
+    else if (ratio <= LUX_K3C){
+        b=LUX_B3C; m=LUX_M3C;
+    }
+    else if (ratio <= LUX_K4C){
+        b=LUX_B4C; m=LUX_M4C;
+    }
+    else if (ratio <= LUX_K5C){
+        b=LUX_B5C; m=LUX_M5C;
+    }
+    else if (ratio <= LUX_K6C){
+        b=LUX_B6C; m=LUX_M6C;
+    }
+    else if (ratio <= LUX_K7C){
+        b=LUX_B7C; m=LUX_M7C;
+    }
+    else if (ratio > LUX_K8C){
+        b=LUX_B8C; m=LUX_M8C;
+    }
+    uint64_t temp_lux = 0;
+    temp_lux = ((channel0 * b) - (channel1 * m));
+    // do not allow negative lux value
+    if (temp_lux < 0) temp_lux = 0;
+
+    // round lsb (2^(LUX_SCALE-1))
+    temp_lux += (1 << (LUX_SCALE-1));
+
+    // strip off fractional portion
+    lux = temp_lux >> LUX_SCALE;
+
+    *int_data = lux;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/tsl2561/tsl2561.h b/ext/lib/upm/src/tsl2561/tsl2561.h
new file mode 100644
index 0000000..7b9f34d
--- /dev/null
+++ b/ext/lib/upm/src/tsl2561/tsl2561.h
@@ -0,0 +1,156 @@
+/*
+ * Author: Nandkishor Sonar <Nandkishor.Sonar@intel.com>,
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 Intel Corporation.
+ *
+ * LIGHT-TO-DIGITAL CONVERTER [TAOS-TSL2561]
+ *   Inspiration and lux calculation formulas from data sheet
+ *   URL: http://www.adafruit.com/datasheets/TSL2561.pdf
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef TSL2561_H_
+#define TSL2561_H_
+
+#include <stdint.h>
+#include <upm.h>
+#include <mraa/i2c.h>
+
+#define TSL2561_Address          (0x29)  //Device address
+
+// Integration time
+#define  INTEGRATION_TIME0_13MS  (0x00)  // 13.7ms
+#define  INTEGRATION_TIME1_101MS (0x01)  // 101ms
+#define  INTEGRATION_TIME2_402MS (0x02)  // 402ms
+
+// Integration time
+#define  GAIN_0X  (0x00)                // No gain - Low
+#define  GAIN_16X (0x10)                // 16x gain - High
+
+// Power control bits
+#define CONTROL_POWERON   (0x03)        // ON
+#define CONTROL_POWEROFF  (0x00)        // OFF
+
+// TSL2561 registers
+#define  REGISTER_Control   (0x80)
+#define  REGISTER_Timing    (0x81)
+#define  REGISTER_Interrupt (0x86)
+#define  REGISTER_Channal0L (0x8C)
+#define  REGISTER_Channal0H (0x8D)
+#define  REGISTER_Channal1L (0x8E)
+#define  REGISTER_Channal1H (0x8F)
+
+// Lux calculations differ slightly for CS package
+#define LUX_SCALE         (14)      // Scale by 2^14
+#define LUX_RATIOSCALE    (9)       // Scale ratio by 2^9
+#define LUX_CHSCALE       (10)      // Scale channel values by 2^10
+#define LUX_CHSCALE_TINT0 (0x7517)  // 322/11 * 2^TSL2561_LUX_CHSCALE
+#define LUX_CHSCALE_TINT1 (0x0FE7)  // 322/81 * 2^TSL2561_LUX_CHSCALE
+
+// CS package Coefficients
+#define LUX_K1C           (0x0043)  // 0.130 * 2^RATIO_SCALE
+#define LUX_B1C           (0x0204)  // 0.0315 * 2^LUX_SCALE
+#define LUX_M1C           (0x01ad)  // 0.0262 * 2^LUX_SCALE
+#define LUX_K2C           (0x0085)  // 0.260 * 2^RATIO_SCALE
+#define LUX_B2C           (0x0228)  // 0.0337 * 2^LUX_SCALE
+#define LUX_M2C           (0x02c1)  // 0.0430 * 2^LUX_SCALE
+#define LUX_K3C           (0x00c8)  // 0.390 * 2^RATIO_SCALE
+#define LUX_B3C           (0x0253)  // 0.0363 * 2^LUX_SCALE
+#define LUX_M3C           (0x0363)  // 0.0529 * 2^LUX_SCALE
+#define LUX_K4C           (0x010a)  // 0.520 * 2^RATIO_SCALE
+#define LUX_B4C           (0x0282)  // 0.0392 * 2^LUX_SCALE
+#define LUX_M4C           (0x03df)  // 0.0605 * 2^LUX_SCALE
+#define LUX_K5C           (0x014d)  // 0.65 * 2^RATIO_SCALE
+#define LUX_B5C           (0x0177)  // 0.0229 * 2^LUX_SCALE
+#define LUX_M5C           (0x01dd)  // 0.0291 * 2^LUX_SCALE
+#define LUX_K6C           (0x019a)  // 0.80 * 2^RATIO_SCALE
+#define LUX_B6C           (0x0101)  // 0.0157 * 2^LUX_SCALE
+#define LUX_M6C           (0x0127)  // 0.0180 * 2^LUX_SCALE
+#define LUX_K7C           (0x029a)  // 1.3 * 2^RATIO_SCALE
+#define LUX_B7C           (0x0037)  // 0.00338 * 2^LUX_SCALE
+#define LUX_M7C           (0x002b)  // 0.00260 * 2^LUX_SCALE
+#define LUX_K8C           (0x029a)  // 1.3 * 2^RATIO_SCALE
+#define LUX_B8C           (0x0000)  // 0.000 * 2^LUX_SCALE
+#define LUX_M8C           (0x0000)  // 0.000 * 2^LUX_SCALE
+
+/**
+ * device context
+ */
+typedef struct _tsl2561_context {
+    mraa_i2c_context    i2c;
+    int                 bus;
+    uint8_t             address;
+    uint8_t             gain;
+    uint8_t             integration_time;
+} *tsl2561_context;
+
+/**
+ * Sensor Init Function
+ *
+ * @param bus I2C bus
+ * @param dev_address I2C address
+ * @param gain Gain associated with the driver
+ * @param integration_time
+ * @return void* pointer to the sensor struct
+ */
+tsl2561_context tsl2561_init(int bus, uint8_t dev_address, uint8_t gain,
+                             uint8_t integration_time);
+
+/**
+ * Closes the sensor module
+ *
+ * @param dev pointer to the sensor struct
+ */
+void tsl2561_close(tsl2561_context dev);
+
+/**
+ * Gets the Lux value
+ *
+ * @param dev pointer to the sensor struct
+ * @param lux pointer to store the lux value
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t tsl2561_get_lux(const tsl2561_context, float* lux);
+
+/**
+ * Write I2C register on the device
+ *
+ * @param dev pointer to the sensor struct
+ * @param reg register to write value to
+ * @param value the value to be written
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t tsl2561_i2c_write_reg(tsl2561_context dev, uint8_t reg,
+                                   uint8_t value);
+
+/**
+ * Read from an I2C register from the device
+ *
+ * @param dev pointer to the sensor struct
+ * @param reg register to write value to
+ * @param data Data read in  from the register
+ * @return upm_result_t UPM success/error code
+ */
+upm_result_t tsl2561_i2c_read_reg(tsl2561_context dev, uint8_t reg,
+                                  uint8_t* data);
+
+
+#endif /* TSL2561_H_ */
diff --git a/ext/lib/upm/src/ttp223/Kbuild b/ext/lib/upm/src/ttp223/Kbuild
new file mode 100644
index 0000000..ca23d6a
--- /dev/null
+++ b/ext/lib/upm/src/ttp223/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_ttp223) += ttp223.o
diff --git a/ext/lib/upm/src/ttp223/Kconfig b/ext/lib/upm/src/ttp223/Kconfig
new file mode 100644
index 0000000..efa77ad
--- /dev/null
+++ b/ext/lib/upm/src/ttp223/Kconfig
@@ -0,0 +1,9 @@
+config UPM_ttp223
+    bool "ttp223"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm ttp223 touch sensor module
+
diff --git a/ext/lib/upm/src/ttp223/Makefile b/ext/lib/upm/src/ttp223/Makefile
new file mode 100644
index 0000000..ba80c02
--- /dev/null
+++ b/ext/lib/upm/src/ttp223/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_ttp223
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/ttp223
+endif
diff --git a/ext/lib/upm/src/ttp223/ttp223.c b/ext/lib/upm/src/ttp223/ttp223.c
new file mode 100644
index 0000000..b724fa0
--- /dev/null
+++ b/ext/lib/upm/src/ttp223/ttp223.c
@@ -0,0 +1,80 @@
+/*
+ * Author: Sarah Knepper <sarah.knepper@intel.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "ttp223.h"
+
+ttp223_context ttp223_init(int pin){
+    ttp223_context dev = 
+      (ttp223_context) malloc(sizeof(struct _ttp223_context));
+
+    if (dev == NULL) {
+        printf("Unable to allocate space for the sensor struct\n");
+        return NULL;
+    }
+
+    dev->gpio_pin = pin;
+
+    dev->gpio = mraa_gpio_init(dev->gpio_pin);
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+    dev->isr_installed = false;
+
+    return dev;
+}
+
+void ttp223_close(ttp223_context dev){
+  mraa_gpio_close(dev->gpio);
+  free(dev);
+}
+
+upm_result_t ttp223_is_pressed(ttp223_context dev, bool* value) {
+    int ret = mraa_gpio_read(dev->gpio);
+
+    if (ret > 0)
+        *value = true;
+    else
+        *value = false;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t upm_ttp223_install_isr(ttp223_context dev,
+                                    mraa_gpio_edge_t edge_level,
+                                    void (*isr)(void *), void *arg){
+    ttp223_uninstall_isr(dev);
+
+    mraa_gpio_isr(dev->gpio, edge_level, isr, arg);
+    dev->isr_installed = true;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t ttp223_uninstall_isr(ttp223_context dev){
+    if (dev->isr_installed)
+        mraa_gpio_isr_exit(dev->gpio);
+
+    dev->isr_installed = false;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/ttp223/ttp223.h b/ext/lib/upm/src/ttp223/ttp223.h
new file mode 100644
index 0000000..9220bd2
--- /dev/null
+++ b/ext/lib/upm/src/ttp223/ttp223.h
@@ -0,0 +1,81 @@
+/*
+ * Author: Sarah Knepper <sarah.knepper@intel.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef TTP223_H_
+#define TTP223_H_
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "upm.h"
+#include "mraa/gpio.h"
+
+/**
+ * device context
+ */
+typedef struct _ttp223_context {
+    mraa_gpio_context       gpio;
+    uint8_t                 gpio_pin;
+    bool                    isr_installed;
+} *ttp223_context;
+
+/**
+ * Sensor Init function
+ *
+ * @param pin The pin number the sensor is attached to
+ * @return void* pointer to the sensor struct
+ */
+ttp223_context ttp223_init(int pin);
+
+/**
+ * Sensor Module close function
+ *
+ * @param dev pointer to the sensor struct
+ */
+void ttp223_close(ttp223_context dev);
+
+/**
+ * Function to tell if the sensor is pressed
+ *
+ * @param dev pointer to the sensor struct
+ * @param value pointer to store whether the sensor is pressed or not
+ * @result upm_result_t UPM success/error code
+ */
+upm_result_t ttp223_is_pressed(ttp223_context dev, bool* value);
+
+/**
+ *
+ */
+upm_result_t ttp223_install_isr(ttp223_context dev,
+                                mraa_gpio_edge_t edge_level,
+                                void (*isr)(void *), void *arg);
+
+/**
+ *
+ */
+upm_result_t ttp223_uninstall_isr(ttp223_context);
+
+#endif /* TTP223_H_ */
diff --git a/ext/lib/upm/src/uln200xa/Kbuild b/ext/lib/upm/src/uln200xa/Kbuild
new file mode 100644
index 0000000..216393c
--- /dev/null
+++ b/ext/lib/upm/src/uln200xa/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_uln200xa) += uln200xa.o
diff --git a/ext/lib/upm/src/uln200xa/Kconfig b/ext/lib/upm/src/uln200xa/Kconfig
new file mode 100644
index 0000000..19c9611
--- /dev/null
+++ b/ext/lib/upm/src/uln200xa/Kconfig
@@ -0,0 +1,8 @@
+config UPM_uln200xa
+    bool "uln200xa"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm ULN200XA Stepper Motor
diff --git a/ext/lib/upm/src/uln200xa/Makefile b/ext/lib/upm/src/uln200xa/Makefile
new file mode 100644
index 0000000..fd186c7
--- /dev/null
+++ b/ext/lib/upm/src/uln200xa/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_uln200xa
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/uln200xa
+endif
diff --git a/ext/lib/upm/src/uln200xa/uln200xa.c b/ext/lib/upm/src/uln200xa/uln200xa.c
new file mode 100644
index 0000000..a2b56b6
--- /dev/null
+++ b/ext/lib/upm/src/uln200xa/uln200xa.c
@@ -0,0 +1,260 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#include <assert.h>
+#include <upm_utilities.h>
+
+#include "uln200xa.h"
+
+static void uln200xa_stepper_step(const uln200xa_context dev);
+
+uln200xa_context uln200xa_init(int stepsPerRev, unsigned int i1,
+                               unsigned int i2, unsigned int i3,
+                               unsigned int i4)
+{
+    uln200xa_context dev =
+        (uln200xa_context)malloc(sizeof(struct _uln200xa_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->stepI1 = NULL;
+    dev->stepI2 = NULL;
+    dev->stepI3 = NULL;
+    dev->stepI4 = NULL;
+
+    dev->stepsPerRev = stepsPerRev;
+    dev->currentStep = 0;
+    dev->stepDelay = 0;
+    dev->stepDirection = 1;          // default is forward
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        uln200xa_close(dev);
+        return NULL;
+    }
+
+    // MRAA contexts...
+    if ( !(dev->stepI1 = mraa_gpio_init(i1)) )
+    {
+        printf("%s: mraa_gpio_init(i1) failed\n",
+               __FUNCTION__);
+        uln200xa_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->stepI1, MRAA_GPIO_OUT);
+
+    if ( !(dev->stepI2 = mraa_gpio_init(i2)) )
+    {
+        printf("%s: mraa_gpio_init(i2) failed\n",
+               __FUNCTION__);
+        uln200xa_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->stepI2, MRAA_GPIO_OUT);
+
+    if ( !(dev->stepI3 = mraa_gpio_init(i3)) )
+    {
+        printf("%s: mraa_gpio_init(i3) failed\n",
+               __FUNCTION__);
+        uln200xa_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->stepI3, MRAA_GPIO_OUT);
+
+    if ( !(dev->stepI4 = mraa_gpio_init(i4)) )
+    {
+        printf("%s: mraa_gpio_init(i4) failed\n",
+               __FUNCTION__);
+        uln200xa_close(dev);
+        return NULL;
+    }
+    mraa_gpio_dir(dev->stepI4, MRAA_GPIO_OUT);
+
+    // set default speed to 1
+    uln200xa_set_speed(dev, 1);
+
+    return dev;
+}
+
+void uln200xa_close(uln200xa_context dev)
+{
+    assert(dev != NULL);
+
+    uln200xa_release(dev);
+    if (dev->stepI1)
+        mraa_gpio_close(dev->stepI1);
+    if (dev->stepI2)
+        mraa_gpio_close(dev->stepI2);
+    if (dev->stepI3)
+        mraa_gpio_close(dev->stepI3);
+    if (dev->stepI4)
+        mraa_gpio_close(dev->stepI4);
+
+    free(dev);
+}
+
+void uln200xa_set_speed(const uln200xa_context dev, unsigned int speed)
+{
+    assert(dev != NULL);
+
+    dev->stepDelay = 60 * 1000 / dev->stepsPerRev / speed;
+}
+
+void uln200xa_set_direction(const uln200xa_context dev,
+                            ULN200XA_DIRECTION_T dir)
+{
+    assert(dev != NULL);
+
+    switch (dir)
+    {
+    case ULN200XA_DIR_CW:
+        dev->stepDirection = 1;
+        break;
+    case ULN200XA_DIR_CCW:
+        dev->stepDirection = -1;
+        break;
+    }
+}
+
+static void uln200xa_stepper_step(const uln200xa_context dev)
+{
+    assert(dev != NULL);
+
+    int step = dev->currentStep % 8;
+
+    // This motor requires a different sequencing order in 8-steps than
+    // usual.
+
+    //   Step I0 I1 I2 I3
+    //     1  0  0  0  1
+    //     2  0  0  1  1
+    //     3  0  0  1  0
+    //     4  0  1  1  0
+    //     5  0  1  0  0
+    //     6  1  1  0  0
+    //     7  1  0  0  0
+    //     8  1  0  0  1
+
+    switch (step)
+    {
+    case 0:    // 0001
+        mraa_gpio_write(dev->stepI1, 0);
+        mraa_gpio_write(dev->stepI2, 0);
+        mraa_gpio_write(dev->stepI3, 0);
+        mraa_gpio_write(dev->stepI4, 1);
+        break;
+    case 1:    // 0011
+        mraa_gpio_write(dev->stepI1, 0);
+        mraa_gpio_write(dev->stepI2, 0);
+        mraa_gpio_write(dev->stepI3, 1);
+        mraa_gpio_write(dev->stepI4, 1);
+        break;
+    case 2:    // 0010
+        mraa_gpio_write(dev->stepI1, 0);
+        mraa_gpio_write(dev->stepI2, 0);
+        mraa_gpio_write(dev->stepI3, 1);
+        mraa_gpio_write(dev->stepI4, 0);
+        break;
+    case 3:    // 0110
+        mraa_gpio_write(dev->stepI1, 0);
+        mraa_gpio_write(dev->stepI2, 1);
+        mraa_gpio_write(dev->stepI3, 1);
+        mraa_gpio_write(dev->stepI4, 0);
+        break;
+    case 4:    // 0100
+        mraa_gpio_write(dev->stepI1, 0);
+        mraa_gpio_write(dev->stepI2, 1);
+        mraa_gpio_write(dev->stepI3, 0);
+        mraa_gpio_write(dev->stepI4, 0);
+        break;
+    case 5:    // 1100
+        mraa_gpio_write(dev->stepI1, 1);
+        mraa_gpio_write(dev->stepI2, 1);
+        mraa_gpio_write(dev->stepI3, 0);
+        mraa_gpio_write(dev->stepI4, 0);
+        break;
+    case 6:    // 1000
+        mraa_gpio_write(dev->stepI1, 1);
+        mraa_gpio_write(dev->stepI2, 0);
+        mraa_gpio_write(dev->stepI3, 0);
+        mraa_gpio_write(dev->stepI4, 0);
+        break;
+    case 7:    // 1001
+        mraa_gpio_write(dev->stepI1, 1);
+        mraa_gpio_write(dev->stepI2, 0);
+        mraa_gpio_write(dev->stepI3, 0);
+        mraa_gpio_write(dev->stepI4, 1);
+        break;
+    default:
+        // can't happen
+        break;
+    }
+}
+
+void uln200xa_stepper_steps(const uln200xa_context dev, unsigned int steps)
+{
+    assert(dev != NULL);
+
+    while (steps > 0)
+    {
+        upm_delay_ms(dev->stepDelay);
+        dev->currentStep += dev->stepDirection;
+
+        if (dev->stepDirection == 1)
+        {
+            if (dev->currentStep >= dev->stepsPerRev)
+                dev->currentStep = 0;
+        }
+        else
+        {
+            if (dev->currentStep <= 0)
+                dev->currentStep = dev->stepsPerRev;
+        }
+
+        steps--;
+        uln200xa_stepper_step(dev);
+    }
+}
+
+void uln200xa_release(const uln200xa_context dev)
+{
+    assert(dev !=NULL);
+
+    // we do these check since this is also called from
+    // uln200xa_close() and we can't be sure that all of the contexts
+    // have been created yet.
+    if (dev->stepI1)
+        mraa_gpio_write(dev->stepI1, 0);
+    if (dev->stepI2)
+        mraa_gpio_write(dev->stepI2, 0);
+    if (dev->stepI3)
+        mraa_gpio_write(dev->stepI3, 0);
+    if (dev->stepI4)
+        mraa_gpio_write(dev->stepI4, 0);
+}
diff --git a/ext/lib/upm/src/uln200xa/uln200xa.h b/ext/lib/upm/src/uln200xa/uln200xa.h
new file mode 100644
index 0000000..a519269
--- /dev/null
+++ b/ext/lib/upm/src/uln200xa/uln200xa.h
@@ -0,0 +1,122 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+    /**
+     * @file uln200xa.h
+     * @library uln200xa
+     * @brief C API for the uln200xa driver
+     *
+     * @include uln200xa.c
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _uln200xa_context {
+        mraa_gpio_context stepI1; // In1
+        mraa_gpio_context stepI2;
+        mraa_gpio_context stepI3;
+        mraa_gpio_context stepI4;
+
+        int      stepsPerRev;
+        int      currentStep;
+        uint32_t stepDelay;
+        int      stepDirection;
+
+    } *uln200xa_context;
+
+    /**
+     * Enum to specify the direction of a motor
+     */
+    typedef enum {
+      ULN200XA_DIR_CW   = 0x01,
+      ULN200XA_DIR_CCW  = 0x02
+    } ULN200XA_DIRECTION_T;
+
+    /**
+     * ULN200XA constructor
+     *
+     * @param stepsPerRev Number of steps per full revolution
+     * @param i1 Digital pin to use for stepper input 1
+     * @param i2 Digital pin to use for stepper input 2
+     * @param i3 Digital pin to use for stepper input 3
+     * @param i4 Digital pin to use for stepper input 4
+     * @return Device context
+     */
+    uln200xa_context uln200xa_init(int stepsPerRev, unsigned int i1,
+                                   unsigned int i2, unsigned int i3,
+                                   unsigned int i4);
+
+    /**
+     * ULN200XA destructor
+     */
+    void uln200xa_close(uln200xa_context dev);
+
+    /**
+     * Sets the speed of the stepper motor in revolutions per minute (RPM)
+     *
+     * @param dev Device context
+     * @param speed Speed to set the motor to, in RPM
+     */
+    void uln200xa_set_speed(const uln200xa_context dev, unsigned int speed);
+
+    /**
+     * Sets the direction of the motor, clockwise or counterclockwise
+     *
+     * @param dev Device context
+     * @param dir Direction to set the motor to
+     */
+    void uln200xa_set_direction(const uln200xa_context dev,
+                                ULN200XA_DIRECTION_T dir);
+
+    /**
+     * Steps the stepper motor a specified number of steps
+     *
+     * @param dev Device context
+     * @param steps Number of steps to move the stepper motor
+     */
+    void uln200xa_stepper_steps(const uln200xa_context dev, unsigned int steps);
+
+    /**
+     * Releases the stepper motor by removing power
+     *
+     * @param dev Device context
+     */
+    void uln200xa_release(const uln200xa_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/urm37/Kbuild b/ext/lib/upm/src/urm37/Kbuild
new file mode 100644
index 0000000..622af44
--- /dev/null
+++ b/ext/lib/upm/src/urm37/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_urm37) += urm37.o
diff --git a/ext/lib/upm/src/urm37/Kconfig b/ext/lib/upm/src/urm37/Kconfig
new file mode 100644
index 0000000..b4e23a6
--- /dev/null
+++ b/ext/lib/upm/src/urm37/Kconfig
@@ -0,0 +1,9 @@
+config UPM_urm37
+    bool "urm37"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm URM37 Ultrasonic Ranger
+
diff --git a/ext/lib/upm/src/urm37/Makefile b/ext/lib/upm/src/urm37/Makefile
new file mode 100644
index 0000000..51c1bf1
--- /dev/null
+++ b/ext/lib/upm/src/urm37/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_urm37
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/urm37
+endif
diff --git a/ext/lib/upm/src/urm37/urm37.c b/ext/lib/upm/src/urm37/urm37.c
new file mode 100644
index 0000000..f468d0c
--- /dev/null
+++ b/ext/lib/upm/src/urm37/urm37.c
@@ -0,0 +1,386 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Thanks to Adafruit for supplying a google translated version of the
+ * Chinese datasheet and some clues in their code.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+
+#include "urm37.h"
+
+#include "upm_utilities.h"
+
+#define URM37_MAX_DATA_LEN      4
+#define URM37_WAIT_TIMEOUT      1000
+#define URM37_MAX_RETRIES       10
+
+urm37_context urm37_init(uint8_t a_pin, uint8_t reset_pin,
+                         uint8_t trigger_pin, float a_ref,
+                         uint8_t uart_bus, bool analog_mode)
+{
+
+  urm37_context dev = (urm37_context)malloc(sizeof(struct _urm37_context));
+
+  if (!dev)
+    return NULL;
+
+  // clear out context
+  memset((void *)dev, 0, sizeof(struct _urm37_context));
+  
+  // NULL out MRAA contexts for now (redundant with memset I know, but...)
+  dev->aio = NULL;
+  dev->gpio_reset = NULL;
+  dev->gpio_trigger = NULL;
+  dev->uart = NULL;
+
+  dev->a_res = 0;
+  dev->a_ref = a_ref;
+
+  // set the mode
+  dev->is_analog_mode = analog_mode;
+
+  // initialize the MRAA contexts (only what we need)
+
+  // analog only
+  if (dev->is_analog_mode)
+    {
+      if (!(dev->aio = mraa_aio_init(a_pin)))
+        {
+          printf("%s: mraa_aio_init() failed.\n", __FUNCTION__);
+          urm37_close(dev);
+          return NULL;
+        }
+
+      // ADC resolution
+      dev->a_res = (float)(1 << mraa_aio_get_bit(dev->aio)) - 1;
+
+      if (!(dev->gpio_trigger = mraa_gpio_init(trigger_pin)))
+        {
+          printf("%s: mraa_gpio_init(trigger) failed.\n", __FUNCTION__);
+          urm37_close(dev);
+          return NULL;
+        }
+
+      mraa_gpio_dir(dev->gpio_trigger, MRAA_GPIO_OUT);
+      mraa_gpio_write(dev->gpio_trigger, 1);
+    }
+  else
+    {
+      // UART only
+      if (!(dev->uart = mraa_uart_init(uart_bus)))
+        {
+          printf("%s: mraa_uart_init() failed.\n", __FUNCTION__);
+          urm37_close(dev);
+          return NULL;
+        }
+
+      mraa_uart_set_baudrate(dev->uart, 9600);
+      mraa_uart_set_non_blocking(dev->uart, false);
+    }
+
+  // reset - used by both analog and uart modes
+  if (!(dev->gpio_reset = mraa_gpio_init(reset_pin)))
+    {
+      printf("%s: mraa_gpio_init(reset) failed.\n", __FUNCTION__);
+      urm37_close(dev);
+      return NULL;
+    }
+
+  mraa_gpio_dir(dev->gpio_reset, MRAA_GPIO_OUT);
+
+  urm37_reset(dev);
+
+  return dev;
+}
+
+void urm37_close(urm37_context dev)
+{
+  if (dev->aio)
+    mraa_aio_close(dev->aio);
+  if (dev->gpio_reset)
+    mraa_gpio_close(dev->gpio_reset);
+  if (dev->gpio_trigger)
+    mraa_gpio_close(dev->gpio_trigger);
+  if (dev->uart)
+    mraa_uart_stop(dev->uart);
+
+  free(dev);
+}
+
+upm_result_t urm37_reset(urm37_context dev)
+{
+  mraa_gpio_write(dev->gpio_reset, 0);
+  upm_delay_us(100);
+  mraa_gpio_write(dev->gpio_reset, 1);
+
+  // wait for reset to complete
+  upm_delay(3);
+
+  return UPM_SUCCESS;
+}
+
+// private
+static bool urm37_data_available(urm37_context dev, uint32_t millis)
+{
+  if (mraa_uart_data_available(dev->uart, millis))
+    return true;
+  else
+    return false;
+}
+
+// private
+static int urm37_read_data(urm37_context dev, char* data)
+{
+  return mraa_uart_read(dev->uart, data, (size_t)URM37_MAX_DATA_LEN);
+}
+
+// private
+static int urm37_write_data(urm37_context dev, const char* data)
+{
+  mraa_uart_flush(dev->uart);
+  return mraa_uart_write(dev->uart, data, (size_t)URM37_MAX_DATA_LEN);
+}
+
+upm_result_t urm37_send_command(urm37_context dev, char* cmd, char* response)
+{
+  if (dev->is_analog_mode)
+    {
+      printf("%s: UART commands are not available in analog mode\n",
+             __FUNCTION__);
+      
+      return UPM_ERROR_NOT_SUPPORTED;
+    }
+
+  int tries = 0;
+
+  while (tries++ < URM37_MAX_RETRIES)
+    {
+      if (urm37_write_data(dev, cmd) < 0)
+        {
+          // A write error of some kind.  We don't try to continue
+          // after this.
+          printf("%s: write_data() failed\n", __FUNCTION__);
+
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      if (!urm37_data_available(dev, URM37_WAIT_TIMEOUT))
+        {
+          // timeout, retry...
+          continue;
+        }
+
+      int rv = urm37_read_data(dev, response);
+      if (rv < 0)
+        {
+          printf("%s: read_data() failed\n", __FUNCTION__);
+          return UPM_ERROR_OPERATION_FAILED;
+        }
+
+      if (rv != URM37_MAX_DATA_LEN)
+        {
+          // read wrong number of bytes...
+          printf("%s: read_data() returned %d bytes, expected %d, retrying\n",
+                 __FUNCTION__, rv, URM37_MAX_DATA_LEN);
+          continue;
+        }
+      else
+        {
+          // we have data, verify cksum, return the response if it's
+          // good, retry otherwise
+          uint8_t cksum = (uint8_t)(response[0] + response[1] + response[2]);
+
+          if ((uint8_t)response[3] != cksum)
+            {
+              printf("%s: checksum failure: got %d, expected %d, retrying\n",
+                     __FUNCTION__, (int)response[3], (int)cksum);
+              continue;
+            }
+
+          // all good
+          return UPM_SUCCESS;
+        }
+    }
+
+  // If we are here, we timed out and all retries were exhausted
+  return UPM_ERROR_TIMED_OUT;
+}
+
+upm_result_t urm37_get_distance(urm37_context dev, float *distance,
+                                int degrees)
+{
+  if (dev->is_analog_mode)
+    {
+      // analog mode
+      int val;
+
+      // send the trigger pulse and sample
+      mraa_gpio_write(dev->gpio_trigger, 0);
+      val = mraa_aio_read(dev->aio);
+      mraa_gpio_write(dev->gpio_trigger, 1);
+
+      // convert to mV
+      float volts = ((float)val * (dev->a_ref / dev->a_res)) * 1000.0;
+
+      // 6.8 mV/cm
+      *distance = volts/6.8;
+      return UPM_SUCCESS;
+    }
+
+  // UART mode
+
+  char cmd[URM37_MAX_DATA_LEN];
+  char resp[URM37_MAX_DATA_LEN];
+
+  // divide degrees by 6 - this is the encoding URM37 uses.
+  uint8_t deg = (uint8_t)(degrees / 6);
+  if (deg > 46)
+    {
+      printf("%s: Degrees out of range, must be between 0-270\n",
+             __FUNCTION__);
+      return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+  uint8_t cksum = 0x22 + deg + 0x00;
+  cmd[0] = 0x22;
+  cmd[1] = deg;
+  cmd[2] = 0x00;
+  cmd[3] = cksum;
+
+  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
+    {
+      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  uint8_t h = (uint8_t) resp[1];
+  uint8_t l = (uint8_t) resp[2];
+
+  *distance = (float)((h << 8) | l);
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t urm37_get_temperature(urm37_context dev, float* temperature)
+{
+  if (dev->is_analog_mode)
+    {
+      printf("%s: Temperature measurement is not available in analog mode\n",
+             __FUNCTION__);
+      return UPM_ERROR_NOT_SUPPORTED;
+    }
+
+  // UART mode
+  char cmd[URM37_MAX_DATA_LEN];
+
+  // get temperature sequence
+  cmd[0] = 0x11;
+  cmd[1] = 0x00;
+  cmd[2] = 0x00;
+  cmd[3] = 0x11; // cksum
+
+  char resp[URM37_MAX_DATA_LEN];
+  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
+    {
+      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  uint8_t h = (uint8_t) resp[1];
+  uint8_t l = (uint8_t) resp[2];
+
+  *temperature = (float)((h & 0x0f) * 256 + l) / 10.0;
+
+  if (h & 0xf0)
+    *temperature *= -1;
+
+  return UPM_SUCCESS;
+}
+
+upm_result_t urm37_read_eeprom(urm37_context dev, uint8_t addr, uint8_t* value)
+{
+  if (dev->is_analog_mode)
+    {
+      printf("%s: EEPROM is not available in analog mode\n",
+             __FUNCTION__);
+      return UPM_ERROR_NOT_SUPPORTED;
+    }
+
+  if (addr > 0x04)
+    {
+      printf("Address must be between 0x00-0x04");
+      return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+  char cmd[URM37_MAX_DATA_LEN];
+  uint8_t cksum = 0x33 + addr + 0x00;
+  cmd[0] = 0x33;
+  cmd[1] = addr;
+  cmd[2] = 0x00;
+  cmd[3] = cksum;
+
+  char resp[URM37_MAX_DATA_LEN];
+
+  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
+    {
+      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  *value = resp[2];
+  return UPM_SUCCESS;
+}
+
+upm_result_t urm37_write_eeprom(urm37_context dev, uint8_t addr, uint8_t value)
+{
+  if (dev->is_analog_mode)
+    {
+      printf("%s: EEPROM is not available in analog mode\n",
+             __FUNCTION__);
+      return UPM_ERROR_NOT_SUPPORTED;
+    }
+
+  if (addr > 0x04)
+    {
+      printf("Address must be between 0x00-0x04");
+      return UPM_ERROR_OUT_OF_RANGE;
+    }
+
+  char cmd[URM37_MAX_DATA_LEN];
+  uint8_t cksum = 0x44 + addr + value;
+  cmd[0] = 0x44;
+  cmd[1] = addr;
+  cmd[2] = value;
+  cmd[3] = cksum;
+
+  char resp[URM37_MAX_DATA_LEN]; // throw away
+  if (urm37_send_command(dev, cmd, resp) != UPM_SUCCESS)
+    {
+      printf("%s: urm37_send_command() failed\n", __FUNCTION__);
+      return UPM_ERROR_OPERATION_FAILED;
+    }
+
+  return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/urm37/urm37.h b/ext/lib/upm/src/urm37/urm37.h
new file mode 100644
index 0000000..7305a90
--- /dev/null
+++ b/ext/lib/upm/src/urm37/urm37.h
@@ -0,0 +1,173 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ *         Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Thanks to Adafruit for supplying a google translated version of the
+ * Chinese datasheet and some clues in their code.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef URM37_H_
+#define URM37_H_
+
+#include <stdint.h>
+#include "upm.h"
+#include "mraa/aio.h"
+#include "mraa/gpio.h"
+#include "mraa/uart.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief UPM C API for the DFRobot URM37 Ultrasonic Ranger
+ *
+ * The driver was tested with the DFRobot URM37 Ultrasonic Ranger,
+ * V4.  It has a range of between 5 and 500 centimeters (cm).  It
+ * supports both analog distance measurement, and UART based
+ * temperature and distance measurements.  This driver does not
+ * support PWM measurement mode.
+ *
+ * For UART operation, the only supported baud rate is 9600.  In
+ * addition, you must ensure that the UART TX/RX pins are
+ * configured for TTL operation (the factory default) rather than
+ * RS232 operation, or permanent damage to your URM37 and/or MCU
+ * will result.  On power up, the LED indicator will blink one
+ * long pulse, followed by one short pulse to indicate TTL
+ * operation.  See the DFRobot wiki for more information:
+ *
+ * (https://www.dfrobot.com/wiki/index.php?title=URM37_V4.0_Ultrasonic_Sensor_%28SKU:SEN0001%29)
+ *
+ * An example using analog mode
+ * @snippet urm37.c Interesting
+ * An example using UART mode
+ * @snippet urm37-uart.c Interesting
+ */
+
+/**
+ * device context
+ */
+typedef struct _urm37_context {
+  mraa_aio_context    aio;
+  mraa_gpio_context   gpio_reset;
+  mraa_gpio_context   gpio_trigger;
+  mraa_uart_context   uart;
+
+  bool                is_analog_mode;
+
+  float               a_ref;
+  float               a_res;
+} *urm37_context;
+
+/**
+ * URM37 Initializer
+ *
+ * @param a_pin Analog pin to use. Ignored in UART mode.
+ * @param reset_pin GPIO pin to use for reset
+ * @param trigger_pin GPIO pin to use for triggering a distance
+ * measurement. Ignored in UART mode.
+ * @param a_ref The analog reference voltage. Ignored in UART mode.
+ * @param uart Default UART to use (0 or 1). Ignored in analog mode.
+ * @param mode true for analog mode, false otherwise.
+ */
+urm37_context urm37_init(uint8_t a_pin, uint8_t reset_pin,
+                         uint8_t trigger_pin, float a_ref, 
+                         uint8_t uart, bool analog_mode);
+
+/**
+ * URM37 sensor close function
+ */
+void urm37_close(urm37_context dev);
+
+/**
+ * Reset the device.  This will take approximately 3 seconds to
+ * complete.
+ *
+ * @param dev sensor context
+ */
+upm_result_t urm37_reset(urm37_context dev);
+
+/**
+ * Get the distance measurement.  A return value of 65535.0
+ * in UART mode indicates an invalid measurement.
+ *
+ * @param dev sensor context
+ * @param distance A pointer to a float that will contain the distance
+ * in CM if the measurement is successful.
+ * @param degrees In UART mode, this specifies the degrees to turn an
+ * attached PWM servo connected to the MOTO output on the URM37.
+ * Valid values are 0-270.  This option is ignored in analog mode.  If
+ * you are not using this functionality, just pass 0.
+ * @return UPM status code
+ */
+upm_result_t urm37_get_distance(urm37_context dev, float *distance,
+                                int degrees);
+
+/**
+ * Get the temperature measurement.  This is only valid in UART mode.
+ *
+ * @param dev sensor context
+ * @param temperature A float pointer containing the measured
+ * temperature in degrees C
+ * @return UPM status code
+ *
+ */
+upm_result_t urm37_get_temperature(urm37_context dev, float* temperature);
+
+/**
+ * In UART mode only, read a value from the EEPROM and return it.
+ *
+ * @param dev sensor context
+ * @param addr The address in the EEPROM to read.  Valid values
+ * are between 0x00-0x04.
+ * @param value A pointer containing the returned value.
+ * @return UPM status code
+ */
+upm_result_t urm37_read_eeprom(urm37_context dev, uint8_t addr, uint8_t* value);
+
+/**
+ * In UART mode only, write a value into an address on the EEPROM.
+ *
+ * @param dev sensor context
+ * @param addr The address in the EEPROM to write.  Valid values
+ * are between 0x00-0x04.
+ * @param value The value to write
+ * @return UPM status code
+ */
+upm_result_t urm37_write_eeprom(urm37_context dev, uint8_t addr, uint8_t value);
+
+/**
+ * In UART mode only, send a 4-byte command, and return a 4-byte response.
+ *
+ * @param dev sensor context
+ * @param cmd A 4-byte command to transmit
+ * @param response The 4-byte response
+ * @return UPM response code (success, failure, or timeout)
+ */
+upm_result_t urm37_send_command(urm37_context dev, char* cmd, char* response);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* URM37_H_ */
diff --git a/ext/lib/upm/src/utilities/Kbuild b/ext/lib/upm/src/utilities/Kbuild
new file mode 100644
index 0000000..13f6716
--- /dev/null
+++ b/ext/lib/upm/src/utilities/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_utilities) += upm_utilities.o
diff --git a/ext/lib/upm/src/utilities/Kconfig b/ext/lib/upm/src/utilities/Kconfig
new file mode 100644
index 0000000..1b58211
--- /dev/null
+++ b/ext/lib/upm/src/utilities/Kconfig
@@ -0,0 +1,9 @@
+config UPM_utilities
+    bool "utilities"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        UPM Utilities Library
+
diff --git a/ext/lib/upm/src/utilities/Makefile b/ext/lib/upm/src/utilities/Makefile
new file mode 100644
index 0000000..819f898
--- /dev/null
+++ b/ext/lib/upm/src/utilities/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_utilities
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/utilities
+endif
diff --git a/ext/lib/upm/src/utilities/upm_utilities.c b/ext/lib/upm/src/utilities/upm_utilities.c
new file mode 100644
index 0000000..b5c6b01
--- /dev/null
+++ b/ext/lib/upm/src/utilities/upm_utilities.c
@@ -0,0 +1,218 @@
+/*
+ * Authors:
+ *          Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <upm_platform.h>
+#include <upm_utilities.h>
+
+void upm_delay(int time)
+{
+    if (time <= 0)
+        time = 1;
+
+#if defined(UPM_PLATFORM_LINUX)
+
+    sleep(time);
+
+#elif defined(UPM_PLATFORM_ZEPHYR)
+# if KERNEL_VERSION_MAJOR == 1 && KERNEL_VERSION_MINOR >= 6
+
+    struct k_timer timer;
+    k_timer_init(&timer, NULL, NULL);
+    k_timer_start(&timer, time * 1000, 0);
+    k_timer_status_sync(&timer);
+
+# else
+
+    struct nano_timer timer;
+    void *timer_data[1];
+    nano_timer_init(&timer, timer_data);
+    nano_timer_start(&timer, SECONDS(time) + 1);
+    nano_timer_test(&timer, TICKS_UNLIMITED);
+
+# endif
+
+#endif
+}
+
+void upm_delay_ms(int time)
+{
+    if (time <= 0)
+        time = 1;
+
+#if defined(UPM_PLATFORM_LINUX)
+
+    usleep(1000 * time);
+
+#elif defined(UPM_PLATFORM_ZEPHYR)
+# if KERNEL_VERSION_MAJOR == 1 && KERNEL_VERSION_MINOR >= 6
+
+    struct k_timer timer;
+    k_timer_init(&timer, NULL, NULL);
+    k_timer_start(&timer, time, 0);
+    k_timer_status_sync(&timer);
+
+# else
+
+    struct nano_timer timer;
+    void *timer_data[1];
+    nano_timer_init(&timer, timer_data);
+    nano_timer_start(&timer, MSEC(time) + 1);
+    nano_timer_test(&timer, TICKS_UNLIMITED);
+
+# endif
+#endif
+}
+
+void upm_delay_us(int time)
+{
+    if (time <= 0)
+        time = 1;
+
+#if defined(UPM_PLATFORM_LINUX)
+
+    usleep(time);
+
+#elif defined(UPM_PLATFORM_ZEPHYR)
+# if KERNEL_VERSION_MAJOR == 1 && KERNEL_VERSION_MINOR >= 6
+    // we will use a upm_clock to do microsecond timings here as k_timer has
+    // only a millisecond resolution.  So we init a clock and spin.
+
+    upm_clock_t timer;
+    upm_clock_init(&timer);
+    while (upm_elapsed_us(&timer) < time)
+        ; // spin
+
+# else
+
+    struct nano_timer timer;
+    void *timer_data[1];
+    nano_timer_init(&timer, timer_data);
+    nano_timer_start(&timer, USEC(time) + 1);
+    nano_timer_test(&timer, TICKS_UNLIMITED);
+
+# endif
+
+#endif
+}
+
+void upm_clock_init(upm_clock_t *clock)
+{
+#if defined(UPM_PLATFORM_LINUX)
+
+    gettimeofday(clock, NULL);
+
+#elif defined(UPM_PLATFORM_ZEPHYR)
+    *clock = sys_cycle_get_32();
+#endif
+}
+
+uint32_t upm_elapsed_ms(upm_clock_t *clock)
+{
+#if defined(UPM_PLATFORM_LINUX)
+
+    struct timeval elapsed, now;
+    uint32_t elapse;
+
+    // get current time
+    gettimeofday(&now, NULL);
+
+    struct timeval startTime = *clock;
+
+    // compute the delta since startTime
+    if( (elapsed.tv_usec = now.tv_usec - startTime.tv_usec) < 0 )
+    {
+        elapsed.tv_usec += 1000000;
+        elapsed.tv_sec = now.tv_sec - startTime.tv_sec - 1;
+    }
+    else
+    {
+        elapsed.tv_sec = now.tv_sec - startTime.tv_sec;
+    }
+
+    elapse = (uint32_t)((elapsed.tv_sec * 1000) + (elapsed.tv_usec / 1000));
+
+    // never return 0
+    if (elapse == 0)
+        elapse = 1;
+
+    return elapse;
+
+#elif defined(UPM_PLATFORM_ZEPHYR)
+    uint32_t now = sys_cycle_get_32();
+
+    uint32_t elapsed =
+        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000000);
+
+    if (elapsed == 0)
+        elapsed = 1;
+
+    return elapsed;
+#endif
+}
+
+uint32_t upm_elapsed_us(upm_clock_t *clock)
+{
+#if defined(UPM_PLATFORM_LINUX)
+
+    struct timeval elapsed, now;
+    uint32_t elapse;
+
+    // get current time
+    gettimeofday(&now, NULL);
+
+    struct timeval startTime = *clock;
+
+    // compute the delta since startTime
+    if( (elapsed.tv_usec = now.tv_usec - startTime.tv_usec) < 0 )
+    {
+        elapsed.tv_usec += 1000000;
+        elapsed.tv_sec = now.tv_sec - startTime.tv_sec - 1;
+    }
+    else
+    {
+        elapsed.tv_sec = now.tv_sec - startTime.tv_sec;
+    }
+
+    elapse = (uint32_t)((elapsed.tv_sec * 1000000) + elapsed.tv_usec);
+
+    // never return 0
+    if (elapse == 0)
+        elapse = 1;
+
+    return elapse;
+
+#elif defined(UPM_PLATFORM_ZEPHYR)
+    uint32_t now = sys_cycle_get_32();
+
+    uint32_t elapsed =
+        (uint32_t)(SYS_CLOCK_HW_CYCLES_TO_NS64(now - *clock)/(uint64_t)1000);
+
+    // never return 0
+    if (elapsed == 0)
+        elapsed = 1;
+
+    return elapsed;
+#endif
+}
diff --git a/ext/lib/upm/src/utilities/upm_utilities.h b/ext/lib/upm/src/utilities/upm_utilities.h
new file mode 100644
index 0000000..3a55776
--- /dev/null
+++ b/ext/lib/upm/src/utilities/upm_utilities.h
@@ -0,0 +1,120 @@
+/*
+ * Authors:
+ *          Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#ifndef UPM_UTILITIES_H_
+#define UPM_UTILITIES_H_
+
+#include <upm_platform.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(UPM_PLATFORM_LINUX)
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+typedef struct timeval upm_clock_t;
+#endif /* UPM_PLATFORM_LINUX */
+
+#if defined(UPM_PLATFORM_ZEPHYR)
+#include <zephyr.h>
+#include <device.h>
+#include <sys_clock.h>
+#include <version.h>
+#include <kernel_version.h>
+
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT           printf
+#else
+#include <misc/printk.h>
+#define PRINT           printk
+#endif
+
+typedef uint32_t upm_clock_t;
+
+#endif /* UPM_PLATFORM_ZEPHYR */
+
+
+/* Get filename w/o path */
+#define __FILENAME__ (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
+
+/**
+ * Delay for a number of seconds
+ *
+ * @param time The number of seconds to delay for
+ */
+void upm_delay(int time);
+
+/**
+ * Delay for a number of milliseconds
+ *
+ * @param time The number of milliseconds to delay for
+ */
+void upm_delay_ms(int time);
+
+/**
+ * Delay for a number of microseconds
+ *
+ * @param time The number of microseconds to delay for
+ */
+void upm_delay_us(int time);
+
+/**
+ * Initialize a clock.  This can be used with upm_elapsed_ms() and
+ * upm_elapsed_us() for measuring a duration.
+ *
+ * @param clock The upm_clock_t to initialize to the current time
+ */
+void upm_clock_init(upm_clock_t *clock);
+
+/**
+ * Return the elapsed time in milliseconds since upm_init_clock() was
+ * last called.
+ *
+ * @param clock A upm_clock_t initialized by upm_init_clock()
+ * @return the number of milliseconds elapsed since upm_init_clock()
+ * was called on the clock parameter.
+ */
+uint32_t upm_elapsed_ms(upm_clock_t *clock);
+
+/**
+ * Return the elapsed time in microseconds since upm_init_clock() was
+ * last called.
+ *
+ * @param clock A upm_clock_t initialized by upm_init_clock()
+ * @return the number of microseconds elapsed since upm_init_clock()
+ * was called on the clock parameter.
+ */
+uint32_t upm_elapsed_us(upm_clock_t *clock);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* UPM_UTILITIES_H_ */
diff --git a/ext/lib/upm/src/vdiv/Kbuild b/ext/lib/upm/src/vdiv/Kbuild
new file mode 100644
index 0000000..0190957
--- /dev/null
+++ b/ext/lib/upm/src/vdiv/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_vdiv) += vdiv.o
diff --git a/ext/lib/upm/src/vdiv/Kconfig b/ext/lib/upm/src/vdiv/Kconfig
new file mode 100644
index 0000000..7c2abff
--- /dev/null
+++ b/ext/lib/upm/src/vdiv/Kconfig
@@ -0,0 +1,9 @@
+config UPM_vdiv
+    bool "vdiv"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm grove voltage divider module
+
diff --git a/ext/lib/upm/src/vdiv/Makefile b/ext/lib/upm/src/vdiv/Makefile
new file mode 100644
index 0000000..0d277cf
--- /dev/null
+++ b/ext/lib/upm/src/vdiv/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_vdiv
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/vdiv
+endif
diff --git a/ext/lib/upm/src/vdiv/vdiv.c b/ext/lib/upm/src/vdiv/vdiv.c
new file mode 100644
index 0000000..fe05cc7
--- /dev/null
+++ b/ext/lib/upm/src/vdiv/vdiv.c
@@ -0,0 +1,122 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "vdiv.h"
+
+vdiv_context vdiv_init(int16_t pin, float voltage_ref)
+{
+    vdiv_context dev = (vdiv_context)malloc(sizeof(struct _vdiv_context));
+
+    if (dev == NULL) return NULL;
+
+    /* Init aio pin */
+    dev->aio = mraa_aio_init(pin);
+
+    if (dev->aio == NULL) {
+        free(dev);
+        return NULL;
+    }
+
+    /* Set defaults */
+    dev->m_aRef = 5.0;
+    dev->m_scale = 1.0;
+    dev->m_offset = 0.0;
+    dev->m_vdiv_sw = 3;
+
+    return dev;
+}
+
+void vdiv_close(vdiv_context dev)
+{
+    mraa_aio_close(dev->aio);
+    free(dev);
+}
+
+upm_result_t vdiv_set_scale(const vdiv_context dev, float scale)
+{
+    dev->m_scale = scale;
+    return UPM_SUCCESS;
+}
+
+upm_result_t vdiv_set_offset(const vdiv_context dev, float offset)
+{
+    dev->m_offset = offset;
+    return UPM_SUCCESS;
+}
+
+float vdiv_get_scale(const vdiv_context dev)
+{
+    return dev->m_scale;
+}
+
+float vdiv_get_offset(const vdiv_context dev)
+{
+    return dev->m_offset;
+}
+
+upm_result_t vdiv_set_divsw(const vdiv_context dev, int vdiv_sw)
+{
+    dev->m_vdiv_sw = vdiv_sw;
+    return UPM_SUCCESS;
+}
+
+int vdiv_get_divsw(const vdiv_context dev)
+{
+    return dev->m_vdiv_sw;
+}
+
+upm_result_t vdiv_get_raw_volts(const vdiv_context dev, float *value)
+{
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+    /* Scale by the ADC reference voltage */
+    *value *= dev->m_aRef;
+
+    return UPM_SUCCESS;
+}
+
+upm_result_t vdiv_get_computed_volts(const vdiv_context dev, float *value)
+{
+    // JET - this is wrong.
+
+    *value = mraa_aio_read_float(dev->aio);
+    if (*value < 0)
+        return UPM_ERROR_OPERATION_FAILED;
+
+     /* Apply raw scale */
+    *value *= dev->m_scale;
+
+    /* Scale to the ADC referecen then to vdiv gain */
+    *value *= dev->m_aRef * dev->m_vdiv_sw;
+
+    /* Apply the offset in volts */
+    *value += dev->m_offset;
+
+    return UPM_SUCCESS;
+}
diff --git a/ext/lib/upm/src/vdiv/vdiv.h b/ext/lib/upm/src/vdiv/vdiv.h
new file mode 100644
index 0000000..4b41baf
--- /dev/null
+++ b/ext/lib/upm/src/vdiv/vdiv.h
@@ -0,0 +1,139 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#pragma once
+
+#include "upm.h"
+#include "mraa/aio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * device context
+ */
+typedef struct _vdiv_context {
+    /* mraa aio pin context */
+    mraa_aio_context aio;
+    /* ADC voltage reference */
+    float m_aRef;
+    /* Scale */
+    float m_scale;
+    /* Offset in sensor units */
+    float m_offset;
+    /* Offset in sensor units */
+    int m_vdiv_sw;
+} *vdiv_context;
+
+
+/**
+ * Initialize analog sensor
+ * @param pin is Analog pin
+ * @return sensor context as void pointer
+ */
+vdiv_context vdiv_init(int16_t pin, float voltage_ref);
+
+/**
+ * Analog sensor destructor
+ * @param sensor context pointer deallocate memory
+ */
+void vdiv_close(vdiv_context dev);
+
+/**
+ * Set sensor scale.  This scale is applied to the return value:
+ *     counts = counts * scale
+ * @param dev sensor context pointer
+ * @param scale count scale value used
+ * @return Function result code
+ */
+upm_result_t vdiv_set_scale(const vdiv_context dev, float scale);
+
+/**
+ * Set sensor offset.  This offset is applied to the return value:
+ *     counts = counts + offset
+ * @param dev sensor context pointer
+ * @param offset count offset value used
+ * @return Function result code
+ */
+upm_result_t vdiv_set_offset(const vdiv_context dev, float offset);
+
+/**
+ * Get sensor scale
+ * @param dev sensor context pointer
+ * @return Sensor scale
+ */
+float vdiv_get_scale(const vdiv_context dev);
+
+/**
+ * Get sensor offset
+ * @param dev sensor context pointer
+ * @return Sensor offset
+ */
+float vdiv_get_offset(const vdiv_context dev);
+
+/**
+ * Set sensor divide switch value
+ * @param dev sensor context pointer
+ * @param vdiv_sw Divide switch value
+ * @return Function result code
+ */
+upm_result_t vdiv_set_divsw(const vdiv_context dev, int vdiv_sw);
+
+/**
+ * Get divide switch value
+ * @param dev sensor context pointer
+ * @return Sensor divide switch value
+ */
+int vdiv_get_divsw(const vdiv_context dev);
+
+/**
+ * Read raw voltage from the sensor
+ * @param dev sensor context pointer
+ * @param *value Raw sensor voltage
+ * @return Function result code
+ */
+upm_result_t vdiv_get_raw_volts(const vdiv_context dev, float *value);
+
+/**
+ * Gets the true voltage value from the sensor.  Voltage divides by 3 or 10,
+ * depending on the toggle switch on the board.  The dynamic range of the
+ * vdiv sensor is listed below.
+ * 
+ *  ADC Ref  SW   max VOL in
+ *  ------- ---   ----------
+ *    3.3v    3       8.5v
+ *    3.3v   10      28.4v
+ *    5.0v    3      12.9v
+ *    5.0v   10      43.0v
+ *
+ * @param dev sensor context pointer
+ * @param *value Voltage (v)
+ * @return Function result code
+ */
+upm_result_t vdiv_get_computed_volts(const vdiv_context dev, float *value);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/water/Kbuild b/ext/lib/upm/src/water/Kbuild
new file mode 100644
index 0000000..8f1a1b9
--- /dev/null
+++ b/ext/lib/upm/src/water/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_water) += water.o
diff --git a/ext/lib/upm/src/water/Kconfig b/ext/lib/upm/src/water/Kconfig
new file mode 100644
index 0000000..ca9821c
--- /dev/null
+++ b/ext/lib/upm/src/water/Kconfig
@@ -0,0 +1,9 @@
+config UPM_water
+    bool "water"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm water sensor module
+
diff --git a/ext/lib/upm/src/water/Makefile b/ext/lib/upm/src/water/Makefile
new file mode 100644
index 0000000..dcdb58a
--- /dev/null
+++ b/ext/lib/upm/src/water/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_water
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/water
+endif
diff --git a/ext/lib/upm/src/water/water.c b/ext/lib/upm/src/water/water.c
new file mode 100644
index 0000000..b16d8cf
--- /dev/null
+++ b/ext/lib/upm/src/water/water.c
@@ -0,0 +1,79 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2014-2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "water.h"
+
+water_context water_init(unsigned int pin)
+{
+  water_context dev =
+    (water_context)malloc(sizeof(struct _water_context));
+
+  if (!dev)
+    return NULL;
+
+  dev->gpio = NULL;
+
+  // make sure MRAA is initialized
+  int mraa_rv;
+  if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+  {
+      printf("mraa_init() failed (%d).\n", mraa_rv);
+      water_close(dev);
+      return NULL;
+  }
+
+  // initialize the MRAA context
+
+  if (!(dev->gpio = mraa_gpio_init(pin)))
+    {
+      printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
+      water_close(dev);
+      return NULL;
+    }
+
+  mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+  return dev;
+}
+
+void water_close(const water_context dev)
+{
+  assert(dev != NULL);
+
+  if (dev->gpio)
+    mraa_gpio_close(dev->gpio);
+
+  free(dev);
+}
+
+bool water_is_wet(const water_context dev)
+{
+  assert(dev != NULL);
+
+  // gpio is low when wet
+  return (mraa_gpio_read(dev->gpio) ? false : true);
+}
diff --git a/ext/lib/upm/src/water/water.h b/ext/lib/upm/src/water/water.h
new file mode 100644
index 0000000..2c54634
--- /dev/null
+++ b/ext/lib/upm/src/water/water.h
@@ -0,0 +1,70 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2014-2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include "upm.h"
+#include "mraa/gpio.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  /**
+   * @brief Water Sensor
+   *
+   * This module simply tests for the presence of water.
+   *
+   * @snippet water.c Interesting
+   */
+
+  /**
+   * Device context
+   */
+  typedef struct _water_context {
+    mraa_gpio_context        gpio;
+  } *water_context;
+
+  /**
+   * Water initializer
+   *
+   * @param pin Digital pin to use
+   * @return an initialized device context on success, NULL on error.
+   */
+  water_context water_init(unsigned int pin);
+
+  /**
+   * Water close function
+   */
+  void water_close(water_context dev);
+
+  /**
+   * Gets the water (wet/not wet) value from the sensor.
+   *
+   * @return true if the sensor is wet, false otherwise
+   */
+  bool water_is_wet(const water_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/ext/lib/upm/src/yg1006/Kbuild b/ext/lib/upm/src/yg1006/Kbuild
new file mode 100644
index 0000000..61d9f25
--- /dev/null
+++ b/ext/lib/upm/src/yg1006/Kbuild
@@ -0,0 +1 @@
+obj-$(CONFIG_UPM_yg1006) += yg1006.o
diff --git a/ext/lib/upm/src/yg1006/Kconfig b/ext/lib/upm/src/yg1006/Kconfig
new file mode 100644
index 0000000..90a3bea
--- /dev/null
+++ b/ext/lib/upm/src/yg1006/Kconfig
@@ -0,0 +1,8 @@
+config UPM_yg1006
+    bool "yg1006"
+    select MRAA
+    select NEWLIB_LIBC
+    depends on UPM
+    default n
+    help
+        upm yg1006 flame sensor
diff --git a/ext/lib/upm/src/yg1006/Makefile b/ext/lib/upm/src/yg1006/Makefile
new file mode 100644
index 0000000..91e8f6c
--- /dev/null
+++ b/ext/lib/upm/src/yg1006/Makefile
@@ -0,0 +1,3 @@
+ifdef CONFIG_UPM_yg1006
+ZEPHYRINCLUDE += -I$(srctree)/ext/lib/upm/src/yg1006
+endif
diff --git a/ext/lib/upm/src/yg1006/yg1006.c b/ext/lib/upm/src/yg1006/yg1006.c
new file mode 100644
index 0000000..4688d97
--- /dev/null
+++ b/ext/lib/upm/src/yg1006/yg1006.c
@@ -0,0 +1,77 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <assert.h>
+#include "yg1006.h"
+
+yg1006_context yg1006_init(unsigned int pin)
+{
+    yg1006_context dev =
+        (yg1006_context)malloc(sizeof(struct _yg1006_context));
+
+    if (!dev)
+        return NULL;
+
+    dev->gpio = NULL;
+
+    // make sure MRAA is initialized
+    int mraa_rv;
+    if ((mraa_rv = mraa_init()) != MRAA_SUCCESS)
+    {
+        printf("%s: mraa_init() failed (%d).\n", __FUNCTION__, mraa_rv);
+        yg1006_close(dev);
+        return NULL;
+    }
+
+    // initialize the MRAA context
+
+    if (!(dev->gpio = mraa_gpio_init(pin)))
+    {
+        printf("%s: mraa_gpio_init() failed.\n", __FUNCTION__);
+        yg1006_close(dev);
+        return NULL;
+    }
+
+    mraa_gpio_dir(dev->gpio, MRAA_GPIO_IN);
+
+    return dev;
+}
+
+void yg1006_close(yg1006_context dev)
+{
+    assert(dev != NULL);
+
+    if (dev->gpio)
+        mraa_gpio_close(dev->gpio);
+
+    free(dev);
+}
+
+bool yg1006_flame_detected(const yg1006_context dev)
+{
+    assert(dev != NULL);
+
+    // gpio is low when a flame is detected
+    return (mraa_gpio_read(dev->gpio) ? false : true);
+}
diff --git a/ext/lib/upm/src/yg1006/yg1006.h b/ext/lib/upm/src/yg1006/yg1006.h
new file mode 100644
index 0000000..e876f60
--- /dev/null
+++ b/ext/lib/upm/src/yg1006/yg1006.h
@@ -0,0 +1,74 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <upm.h>
+#include <mraa/gpio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /**
+     * @brief YG1006 Flame Sensor
+     *
+     *   UPM module for the YG1006 flame sensor. It detects a flame or any
+     *   other light source in the 760-1,100 nm wavelength range.
+     *
+     * @snippet yg1006.cxx Interesting
+     */
+
+    /**
+     * Device context
+     */
+    typedef struct _yg1006_context {
+        mraa_gpio_context        gpio;
+    } *yg1006_context;
+
+    /**
+     * YG1006 initializer
+     *
+     * @param pin Digital pin to use
+     * @return an initialized device context on success, NULL on error.
+     */
+    yg1006_context yg1006_init(unsigned int pin);
+
+    /**
+     * YG1006 close function
+     */
+    void yg1006_close(yg1006_context dev);
+
+    /**
+     * Determines whether a flame has been detected
+     *
+     * @return true if a flame or another comparable light source has
+     * been detected
+     */
+    bool yg1006_flame_detected(const yg1006_context dev);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/samples/upm/a110x/Makefile b/samples/upm/a110x/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/a110x/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/a110x/prj.conf b/samples/upm/a110x/prj.conf
new file mode 100644
index 0000000..7215b25
--- /dev/null
+++ b/samples/upm/a110x/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_a110x=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/a110x/src/Makefile b/samples/upm/a110x/src/Makefile
new file mode 100644
index 0000000..6db9fda
--- /dev/null
+++ b/samples/upm/a110x/src/Makefile
@@ -0,0 +1 @@
+obj-y = a110x.o
\ No newline at end of file
diff --git a/samples/upm/a110x/src/a110x.c b/samples/upm/a110x/src/a110x.c
new file mode 100644
index 0000000..3accc37
--- /dev/null
+++ b/samples/upm/a110x/src/a110x.c
@@ -0,0 +1,32 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "a110x.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    a110x_context dev = a110x_init(2);
+    bool abc = 0;
+    while(1){
+        if(a110x_magnet_detected(dev, &abc) != UPM_SUCCESS){
+            printf("an error has occured\n");
+        }
+        upm_delay(1);
+        printf("value retrieved: %d\n", abc);
+    }
+
+    return 0;
+}
diff --git a/samples/upm/apa102/Makefile b/samples/upm/apa102/Makefile
new file mode 100644
index 0000000..8ed3410
--- /dev/null
+++ b/samples/upm/apa102/Makefile
@@ -0,0 +1,6 @@
+MDEF_FILE = prj.mdef
+KERNEL_TYPE = micro
+BOARD ?= arduino_101_factory
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/apa102/prj.conf b/samples/upm/apa102/prj.conf
new file mode 100644
index 0000000..89db8d4
--- /dev/null
+++ b/samples/upm/apa102/prj.conf
@@ -0,0 +1,22 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_MRAA=y
+CONFIG_SPI=y
+CONFIG_SPI_QMSI=y
+CONFIG_MRAA_SPI=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_apa102=y
+CONFIG_PINMUX=y
+CONFIG_PINMUX_DEV=y
+CONFIG_PINMUX_DEV_NAME="PINMUX_DEV"
+# CONFIG_PINMUX_DEV_QUARK_MCU is not set
+CONFIG_PINMUX_DEV_QMSI=y
+CONFIG_PINMUX_NAME="PINMUX"
+CONFIG_PINMUX_INIT_PRIORITY=60
+CONFIG_UPM_utilities=y
diff --git a/samples/upm/apa102/prj.mdef b/samples/upm/apa102/prj.mdef
new file mode 100644
index 0000000..6c33f79
--- /dev/null
+++ b/samples/upm/apa102/prj.mdef
@@ -0,0 +1,5 @@
+% Application       : Hello demo
+
+% TASK NAME  PRIO ENTRY STACK GROUPS
+% ==================================
+  TASK TASKA    7 main  2048 [EXE]
diff --git a/samples/upm/apa102/src/Makefile b/samples/upm/apa102/src/Makefile
new file mode 100644
index 0000000..00066e1
--- /dev/null
+++ b/samples/upm/apa102/src/Makefile
@@ -0,0 +1 @@
+obj-y = main.o
diff --git a/samples/upm/apa102/src/main.c b/samples/upm/apa102/src/main.c
new file mode 100644
index 0000000..49b4900
--- /dev/null
+++ b/samples/upm/apa102/src/main.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2012-2014 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <zephyr.h>
+#include <apa102.h>
+#include <spi.h>
+#include <malloc.h>
+#include <pinmux.h>
+#include <sys_clock.h>
+#include "upm_utilities.h"
+
+#define SLEEPTICKS	SECONDS(1)
+#if defined(CONFIG_STDOUT_CONSOLE)
+#include <stdio.h>
+#define PRINT           printf
+#else
+#include <misc/printk.h>
+#define PRINT           printk
+#endif
+
+/*
+ * @file
+ * @brief Hello World demo
+ * Nanokernel version of hello world demo
+ */
+
+
+void main(void)
+{
+	printf("starting program\n");
+	mraa_init();
+	struct nano_timer timer;
+	void *timer_data[1];
+	nano_timer_init(&timer, timer_data);
+	apa102_context dev = apa102_init(60, 0, -1);
+
+// setting to red
+	if(apa102_set_leds(dev, 0, 29, 5, 255, 0, 0) != UPM_SUCCESS){
+		printf("error while setting the leds\n");
+	}
+	if(apa102_refresh(dev) != UPM_SUCCESS){
+		printf("error while dumping the buffer onto the LEDs\n");
+	}
+upm_delay(1);
+// setting to green
+	if(apa102_set_leds(dev, 0, 29, 5, 0, 255, 0) != UPM_SUCCESS){
+		printf("error while setting the leds\n");
+	}
+	if(apa102_refresh(dev) != UPM_SUCCESS){
+		printf("error while dumping the buffer onto the LEDs\n");
+	}
+upm_delay(1);
+// setting to blue
+	if(apa102_set_leds(dev, 0, 29, 5, 0, 0, 255) != UPM_SUCCESS){
+		printf("error while setting the leds\n");
+	}
+	if(apa102_refresh(dev) != UPM_SUCCESS){
+		printf("error while dumping the buffer onto the LEDs\n");
+	}
+	apa102_close(dev);
+}
diff --git a/samples/upm/bh1750/Makefile b/samples/upm/bh1750/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/bh1750/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/bh1750/prj.conf b/samples/upm/bh1750/prj.conf
new file mode 100644
index 0000000..13dab71
--- /dev/null
+++ b/samples/upm/bh1750/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_bh1750=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/bh1750/src/Makefile b/samples/upm/bh1750/src/Makefile
new file mode 100644
index 0000000..15b8995
--- /dev/null
+++ b/samples/upm/bh1750/src/Makefile
@@ -0,0 +1 @@
+obj-y = bh1750.o
\ No newline at end of file
diff --git a/samples/upm/bh1750/src/bh1750.c b/samples/upm/bh1750/src/bh1750.c
new file mode 100644
index 0000000..d07c9b4
--- /dev/null
+++ b/samples/upm/bh1750/src/bh1750.c
@@ -0,0 +1,83 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "bh1750.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a BH1750 sensor on default I2C bus (0), using the
+    // default I2C address (0x23), and setting the mode to highest
+    // resolution, lowest power mode.
+    bh1750_context sensor = bh1750_init(BH1750_DEFAULT_I2C_BUS,
+            BH1750_DEFAULT_I2C_ADDR,
+            BH1750_OPMODE_H2_ONCE);
+
+    if (!sensor)
+    {
+        printf("bh1750_init() failed.\n");
+        return 1;
+    }
+
+    // Every second, sample the BH1750 and output the measured lux value
+
+    while (shouldRun)
+    {
+        float lux;
+
+        bh1750_get_lux(sensor, &lux);
+        printf("Detected Light Level (lux): %f\n", lux);
+        upm_delay(1);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    bh1750_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/biss0001/Makefile b/samples/upm/biss0001/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/biss0001/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/biss0001/prj.conf b/samples/upm/biss0001/prj.conf
new file mode 100644
index 0000000..2aeb1e3
--- /dev/null
+++ b/samples/upm/biss0001/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_biss0001=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/biss0001/src/Makefile b/samples/upm/biss0001/src/Makefile
new file mode 100644
index 0000000..27faedd
--- /dev/null
+++ b/samples/upm/biss0001/src/Makefile
@@ -0,0 +1 @@
+obj-y = biss0001.o
diff --git a/samples/upm/biss0001/src/biss0001.c b/samples/upm/biss0001/src/biss0001.c
new file mode 100644
index 0000000..034c625
--- /dev/null
+++ b/samples/upm/biss0001/src/biss0001.c
@@ -0,0 +1,70 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "biss0001.h"
+#include "upm_utilities.h"
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+
+int main ()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate a BISS0001 sensor on digital pin D2
+    biss0001_context sensor = biss0001_init(2);
+
+    if (!sensor)
+    {
+        printf("biss0001_init() failed.\n");
+        return(1);
+    }
+
+    while (shouldRun)
+    {
+        if (biss0001_motion_detected(sensor))
+            printf("Motion detected.\n");
+        else
+            printf("No motion detected.\n");
+
+        upm_delay(1);
+    }
+//! [Interesting]
+
+    printf("Exiting...\n");
+
+    biss0001_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/bmi160/Makefile b/samples/upm/bmi160/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/bmi160/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/bmi160/prj.conf b/samples/upm/bmi160/prj.conf
new file mode 100644
index 0000000..44e0654
--- /dev/null
+++ b/samples/upm/bmi160/prj.conf
@@ -0,0 +1,22 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_SPI=y
+CONFIG_SPI=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_MRAA_GPIO=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
+CONFIG_UPM=y
+CONFIG_UPM_bmi160=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_SPI_QMSI=y
+CONFIG_PINMUX=y
+CONFIG_PINMUX_DEV=y
+CONFIG_PINMUX_DEV_NAME=âPINMUX_DEVâ
+CONFIG_PINMUX_DEV_QMSI=y
+CONFIG_PINMUX_NAME=âPINMUXâ
+CONFIG_PINMUX_INIT_PRIORITY=60
+#CONFIG_SPI_CS_GPIO=y
+#CONFIG_SPI_0_CS_GPIO=24
diff --git a/samples/upm/bmi160/prj_internal.conf b/samples/upm/bmi160/prj_internal.conf
new file mode 100644
index 0000000..201e309
--- /dev/null
+++ b/samples/upm/bmi160/prj_internal.conf
@@ -0,0 +1,26 @@
+# console related
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_CONSOLE_HANDLER=y
+CONFIG_CONSOLE_HANDLER_SHELL=y
+# timer configuration
+CONFIG_NANO_TIMERS=y
+CONFIG_NANO_TIMEOUTS=y
+# Enable Zephyr SPI driver
+CONFIG_SPI=y
+CONFIG_SPI_DW_ARC_AUX_REGS=y
+CONFIG_SPI_DW_INTERRUPT_SEPARATED_LINES=y
+# Enable malloc/free support
+CONFIG_NEWLIB_LIBC=y
+# Enable Zephyr GPIO
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI_SS=y
+# set up MRAA
+CONFIG_MRAA=y
+CONFIG_MRAA_SPI=y
+CONFIG_MRAA_GPIO=y
+# UPM specific
+CONFIG_UPM=y
+CONFIG_UPM_bmi160=y
+CONFIG_UPM_utilities=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
diff --git a/samples/upm/bmi160/src/Makefile b/samples/upm/bmi160/src/Makefile
new file mode 100644
index 0000000..4a50a00
--- /dev/null
+++ b/samples/upm/bmi160/src/Makefile
@@ -0,0 +1 @@
+obj-y = bmi160.o
diff --git a/samples/upm/bmi160/src/bmi160.c b/samples/upm/bmi160/src/bmi160.c
new file mode 100644
index 0000000..3491363
--- /dev/null
+++ b/samples/upm/bmi160/src/bmi160.c
@@ -0,0 +1,93 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "bmi160.h"
+#include "upm_utilities.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a BMI160 sensor on I2C bus 0, address 0x69, and
+    // disable the magnetometer (since it is an optional component
+    // that may not be present).  Since we are using I2C, pass a valid
+    // I2C address, and supply -1 as the cs_pin.
+    //
+    // bmi160_context sensor = bmi160_init(0, 0x69, -1, false);
+
+    // For SPI, you would use something like this, using gpio 10 as
+    // the cs pin.  Passing -1 as the address indicates SPI operation.
+    //
+    // bmi160_context sensor = bmi160_init(0, -1, 10, false);
+    printf("FLOATING? %f\n", 3.14159);
+    bmi160_context sensor = bmi160_init(0, -1, 2, false);
+
+    if (!sensor)
+    {
+        printf("bmi160_init() failed.\n");
+        return(1);
+    }
+
+    // Every half second, update and print values
+
+    while (shouldRun)
+    {
+        bmi160_update(sensor);
+
+        float x, y, z;
+
+        bmi160_get_accelerometer(sensor, &x, &y, &z);
+        printf("Acceleration x = %f y = %f z = %f\n",
+               x, y, z);
+
+        bmi160_get_gyroscope(sensor, &x, &y, &z);
+        printf("Gyroscope    x = %f y = %f z = %f\n",
+               x, y, z);
+
+        printf("\n");
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting...\n");
+
+    bmi160_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/button/Makefile b/samples/upm/button/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/button/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/button/prj.conf b/samples/upm/button/prj.conf
new file mode 100644
index 0000000..95de39a
--- /dev/null
+++ b/samples/upm/button/prj.conf
@@ -0,0 +1,10 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_button=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
+CONFIG_MRAA_GPIO=y
+CONFIG_STDOUT_CONSOLE=y
diff --git a/samples/upm/button/src/Makefile b/samples/upm/button/src/Makefile
new file mode 100644
index 0000000..500e4f5
--- /dev/null
+++ b/samples/upm/button/src/Makefile
@@ -0,0 +1 @@
+obj-y = button.o
diff --git a/samples/upm/button/src/button.c b/samples/upm/button/src/button.c
new file mode 100644
index 0000000..9453121
--- /dev/null
+++ b/samples/upm/button/src/button.c
@@ -0,0 +1,54 @@
+/*
+ * Authors: Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2014 - 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "button.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    button_context dev = button_init(2);
+    bool abc = 0;
+    while(1){
+        if(button_get_value(dev, &abc) != UPM_SUCCESS){
+            printf("an error has occured\n");
+        }
+        upm_delay(1);
+        printf("value retrieved: %d\n", abc);
+    }
+
+    return 0;
+}
diff --git a/samples/upm/button_intr/Makefile b/samples/upm/button_intr/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/button_intr/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/button_intr/prj.conf b/samples/upm/button_intr/prj.conf
new file mode 100644
index 0000000..95de39a
--- /dev/null
+++ b/samples/upm/button_intr/prj.conf
@@ -0,0 +1,10 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_button=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
+CONFIG_MRAA_GPIO=y
+CONFIG_STDOUT_CONSOLE=y
diff --git a/samples/upm/button_intr/src/Makefile b/samples/upm/button_intr/src/Makefile
new file mode 100644
index 0000000..fa09cfa
--- /dev/null
+++ b/samples/upm/button_intr/src/Makefile
@@ -0,0 +1 @@
+obj-y = button_intr.o
diff --git a/samples/upm/button_intr/src/button_intr.c b/samples/upm/button_intr/src/button_intr.c
new file mode 100644
index 0000000..432e32d
--- /dev/null
+++ b/samples/upm/button_intr/src/button_intr.c
@@ -0,0 +1,59 @@
+/*
+ * Authors: Abhishek Malik <abhishek.malik@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "button.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int counter;
+
+void button_isr(void *arg){
+    counter++;
+}
+
+int main()
+{
+    counter = 0;
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    button_context dev = button_init(2);
+
+    button_install_isr(dev, MRAA_GPIO_EDGE_RISING, button_isr, NULL);
+    while(1){
+        printf("Interrupts: %d\n", counter);
+        upm_delay(3);
+    }
+
+    return 0;
+}
diff --git a/samples/upm/buzzer/Makefile b/samples/upm/buzzer/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/buzzer/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/buzzer/prj.conf b/samples/upm/buzzer/prj.conf
new file mode 100644
index 0000000..52b3b77
--- /dev/null
+++ b/samples/upm/buzzer/prj.conf
@@ -0,0 +1,11 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_PWM=y
+CONFIG_PWM=y
+CONFIG_PWM_QMSI=y
+CONFIG_PWM_QMSI_DEV_NAME="PWM_0"
+CONFIG_PWM_QMSI_NUM_PORTS=4
+CONFIG_NEWLIB_LIBC=y
+CONFIG_UPM=y
+CONFIG_UPM_buzzer=y
+CONFIG_UPM_utilities=y
diff --git a/samples/upm/buzzer/src/Makefile b/samples/upm/buzzer/src/Makefile
new file mode 100644
index 0000000..3700285
--- /dev/null
+++ b/samples/upm/buzzer/src/Makefile
@@ -0,0 +1 @@
+obj-y = buzzer.o
diff --git a/samples/upm/buzzer/src/buzzer.c b/samples/upm/buzzer/src/buzzer.c
new file mode 100644
index 0000000..763354d
--- /dev/null
+++ b/samples/upm/buzzer/src/buzzer.c
@@ -0,0 +1,68 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <buzzer.h>
+
+
+int
+main(int argc, char **argv)
+{
+//! [Interesting]
+    int chord[] = { BUZZER_DO, BUZZER_RE, BUZZER_MI,
+                    BUZZER_FA, BUZZER_SOL, BUZZER_LA,
+                    BUZZER_SI };
+
+    // create Buzzer context, using PWM pin 5
+    buzzer_context sound = buzzer_init(5);
+
+    if (!sound)
+    {
+        printf("buzzer_init() failed\n");
+        return 1;
+    }
+
+    printf("Playing...\n");
+
+    // play each sound (DO, RE, MI, etc...) for .5 seconds, pausing
+    // for 0.1 seconds between notes
+    for (int chord_ind = 0; chord_ind < 7; chord_ind++)
+    {
+        buzzer_play_sound(sound, chord[chord_ind], 500000);
+        printf("%d\n", chord[chord_ind]);
+        upm_delay_ms(100);
+    }
+
+    printf("Exiting...\n");
+
+    buzzer_close(sound);
+
+//! [Interesting]
+
+    return 0;
+}
diff --git a/samples/upm/collision/Makefile b/samples/upm/collision/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/collision/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/collision/prj.conf b/samples/upm/collision/prj.conf
new file mode 100644
index 0000000..3658e69
--- /dev/null
+++ b/samples/upm/collision/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_collision=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/collision/src/Makefile b/samples/upm/collision/src/Makefile
new file mode 100644
index 0000000..e4d9669
--- /dev/null
+++ b/samples/upm/collision/src/Makefile
@@ -0,0 +1 @@
+obj-y = collision.o
\ No newline at end of file
diff --git a/samples/upm/collision/src/collision.c b/samples/upm/collision/src/collision.c
new file mode 100644
index 0000000..8fd1c8d
--- /dev/null
+++ b/samples/upm/collision/src/collision.c
@@ -0,0 +1,31 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "collision.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    collision_context dev = collision_init(2);
+    bool abc = 0;
+    while(1){
+        if(collision_is_colliding(dev, &abc) != UPM_SUCCESS){
+            printf("an error has occured\n");
+        }
+        upm_delay(1);
+        printf("value retrieved: %d\n", abc);
+    }
+    collision_close(dev);
+}
diff --git a/samples/upm/dfrorp/Makefile b/samples/upm/dfrorp/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/dfrorp/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/dfrorp/prj.conf b/samples/upm/dfrorp/prj.conf
new file mode 100644
index 0000000..25b63c3
--- /dev/null
+++ b/samples/upm/dfrorp/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_dfrorp=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
diff --git a/samples/upm/dfrorp/src/Makefile b/samples/upm/dfrorp/src/Makefile
new file mode 100644
index 0000000..693ea84
--- /dev/null
+++ b/samples/upm/dfrorp/src/Makefile
@@ -0,0 +1 @@
+obj-y = dfrorp.o
\ No newline at end of file
diff --git a/samples/upm/dfrorp/src/dfrorp.c b/samples/upm/dfrorp/src/dfrorp.c
new file mode 100644
index 0000000..e2466b7
--- /dev/null
+++ b/samples/upm/dfrorp/src/dfrorp.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "dfrorp.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a DFRobot ORP sensor on analog pin A0 with an analog
+    // reference voltage of 5.0.
+    dfrorp_context sensor = dfrorp_init(0, 5.0);
+
+    if (!sensor)
+    {
+        printf("dfrorp_init() failed.\n");
+        return(1);
+    }
+
+    // To calibrate:
+    //
+    // Disconnect the sensor probe (but leave the sensor interface board
+    // connected).  Then run one of the examples while holding down the
+    // 'calibrate' button on the device.  Read the ORP value reported
+    // (it should be fairly small).
+    //
+    // This value is what you should supply to
+    // dfrorp_set_orp_cal_offset().  Then reconnect the probe to the
+    // interface board and you should be ready to go.
+    //
+    // DO NOT press the calibrate button on the interface board while
+    // the probe is attached or you can permanently damage the probe.
+    dfrorp_set_calibration_offset(sensor, 0.97);
+
+    // Every second, update and print values
+    while (shouldRun)
+    {
+        dfrorp_update(sensor);
+
+        printf("ORP = %f mV\n", dfrorp_get_orp(sensor));
+
+        upm_delay(1);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting...\n");
+
+    dfrorp_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/dfrph/Makefile b/samples/upm/dfrph/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/dfrph/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/dfrph/prj.conf b/samples/upm/dfrph/prj.conf
new file mode 100644
index 0000000..79e3609
--- /dev/null
+++ b/samples/upm/dfrph/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_dfrph=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
diff --git a/samples/upm/dfrph/src/Makefile b/samples/upm/dfrph/src/Makefile
new file mode 100644
index 0000000..489e051
--- /dev/null
+++ b/samples/upm/dfrph/src/Makefile
@@ -0,0 +1 @@
+obj-y = dfrph.o
\ No newline at end of file
diff --git a/samples/upm/dfrph/src/dfrph.c b/samples/upm/dfrph/src/dfrph.c
new file mode 100644
index 0000000..34cd49c
--- /dev/null
+++ b/samples/upm/dfrph/src/dfrph.c
@@ -0,0 +1,85 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "dfrph.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a dfrph sensor on analog pin A0
+    dfrph_context sensor = dfrph_init(0);
+
+    if (!sensor)
+    {
+        printf("dfrph_init() failed.\n");
+        return(1);
+    }
+
+    // Set the ADC reference to 3.3 for the Arduino 101
+    dfrph_set_aref(sensor, 3.3);
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float volts = 0.0, pH = 0.0;
+
+        dfrph_get_raw_volts(sensor, &volts);
+        dfrph_get_ph(sensor, &pH);
+
+        printf("Detected volts: %0.03f\n", volts);
+        printf("pH value: %0.03f\n", pH);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    dfrph_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/ecezo/Makefile b/samples/upm/ecezo/Makefile
new file mode 100644
index 0000000..17cffed
--- /dev/null
+++ b/samples/upm/ecezo/Makefile
@@ -0,0 +1,6 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+LDFLAGS += -u _printf_float
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/ecezo/prj.conf b/samples/upm/ecezo/prj.conf
new file mode 100644
index 0000000..ea5cc43
--- /dev/null
+++ b/samples/upm/ecezo/prj.conf
@@ -0,0 +1,10 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_MRAA_UART=y
+CONFIG_I2C=y
+CONFIG_UART=y
+CONFIG_UPM=y
+CONFIG_UPM_ecezo=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/ecezo/src/Makefile b/samples/upm/ecezo/src/Makefile
new file mode 100644
index 0000000..e830077
--- /dev/null
+++ b/samples/upm/ecezo/src/Makefile
@@ -0,0 +1 @@
+obj-y = ecezo.o
diff --git a/samples/upm/ecezo/src/ecezo.c b/samples/upm/ecezo/src/ecezo.c
new file mode 100644
index 0000000..1e73fe6
--- /dev/null
+++ b/samples/upm/ecezo/src/ecezo.c
@@ -0,0 +1,85 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <ecezo.h>
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a ECEZO sensor on uart 0 at 9600 baud.
+    // ecezo_context sensor = ecezo_uart_init(0, 9600);
+
+    // For I2C, assuming the device is configured for address 0x64 on
+    // I2C bus 0, you could use something like:
+    //
+    ecezo_context sensor = ecezo_i2c_init(0, 0x64);
+
+    if (!sensor)
+    {
+        printf("ecezo_init() failed.\n");
+        return 1;
+    }
+
+    while (shouldRun)
+    {
+        // this will take about 1 second to complete
+        if (ecezo_update(sensor))
+        {
+            printf("ecezo_update() failed\n");
+        }
+        else
+        {
+            printf("EC %f uS/cm, TDS %f mg/L, Salinity %f PSS-78, SG %f\n",
+                   ecezo_get_ec(sensor),
+                   ecezo_get_tds(sensor),
+                   ecezo_get_salinity(sensor),
+                   ecezo_get_sg(sensor));
+        }
+
+        upm_delay(5);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    ecezo_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/emg/Makefile b/samples/upm/emg/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/emg/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/emg/prj.conf b/samples/upm/emg/prj.conf
new file mode 100644
index 0000000..947ad2a
--- /dev/null
+++ b/samples/upm/emg/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_emg=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/emg/src/Makefile b/samples/upm/emg/src/Makefile
new file mode 100644
index 0000000..91b4f11
--- /dev/null
+++ b/samples/upm/emg/src/Makefile
@@ -0,0 +1 @@
+obj-y = emg.o
\ No newline at end of file
diff --git a/samples/upm/emg/src/emg.c b/samples/upm/emg/src/emg.c
new file mode 100644
index 0000000..329198a
--- /dev/null
+++ b/samples/upm/emg/src/emg.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "emg.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a emg sensor on analog pin A0
+    emg_context sensor = emg_init(0);
+
+    if (!sensor)
+    {
+        printf("emg_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    emg_set_aref(sensor, 5.0);
+    emg_set_scale(sensor, 1.0);
+    emg_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            emg_get_aref(sensor),
+            emg_get_scale(sensor),
+            emg_get_offset(sensor));
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float normalized = 0.0;
+        float raw_volts = 0.0;
+        float volts = 0.0;
+
+        emg_get_normalized(sensor, &normalized);
+        emg_get_raw_volts(sensor, &raw_volts);
+        emg_get_volts(sensor, &volts);
+
+        printf("Normalized output: %0.03f, raw emg sensor output: %0.03f v "
+                "adjusted output: %0.03f v\n", normalized, raw_volts, volts);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    emg_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/flex/Makefile b/samples/upm/flex/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/flex/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/flex/prj.conf b/samples/upm/flex/prj.conf
new file mode 100644
index 0000000..f135667
--- /dev/null
+++ b/samples/upm/flex/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_flex=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/flex/src/Makefile b/samples/upm/flex/src/Makefile
new file mode 100644
index 0000000..95d8745
--- /dev/null
+++ b/samples/upm/flex/src/Makefile
@@ -0,0 +1 @@
+obj-y = flex.o
\ No newline at end of file
diff --git a/samples/upm/flex/src/flex.c b/samples/upm/flex/src/flex.c
new file mode 100644
index 0000000..74fded3
--- /dev/null
+++ b/samples/upm/flex/src/flex.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "flex.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a flex sensor on analog pin A0
+    flex_context sensor = flex_init(0);
+
+    if (!sensor)
+    {
+        printf("flex_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    flex_set_aref(sensor, 5.0);
+    flex_set_scale(sensor, 1.0);
+    flex_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            flex_get_aref(sensor),
+            flex_get_scale(sensor),
+            flex_get_offset(sensor));
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float normalized = 0.0;
+        float raw_volts = 0.0;
+        float volts = 0.0;
+
+        flex_get_normalized(sensor, &normalized);
+        flex_get_raw_volts(sensor, &raw_volts);
+        flex_get_volts(sensor, &volts);
+
+        printf("Normalized output: %0.03f, raw flex sensor output: %0.03f v "
+                "adjusted output: %0.03f v\n", normalized, raw_volts, volts);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    flex_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/gas/Makefile b/samples/upm/gas/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/gas/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/gas/prj.conf b/samples/upm/gas/prj.conf
new file mode 100644
index 0000000..f8745ca
--- /dev/null
+++ b/samples/upm/gas/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_gas=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
diff --git a/samples/upm/gas/src/Makefile b/samples/upm/gas/src/Makefile
new file mode 100644
index 0000000..cd32b40
--- /dev/null
+++ b/samples/upm/gas/src/Makefile
@@ -0,0 +1 @@
+obj-y = mqx.o
\ No newline at end of file
diff --git a/samples/upm/gas/src/mqx.c b/samples/upm/gas/src/mqx.c
new file mode 100644
index 0000000..4eff30e
--- /dev/null
+++ b/samples/upm/gas/src/mqx.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "mqx.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a mqx sensor on analog pin A0
+    mqx_context sensor = mqx_init(0);
+
+    if (!sensor)
+    {
+        printf("mqx_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    mqx_set_aref(sensor, 5.0);
+    mqx_set_scale(sensor, 1.0);
+    mqx_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            mqx_get_aref(sensor),
+            mqx_get_scale(sensor),
+            mqx_get_offset(sensor));
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float normalized = 0.0;
+        float raw_volts = 0.0;
+        float volts = 0.0;
+
+        mqx_get_normalized(sensor, &normalized);
+        mqx_get_raw_volts(sensor, &raw_volts);
+        mqx_get_volts(sensor, &volts);
+
+        printf("Normalized output: %0.03f, raw mqx sensor output: %0.03f v "
+                "adjusted output: %0.03f v\n", normalized, raw_volts, volts);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    mqx_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/gp2y0a/Makefile b/samples/upm/gp2y0a/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/gp2y0a/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/gp2y0a/prj.conf b/samples/upm/gp2y0a/prj.conf
new file mode 100644
index 0000000..9fd030b
--- /dev/null
+++ b/samples/upm/gp2y0a/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_gp2y0a=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
diff --git a/samples/upm/gp2y0a/src/Makefile b/samples/upm/gp2y0a/src/Makefile
new file mode 100644
index 0000000..93fe322
--- /dev/null
+++ b/samples/upm/gp2y0a/src/Makefile
@@ -0,0 +1 @@
+obj-y = gp2y0a.o
\ No newline at end of file
diff --git a/samples/upm/gp2y0a/src/gp2y0a.c b/samples/upm/gp2y0a/src/gp2y0a.c
new file mode 100644
index 0000000..e4d183b
--- /dev/null
+++ b/samples/upm/gp2y0a/src/gp2y0a.c
@@ -0,0 +1,34 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "gp2y0a.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    gp2y0a_context dev = gp2y0a_init(14, 5.0);
+    float val;
+    while(1){
+        if(gp2y0a_get_value(dev, 5.0, 20, &val) != UPM_SUCCESS){
+            printf("Failed to get any values from the sensor\n");
+        }
+        printf("Moisture Value: %f\n", val);
+        upm_delay(1);
+    }
+    gp2y0a_close(dev);
+
+    return 0;
+}
+
diff --git a/samples/upm/gsr/Makefile b/samples/upm/gsr/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/gsr/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/gsr/prj.conf b/samples/upm/gsr/prj.conf
new file mode 100644
index 0000000..f90297f
--- /dev/null
+++ b/samples/upm/gsr/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_gsr=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/gsr/src/Makefile b/samples/upm/gsr/src/Makefile
new file mode 100644
index 0000000..b9a2c52
--- /dev/null
+++ b/samples/upm/gsr/src/Makefile
@@ -0,0 +1 @@
+obj-y = gsr.o
\ No newline at end of file
diff --git a/samples/upm/gsr/src/gsr.c b/samples/upm/gsr/src/gsr.c
new file mode 100644
index 0000000..ed3b585
--- /dev/null
+++ b/samples/upm/gsr/src/gsr.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "gsr.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a gsr sensor on analog pin A0
+    gsr_context sensor = gsr_init(0);
+
+    if (!sensor)
+    {
+        printf("gsr_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    gsr_set_aref(sensor, 5.0);
+    gsr_set_scale(sensor, 1.0);
+    gsr_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            gsr_get_aref(sensor),
+            gsr_get_scale(sensor),
+            gsr_get_offset(sensor));
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float normalized = 0.0;
+        float raw_volts = 0.0;
+        float volts = 0.0;
+
+        gsr_get_normalized(sensor, &normalized);
+        gsr_get_raw_volts(sensor, &raw_volts);
+        gsr_get_volts(sensor, &volts);
+
+        printf("Normalized output: %0.03f, raw gsr sensor output: %0.03f v "
+                "adjusted output: %0.03f v\n", normalized, raw_volts, volts);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    gsr_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/guvas12d/Makefile b/samples/upm/guvas12d/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/guvas12d/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/guvas12d/prj.conf b/samples/upm/guvas12d/prj.conf
new file mode 100644
index 0000000..e7ab85d
--- /dev/null
+++ b/samples/upm/guvas12d/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_ADC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_guvas12d=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/guvas12d/src/Makefile b/samples/upm/guvas12d/src/Makefile
new file mode 100644
index 0000000..552a340
--- /dev/null
+++ b/samples/upm/guvas12d/src/Makefile
@@ -0,0 +1 @@
+obj-y = guvas12d.o
diff --git a/samples/upm/guvas12d/src/guvas12d.c b/samples/upm/guvas12d/src/guvas12d.c
new file mode 100644
index 0000000..9c984f4
--- /dev/null
+++ b/samples/upm/guvas12d/src/guvas12d.c
@@ -0,0 +1,89 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <guvas12d.h>
+
+bool shouldRun = true;
+
+// analog voltage, usually 3.3 or 5.0
+#define GUVAS12D_AREF   5.0
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // This was tested with the Grove UV Sensor module.
+    // It has a sensing range from between 240-370nm.  It's strongest
+    // response is around 320-360nm.
+
+    // Instantiate a GUVAS12D on analog pin A0
+    guvas12d_context uv = guvas12d_init(0, GUVAS12D_AREF);
+
+    if (!uv)
+    {
+        printf("guvas12d_init() failed\n");
+        return 1;
+    }
+
+    // The higher the voltage the more intense the UV radiation.
+    while (shouldRun)
+    {
+        float volts = 0;
+        float intensity = 0;
+
+        if (guvas12d_get_volts(uv, &volts))
+        {
+            printf("guvas12d_get_volts() failed\n");
+            return 1;
+        }
+
+        if (guvas12d_get_intensity(uv, &intensity))
+        {
+            printf("guvas12d_get_intensity() failed\n");
+            return 1;
+        }
+
+        printf("Volts: %f, Intensity %f mW/m^2\n", volts, intensity);
+
+        upm_delay(1);
+    }
+
+    printf("Exiting\n");
+
+    guvas12d_close(uv);
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/hka5/Makefile b/samples/upm/hka5/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/hka5/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/hka5/prj.conf b/samples/upm/hka5/prj.conf
new file mode 100644
index 0000000..ec366b4
--- /dev/null
+++ b/samples/upm/hka5/prj.conf
@@ -0,0 +1,10 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_MRAA_UART=y
+CONFIG_UPM=y
+CONFIG_UPM_hka5=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/hka5/src/Makefile b/samples/upm/hka5/src/Makefile
new file mode 100644
index 0000000..d075e98
--- /dev/null
+++ b/samples/upm/hka5/src/Makefile
@@ -0,0 +1 @@
+obj-y = hka5.o
\ No newline at end of file
diff --git a/samples/upm/hka5/src/hka5.c b/samples/upm/hka5/src/hka5.c
new file mode 100644
index 0000000..0e56ef6
--- /dev/null
+++ b/samples/upm/hka5/src/hka5.c
@@ -0,0 +1,86 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "hka5.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a HKA5 sensor on uart 0.  We don't use the set or
+    // reset pins, so we pass -1 for them.
+    hka5_context sensor = hka5_init(0, -1, -1);
+
+    if (!sensor)
+    {
+        printf("hka5_init() failed.\n");
+        return 1;
+    }
+
+    // update once every 2 seconds and output data
+    while (shouldRun)
+    {
+        if (hka5_update(sensor) != UPM_SUCCESS)
+        {
+            printf("hka5_update() failed, exiting.\n");
+            shouldRun = false;
+        }
+
+        printf("PM 1  : %d ug/m3\n", hka5_get_pm1(sensor));
+        printf("PM 2.5: %d ug/m3\n", hka5_get_pm2_5(sensor));
+        printf("PM 10 : %d ug/m3\n", hka5_get_pm10(sensor));
+        printf("\n");
+
+        upm_delay(2);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    hka5_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/ims/Makefile b/samples/upm/ims/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/ims/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/ims/prj.conf b/samples/upm/ims/prj.conf
new file mode 100644
index 0000000..8cf0b52
--- /dev/null
+++ b/samples/upm/ims/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_ims=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/ims/src/Makefile b/samples/upm/ims/src/Makefile
new file mode 100644
index 0000000..da9ee05
--- /dev/null
+++ b/samples/upm/ims/src/Makefile
@@ -0,0 +1 @@
+obj-y = ims.o
diff --git a/samples/upm/ims/src/ims.c b/samples/upm/ims/src/ims.c
new file mode 100644
index 0000000..7be3e0c
--- /dev/null
+++ b/samples/upm/ims/src/ims.c
@@ -0,0 +1,76 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include "ims.h"
+#include "upm_utilities.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+
+    //! [Interesting]
+    ims_context* sensor = ims_init(0, IMS_ADDRESS_DEFAULT);
+
+    if (!sensor)
+    {
+        printf("ims_init() failed\n");
+        return 1;
+    }
+
+    // Every second, sample the sensor outputs
+    while (shouldRun)
+    {
+        uint16_t version, light, moisture, temp;
+
+        if (ims_get_version(sensor, &version) == UPM_SUCCESS &&
+            ims_get_light(sensor, &light) == UPM_SUCCESS &&
+            ims_get_moisture(sensor, &moisture) == UPM_SUCCESS &&
+            ims_get_temperature(sensor, &temp) == UPM_SUCCESS)
+            printf("Version: %d light: 0x%04x moisture: 0x%04x temp: %3.2f C\n",
+                    version, light, moisture, temp/10.0);
+        else
+            break;
+
+        upm_delay(1);
+    }
+
+    //! [Interesting]
+    printf("Exiting\n");
+    ims_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/jhd1313m1/Makefile b/samples/upm/jhd1313m1/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/jhd1313m1/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/jhd1313m1/prj.conf b/samples/upm/jhd1313m1/prj.conf
new file mode 100644
index 0000000..18e2365
--- /dev/null
+++ b/samples/upm/jhd1313m1/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_jhd1313m1=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/jhd1313m1/src/Makefile b/samples/upm/jhd1313m1/src/Makefile
new file mode 100644
index 0000000..17accd0
--- /dev/null
+++ b/samples/upm/jhd1313m1/src/Makefile
@@ -0,0 +1 @@
+obj-y = jhd1313m1.o
diff --git a/samples/upm/jhd1313m1/src/jhd1313m1.c b/samples/upm/jhd1313m1/src/jhd1313m1.c
new file mode 100644
index 0000000..7004172
--- /dev/null
+++ b/samples/upm/jhd1313m1/src/jhd1313m1.c
@@ -0,0 +1,84 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "jhd1313m1.h"
+#include "upm_utilities.h"
+#include "signal.h"
+#include "string.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main(int argc, char **argv)
+{
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+    // initialize a JHD1313m1 on I2C bus 0, LCD address 0x3e, RGB
+    // address 0x62
+    jhd1313m1_context lcd = jhd1313m1_init(0, 0x3e, 0x62);
+
+    if (!lcd)
+    {
+        printf("jhd1313m1_i2c_init() failed\n");
+        return 1;
+    }
+
+    int ndx = 0;
+    char str[20];
+    uint8_t rgb[7][3] = {
+        {0xd1, 0x00, 0x00},
+        {0xff, 0x66, 0x22},
+        {0xff, 0xda, 0x21},
+        {0x33, 0xdd, 0x00},
+        {0x11, 0x33, 0xcc},
+        {0x22, 0x00, 0x66},
+        {0x33, 0x00, 0x44}};
+    while (shouldRun)
+    {
+        snprintf(str, sizeof(str), "Hello World %d", ndx);
+        // Alternate rows on the LCD
+        jhd1313m1_set_cursor(lcd, ndx%2, 0);
+        jhd1313m1_write(lcd, str, strlen(str));
+        // Change the color
+        uint8_t r = rgb[ndx%7][0];
+        uint8_t g = rgb[ndx%7][1];
+        uint8_t b = rgb[ndx%7][2];
+        jhd1313m1_set_color(lcd, r, g, b);
+        // Echo via printf
+        printf("Hello World %d rgb: 0x%02x%02x%02x\n", ndx++, r, g, b);
+
+        upm_delay(1);
+    }
+
+    jhd1313m1_close(lcd);
+//! [Interesting]
+
+    return 0;
+}
diff --git a/samples/upm/joystick12/Makefile b/samples/upm/joystick12/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/joystick12/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/joystick12/prj.conf b/samples/upm/joystick12/prj.conf
new file mode 100644
index 0000000..cf84227
--- /dev/null
+++ b/samples/upm/joystick12/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_joystick12=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/joystick12/src/Makefile b/samples/upm/joystick12/src/Makefile
new file mode 100644
index 0000000..c119856
--- /dev/null
+++ b/samples/upm/joystick12/src/Makefile
@@ -0,0 +1 @@
+obj-y = joystick12.o
\ No newline at end of file
diff --git a/samples/upm/joystick12/src/joystick12.c b/samples/upm/joystick12/src/joystick12.c
new file mode 100644
index 0000000..89b06ae
--- /dev/null
+++ b/samples/upm/joystick12/src/joystick12.c
@@ -0,0 +1,95 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "joystick12.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a joystick12 sensor
+    //    X = Analog pin A0
+    //    Y = Analog pin A1
+    joystick12_context sensor = joystick12_init(0, 1);
+
+    if (!sensor)
+    {
+        printf("joystick12_init() failed.\n");
+        return -1;
+    }
+
+    printf("Press any key to zero joystick...\n");
+    getchar();
+
+    // Zero x and y axis
+    joystick12_zero(sensor);
+
+    printf("Hold the X axis to the far neg or pos value, then press a key...\n");
+    getchar();
+    joystick12_calibrate_x(sensor);
+    printf("Hold the Y axis to the far neg or pos value, then press a key...\n");
+    getchar();
+    joystick12_calibrate_y(sensor);
+
+    // Every half a second, sample the sensor output
+    float x, y;
+    while (shouldRun)
+    {
+        joystick12_get_value_x(sensor, &x);
+        joystick12_get_value_y(sensor, &y);
+
+        printf("X: %5.02f Y: %5.02f\n", x, y);
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    joystick12_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/lcm1602/Makefile b/samples/upm/lcm1602/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/lcm1602/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/lcm1602/prj.conf b/samples/upm/lcm1602/prj.conf
new file mode 100644
index 0000000..e73feb2
--- /dev/null
+++ b/samples/upm/lcm1602/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_lcm1602=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/lcm1602/src/Makefile b/samples/upm/lcm1602/src/Makefile
new file mode 100644
index 0000000..d6f3f85
--- /dev/null
+++ b/samples/upm/lcm1602/src/Makefile
@@ -0,0 +1 @@
+obj-y = lcm1602-i2c.o
diff --git a/samples/upm/lcm1602/src/lcm1602-i2c.c b/samples/upm/lcm1602/src/lcm1602-i2c.c
new file mode 100644
index 0000000..5193e06
--- /dev/null
+++ b/samples/upm/lcm1602/src/lcm1602-i2c.c
@@ -0,0 +1,53 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "lcm1602.h"
+#include <upm_utilities.h>
+
+int main(int argc, char **argv)
+{
+//! [Interesting]
+    lcm1602_context lcd = lcm1602_i2c_init(0, 0x20, true, 16, 2);
+
+    if (!lcd)
+    {
+        printf("lcm1602_i2c_init() failed\n");
+        return 1;
+    }
+
+    lcm1602_set_cursor(lcd, 0, 0);
+    lcm1602_write(lcd, "Hello World 1", 13);
+
+    upm_delay(3);
+
+    lcm1602_set_cursor(lcd, 1, 0);
+    lcm1602_write(lcd, "Hello World 2", 13);
+
+    upm_delay(3);
+
+    lcm1602_close(lcd);
+//! [Interesting]
+
+    return 0;
+}
diff --git a/samples/upm/ldt0028/Makefile b/samples/upm/ldt0028/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/ldt0028/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/ldt0028/prj.conf b/samples/upm/ldt0028/prj.conf
new file mode 100644
index 0000000..27dbd37
--- /dev/null
+++ b/samples/upm/ldt0028/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_ldt0028=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/ldt0028/src/Makefile b/samples/upm/ldt0028/src/Makefile
new file mode 100644
index 0000000..9984e5d
--- /dev/null
+++ b/samples/upm/ldt0028/src/Makefile
@@ -0,0 +1 @@
+obj-y = ldt0028.o
\ No newline at end of file
diff --git a/samples/upm/ldt0028/src/ldt0028.c b/samples/upm/ldt0028/src/ldt0028.c
new file mode 100644
index 0000000..6f1794b
--- /dev/null
+++ b/samples/upm/ldt0028/src/ldt0028.c
@@ -0,0 +1,103 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "ldt0028.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a ldt0028 sensor on analog pin A0
+    ldt0028_context sensor = ldt0028_init(0);
+
+    if (!sensor)
+    {
+        printf("ldt0028_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    ldt0028_set_aref(sensor, 5.0);
+    ldt0028_set_scale(sensor, 1.0);
+    ldt0028_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            ldt0028_get_aref(sensor),
+            ldt0028_get_scale(sensor),
+            ldt0028_get_offset(sensor));
+
+    float normalized = 0.0;
+    float raw_volts = 0.0;
+    float volts = 0.0;
+
+    float norm_base = 0.1;
+
+    printf("Using normalized sensor output average == %f\n", norm_base);
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+
+        ldt0028_get_normalized(sensor, &normalized);
+        ldt0028_get_raw_volts(sensor, &raw_volts);
+        ldt0028_get_volts(sensor, &volts);
+
+        if (normalized > norm_base)
+        {
+            printf("Detected vibration!\n");
+            printf("Normalized output: %0.03f, raw ldt0028 sensor output: %0.03f v "
+                    "adjusted output: %0.03f v\n\n", normalized, raw_volts, volts);
+        }
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    ldt0028_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/led/Makefile b/samples/upm/led/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/led/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/led/prj.conf b/samples/upm/led/prj.conf
new file mode 100644
index 0000000..4d6d098
--- /dev/null
+++ b/samples/upm/led/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_led=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/led/src/Makefile b/samples/upm/led/src/Makefile
new file mode 100644
index 0000000..5ae89fa
--- /dev/null
+++ b/samples/upm/led/src/Makefile
@@ -0,0 +1 @@
+obj-y = led.o
\ No newline at end of file
diff --git a/samples/upm/led/src/led.c b/samples/upm/led/src/led.c
new file mode 100644
index 0000000..d669e7d
--- /dev/null
+++ b/samples/upm/led/src/led.c
@@ -0,0 +1,40 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "led.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main(void)
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    printf("Before LED init\n");
+
+    // Arduino GPIO pin 13 (arduino 101 onboard LED)
+    led_context dev = led_init(13);
+    printf("LED init\n");
+    while(1){
+        printf("Turning on\n");
+        if(led_on(dev) != UPM_SUCCESS){
+            printf("problem turning the LED on\n");
+        }
+        upm_delay_ms(750);
+        printf("Turning off\n");
+        if(led_off(dev) != UPM_SUCCESS){
+            printf("problem turning the LED off\n");
+        }
+        upm_delay_ms(750);
+    }
+    led_close(dev);
+    return 0;
+}
diff --git a/samples/upm/light/Makefile b/samples/upm/light/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/light/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/light/prj.conf b/samples/upm/light/prj.conf
new file mode 100644
index 0000000..cbc8c09
--- /dev/null
+++ b/samples/upm/light/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_light=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/light/src/Makefile b/samples/upm/light/src/Makefile
new file mode 100644
index 0000000..40543e4
--- /dev/null
+++ b/samples/upm/light/src/Makefile
@@ -0,0 +1 @@
+obj-y = light.o
\ No newline at end of file
diff --git a/samples/upm/light/src/light.c b/samples/upm/light/src/light.c
new file mode 100644
index 0000000..f8b4641
--- /dev/null
+++ b/samples/upm/light/src/light.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "light.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a light sensor on analog pin A0
+    light_context sensor = light_init(0);
+
+    if (!sensor)
+    {
+        printf("light_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    light_set_aref(sensor, 5.0);
+    light_set_scale(sensor, 1.0);
+    light_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            light_get_aref(sensor),
+            light_get_scale(sensor),
+            light_get_offset(sensor));
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float normalized = 0.0;
+        float raw_volts = 0.0;
+        float lux = 0.0;
+
+        light_get_normalized(sensor, &normalized);
+        light_get_raw_volts(sensor, &raw_volts);
+        light_get_lux(sensor, &lux);
+
+        printf("Normalized output: %0.03f, raw light sensor output: %0.03f v "
+                "light output: %0.03f lux\n", normalized, raw_volts, lux);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    light_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/linefinder/Makefile b/samples/upm/linefinder/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/linefinder/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/linefinder/prj.conf b/samples/upm/linefinder/prj.conf
new file mode 100644
index 0000000..f1a6cba
--- /dev/null
+++ b/samples/upm/linefinder/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_linefinder=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/linefinder/src/Makefile b/samples/upm/linefinder/src/Makefile
new file mode 100644
index 0000000..2311584
--- /dev/null
+++ b/samples/upm/linefinder/src/Makefile
@@ -0,0 +1 @@
+obj-y = linefinder.o
diff --git a/samples/upm/linefinder/src/linefinder.c b/samples/upm/linefinder/src/linefinder.c
new file mode 100644
index 0000000..1a427a4
--- /dev/null
+++ b/samples/upm/linefinder/src/linefinder.c
@@ -0,0 +1,72 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include "linefinder.h"
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+
+int main ()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate a  Line Finder sensor on digital pin D2
+    linefinder_context sensor = linefinder_init(2);
+
+    if (!sensor)
+    {
+        printf("linefinder_init() failed\n");
+        return 1;
+    }
+
+    // check every second for the presence of white or black detection
+    while (shouldRun)
+    {
+        if (linefinder_white_detected(sensor))
+            printf("White detected.\n");
+        else
+            printf("Black detected.\n");
+
+        upm_delay(1);
+    }
+
+    printf("Exiting...\n");
+
+    linefinder_close(sensor);
+
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/lm35/Makefile b/samples/upm/lm35/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/lm35/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/lm35/prj.conf b/samples/upm/lm35/prj.conf
new file mode 100644
index 0000000..5cfeb9e
--- /dev/null
+++ b/samples/upm/lm35/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_ADC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_lm35=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/lm35/src/Makefile b/samples/upm/lm35/src/Makefile
new file mode 100644
index 0000000..dea950c
--- /dev/null
+++ b/samples/upm/lm35/src/Makefile
@@ -0,0 +1 @@
+obj-y = lm35.o
diff --git a/samples/upm/lm35/src/lm35.c b/samples/upm/lm35/src/lm35.c
new file mode 100644
index 0000000..3ab5a59
--- /dev/null
+++ b/samples/upm/lm35/src/lm35.c
@@ -0,0 +1,72 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+#include "lm35.h"
+#include "upm_utilities.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+  signal(SIGINT, sig_handler);
+
+//! [Interesting]
+
+  // Instantiate a LM35 on analog pin A0, with a default analog
+  // reference voltage of 5.0
+  lm35_context sensor = lm35_init(0, 3.3);
+
+  // Every half second, sample the sensor and output the temperature
+
+  while (shouldRun)
+    {
+        float temp;
+        if (lm35_get_temperature(sensor, &temp) != UPM_SUCCESS)
+        {
+            printf("lm35_get_temperature failed\n");
+            return 1;
+        }
+
+        printf("Temperature: %3.2f C\n", temp);
+
+        upm_delay_ms(500);
+    }
+
+//! [Interesting]
+
+  printf("Exiting\n");
+
+  lm35_close(sensor);
+
+  return 0;
+}
diff --git a/samples/upm/loudness/Makefile b/samples/upm/loudness/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/loudness/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/loudness/prj.conf b/samples/upm/loudness/prj.conf
new file mode 100644
index 0000000..f3cfb3f
--- /dev/null
+++ b/samples/upm/loudness/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_loudness=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
diff --git a/samples/upm/loudness/src/Makefile b/samples/upm/loudness/src/Makefile
new file mode 100644
index 0000000..0ca8d26
--- /dev/null
+++ b/samples/upm/loudness/src/Makefile
@@ -0,0 +1 @@
+obj-y = loudness.o
\ No newline at end of file
diff --git a/samples/upm/loudness/src/loudness.c b/samples/upm/loudness/src/loudness.c
new file mode 100644
index 0000000..2ff0e49
--- /dev/null
+++ b/samples/upm/loudness/src/loudness.c
@@ -0,0 +1,34 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "loudness.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    loudness_context dev = loudness_init(14);
+    int val;
+    while(1){
+        if(loudness_get_value(dev, &val) != UPM_SUCCESS){
+            printf("Failed to get any values from the sensor\n");
+        }
+        printf("Loudness Value: %d\n", val);
+        upm_delay(1);
+    }
+    loudness_close(dev);
+
+    return 0;
+}
+
diff --git a/samples/upm/m24lr64e/Makefile b/samples/upm/m24lr64e/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/m24lr64e/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/m24lr64e/prj.conf b/samples/upm/m24lr64e/prj.conf
new file mode 100644
index 0000000..b8039fe
--- /dev/null
+++ b/samples/upm/m24lr64e/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_m24lr64e=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/m24lr64e/src/Makefile b/samples/upm/m24lr64e/src/Makefile
new file mode 100644
index 0000000..1392583
--- /dev/null
+++ b/samples/upm/m24lr64e/src/Makefile
@@ -0,0 +1 @@
+obj-y = m24lr64e.o
\ No newline at end of file
diff --git a/samples/upm/m24lr64e/src/m24lr64e.c b/samples/upm/m24lr64e/src/m24lr64e.c
new file mode 100644
index 0000000..31c8e0d
--- /dev/null
+++ b/samples/upm/m24lr64e/src/m24lr64e.c
@@ -0,0 +1,38 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "m24lr64e.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    m24lr64e_context dev = m24lr64e_init(0, M24LR64E_USER_MODE);
+    int addr = M24LR64E_EEPROM_I2C_LENGTH-1;
+    printf("address being accessed: %d\n", addr);
+    uint8_t byte; 
+    if(m24lr64e_read_byte(dev, addr, &byte) != UPM_SUCCESS)
+        printf("error while reading value\n");
+    printf("value read from the device: %d\n", byte);
+    byte = ~byte;
+    printf("byte to be written: %d\n", byte);
+    if(m24lr64e_write_byte(dev, addr, byte) != UPM_SUCCESS)
+        printf("error while writing byte to the device\n");
+    uint8_t var;
+    if(m24lr64e_read_byte(dev, addr, &var) != UPM_SUCCESS)
+        printf("error while reading value back\n");
+    printf("new value at %d: %d\n", addr, var);
+    m24lr64e_close(dev);
+    printf("all done!!\n");
+
+    return 0;
+}
diff --git a/samples/upm/mb704x/Makefile b/samples/upm/mb704x/Makefile
new file mode 100644
index 0000000..17cffed
--- /dev/null
+++ b/samples/upm/mb704x/Makefile
@@ -0,0 +1,6 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+LDFLAGS += -u _printf_float
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/mb704x/prj.conf b/samples/upm/mb704x/prj.conf
new file mode 100644
index 0000000..66a55b7
--- /dev/null
+++ b/samples/upm/mb704x/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_mb704x=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/mb704x/src/Makefile b/samples/upm/mb704x/src/Makefile
new file mode 100644
index 0000000..a509180
--- /dev/null
+++ b/samples/upm/mb704x/src/Makefile
@@ -0,0 +1 @@
+obj-y = mb704x.o
diff --git a/samples/upm/mb704x/src/mb704x.c b/samples/upm/mb704x/src/mb704x.c
new file mode 100644
index 0000000..6a00752
--- /dev/null
+++ b/samples/upm/mb704x/src/mb704x.c
@@ -0,0 +1,77 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <mb704x.h>
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+
+    // Instantiate a MB704X sensor on i2c bus 0, address 112.
+    mb704x_context sensor = mb704x_init(0, 112);
+
+    if (!sensor)
+    {
+        printf("mb704x_init() failed.\n");
+        return 1;
+    }
+
+    while (shouldRun)
+    {
+        // this will take about 1 second to complete
+        int range = mb704x_get_range(sensor);
+        if (range < 0)
+        {
+            printf("Error getting range.\n");
+        }
+        else
+        {
+            printf("Range: %d cm\n", range);
+        }
+
+        upm_delay_ms(500);
+    }
+
+    printf("Exiting\n");
+
+    mb704x_close(sensor);
+
+//! [Interesting]
+
+    return 0;
+}
diff --git a/samples/upm/md-stepper/Makefile b/samples/upm/md-stepper/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/md-stepper/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/md-stepper/prj.conf b/samples/upm/md-stepper/prj.conf
new file mode 100644
index 0000000..69e9f89
--- /dev/null
+++ b/samples/upm/md-stepper/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_md=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/md-stepper/src/Makefile b/samples/upm/md-stepper/src/Makefile
new file mode 100644
index 0000000..e0b7f58
--- /dev/null
+++ b/samples/upm/md-stepper/src/Makefile
@@ -0,0 +1 @@
+obj-y = md-stepper.o
diff --git a/samples/upm/md-stepper/src/md-stepper.c b/samples/upm/md-stepper/src/md-stepper.c
new file mode 100644
index 0000000..7f832c8
--- /dev/null
+++ b/samples/upm/md-stepper/src/md-stepper.c
@@ -0,0 +1,69 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+
+#include <md.h>
+#include <upm_utilities.h>
+
+int main(int argc, char **argv)
+{
+  //! [Interesting]
+  // Instantiate an I2C Motor Driver on I2C bus 0
+
+  md_context stepper = md_init(MD_I2C_BUS, MD_DEFAULT_I2C_ADDR);
+
+  if (!stepper)
+  {
+      printf("md_init() failed\n");
+      return 1;
+  }
+
+  // This example demonstrates using the MD to drive a stepper motor
+
+  // configure it, for this example, we'll assume 200 steps per rev
+  md_config_stepper(stepper, 200, MD_STEP_MODE1);
+
+  // set for half a rotation
+  md_set_stepper_steps(stepper, 100);
+
+  // let it go - clockwise rotation, 10 RPM speed
+  md_enable_stepper(stepper, MD_STEP_DIR_CW, 10);
+
+  upm_delay(3);
+
+  // Now do it backwards...
+  md_set_stepper_steps(stepper, 100);
+  md_enable_stepper(stepper, MD_STEP_DIR_CCW, 10);
+
+  // now disable
+  md_disable_stepper(stepper);
+
+  printf("Exiting...\n");
+
+  md_close(stepper);
+  //! [Interesting]
+  return 0;
+}
diff --git a/samples/upm/md/Makefile b/samples/upm/md/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/md/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/md/prj.conf b/samples/upm/md/prj.conf
new file mode 100644
index 0000000..69e9f89
--- /dev/null
+++ b/samples/upm/md/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_md=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/md/src/Makefile b/samples/upm/md/src/Makefile
new file mode 100644
index 0000000..9261507
--- /dev/null
+++ b/samples/upm/md/src/Makefile
@@ -0,0 +1 @@
+obj-y = md.o
diff --git a/samples/upm/md/src/md.c b/samples/upm/md/src/md.c
new file mode 100644
index 0000000..8839324
--- /dev/null
+++ b/samples/upm/md/src/md.c
@@ -0,0 +1,64 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+
+#include <md.h>
+#include <upm_utilities.h>
+
+
+int main(int argc, char **argv)
+{
+//! [Interesting]
+  // Instantiate an I2C Motor Driver on I2C bus 0
+
+  md_context motors = md_init(MD_I2C_BUS, MD_DEFAULT_I2C_ADDR);
+
+  if (!motors)
+  {
+      printf("md_init() failed\n");
+      return 1;
+  }
+
+  // set direction to CW and set speed to 50%
+  printf("Spin M1 and M2 at half speed for 3 seconds\n");
+  md_set_motor_directions(motors, MD_DIR_CW, MD_DIR_CW);
+  md_set_motor_speeds(motors, 127, 127);
+
+  upm_delay(3);
+  // counter clockwise
+  printf("Reversing M1 and M2 for 3 seconds\n");
+  md_set_motor_directions(motors, MD_DIR_CCW, MD_DIR_CCW);
+  upm_delay(3);
+
+  printf("Stopping motors\n");
+  md_set_motor_speeds(motors, 0, 0);
+
+  printf("Exiting...\n");
+
+  md_close(motors);
+//! [Interesting]
+  return 0;
+}
diff --git a/samples/upm/mic/Makefile b/samples/upm/mic/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/mic/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/mic/prj.conf b/samples/upm/mic/prj.conf
new file mode 100644
index 0000000..3bfe110
--- /dev/null
+++ b/samples/upm/mic/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_mic=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
+CONFIG_STDOUT_CONSOLE=y
diff --git a/samples/upm/mic/src/Makefile b/samples/upm/mic/src/Makefile
new file mode 100644
index 0000000..cceb761
--- /dev/null
+++ b/samples/upm/mic/src/Makefile
@@ -0,0 +1 @@
+obj-y = mic.o
diff --git a/samples/upm/mic/src/mic.c b/samples/upm/mic/src/mic.c
new file mode 100644
index 0000000..14ace6b
--- /dev/null
+++ b/samples/upm/mic/src/mic.c
@@ -0,0 +1,56 @@
+/*
+ * Author:Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "mic.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+//! [Interesting]
+    // Instantiate a Grove Mic Sensor, using analog pins A0
+    mic_context dev = mic_init(0);
+
+    float val;
+    while(1) {
+        mic_get_value(dev, &val);
+        printf("mic value: %f\n", val);
+        upm_delay(1);
+    }
+
+    mic_close(dev);
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/mma7361/Makefile b/samples/upm/mma7361/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/mma7361/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/mma7361/prj.conf b/samples/upm/mma7361/prj.conf
new file mode 100644
index 0000000..26aa881
--- /dev/null
+++ b/samples/upm/mma7361/prj.conf
@@ -0,0 +1,12 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_mma7361=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI_SS=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
diff --git a/samples/upm/mma7361/src/Makefile b/samples/upm/mma7361/src/Makefile
new file mode 100644
index 0000000..2b2462e
--- /dev/null
+++ b/samples/upm/mma7361/src/Makefile
@@ -0,0 +1 @@
+obj-y = mma7361.o
\ No newline at end of file
diff --git a/samples/upm/mma7361/src/mma7361.c b/samples/upm/mma7361/src/mma7361.c
new file mode 100644
index 0000000..b4067f3
--- /dev/null
+++ b/samples/upm/mma7361/src/mma7361.c
@@ -0,0 +1,93 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "mma7361.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a MMA7361 sensor on analog pins A0 (X), A1 (Y) A2
+    // (Z), selftest pin on D2, sleep pin on D3 nd an analog reference
+    // value of 5.0.  The freefall pin and the range pin are unused
+    // (-1).
+    mma7361_context sensor = mma7361_init(0, 1, 2, 2, 3, -1, -1, 5.0);
+
+    if (!sensor)
+    {
+        printf("mma7361_init() failed.\n");
+        return(1);
+    }
+
+    // 1.5g (true = 6g)
+    mma7361_set_range(sensor, false);
+
+    // Every 10th of a second, update and print values
+
+    while (shouldRun)
+    {
+        mma7361_update(sensor);
+
+        float x, y, z;
+
+        mma7361_get_acceleration(sensor, &x, &y, &z);
+        printf("Acceleration x = %f y = %f z = %f\n",
+                x, y, z);
+
+        mma7361_get_volts(sensor, &x, &y, &z);
+        printf("Volts x = %f y = %f z = %f\n\n",
+                x, y, z);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting...\n");
+
+    mma7361_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/mma7660/Makefile b/samples/upm/mma7660/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/mma7660/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/mma7660/prj.conf b/samples/upm/mma7660/prj.conf
new file mode 100644
index 0000000..33a132c
--- /dev/null
+++ b/samples/upm/mma7660/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_UPM=y
+CONFIG_UPM_mma7660=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/mma7660/src/Makefile b/samples/upm/mma7660/src/Makefile
new file mode 100644
index 0000000..16dc29e
--- /dev/null
+++ b/samples/upm/mma7660/src/Makefile
@@ -0,0 +1 @@
+obj-y = mma7660.o
diff --git a/samples/upm/mma7660/src/mma7660.c b/samples/upm/mma7660/src/mma7660.c
new file mode 100644
index 0000000..c74484d
--- /dev/null
+++ b/samples/upm/mma7660/src/mma7660.c
@@ -0,0 +1,83 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include "upm_utilities.h"
+#include "mma7660.h"
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main(int argc, char **argv)
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate an MMA7660 on I2C bus 0
+
+    mma7660_context accel = mma7660_init(MMA7660_DEFAULT_I2C_BUS,
+                                         MMA7660_DEFAULT_I2C_ADDR);
+
+    if (!accel)
+    {
+        printf("mma7660_init() failed\n");
+        return 1;
+    }
+
+    // place device in standby mode so we can write registers
+    mma7660_set_mode_standby(accel);
+
+    // enable 64 samples per second
+    mma7660_set_sample_rate(accel, MMA7660_AUTOSLEEP_64);
+
+    // place device into active mode
+    mma7660_set_mode_active(accel);
+
+    while (shouldRun)
+    {
+        float ax, ay, az;
+
+        mma7660_get_acceleration(accel, &ax, &ay, &az);
+        printf("Acceleration: x = %f y = %f z = %f\n\n",
+               ax, ay, az);
+
+        upm_delay_ms(500);
+    }
+
+    printf("Exiting...\n");
+
+    mma7660_close(accel);
+
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/moisture/Makefile b/samples/upm/moisture/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/moisture/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/moisture/prj.conf b/samples/upm/moisture/prj.conf
new file mode 100644
index 0000000..d5b838e
--- /dev/null
+++ b/samples/upm/moisture/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_moisture=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
diff --git a/samples/upm/moisture/src/Makefile b/samples/upm/moisture/src/Makefile
new file mode 100644
index 0000000..a63417e
--- /dev/null
+++ b/samples/upm/moisture/src/Makefile
@@ -0,0 +1 @@
+obj-y = moisture.o
\ No newline at end of file
diff --git a/samples/upm/moisture/src/moisture.c b/samples/upm/moisture/src/moisture.c
new file mode 100644
index 0000000..5ee4dbf
--- /dev/null
+++ b/samples/upm/moisture/src/moisture.c
@@ -0,0 +1,33 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "moisture.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    moisture_context dev = moisture_init(14);
+    int val;
+    while(1){
+        if(moisture_get_moisture(dev, &val) != UPM_SUCCESS){
+            printf("Failed to get any values from the sensor\n");
+        }
+        printf("Moisture Value: %d\n", val);
+        upm_delay(1);
+    }
+    moisture_close(dev);
+
+    return 0;
+}
diff --git a/samples/upm/mpr121/Makefile b/samples/upm/mpr121/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/mpr121/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/mpr121/prj.conf b/samples/upm/mpr121/prj.conf
new file mode 100644
index 0000000..f3e23a5
--- /dev/null
+++ b/samples/upm/mpr121/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA_I2C=y
+CONFIG_I2C=y
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_mpr121=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/mpr121/src/Makefile b/samples/upm/mpr121/src/Makefile
new file mode 100644
index 0000000..e499c04
--- /dev/null
+++ b/samples/upm/mpr121/src/Makefile
@@ -0,0 +1 @@
+obj-y = mpr121.o
\ No newline at end of file
diff --git a/samples/upm/mpr121/src/mpr121.c b/samples/upm/mpr121/src/mpr121.c
new file mode 100644
index 0000000..b69fa96
--- /dev/null
+++ b/samples/upm/mpr121/src/mpr121.c
@@ -0,0 +1,39 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "mpr121.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    mpr121_context dev = mpr121_init(MPR121_I2C_BUS, MPR121_DEFAULT_I2C_ADDR);
+
+    if(mpr121_config_an3944(dev) != UPM_SUCCESS){
+        printf("unable to configure device\n");
+    }
+    uint32_t states;
+    while(1){
+        if(mpr121_read_buttons(dev, &states, 0) != UPM_SUCCESS){
+            printf("Error while reading button values\n");
+        }
+        printf("retrieved button states: %d\n", states);
+        upm_delay(1);
+    }
+
+    mpr121_close(dev);
+    printf("all done!!\n");
+
+    return 0;
+}
diff --git a/samples/upm/mq303a/Makefile b/samples/upm/mq303a/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/mq303a/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/mq303a/prj.conf b/samples/upm/mq303a/prj.conf
new file mode 100644
index 0000000..640095e
--- /dev/null
+++ b/samples/upm/mq303a/prj.conf
@@ -0,0 +1,13 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_mq303a=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI_SS=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+
diff --git a/samples/upm/mq303a/src/Makefile b/samples/upm/mq303a/src/Makefile
new file mode 100644
index 0000000..87bf4f7
--- /dev/null
+++ b/samples/upm/mq303a/src/Makefile
@@ -0,0 +1 @@
+obj-y = mq303a.o
\ No newline at end of file
diff --git a/samples/upm/mq303a/src/mq303a.c b/samples/upm/mq303a/src/mq303a.c
new file mode 100644
index 0000000..dc447c7
--- /dev/null
+++ b/samples/upm/mq303a/src/mq303a.c
@@ -0,0 +1,34 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "mq303a.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main() {
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+
+    /* --------- MQ303A EXAMPLE -------- */
+    mq303a_context dev = mq303a_init(0, 15);
+    printf("init done for mq303a\n");
+    int value;
+    mq303a_heater_enable(dev, true);
+    upm_delay(12);
+    while(1){
+        mq303a_get_value(dev, &value);
+        printf("returned value: %d\n", value);
+        upm_delay(1);
+    }
+
+    return 0;
+}
diff --git a/samples/upm/ms5803/Makefile b/samples/upm/ms5803/Makefile
new file mode 100644
index 0000000..17cffed
--- /dev/null
+++ b/samples/upm/ms5803/Makefile
@@ -0,0 +1,6 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+LDFLAGS += -u _printf_float
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/ms5803/prj.conf b/samples/upm/ms5803/prj.conf
new file mode 100644
index 0000000..5b49678
--- /dev/null
+++ b/samples/upm/ms5803/prj.conf
@@ -0,0 +1,10 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_I2C=y
+CONFIG_MRAA_SPI=y
+CONFIG_I2C=y
+CONFIG_SPI=y
+CONFIG_UPM=y
+CONFIG_UPM_ms5803=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/ms5803/src/Makefile b/samples/upm/ms5803/src/Makefile
new file mode 100644
index 0000000..a23d3b0
--- /dev/null
+++ b/samples/upm/ms5803/src/Makefile
@@ -0,0 +1 @@
+obj-y = ms5803.o
diff --git a/samples/upm/ms5803/src/ms5803.c b/samples/upm/ms5803/src/ms5803.c
new file mode 100644
index 0000000..1fdf3ac
--- /dev/null
+++ b/samples/upm/ms5803/src/ms5803.c
@@ -0,0 +1,80 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include "ms5803.h"
+#include "upm_utilities.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+  signal(SIGINT, sig_handler);
+
+//! [Interesting]
+
+  // Instantiate a MS5803 on analog I2C bus 0, at the default address
+//  ms5803_context sensor = ms5803_init(0, MS5803_DEFAULT_I2C_ADDR, -1);
+  ms5803_context sensor = ms5803_init(0, -1, 2);
+
+  if (!sensor)
+  {
+      printf("ms5803_init() failed\n");
+      return 1;
+  }
+
+  // Every second, sample the sensor and output the pressure and
+  // temperature
+
+  while (shouldRun)
+    {
+        if (ms5803_update(sensor))
+        {
+            printf("ms5803_update() failed\n");
+        }
+
+        printf("Temperature: %f C, Pressure = %f mbar\n",
+               ms5803_get_temperature(sensor),
+               ms5803_get_pressure(sensor));
+
+        upm_delay(1);
+    }
+
+//! [Interesting]
+
+  printf("Exiting\n");
+
+  ms5803_close(sensor);
+
+  return 0;
+}
diff --git a/samples/upm/my9221/Makefile b/samples/upm/my9221/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/my9221/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/my9221/prj.conf b/samples/upm/my9221/prj.conf
new file mode 100644
index 0000000..ab6afb0
--- /dev/null
+++ b/samples/upm/my9221/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_my9221=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/my9221/src/Makefile b/samples/upm/my9221/src/Makefile
new file mode 100644
index 0000000..58f7f92
--- /dev/null
+++ b/samples/upm/my9221/src/Makefile
@@ -0,0 +1 @@
+obj-y = my9221.o
diff --git a/samples/upm/my9221/src/my9221.c b/samples/upm/my9221/src/my9221.c
new file mode 100644
index 0000000..6f37667
--- /dev/null
+++ b/samples/upm/my9221/src/my9221.c
@@ -0,0 +1,89 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <my9221.h>
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+
+int main ()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+
+    // Instantiate a GroveLEDBar, we use D8 for the data, and D9 for the
+    // clock.  We only use a single instance.
+    my9221_context leds = my9221_init(8, 7, 1);
+
+    if (!leds)
+    {
+        printf("my9221_init() failed\n");
+        return 1;
+    }
+
+    while (shouldRun)
+    {
+        // count up
+        printf("Counting up: ");
+        for (int i=0; i<my9221_get_max_leds(leds); i++)
+        {
+            printf("%d ", i);
+            my9221_clear_all(leds);
+            my9221_set_led(leds, i, true);
+            upm_delay_ms(100);
+        }
+        printf("\n");
+        upm_delay_ms(100);
+
+        // count down
+        printf("Counting down: ");
+        for (int i=my9221_get_max_leds(leds) - 1; i>=0; i--)
+        {
+            printf("%d ", i);
+            my9221_clear_all(leds);
+            my9221_set_led(leds, i, true);
+            upm_delay_ms(100);
+        }
+        printf("\n");
+        upm_delay_ms(100);
+    }
+
+    printf("Exiting...\n");
+
+    my9221_close(leds);
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/nmea_gps/Makefile b/samples/upm/nmea_gps/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/nmea_gps/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/nmea_gps/prj.conf b/samples/upm/nmea_gps/prj.conf
new file mode 100644
index 0000000..9b2ff65
--- /dev/null
+++ b/samples/upm/nmea_gps/prj.conf
@@ -0,0 +1,11 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_MRAA_I2C=y
+CONFIG_MRAA_UART=y
+CONFIG_UPM=y
+CONFIG_UPM_nmea_gps=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/nmea_gps/src/Makefile b/samples/upm/nmea_gps/src/Makefile
new file mode 100644
index 0000000..69c0e40
--- /dev/null
+++ b/samples/upm/nmea_gps/src/Makefile
@@ -0,0 +1 @@
+obj-y = nmea_gps.o
\ No newline at end of file
diff --git a/samples/upm/nmea_gps/src/nmea_gps.c b/samples/upm/nmea_gps/src/nmea_gps.c
new file mode 100644
index 0000000..f8aa068
--- /dev/null
+++ b/samples/upm/nmea_gps/src/nmea_gps.c
@@ -0,0 +1,88 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "nmea_gps.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+const size_t bufferLength = 256;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a NMEA_GPS sensor on uart 0 at 9600 baud with enable
+    // pin on D3.  If you do not need an enable pin, you can specify -1.
+    nmea_gps_context sensor = nmea_gps_init(0, 9600, 3);
+
+    if (!sensor)
+    {
+        printf("nmea_gps_init() failed.\n");
+        return 1;
+    }
+
+    char buffer[bufferLength];
+    int rv = 0;
+
+    // loop, dumping NMEA data out as fast as it comes in
+    while (shouldRun && nmea_gps_data_available(sensor, 5000))
+    {
+        if ((rv = nmea_gps_read(sensor, buffer, bufferLength)) >= 0)
+        {
+            int i;
+            for (i=0; i<rv; i++)
+                printf("%c", buffer[i]);
+        }
+    }
+
+    if (shouldRun)
+        printf("Timed out\n");
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    nmea_gps_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/o2/Makefile b/samples/upm/o2/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/o2/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/o2/prj.conf b/samples/upm/o2/prj.conf
new file mode 100644
index 0000000..7501ee2
--- /dev/null
+++ b/samples/upm/o2/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_o2=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/o2/src/Makefile b/samples/upm/o2/src/Makefile
new file mode 100644
index 0000000..7bda1df
--- /dev/null
+++ b/samples/upm/o2/src/Makefile
@@ -0,0 +1 @@
+obj-y = o2.o
\ No newline at end of file
diff --git a/samples/upm/o2/src/o2.c b/samples/upm/o2/src/o2.c
new file mode 100644
index 0000000..a102ff8
--- /dev/null
+++ b/samples/upm/o2/src/o2.c
@@ -0,0 +1,83 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "o2.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a o2 sensor on analog pin A0
+    o2_context sensor = o2_init(0);
+
+    if (!sensor)
+    {
+        printf("o2_init() failed.\n");
+        return -1;
+    }
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float raw_volts = 0.0;
+        float o2_percent = 0.0;
+
+        o2_get_raw_volts(sensor, &raw_volts);
+        o2_get_value(sensor, &o2_percent);
+
+        printf("O2 raw volts: %0.03f v, o2: %0.03f %%\n",
+                raw_volts, o2_percent);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    o2_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/otp538u/Makefile b/samples/upm/otp538u/Makefile
new file mode 100644
index 0000000..17cffed
--- /dev/null
+++ b/samples/upm/otp538u/Makefile
@@ -0,0 +1,6 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+LDFLAGS += -u _printf_float
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/otp538u/prj.conf b/samples/upm/otp538u/prj.conf
new file mode 100644
index 0000000..aef3d97
--- /dev/null
+++ b/samples/upm/otp538u/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_ADC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_MRAA=y
+CONFIG_MRAA_AIO=y
+CONFIG_UPM=y
+CONFIG_UPM_otp538u=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
diff --git a/samples/upm/otp538u/src/Makefile b/samples/upm/otp538u/src/Makefile
new file mode 100644
index 0000000..750d52a
--- /dev/null
+++ b/samples/upm/otp538u/src/Makefile
@@ -0,0 +1 @@
+obj-y = otp538u.o
diff --git a/samples/upm/otp538u/src/otp538u.c b/samples/upm/otp538u/src/otp538u.c
new file mode 100644
index 0000000..a0444bd
--- /dev/null
+++ b/samples/upm/otp538u/src/otp538u.c
@@ -0,0 +1,81 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <otp538u.h>
+
+
+bool shouldRun = true;
+
+// analog voltage, usually 3.3 or 5.0
+#define OTP538U_AREF   5.0
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+
+    // Instantiate a OTP538U on analog pins A0 and A1
+    // A0 is used for the Ambient Temperature and A1 is used for the
+    // Object temperature.
+    otp538u_context temps = otp538u_init(0, 1, 3.3);
+
+    // enable debugging if you would like
+    // otp538u_set_debug(temps, true);
+
+    // Output ambient and object temperatures
+    while (shouldRun)
+    {
+        float ambient = 0, object = 0;
+
+        if (otp538u_get_ambient_temperature(temps, &ambient))
+            printf("otp538u_get_ambient_temperature() failed\n");
+        else if (otp538u_get_object_temperature(temps, &object))
+            printf("otp538u_get_object_temperature() failed\n");
+        else
+            printf("Ambient temp: %f C, Object temp: %f C\n",
+                   ambient, object);
+
+        printf("\n");
+        upm_delay(1);
+    }
+
+    printf("Exiting\n");
+
+    otp538u_close(temps);
+
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/ppd42ns/Makefile b/samples/upm/ppd42ns/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/ppd42ns/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/ppd42ns/prj.conf b/samples/upm/ppd42ns/prj.conf
new file mode 100644
index 0000000..f7190d5
--- /dev/null
+++ b/samples/upm/ppd42ns/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_ppd42ns=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/ppd42ns/src/Makefile b/samples/upm/ppd42ns/src/Makefile
new file mode 100644
index 0000000..8332b48
--- /dev/null
+++ b/samples/upm/ppd42ns/src/Makefile
@@ -0,0 +1 @@
+obj-y = ppd42ns.o
diff --git a/samples/upm/ppd42ns/src/ppd42ns.c b/samples/upm/ppd42ns/src/ppd42ns.c
new file mode 100644
index 0000000..9cce7dc
--- /dev/null
+++ b/samples/upm/ppd42ns/src/ppd42ns.c
@@ -0,0 +1,67 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <ppd42ns.h>
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate a dust sensor on GPIO pin D8
+    ppd42ns_context dust = ppd42ns_init(8);
+
+    ppd42ns_dust_data data;
+    printf("This program will give readings every 30 seconds until "
+           "you stop it\n");
+
+    while (shouldRun)
+    {
+        data = ppd42ns_get_data(dust);
+        printf("Low pulse occupancy: %d\n", data.lowPulseOccupancy);
+        printf("Ratio: %f\n", data.ratio);
+        printf("Concentration: %f\n\n", data.concentration);
+    }
+
+    printf("Exiting...\n");
+
+    ppd42ns_close(dust);
+
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/relay/Makefile b/samples/upm/relay/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/relay/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/relay/prj.conf b/samples/upm/relay/prj.conf
new file mode 100644
index 0000000..74c33df
--- /dev/null
+++ b/samples/upm/relay/prj.conf
@@ -0,0 +1,11 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_UPM=y
+CONFIG_UPM_relay=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+
diff --git a/samples/upm/relay/src/Makefile b/samples/upm/relay/src/Makefile
new file mode 100644
index 0000000..4091fd7
--- /dev/null
+++ b/samples/upm/relay/src/Makefile
@@ -0,0 +1 @@
+obj-y = relay.o
diff --git a/samples/upm/relay/src/relay.c b/samples/upm/relay/src/relay.c
new file mode 100644
index 0000000..ce5a9b6
--- /dev/null
+++ b/samples/upm/relay/src/relay.c
@@ -0,0 +1,68 @@
+/*
+ * Author:Sisinty Sasmita Patra <sisinty.s.patra@intel.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "relay.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+//! [Interesting]
+    relay_context dev = relay_init(2);
+
+    while(1) {
+        printf("Turning on\n");
+
+        if(relay_on(dev) != UPM_SUCCESS){
+            printf("problem turning relay on\n");
+        }
+        printf("relay is turned on\n");
+
+        upm_delay(1);
+
+        printf("Turning off\n");
+
+        if(relay_off(dev) != UPM_SUCCESS){
+            printf("problem turning relay off\n");
+        }
+        printf("relay is turned off\n");
+
+        upm_delay(1);
+    }
+
+    relay_close(dev);
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/rotary/Makefile b/samples/upm/rotary/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/rotary/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/rotary/prj.conf b/samples/upm/rotary/prj.conf
new file mode 100644
index 0000000..bad48fb
--- /dev/null
+++ b/samples/upm/rotary/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_rotary=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
+CONFIG_STDOUT_CONSOLE=y
diff --git a/samples/upm/rotary/src/Makefile b/samples/upm/rotary/src/Makefile
new file mode 100644
index 0000000..91e0308
--- /dev/null
+++ b/samples/upm/rotary/src/Makefile
@@ -0,0 +1 @@
+obj-y = rotary.o
diff --git a/samples/upm/rotary/src/rotary.c b/samples/upm/rotary/src/rotary.c
new file mode 100644
index 0000000..2f2d172
--- /dev/null
+++ b/samples/upm/rotary/src/rotary.c
@@ -0,0 +1,56 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "rotary.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+//! [Interesting]
+    // Instantiate a Grove Rotary Angle Sensor, using analog pins A0
+    rotary_context dev = rotary_init(0, 5.0);
+
+    float angle;
+    while(1) {
+        rotary_get_value_voltage(dev, &angle);
+        printf("rotary voltage value detected: %f\n", angle);
+        upm_delay(1);
+    }
+
+    rotary_close(dev);
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/rotaryencoder/Makefile b/samples/upm/rotaryencoder/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/rotaryencoder/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/rotaryencoder/prj.conf b/samples/upm/rotaryencoder/prj.conf
new file mode 100644
index 0000000..daa9c02
--- /dev/null
+++ b/samples/upm/rotaryencoder/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_rotaryencoder=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/rotaryencoder/src/Makefile b/samples/upm/rotaryencoder/src/Makefile
new file mode 100644
index 0000000..4e95ff7
--- /dev/null
+++ b/samples/upm/rotaryencoder/src/Makefile
@@ -0,0 +1 @@
+obj-y = rotaryencoder.o
diff --git a/samples/upm/rotaryencoder/src/rotaryencoder.c b/samples/upm/rotaryencoder/src/rotaryencoder.c
new file mode 100644
index 0000000..3ad9e9c
--- /dev/null
+++ b/samples/upm/rotaryencoder/src/rotaryencoder.c
@@ -0,0 +1,70 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <signal.h>
+
+#include "rotaryencoder.h"
+#include "upm_utilities.h"
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate a Grove Rotary Encoder, using signal pins D2 and D3
+//    rotaryencoder_context sensor = rotaryencoder_init(2, 3);
+    rotaryencoder_context sensor = rotaryencoder_init(2, 4);
+
+    if (!sensor)
+    {
+        printf("rotaryencoder_init() failed.\n");
+        return 1;
+    }
+
+    while (shouldRun)
+    {
+        printf("Position: %d\n", rotaryencoder_get_position(sensor));
+
+        upm_delay_ms(100);
+    }
+
+
+    printf("Exiting...\n");
+
+    rotaryencoder_close(sensor);
+
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/rpr220-intr/Makefile b/samples/upm/rpr220-intr/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/rpr220-intr/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/rpr220-intr/prj.conf b/samples/upm/rpr220-intr/prj.conf
new file mode 100644
index 0000000..61ba11c
--- /dev/null
+++ b/samples/upm/rpr220-intr/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_rpr220=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/rpr220-intr/src/Makefile b/samples/upm/rpr220-intr/src/Makefile
new file mode 100644
index 0000000..8d15823
--- /dev/null
+++ b/samples/upm/rpr220-intr/src/Makefile
@@ -0,0 +1 @@
+obj-y = rpr220-intr.o
diff --git a/samples/upm/rpr220-intr/src/rpr220-intr.c b/samples/upm/rpr220-intr/src/rpr220-intr.c
new file mode 100644
index 0000000..6337ab4
--- /dev/null
+++ b/samples/upm/rpr220-intr/src/rpr220-intr.c
@@ -0,0 +1,84 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <rpr220.h>
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+volatile unsigned int counter = 0;
+
+// Our interrupt handler
+void rpr220_isr(void *arg)
+{
+    counter++;
+}
+
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // This example uses an interrupt handler to increment a counter
+
+    // Instantiate an RPR220 digital pin D2
+    // This was tested on the Grove IR Reflective Sensor
+    rpr220_context sensor = rpr220_init(2);
+
+    if (!sensor)
+    {
+        printf("rpr220_init() failed\n");
+        return 1;
+    }
+
+    // Here, we setup our Interupt Service Routine (ISR) to count
+    // 'black' pulses detected.  We do not pass an argument to the
+    // interrupt handler (NULL).
+
+    rpr220_install_isr(sensor, rpr220_isr, NULL);
+
+    while (shouldRun)
+    {
+        printf("Counter: %d\n", counter);
+
+        upm_delay(1);
+    }
+
+    printf("Exiting...\n");
+
+    rpr220_close(sensor);
+//! [Interesting]
+
+    return 0;
+}
diff --git a/samples/upm/rpr220/Makefile b/samples/upm/rpr220/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/rpr220/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/rpr220/prj.conf b/samples/upm/rpr220/prj.conf
new file mode 100644
index 0000000..61ba11c
--- /dev/null
+++ b/samples/upm/rpr220/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_rpr220=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/rpr220/src/Makefile b/samples/upm/rpr220/src/Makefile
new file mode 100644
index 0000000..28d97c7
--- /dev/null
+++ b/samples/upm/rpr220/src/Makefile
@@ -0,0 +1 @@
+obj-y = rpr220.o
diff --git a/samples/upm/rpr220/src/rpr220.c b/samples/upm/rpr220/src/rpr220.c
new file mode 100644
index 0000000..923aa8d
--- /dev/null
+++ b/samples/upm/rpr220/src/rpr220.c
@@ -0,0 +1,72 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2015 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include <upm_utilities.h>
+#include <rpr220.h>
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+
+int main()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // This example uses a simple method to determine current status
+
+    // Instantiate an RPR220 digital pin D2
+    // This was tested on the Grove IR Reflective Sensor
+    rpr220_context sensor = rpr220_init(2);
+
+    if (!sensor)
+    {
+        printf("rpr220_init() failed\n");
+        return 1;
+    }
+
+    while (shouldRun)
+    {
+        if (rpr220_black_detected(sensor))
+            printf("Black detected\n");
+        else
+            printf("Black NOT detected\n");
+
+        upm_delay_ms(100);           // 100ms
+    }
+
+    printf("Exiting...\n");
+
+    rpr220_close(sensor);
+//! [Interesting]
+    return 0;
+}
diff --git a/samples/upm/servo/Makefile b/samples/upm/servo/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/servo/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/servo/prj.conf b/samples/upm/servo/prj.conf
new file mode 100644
index 0000000..dc74998
--- /dev/null
+++ b/samples/upm/servo/prj.conf
@@ -0,0 +1,11 @@
+CONFIG_MRAA=y
+CONFIG_MRAA_PWM=y
+CONFIG_UPM=y
+CONFIG_UPM_servo=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_PWM=y
+CONFIG_PWM_QMSI=y
+CONFIG_PWM_QMSI_DEV_NAME="PWM_0"
+CONFIG_PWM_QMSI_NUM_PORTS=4
+CONFIG_STDOUT_CONSOLE=y
diff --git a/samples/upm/servo/src/Makefile b/samples/upm/servo/src/Makefile
new file mode 100644
index 0000000..e07e58c
--- /dev/null
+++ b/samples/upm/servo/src/Makefile
@@ -0,0 +1 @@
+obj-y = servo.o
\ No newline at end of file
diff --git a/samples/upm/servo/src/servo.c b/samples/upm/servo/src/servo.c
new file mode 100644
index 0000000..057d736
--- /dev/null
+++ b/samples/upm/servo/src/servo.c
@@ -0,0 +1,44 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "es08a.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    es08a_context dev = es08a_init(3, ES08A_MIN_PULSE_WIDTH, ES08A_MAX_PULSE_WIDTH);
+    if(dev == NULL){
+        printf("unable to initialize the servo context\n");
+    }
+
+    if(es08a_set_angle(dev, 90) != UPM_SUCCESS){
+        printf("unable to set angle to 90 degrees\n");
+    }
+    upm_delay(1);
+
+    if(es08a_set_angle(dev, 180) != UPM_SUCCESS){
+        printf("unable to set angle to 180 degrees\n");
+    }
+    upm_delay(1);
+
+    if(es08a_set_angle(dev, 90) != UPM_SUCCESS){
+        printf("unable to set angle to 90 degrees\n");
+    }
+    upm_delay(1);
+
+    es08a_halt(dev);
+
+    return 0;
+}
diff --git a/samples/upm/sht1x/Makefile b/samples/upm/sht1x/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/sht1x/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/sht1x/prj.conf b/samples/upm/sht1x/prj.conf
new file mode 100644
index 0000000..bfeb16b
--- /dev/null
+++ b/samples/upm/sht1x/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_sht1x=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/sht1x/src/Makefile b/samples/upm/sht1x/src/Makefile
new file mode 100644
index 0000000..0c54af0
--- /dev/null
+++ b/samples/upm/sht1x/src/Makefile
@@ -0,0 +1 @@
+obj-y = sht1x.o
\ No newline at end of file
diff --git a/samples/upm/sht1x/src/nmea_gps_i2c.c b/samples/upm/sht1x/src/nmea_gps_i2c.c
new file mode 100644
index 0000000..4a8e102
--- /dev/null
+++ b/samples/upm/sht1x/src/nmea_gps_i2c.c
@@ -0,0 +1,90 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "nmea_gps.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+const size_t bufferLength = 128;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a NMEA_GPS UBLOX based i2c sensor on i2c bus 0 at
+    // address 0x42
+    nmea_gps_context sensor = nmea_gps_init_ublox_i2c(0, 0x42);
+
+    if (!sensor)
+    {
+        printf("nmea_gps_init_ublox_i2c() failed.\n");
+        return 1;
+    }
+
+    char buffer[bufferLength];
+    int rv = 0;
+
+    // loop, dumping NMEA data out as fast as it comes in
+    while (shouldRun)
+    {
+        if (!nmea_gps_data_available(sensor, 0))
+            upm_delay_ms(500);
+        else
+        {
+            if ((rv = nmea_gps_read(sensor, buffer, bufferLength)) >= 0)
+            {
+                int i;
+                for (i=0; i<rv; i++)
+                    printf("%c", buffer[i]);
+            }
+        }
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    nmea_gps_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/sht1x/src/sht1x.c b/samples/upm/sht1x/src/sht1x.c
new file mode 100644
index 0000000..02889d9
--- /dev/null
+++ b/samples/upm/sht1x/src/sht1x.c
@@ -0,0 +1,85 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "sht1x.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a SHT1X sensor using D2 as the clock, and D3 as the
+    // data pin.
+    sht1x_context sensor = sht1x_init(2, 3);
+
+    if (!sensor)
+    {
+        printf("sht1x_init() failed.\n");
+        return 1;
+    }
+
+    // Every 2 seconds, update and print values
+    while (shouldRun)
+    {
+        if (sht1x_update(sensor))
+        {
+            printf("sht1x_update() failed, exiting.\n");
+            break;
+        }
+
+        printf("Temperature: %f C\n", sht1x_get_temperature(sensor));
+        printf("Humidity:    %f RH\n", sht1x_get_humidity(sensor));
+        printf("\n");
+
+        upm_delay(2);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    sht1x_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/slide/Makefile b/samples/upm/slide/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/slide/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/slide/prj.conf b/samples/upm/slide/prj.conf
new file mode 100644
index 0000000..7eee487
--- /dev/null
+++ b/samples/upm/slide/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_slide=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/slide/src/Makefile b/samples/upm/slide/src/Makefile
new file mode 100644
index 0000000..e97f9f2
--- /dev/null
+++ b/samples/upm/slide/src/Makefile
@@ -0,0 +1 @@
+obj-y = slide.o
\ No newline at end of file
diff --git a/samples/upm/slide/src/slide.c b/samples/upm/slide/src/slide.c
new file mode 100644
index 0000000..8a746f9
--- /dev/null
+++ b/samples/upm/slide/src/slide.c
@@ -0,0 +1,94 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "slide.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a slide sensor on analog pin A0
+    slide_context sensor = slide_init(0);
+
+    if (!sensor)
+    {
+        printf("slide_init() failed.\n");
+        return -1;
+    }
+
+    // Set the aref, scale, and offset
+    slide_set_aref(sensor, 5.0);
+    slide_set_scale(sensor, 1.0);
+    slide_set_offset(sensor, -.1);
+    printf("aRef: %0.03f scale: %0.03f offset: %0.03f\n\n",
+            slide_get_aref(sensor),
+            slide_get_scale(sensor),
+            slide_get_offset(sensor));
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float normalized = 0.0;
+        float raw_volts = 0.0;
+        float volts = 0.0;
+
+        slide_get_normalized(sensor, &normalized);
+        slide_get_raw_volts(sensor, &raw_volts);
+        slide_get_volts(sensor, &volts);
+
+        printf("Normalized output: %0.03f, raw slide sensor output: %0.03f v "
+                "adjusted output: %0.03f v\n", normalized, raw_volts, volts);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    slide_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/temperature/Makefile b/samples/upm/temperature/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/temperature/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/temperature/prj.conf b/samples/upm/temperature/prj.conf
new file mode 100644
index 0000000..ccaa11c
--- /dev/null
+++ b/samples/upm/temperature/prj.conf
@@ -0,0 +1,16 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_temperature=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+
+CONFIG_MRAA_AIO=y
+CONFIG_ADC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_PINMUX=y
+CONFIG_PINMUX_DEV=y
+CONFIG_PINMUX_DEV_NAME=âPINMUX_DEVâ
+CONFIG_PINMUX_DEV_QMSI=y
+CONFIG_PINMUX_NAME=âPINMUXâ
+CONFIG_PINMUX_INIT_PRIORITY=60
diff --git a/samples/upm/temperature/src/Makefile b/samples/upm/temperature/src/Makefile
new file mode 100644
index 0000000..a3f2cf3
--- /dev/null
+++ b/samples/upm/temperature/src/Makefile
@@ -0,0 +1 @@
+obj-y = temperature.o
diff --git a/samples/upm/temperature/src/temperature.c b/samples/upm/temperature/src/temperature.c
new file mode 100644
index 0000000..69b9b38
--- /dev/null
+++ b/samples/upm/temperature/src/temperature.c
@@ -0,0 +1,34 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "temperature.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    temperature_context dev = temperature_init(0);
+    float val;
+    while(1){
+        if(temperature_get_value(dev, &val) != UPM_SUCCESS){
+            printf("Failed to get any values from the sensor\n");
+        }
+        printf("Temperature Value: %f\n", val);
+        upm_delay(1);
+    }
+    temperature_close(dev);
+
+    return 0;
+}
+
diff --git a/samples/upm/tsl2561/Makefile b/samples/upm/tsl2561/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/tsl2561/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/tsl2561/prj.conf b/samples/upm/tsl2561/prj.conf
new file mode 100644
index 0000000..80c1dd6
--- /dev/null
+++ b/samples/upm/tsl2561/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_I2C=y
+CONFIG_MRAA_I2C=y
+CONFIG_MRAA=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_UPM_tsl2561=y
+CONFIG_UPM_utilities=y
+CONFIG_UPM=y
diff --git a/samples/upm/tsl2561/src/Makefile b/samples/upm/tsl2561/src/Makefile
new file mode 100644
index 0000000..8431922
--- /dev/null
+++ b/samples/upm/tsl2561/src/Makefile
@@ -0,0 +1 @@
+obj-y = tsl2561.o
\ No newline at end of file
diff --git a/samples/upm/tsl2561/src/tsl2561.c b/samples/upm/tsl2561/src/tsl2561.c
new file mode 100644
index 0000000..d10f1fd
--- /dev/null
+++ b/samples/upm/tsl2561/src/tsl2561.c
@@ -0,0 +1,29 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "tsl2561.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    tsl2561_context dev = tsl2561_init(0, TSL2561_Address, GAIN_0X, INTEGRATION_TIME1_101MS);
+    float abc = 0;
+    if(tsl2561_get_lux(dev, &abc) != UPM_SUCCESS){
+        printf("ERROR !! ERROR !! ERROR!!");
+    }
+    printf("value retrieved: %f\n", abc);
+
+    return 0;
+}
diff --git a/samples/upm/ttp223/Makefile b/samples/upm/ttp223/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/ttp223/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/ttp223/prj.conf b/samples/upm/ttp223/prj.conf
new file mode 100644
index 0000000..7d3f2d3
--- /dev/null
+++ b/samples/upm/ttp223/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_ttp223=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/ttp223/src/Makefile b/samples/upm/ttp223/src/Makefile
new file mode 100644
index 0000000..bb779d8
--- /dev/null
+++ b/samples/upm/ttp223/src/Makefile
@@ -0,0 +1 @@
+obj-y = ttp223.o
\ No newline at end of file
diff --git a/samples/upm/ttp223/src/ttp223.c b/samples/upm/ttp223/src/ttp223.c
new file mode 100644
index 0000000..b448254
--- /dev/null
+++ b/samples/upm/ttp223/src/ttp223.c
@@ -0,0 +1,32 @@
+//Modified: Abhishek Malik <abhishek.malik@intel.com>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include "ttp223.h"
+
+#include "upm_utilities.h"
+#include "mraa.h"
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    ttp223_context dev = ttp223_init(2);
+    bool abc = 0;
+    while(1){
+        if(ttp223_is_pressed(dev, &abc) != UPM_SUCCESS){
+            printf("an error has occured\n");
+        }
+        upm_delay(1);
+        printf("value retrieved: %d\n", abc);
+    }
+
+    return 0;
+}
diff --git a/samples/upm/uln200xa/Makefile b/samples/upm/uln200xa/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/uln200xa/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/uln200xa/prj.conf b/samples/upm/uln200xa/prj.conf
new file mode 100644
index 0000000..2162a6b
--- /dev/null
+++ b/samples/upm/uln200xa/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_uln200xa=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/uln200xa/src/Makefile b/samples/upm/uln200xa/src/Makefile
new file mode 100644
index 0000000..81af693
--- /dev/null
+++ b/samples/upm/uln200xa/src/Makefile
@@ -0,0 +1 @@
+obj-y = uln200xa.o
diff --git a/samples/upm/uln200xa/src/uln200xa.c b/samples/upm/uln200xa/src/uln200xa.c
new file mode 100644
index 0000000..ff9cbe1
--- /dev/null
+++ b/samples/upm/uln200xa/src/uln200xa.c
@@ -0,0 +1,70 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+
+#include <upm_utilities.h>
+#include "uln200xa.h"
+
+int main ()
+{
+//! [Interesting]
+
+    // Instantiate a Stepper motor on a ULN200XA Darlington controller.
+
+    // This was tested with the Grove Gear Stepper Motor with Driver
+
+    // Wire the pins so that I1 is pin D8, I2 is pin D9, I3 is pin D10 and
+    // I4 is pin D11
+    uln200xa_context motor = uln200xa_init(4096, 8, 9, 10, 11);
+//    uln200xa_context motor = uln200xa_init(4096, 2, 4, 8, 11);
+
+    if (!motor)
+    {
+        printf("uln200xa_init() failed\n");
+        return 1;
+    }
+
+    uln200xa_set_speed(motor, 5);
+    uln200xa_set_direction(motor, ULN200XA_DIR_CW);
+    printf("Rotating 1 revolution clockwise.\n");
+    uln200xa_stepper_steps(motor, 4096);
+
+    printf("Sleeping for 2 seconds...\n");
+    upm_delay(2);
+
+    printf("Rotating 1/2 revolution counter clockwise.\n");
+    uln200xa_set_direction(motor, ULN200XA_DIR_CCW);
+    uln200xa_stepper_steps(motor, 2048);
+
+    // turn off the power
+    uln200xa_release(motor);
+
+    printf("Exiting...\n");
+
+    uln200xa_close(motor);
+//! [Interesting]
+  return 0;
+}
diff --git a/samples/upm/upm.samples.json b/samples/upm/upm.samples.json
new file mode 100644
index 0000000..52861de
--- /dev/null
+++ b/samples/upm/upm.samples.json
@@ -0,0 +1,782 @@
+[
+    {
+        "path" : "upm/a110x",
+        "example": {
+            "name" : "a110x",
+            "description" : "Hall effect sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/bh1750",
+        "example": {
+            "name" : "bh1750",
+            "description" : "Digital light sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/biss0001",
+        "example": {
+            "name" : "biss0001",
+            "description" : "Passive Infrared (PIR) motion sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/bmi160",
+        "example": {
+            "name" : "bmi160",
+            "description" : "Bosch Sensortec IMU (triaxial accelerometer, triaxial gyroscope and magnetometer interface)",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/button_intr",
+        "example": {
+            "name" : "button_intr",
+            "description" : "Button sensor Interrupt Example",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/button",
+        "example": {
+            "name" : "button",
+            "description" : "Button sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/buzzer",
+        "example": {
+            "name" : "buzzer",
+            "description" : "Buzzer",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/collision",
+        "example": {
+            "name" : "collision",
+            "description" : "Collision sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/dfrorp",
+        "example": {
+            "name" : "dfrorp",
+            "description" : "DFRobot analog oxidation reduction potential (ORP) sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/dfrph",
+        "example": {
+            "name" : "dfrph",
+            "description" : "DFRobot pH sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/ecezo",
+        "example": {
+            "name" : "ecezo",
+            "description" : "Driver for the EC-EZO EC sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/emg",
+        "example": {
+            "name" : "emg",
+            "description" : "Electromyography (EMG) detector",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/flex",
+        "example": {
+            "name" : "flex",
+            "description" : "Resistive flex sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/gas",
+        "example": {
+            "name" : "gas",
+            "description" : "Generic gas detection sensor library",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/gp2y0a",
+        "example": {
+            "name" : "gp2y0a",
+            "description" : "Analog Infrared (IR) based distance sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/gsr",
+        "example": {
+            "name" : "gsr",
+            "description" : "Galvanic skin response (GSR) sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/guvas12d",
+        "example": {
+            "name" : "guvas12d",
+            "description" : "Analog UV sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/hka5",
+        "example": {
+            "name" : "hka5",
+            "description" : "DFRobot laser particulate matter (PM) sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/ims",
+        "example": {
+            "name" : "ims",
+            "description" : "Catnip Electronics I2C moisture sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/jhd1313m1",
+        "example": {
+            "name" : "jhd1313m1",
+            "description" : "LCD display driver for the JHD1313M1 controller for HD44780-based displays",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/joystick12",
+        "example": {
+            "name" : "joystick12",
+            "description" : "2-axis analog joystick",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/lcm1602",
+        "example": {
+            "name" : "lcm1602",
+            "description" : "LCD display driver for the LCM1602 controller for HD44780-based displays",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/ldt0028",
+        "example": {
+            "name" : "ldt0028",
+            "description" : "Piezo vibration sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/led",
+        "example": {
+            "name" : "led",
+            "description" : "Blink arduino 101 onboard LED",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/light",
+        "example": {
+            "name" : "light",
+            "description" : "Analog light sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/linefinder",
+        "example": {
+            "name" : "linefinder",
+            "description" : "Line finder",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/lm35",
+        "example": {
+            "name" : "lm35",
+            "description" : "Analog temperature sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/loudness",
+        "example": {
+            "name" : "loudness",
+            "description" : "Loudness sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/m24lr64e",
+        "example": {
+            "name" : "m24lr64e",
+            "description" : "Dynamic NFC/RFID tag module",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/mb704x",
+        "example": {
+            "name" : "mb704x",
+            "description" : "Driver for the MB704x MaxSonar-WR Ultrasonic Ranger",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/md",
+        "example": {
+            "name" : "md",
+            "description" : "I2C motor driver",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/md-stepper",
+        "example": {
+            "name" : "md-stepper",
+            "description" : "I2C motor driver",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/mic",
+        "example": {
+            "name" : "mic",
+            "description" : "Mic Sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/mma7361",
+        "example": {
+            "name" : "mma7361",
+            "description" : "Triaxial analog accelerometer",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/mma7660",
+        "example": {
+            "name" : "mma7660",
+            "description" : "Driver for the MMA7660 Accelerometer (1.5g)",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/moisture",
+        "example": {
+            "name" : "moisture",
+            "description" : "Moisture sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/mpr121",
+        "example": {
+            "name" : "mpr121",
+            "description" : "Digital capacitive touch sensor controller",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/mq303a",
+        "example": {
+            "name" : "mq303a",
+            "description" : "Alcohol detection sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/ms5803",
+        "example": {
+            "name" : "ms5803",
+            "description" : "Driver for the MS5803 Pressure and Temperature sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/my9221",
+        "example": {
+            "name" : "my9221",
+            "description" : "MY9221 LED controller",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/nmea_gps",
+        "example": {
+            "name" : "nmea_gps",
+            "description" : "Generic driver for GPS NMEA sensors",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/o2",
+        "example": {
+            "name" : "o2",
+            "description" : "Oxygen (O2) concentration sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/otp538u",
+        "example": {
+            "name" : "otp538u",
+            "description" : "Analog IR Temperature sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/ppd42ns",
+        "example": {
+            "name" : "ppd42ns",
+            "description" : "PPD42NS Dust Sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/relay",
+        "example": {
+            "name" : "relay",
+            "description" : "Relay Sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/rotaryencoder",
+        "example": {
+            "name" : "rotaryencoder",
+            "description" : "Rotary encoder",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/rotary",
+        "example": {
+            "name" : "rotary",
+            "description" : "Rotary Angle Sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/rpr220-intr",
+        "example": {
+            "name" : "rpr220-intr",
+            "description" : "Infrared (IR) reflective sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/rpr220",
+        "example": {
+            "name" : "rpr220",
+            "description" : "Infrared (IR) reflective sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/servo",
+        "example": {
+            "name" : "servo",
+            "description" : "Servo controller",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/sht1x",
+        "example": {
+            "name" : "sht1x",
+            "description" : "Temperature and humidity sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/slide",
+        "example": {
+            "name" : "slide",
+            "description" : "Slide potentiometer sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/temperature",
+        "example": {
+            "name" : "temperature",
+            "description" : "UPM Temperature",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/tsl2561",
+        "example": {
+            "name" : "tsl2561",
+            "description" : "Digital light sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/ttp223",
+        "example": {
+            "name" : "ttp223",
+            "description" : "Capacitive touch sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/uln200xa",
+        "example": {
+            "name" : "uln200xa",
+            "description" : "ULN200XA Stepper Motor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/urm37",
+        "example": {
+            "name" : "urm37",
+            "description" : "Ultrasonic range finder",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/vdiv",
+        "example": {
+            "name" : "vdiv",
+            "description" : "Analog voltage divider sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/water",
+        "example": {
+            "name" : "water",
+            "description" : "Water detection sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    },
+    {
+        "path" : "upm/yg1006",
+        "example": {
+            "name" : "yg1006",
+            "description" : "Analog flame sensor",
+            "category": "UPM",
+            "platform": {
+                "boards": [
+                    "arduino_101_sss"
+                ]
+            }
+        }
+    }
+]
diff --git a/samples/upm/urm37/Makefile b/samples/upm/urm37/Makefile
new file mode 100644
index 0000000..9862696
--- /dev/null
+++ b/samples/upm/urm37/Makefile
@@ -0,0 +1,5 @@
+KERNEL_TYPE = micro
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/urm37/prj.conf b/samples/upm/urm37/prj.conf
new file mode 100644
index 0000000..8988c7b
--- /dev/null
+++ b/samples/upm/urm37/prj.conf
@@ -0,0 +1,14 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_MRAA_AIO=y
+CONFIG_MRAA_UART=y
+CONFIG_UPM=y
+CONFIG_UPM_urm37=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_ADC=y
+CONFIG_GPIO_QMSI_SS=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_UART_LINE_CTRL=y
diff --git a/samples/upm/urm37/src/Makefile b/samples/upm/urm37/src/Makefile
new file mode 100644
index 0000000..886edd7
--- /dev/null
+++ b/samples/upm/urm37/src/Makefile
@@ -0,0 +1 @@
+obj-y = urm37.o
\ No newline at end of file
diff --git a/samples/upm/urm37/src/urm37.c b/samples/upm/urm37/src/urm37.c
new file mode 100644
index 0000000..1c773d1
--- /dev/null
+++ b/samples/upm/urm37/src/urm37.c
@@ -0,0 +1,81 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "urm37.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a URM37 sensor on analog pin A0, reset pin on D2,
+    // trigger pin on D3 with an analog reference voltage of 5.0
+    urm37_context sensor = urm37_init(0, 2, 3, 5.0, 0, true);
+
+    if (!sensor)
+    {
+        printf("urm37_init() failed.\n");
+        return(1);
+    }
+
+    // Every half a second, sample the URM37 and output the measured
+    // distance in cm.
+
+    while (shouldRun)
+    {
+        float distance;
+
+        urm37_get_distance(sensor, &distance, 0);
+        printf("Detected distance (cm): %f\n", distance);
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    urm37_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/vdiv/Makefile b/samples/upm/vdiv/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/vdiv/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/vdiv/prj.conf b/samples/upm/vdiv/prj.conf
new file mode 100644
index 0000000..9a5282e
--- /dev/null
+++ b/samples/upm/vdiv/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MRAA=y
+CONFIG_UPM=y
+CONFIG_UPM_vdiv=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_ADC_QMSI_SS=y
+CONFIG_ADC=y
+CONFIG_MRAA_AIO=y
\ No newline at end of file
diff --git a/samples/upm/vdiv/src/Makefile b/samples/upm/vdiv/src/Makefile
new file mode 100644
index 0000000..b6fed9c
--- /dev/null
+++ b/samples/upm/vdiv/src/Makefile
@@ -0,0 +1 @@
+obj-y = vdiv.o
\ No newline at end of file
diff --git a/samples/upm/vdiv/src/vdiv.c b/samples/upm/vdiv/src/vdiv.c
new file mode 100644
index 0000000..be2a596
--- /dev/null
+++ b/samples/upm/vdiv/src/vdiv.c
@@ -0,0 +1,82 @@
+/*
+ * Author: Noel Eck <noel.eck@intel.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "vdiv.h"
+#include "upm_utilities.h"
+#include "mraa.h"
+
+bool shouldRun = true;
+
+void sig_handler(int signo)
+{
+    if (signo == SIGINT)
+        shouldRun = false;
+}
+
+int main()
+{
+    if (mraa_init() != MRAA_SUCCESS)
+    {
+        fprintf(stderr,"Failed to initialize mraa\n");
+        return -1;
+    }
+
+    signal(SIGINT, sig_handler);
+
+    //! [Interesting]
+
+    // Instantiate a sensor on analog pin A0
+    vdiv_context sensor = vdiv_init(0, 5);
+
+    if (!sensor)
+    {
+        printf("vdiv_init() failed.\n");
+        return(1);
+    }
+
+    // Every half a second, sample the sensor output
+    while (shouldRun)
+    {
+        float raw_volts = 0.0, computed_volts = 0.0;
+
+        vdiv_get_raw_volts(sensor, &raw_volts);
+        vdiv_get_computed_volts(sensor, &computed_volts);
+
+        printf("Divide SW: %d ADC voltage: %0.03f Sensor voltage: %0.03f\n",
+                vdiv_get_divsw(sensor), raw_volts, computed_volts);
+
+        upm_delay_ms(500);
+    }
+
+    //! [Interesting]
+
+    printf("Exiting\n");
+
+    vdiv_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/water/Makefile b/samples/upm/water/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/water/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/water/prj.conf b/samples/upm/water/prj.conf
new file mode 100644
index 0000000..13bb8f1
--- /dev/null
+++ b/samples/upm/water/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_water=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/water/src/Makefile b/samples/upm/water/src/Makefile
new file mode 100644
index 0000000..4c7ccb7
--- /dev/null
+++ b/samples/upm/water/src/Makefile
@@ -0,0 +1 @@
+obj-y = water.o
diff --git a/samples/upm/water/src/water.c b/samples/upm/water/src/water.c
new file mode 100644
index 0000000..1ebc4bf
--- /dev/null
+++ b/samples/upm/water/src/water.c
@@ -0,0 +1,70 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "water.h"
+#include "upm_utilities.h"
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+
+int main ()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate a Water sensor on digital pin D2
+    water_context sensor = water_init(2);
+
+    if (!sensor)
+    {
+        printf("dfrec_init() failed.\n");
+        return(1);
+    }
+
+    while (shouldRun)
+    {
+        if (water_is_wet(sensor))
+            printf("Sensor is wet\n");
+        else
+            printf("Sensor is dry\n");
+
+        upm_delay(1);
+    }
+//! [Interesting]
+
+    printf("Exiting...\n");
+
+    water_close(sensor);
+
+    return 0;
+}
diff --git a/samples/upm/yg1006/Makefile b/samples/upm/yg1006/Makefile
new file mode 100644
index 0000000..4de50f9
--- /dev/null
+++ b/samples/upm/yg1006/Makefile
@@ -0,0 +1,4 @@
+BOARD ?= qemu_x86
+CONF_FILE = prj.conf
+
+include ${ZEPHYR_BASE}/Makefile.inc
diff --git a/samples/upm/yg1006/prj.conf b/samples/upm/yg1006/prj.conf
new file mode 100644
index 0000000..a45aedb
--- /dev/null
+++ b/samples/upm/yg1006/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_STDOUT_CONSOLE=y
+CONFIG_MRAA=y
+CONFIG_MRAA_GPIO=y
+CONFIG_UPM=y
+CONFIG_UPM_yg1006=y
+CONFIG_UPM_utilities=y
+CONFIG_NEWLIB_LIBC=y
+CONFIG_GPIO=y
+CONFIG_GPIO_QMSI=y
diff --git a/samples/upm/yg1006/src/Makefile b/samples/upm/yg1006/src/Makefile
new file mode 100644
index 0000000..74a0b64
--- /dev/null
+++ b/samples/upm/yg1006/src/Makefile
@@ -0,0 +1 @@
+obj-y = yg1006.o
diff --git a/samples/upm/yg1006/src/yg1006.c b/samples/upm/yg1006/src/yg1006.c
new file mode 100644
index 0000000..3d361e1
--- /dev/null
+++ b/samples/upm/yg1006/src/yg1006.c
@@ -0,0 +1,70 @@
+/*
+ * Author: Jon Trulson <jtrulson@ics.com>
+ * Copyright (c) 2016 Intel Corporation.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <unistd.h>
+#include <signal.h>
+
+#include "yg1006.h"
+#include "upm_utilities.h"
+
+int shouldRun = true;
+
+void sig_handler(int signo)
+{
+  if (signo == SIGINT)
+    shouldRun = false;
+}
+
+
+int main ()
+{
+    signal(SIGINT, sig_handler);
+
+//! [Interesting]
+    // Instantiate a YG1006 sensor on digital pin D2
+    yg1006_context sensor = yg1006_init(2);
+
+    if (!sensor)
+    {
+        printf("yg1006_init() failed.\n");
+        return(1);
+    }
+
+    while (shouldRun)
+    {
+        if (yg1006_flame_detected(sensor))
+            printf("Flame detected.\n");
+        else
+            printf("No flame detected.\n");
+
+        upm_delay(1);
+    }
+//! [Interesting]
+
+    printf("Exiting...\n");
+
+    yg1006_close(sensor);
+
+    return 0;
+}
